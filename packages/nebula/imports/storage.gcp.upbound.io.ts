// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Bucket is the Schema for the Buckets API. Creates a new bucket in Google Cloud Storage.
 *
 * @schema Bucket
 */
export class Bucket extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Bucket"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'Bucket',
  }

  /**
   * Renders a Kubernetes manifest for "Bucket".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketProps): any {
    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(props),
    };
  }

  /**
   * Defines a "Bucket" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketProps) {
    super(scope, id, {
      ...Bucket.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(resolved),
    };
  }
}

/**
 * Bucket is the Schema for the Buckets API. Creates a new bucket in Google Cloud Storage.
 *
 * @schema Bucket
 */
export interface BucketProps {
  /**
   * @schema Bucket#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketSpec defines the desired state of Bucket
   *
   * @schema Bucket#spec
   */
  readonly spec: BucketSpec;
}

/**
 * Converts an object of type 'BucketProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketProps(obj: BucketProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BucketSpec defines the desired state of Bucket
 *
 * @schema BucketSpec
 */
export interface BucketSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BucketSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketSpecDeletionPolicy;

  /**
   * @schema BucketSpec#forProvider
   */
  readonly forProvider: BucketSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema BucketSpec#initProvider
   */
  readonly initProvider?: BucketSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BucketSpec#managementPolicies
   */
  readonly managementPolicies?: BucketSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema BucketSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketSpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema BucketSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'BucketSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpec(obj: BucketSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketSpecForProvider(obj.forProvider),
    'initProvider': toJson_BucketSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BucketSpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_BucketSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BucketSpecDeletionPolicy
 */
export enum BucketSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketSpecForProvider
 */
export interface BucketSpecForProvider {
  /**
   * The bucket's Autoclass configuration.  Structure is documented below.
   *
   * @schema BucketSpecForProvider#autoclass
   */
  readonly autoclass?: BucketSpecForProviderAutoclass[];

  /**
   * The bucket's Cross-Origin Resource Sharing (CORS) configuration. Multiple blocks of this type are permitted. Structure is documented below.
   *
   * @schema BucketSpecForProvider#cors
   */
  readonly cors?: BucketSpecForProviderCors[];

  /**
   * The bucket's custom location configuration, which specifies the individual regions that comprise a dual-region bucket. If the bucket is designated a single or multi-region, the parameters are empty. Structure is documented below.
   *
   * @schema BucketSpecForProvider#customPlacementConfig
   */
  readonly customPlacementConfig?: BucketSpecForProviderCustomPlacementConfig[];

  /**
   * Whether or not to automatically apply an eventBasedHold to new objects added to the bucket.
   *
   * @schema BucketSpecForProvider#defaultEventBasedHold
   */
  readonly defaultEventBasedHold?: boolean;

  /**
   * Enables object retention on a storage bucket.
   *
   * @schema BucketSpecForProvider#enableObjectRetention
   */
  readonly enableObjectRetention?: boolean;

  /**
   * The bucket's encryption configuration. Structure is documented below.
   *
   * @schema BucketSpecForProvider#encryption
   */
  readonly encryption?: BucketSpecForProviderEncryption[];

  /**
   * When deleting a bucket, this
   * boolean option will delete all contained objects.
   *
   * @schema BucketSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * The bucket's hierarchical namespace policy, which defines the bucket capability to handle folders in logical structure. Structure is documented below. To use this configuration, uniform_bucket_level_access must be enabled on bucket.
   *
   * @schema BucketSpecForProvider#hierarchicalNamespace
   */
  readonly hierarchicalNamespace?: BucketSpecForProviderHierarchicalNamespace[];

  /**
   * The bucket IP filtering configuration. Specifies the network sources that can access the bucket, as well as its underlying objects. Structure is documented below.
   *
   * @schema BucketSpecForProvider#ipFilter
   */
  readonly ipFilter?: BucketSpecForProviderIpFilter[];

  /**
   * A map of key/value label pairs to assign to the bucket.
   *
   * @schema BucketSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The bucket's Lifecycle Rules configuration. Multiple blocks of this type are permitted. Structure is documented below.
   *
   * @schema BucketSpecForProvider#lifecycleRule
   */
  readonly lifecycleRule?: BucketSpecForProviderLifecycleRule[];

  /**
   * The GCS location.
   *
   * @schema BucketSpecForProvider#location
   */
  readonly location?: string;

  /**
   * The bucket's Access & Storage Logs configuration. Structure is documented below.
   *
   * @schema BucketSpecForProvider#logging
   */
  readonly logging?: BucketSpecForProviderLogging[];

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema BucketSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Prevents public access to a bucket. Acceptable values are "inherited" or "enforced". If "inherited", the bucket uses public access prevention. only if the bucket is subject to the public access prevention organization policy constraint. Defaults to "inherited".
   *
   * @default inherited".
   * @schema BucketSpecForProvider#publicAccessPrevention
   */
  readonly publicAccessPrevention?: string;

  /**
   * Enables Requester Pays on a storage bucket.
   *
   * @schema BucketSpecForProvider#requesterPays
   */
  readonly requesterPays?: boolean;

  /**
   * Configuration of the bucket's data retention policy for how long objects in the bucket should be retained. Structure is documented below.
   *
   * @schema BucketSpecForProvider#retentionPolicy
   */
  readonly retentionPolicy?: BucketSpecForProviderRetentionPolicy[];

  /**
   * The recovery point objective for cross-region replication of the bucket. Applicable only for dual and multi-region buckets. "DEFAULT" sets default replication. "ASYNC_TURBO" value enables turbo replication, valid for dual-region buckets only. See Turbo Replication for more information. If rpo is not specified at bucket creation, it defaults to "DEFAULT" for dual and multi-region buckets. NOTE If used with single-region bucket, It will throw an error.
   *
   * @schema BucketSpecForProvider#rpo
   */
  readonly rpo?: string;

  /**
   * The bucket's soft delete policy, which defines the period of time that soft-deleted objects will be retained, and cannot be permanently deleted. Structure is documented below.
   *
   * @schema BucketSpecForProvider#softDeletePolicy
   */
  readonly softDeletePolicy?: BucketSpecForProviderSoftDeletePolicy[];

  /**
   * The Storage Class of the new bucket. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.
   *
   * @schema BucketSpecForProvider#storageClass
   */
  readonly storageClass?: string;

  /**
   * Enables Uniform bucket-level access access to a bucket.
   *
   * @schema BucketSpecForProvider#uniformBucketLevelAccess
   */
  readonly uniformBucketLevelAccess?: boolean;

  /**
   * The bucket's Versioning configuration.  Structure is documented below.
   *
   * @schema BucketSpecForProvider#versioning
   */
  readonly versioning?: BucketSpecForProviderVersioning[];

  /**
   * Configuration if the bucket acts as a website. Structure is documented below.
   *
   * @schema BucketSpecForProvider#website
   */
  readonly website?: BucketSpecForProviderWebsite[];
}

/**
 * Converts an object of type 'BucketSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProvider(obj: BucketSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoclass': obj.autoclass?.map(y => toJson_BucketSpecForProviderAutoclass(y)),
    'cors': obj.cors?.map(y => toJson_BucketSpecForProviderCors(y)),
    'customPlacementConfig': obj.customPlacementConfig?.map(y => toJson_BucketSpecForProviderCustomPlacementConfig(y)),
    'defaultEventBasedHold': obj.defaultEventBasedHold,
    'enableObjectRetention': obj.enableObjectRetention,
    'encryption': obj.encryption?.map(y => toJson_BucketSpecForProviderEncryption(y)),
    'forceDestroy': obj.forceDestroy,
    'hierarchicalNamespace': obj.hierarchicalNamespace?.map(y => toJson_BucketSpecForProviderHierarchicalNamespace(y)),
    'ipFilter': obj.ipFilter?.map(y => toJson_BucketSpecForProviderIpFilter(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'lifecycleRule': obj.lifecycleRule?.map(y => toJson_BucketSpecForProviderLifecycleRule(y)),
    'location': obj.location,
    'logging': obj.logging?.map(y => toJson_BucketSpecForProviderLogging(y)),
    'project': obj.project,
    'publicAccessPrevention': obj.publicAccessPrevention,
    'requesterPays': obj.requesterPays,
    'retentionPolicy': obj.retentionPolicy?.map(y => toJson_BucketSpecForProviderRetentionPolicy(y)),
    'rpo': obj.rpo,
    'softDeletePolicy': obj.softDeletePolicy?.map(y => toJson_BucketSpecForProviderSoftDeletePolicy(y)),
    'storageClass': obj.storageClass,
    'uniformBucketLevelAccess': obj.uniformBucketLevelAccess,
    'versioning': obj.versioning?.map(y => toJson_BucketSpecForProviderVersioning(y)),
    'website': obj.website?.map(y => toJson_BucketSpecForProviderWebsite(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema BucketSpecInitProvider
 */
export interface BucketSpecInitProvider {
  /**
   * The bucket's Autoclass configuration.  Structure is documented below.
   *
   * @schema BucketSpecInitProvider#autoclass
   */
  readonly autoclass?: BucketSpecInitProviderAutoclass[];

  /**
   * The bucket's Cross-Origin Resource Sharing (CORS) configuration. Multiple blocks of this type are permitted. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#cors
   */
  readonly cors?: BucketSpecInitProviderCors[];

  /**
   * The bucket's custom location configuration, which specifies the individual regions that comprise a dual-region bucket. If the bucket is designated a single or multi-region, the parameters are empty. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#customPlacementConfig
   */
  readonly customPlacementConfig?: BucketSpecInitProviderCustomPlacementConfig[];

  /**
   * Whether or not to automatically apply an eventBasedHold to new objects added to the bucket.
   *
   * @schema BucketSpecInitProvider#defaultEventBasedHold
   */
  readonly defaultEventBasedHold?: boolean;

  /**
   * Enables object retention on a storage bucket.
   *
   * @schema BucketSpecInitProvider#enableObjectRetention
   */
  readonly enableObjectRetention?: boolean;

  /**
   * The bucket's encryption configuration. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#encryption
   */
  readonly encryption?: BucketSpecInitProviderEncryption[];

  /**
   * When deleting a bucket, this
   * boolean option will delete all contained objects.
   *
   * @schema BucketSpecInitProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * The bucket's hierarchical namespace policy, which defines the bucket capability to handle folders in logical structure. Structure is documented below. To use this configuration, uniform_bucket_level_access must be enabled on bucket.
   *
   * @schema BucketSpecInitProvider#hierarchicalNamespace
   */
  readonly hierarchicalNamespace?: BucketSpecInitProviderHierarchicalNamespace[];

  /**
   * The bucket IP filtering configuration. Specifies the network sources that can access the bucket, as well as its underlying objects. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#ipFilter
   */
  readonly ipFilter?: BucketSpecInitProviderIpFilter[];

  /**
   * A map of key/value label pairs to assign to the bucket.
   *
   * @schema BucketSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The bucket's Lifecycle Rules configuration. Multiple blocks of this type are permitted. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#lifecycleRule
   */
  readonly lifecycleRule?: BucketSpecInitProviderLifecycleRule[];

  /**
   * The GCS location.
   *
   * @schema BucketSpecInitProvider#location
   */
  readonly location?: string;

  /**
   * The bucket's Access & Storage Logs configuration. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#logging
   */
  readonly logging?: BucketSpecInitProviderLogging[];

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema BucketSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Prevents public access to a bucket. Acceptable values are "inherited" or "enforced". If "inherited", the bucket uses public access prevention. only if the bucket is subject to the public access prevention organization policy constraint. Defaults to "inherited".
   *
   * @default inherited".
   * @schema BucketSpecInitProvider#publicAccessPrevention
   */
  readonly publicAccessPrevention?: string;

  /**
   * Enables Requester Pays on a storage bucket.
   *
   * @schema BucketSpecInitProvider#requesterPays
   */
  readonly requesterPays?: boolean;

  /**
   * Configuration of the bucket's data retention policy for how long objects in the bucket should be retained. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#retentionPolicy
   */
  readonly retentionPolicy?: BucketSpecInitProviderRetentionPolicy[];

  /**
   * The recovery point objective for cross-region replication of the bucket. Applicable only for dual and multi-region buckets. "DEFAULT" sets default replication. "ASYNC_TURBO" value enables turbo replication, valid for dual-region buckets only. See Turbo Replication for more information. If rpo is not specified at bucket creation, it defaults to "DEFAULT" for dual and multi-region buckets. NOTE If used with single-region bucket, It will throw an error.
   *
   * @schema BucketSpecInitProvider#rpo
   */
  readonly rpo?: string;

  /**
   * The bucket's soft delete policy, which defines the period of time that soft-deleted objects will be retained, and cannot be permanently deleted. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#softDeletePolicy
   */
  readonly softDeletePolicy?: BucketSpecInitProviderSoftDeletePolicy[];

  /**
   * The Storage Class of the new bucket. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.
   *
   * @schema BucketSpecInitProvider#storageClass
   */
  readonly storageClass?: string;

  /**
   * Enables Uniform bucket-level access access to a bucket.
   *
   * @schema BucketSpecInitProvider#uniformBucketLevelAccess
   */
  readonly uniformBucketLevelAccess?: boolean;

  /**
   * The bucket's Versioning configuration.  Structure is documented below.
   *
   * @schema BucketSpecInitProvider#versioning
   */
  readonly versioning?: BucketSpecInitProviderVersioning[];

  /**
   * Configuration if the bucket acts as a website. Structure is documented below.
   *
   * @schema BucketSpecInitProvider#website
   */
  readonly website?: BucketSpecInitProviderWebsite[];
}

/**
 * Converts an object of type 'BucketSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProvider(obj: BucketSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoclass': obj.autoclass?.map(y => toJson_BucketSpecInitProviderAutoclass(y)),
    'cors': obj.cors?.map(y => toJson_BucketSpecInitProviderCors(y)),
    'customPlacementConfig': obj.customPlacementConfig?.map(y => toJson_BucketSpecInitProviderCustomPlacementConfig(y)),
    'defaultEventBasedHold': obj.defaultEventBasedHold,
    'enableObjectRetention': obj.enableObjectRetention,
    'encryption': obj.encryption?.map(y => toJson_BucketSpecInitProviderEncryption(y)),
    'forceDestroy': obj.forceDestroy,
    'hierarchicalNamespace': obj.hierarchicalNamespace?.map(y => toJson_BucketSpecInitProviderHierarchicalNamespace(y)),
    'ipFilter': obj.ipFilter?.map(y => toJson_BucketSpecInitProviderIpFilter(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'lifecycleRule': obj.lifecycleRule?.map(y => toJson_BucketSpecInitProviderLifecycleRule(y)),
    'location': obj.location,
    'logging': obj.logging?.map(y => toJson_BucketSpecInitProviderLogging(y)),
    'project': obj.project,
    'publicAccessPrevention': obj.publicAccessPrevention,
    'requesterPays': obj.requesterPays,
    'retentionPolicy': obj.retentionPolicy?.map(y => toJson_BucketSpecInitProviderRetentionPolicy(y)),
    'rpo': obj.rpo,
    'softDeletePolicy': obj.softDeletePolicy?.map(y => toJson_BucketSpecInitProviderSoftDeletePolicy(y)),
    'storageClass': obj.storageClass,
    'uniformBucketLevelAccess': obj.uniformBucketLevelAccess,
    'versioning': obj.versioning?.map(y => toJson_BucketSpecInitProviderVersioning(y)),
    'website': obj.website?.map(y => toJson_BucketSpecInitProviderWebsite(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema BucketSpecManagementPolicies
 */
export enum BucketSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema BucketSpecProviderConfigRef
 */
export interface BucketSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecProviderConfigRef#policy
   */
  readonly policy?: BucketSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'BucketSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecProviderConfigRef(obj: BucketSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema BucketSpecWriteConnectionSecretToRef
 */
export interface BucketSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'BucketSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecWriteConnectionSecretToRef(obj: BucketSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderAutoclass
 */
export interface BucketSpecForProviderAutoclass {
  /**
   * While set to true, autoclass automatically transitions objects in your bucket to appropriate storage classes based on each object's access pattern.
   *
   * @schema BucketSpecForProviderAutoclass#enabled
   */
  readonly enabled?: boolean;

  /**
   * The storage class that objects in the bucket eventually transition to if they are not read for a certain length of time. Supported values include: NEARLINE, ARCHIVE.
   *
   * @schema BucketSpecForProviderAutoclass#terminalStorageClass
   */
  readonly terminalStorageClass?: string;
}

/**
 * Converts an object of type 'BucketSpecForProviderAutoclass' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderAutoclass(obj: BucketSpecForProviderAutoclass | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'terminalStorageClass': obj.terminalStorageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderCors
 */
export interface BucketSpecForProviderCors {
  /**
   * The value, in seconds, to return in the Access-Control-Max-Age header used in preflight responses.
   *
   * @schema BucketSpecForProviderCors#maxAgeSeconds
   */
  readonly maxAgeSeconds?: number;

  /**
   * The list of HTTP methods on which to include CORS response headers, (GET, OPTIONS, POST, etc) Note: "*" is permitted in the list of methods, and means "any method".
   *
   * @schema BucketSpecForProviderCors#method
   */
  readonly method?: string[];

  /**
   * The list of Origins eligible to receive CORS response headers. Note: "*" is permitted in the list of origins, and means "any Origin".
   *
   * @schema BucketSpecForProviderCors#origin
   */
  readonly origin?: string[];

  /**
   * The list of HTTP headers other than the simple response headers to give permission for the user-agent to share across domains.
   *
   * @schema BucketSpecForProviderCors#responseHeader
   */
  readonly responseHeader?: string[];
}

/**
 * Converts an object of type 'BucketSpecForProviderCors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderCors(obj: BucketSpecForProviderCors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxAgeSeconds': obj.maxAgeSeconds,
    'method': obj.method?.map(y => y),
    'origin': obj.origin?.map(y => y),
    'responseHeader': obj.responseHeader?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderCustomPlacementConfig
 */
export interface BucketSpecForProviderCustomPlacementConfig {
  /**
   * The list of individual regions that comprise a dual-region bucket. See Cloud Storage bucket locations for a list of acceptable regions. Note: If any of the data_locations changes, it will recreate the bucket.
   *
   * @schema BucketSpecForProviderCustomPlacementConfig#dataLocations
   */
  readonly dataLocations?: string[];
}

/**
 * Converts an object of type 'BucketSpecForProviderCustomPlacementConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderCustomPlacementConfig(obj: BucketSpecForProviderCustomPlacementConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataLocations': obj.dataLocations?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderEncryption
 */
export interface BucketSpecForProviderEncryption {
  /**
   * : The id of a Cloud KMS key that will be used to encrypt objects inserted into this bucket, if no encryption method is specified.
   * You must pay attention to whether the crypto key is available in the location that this bucket is created in.
   * See the docs for more details.
   *
   * @schema BucketSpecForProviderEncryption#defaultKmsKeyName
   */
  readonly defaultKmsKeyName?: string;
}

/**
 * Converts an object of type 'BucketSpecForProviderEncryption' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderEncryption(obj: BucketSpecForProviderEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultKmsKeyName': obj.defaultKmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderHierarchicalNamespace
 */
export interface BucketSpecForProviderHierarchicalNamespace {
  /**
   * Enables hierarchical namespace for the bucket.
   *
   * @schema BucketSpecForProviderHierarchicalNamespace#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'BucketSpecForProviderHierarchicalNamespace' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderHierarchicalNamespace(obj: BucketSpecForProviderHierarchicalNamespace | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderIpFilter
 */
export interface BucketSpecForProviderIpFilter {
  /**
   * While set true, allows all service agents to access the bucket regardless of the IP filter configuration.
   *
   * @schema BucketSpecForProviderIpFilter#allowAllServiceAgentAccess
   */
  readonly allowAllServiceAgentAccess?: boolean;

  /**
   * While set true, allows cross-org VPCs in the bucket's IP filter configuration.
   *
   * @schema BucketSpecForProviderIpFilter#allowCrossOrgVpcs
   */
  readonly allowCrossOrgVpcs?: boolean;

  /**
   * The state of the IP filter configuration. Valid values are Enabled and Disabled. When set to Enabled, IP filtering rules are applied to a bucket and all incoming requests to the bucket are evaluated against these rules. When set to Disabled, IP filtering rules are not applied to a bucket. Note: allow_all_service_agent_access must be supplied when mode is set to Enabled, it can be ommited for other values.
   *
   * @schema BucketSpecForProviderIpFilter#mode
   */
  readonly mode?: string;

  /**
   * The public network IP address ranges that can access the bucket and its data. Structure is documented below.
   *
   * @schema BucketSpecForProviderIpFilter#publicNetworkSource
   */
  readonly publicNetworkSource?: BucketSpecForProviderIpFilterPublicNetworkSource[];

  /**
   * The list of VPC networks that can access the bucket. Structure is documented below.
   *
   * @schema BucketSpecForProviderIpFilter#vpcNetworkSources
   */
  readonly vpcNetworkSources?: BucketSpecForProviderIpFilterVpcNetworkSources[];
}

/**
 * Converts an object of type 'BucketSpecForProviderIpFilter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderIpFilter(obj: BucketSpecForProviderIpFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAllServiceAgentAccess': obj.allowAllServiceAgentAccess,
    'allowCrossOrgVpcs': obj.allowCrossOrgVpcs,
    'mode': obj.mode,
    'publicNetworkSource': obj.publicNetworkSource?.map(y => toJson_BucketSpecForProviderIpFilterPublicNetworkSource(y)),
    'vpcNetworkSources': obj.vpcNetworkSources?.map(y => toJson_BucketSpecForProviderIpFilterVpcNetworkSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderLifecycleRule
 */
export interface BucketSpecForProviderLifecycleRule {
  /**
   * The Lifecycle Rule's action configuration. A single block of this type is supported. Structure is documented below.
   *
   * @schema BucketSpecForProviderLifecycleRule#action
   */
  readonly action?: BucketSpecForProviderLifecycleRuleAction[];

  /**
   * The Lifecycle Rule's condition configuration. A single block of this type is supported. Structure is documented below.
   *
   * @schema BucketSpecForProviderLifecycleRule#condition
   */
  readonly condition?: BucketSpecForProviderLifecycleRuleCondition[];
}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleRule' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderLifecycleRule(obj: BucketSpecForProviderLifecycleRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_BucketSpecForProviderLifecycleRuleAction(y)),
    'condition': obj.condition?.map(y => toJson_BucketSpecForProviderLifecycleRuleCondition(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderLogging
 */
export interface BucketSpecForProviderLogging {
  /**
   * The bucket that will receive log objects.
   *
   * @schema BucketSpecForProviderLogging#logBucket
   */
  readonly logBucket?: string;

  /**
   * The object prefix for log objects. If it's not provided,
   * by default GCS sets this to this bucket's name.
   *
   * @schema BucketSpecForProviderLogging#logObjectPrefix
   */
  readonly logObjectPrefix?: string;
}

/**
 * Converts an object of type 'BucketSpecForProviderLogging' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderLogging(obj: BucketSpecForProviderLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logBucket': obj.logBucket,
    'logObjectPrefix': obj.logObjectPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderRetentionPolicy
 */
export interface BucketSpecForProviderRetentionPolicy {
  /**
   * If set to true, the bucket will be locked and permanently restrict edits to the bucket's retention policy.  Caution: Locking a bucket is an irreversible action.
   *
   * @schema BucketSpecForProviderRetentionPolicy#isLocked
   */
  readonly isLocked?: boolean;

  /**
   * The period of time, in seconds, that objects in the bucket must be retained and cannot be deleted, overwritten, or archived. The value must be less than 2,147,483,647 seconds.
   *
   * @schema BucketSpecForProviderRetentionPolicy#retentionPeriod
   */
  readonly retentionPeriod?: number;
}

/**
 * Converts an object of type 'BucketSpecForProviderRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderRetentionPolicy(obj: BucketSpecForProviderRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isLocked': obj.isLocked,
    'retentionPeriod': obj.retentionPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderSoftDeletePolicy
 */
export interface BucketSpecForProviderSoftDeletePolicy {
  /**
   * The duration in seconds that soft-deleted objects in the bucket will be retained and cannot be permanently deleted. Default value is 604800. The value must be in between 604800(7 days) and 7776000(90 days). Note: To disable the soft delete policy on a bucket, This field must be set to 0.
   *
   * @schema BucketSpecForProviderSoftDeletePolicy#retentionDurationSeconds
   */
  readonly retentionDurationSeconds?: number;
}

/**
 * Converts an object of type 'BucketSpecForProviderSoftDeletePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderSoftDeletePolicy(obj: BucketSpecForProviderSoftDeletePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'retentionDurationSeconds': obj.retentionDurationSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderVersioning
 */
export interface BucketSpecForProviderVersioning {
  /**
   * While set to true, versioning is fully enabled for this bucket.
   *
   * @schema BucketSpecForProviderVersioning#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'BucketSpecForProviderVersioning' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderVersioning(obj: BucketSpecForProviderVersioning | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderWebsite
 */
export interface BucketSpecForProviderWebsite {
  /**
   * Behaves as the bucket's directory index where
   * missing objects are treated as potential directories.
   *
   * @schema BucketSpecForProviderWebsite#mainPageSuffix
   */
  readonly mainPageSuffix?: string;

  /**
   * The custom object to return when a requested
   * resource is not found.
   *
   * @schema BucketSpecForProviderWebsite#notFoundPage
   */
  readonly notFoundPage?: string;
}

/**
 * Converts an object of type 'BucketSpecForProviderWebsite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderWebsite(obj: BucketSpecForProviderWebsite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mainPageSuffix': obj.mainPageSuffix,
    'notFoundPage': obj.notFoundPage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderAutoclass
 */
export interface BucketSpecInitProviderAutoclass {
  /**
   * While set to true, autoclass automatically transitions objects in your bucket to appropriate storage classes based on each object's access pattern.
   *
   * @schema BucketSpecInitProviderAutoclass#enabled
   */
  readonly enabled?: boolean;

  /**
   * The storage class that objects in the bucket eventually transition to if they are not read for a certain length of time. Supported values include: NEARLINE, ARCHIVE.
   *
   * @schema BucketSpecInitProviderAutoclass#terminalStorageClass
   */
  readonly terminalStorageClass?: string;
}

/**
 * Converts an object of type 'BucketSpecInitProviderAutoclass' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderAutoclass(obj: BucketSpecInitProviderAutoclass | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'terminalStorageClass': obj.terminalStorageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderCors
 */
export interface BucketSpecInitProviderCors {
  /**
   * The value, in seconds, to return in the Access-Control-Max-Age header used in preflight responses.
   *
   * @schema BucketSpecInitProviderCors#maxAgeSeconds
   */
  readonly maxAgeSeconds?: number;

  /**
   * The list of HTTP methods on which to include CORS response headers, (GET, OPTIONS, POST, etc) Note: "*" is permitted in the list of methods, and means "any method".
   *
   * @schema BucketSpecInitProviderCors#method
   */
  readonly method?: string[];

  /**
   * The list of Origins eligible to receive CORS response headers. Note: "*" is permitted in the list of origins, and means "any Origin".
   *
   * @schema BucketSpecInitProviderCors#origin
   */
  readonly origin?: string[];

  /**
   * The list of HTTP headers other than the simple response headers to give permission for the user-agent to share across domains.
   *
   * @schema BucketSpecInitProviderCors#responseHeader
   */
  readonly responseHeader?: string[];
}

/**
 * Converts an object of type 'BucketSpecInitProviderCors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderCors(obj: BucketSpecInitProviderCors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxAgeSeconds': obj.maxAgeSeconds,
    'method': obj.method?.map(y => y),
    'origin': obj.origin?.map(y => y),
    'responseHeader': obj.responseHeader?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderCustomPlacementConfig
 */
export interface BucketSpecInitProviderCustomPlacementConfig {
  /**
   * The list of individual regions that comprise a dual-region bucket. See Cloud Storage bucket locations for a list of acceptable regions. Note: If any of the data_locations changes, it will recreate the bucket.
   *
   * @schema BucketSpecInitProviderCustomPlacementConfig#dataLocations
   */
  readonly dataLocations?: string[];
}

/**
 * Converts an object of type 'BucketSpecInitProviderCustomPlacementConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderCustomPlacementConfig(obj: BucketSpecInitProviderCustomPlacementConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataLocations': obj.dataLocations?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderEncryption
 */
export interface BucketSpecInitProviderEncryption {
  /**
   * : The id of a Cloud KMS key that will be used to encrypt objects inserted into this bucket, if no encryption method is specified.
   * You must pay attention to whether the crypto key is available in the location that this bucket is created in.
   * See the docs for more details.
   *
   * @schema BucketSpecInitProviderEncryption#defaultKmsKeyName
   */
  readonly defaultKmsKeyName?: string;
}

/**
 * Converts an object of type 'BucketSpecInitProviderEncryption' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderEncryption(obj: BucketSpecInitProviderEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultKmsKeyName': obj.defaultKmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderHierarchicalNamespace
 */
export interface BucketSpecInitProviderHierarchicalNamespace {
  /**
   * Enables hierarchical namespace for the bucket.
   *
   * @schema BucketSpecInitProviderHierarchicalNamespace#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'BucketSpecInitProviderHierarchicalNamespace' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderHierarchicalNamespace(obj: BucketSpecInitProviderHierarchicalNamespace | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderIpFilter
 */
export interface BucketSpecInitProviderIpFilter {
  /**
   * While set true, allows all service agents to access the bucket regardless of the IP filter configuration.
   *
   * @schema BucketSpecInitProviderIpFilter#allowAllServiceAgentAccess
   */
  readonly allowAllServiceAgentAccess?: boolean;

  /**
   * While set true, allows cross-org VPCs in the bucket's IP filter configuration.
   *
   * @schema BucketSpecInitProviderIpFilter#allowCrossOrgVpcs
   */
  readonly allowCrossOrgVpcs?: boolean;

  /**
   * The state of the IP filter configuration. Valid values are Enabled and Disabled. When set to Enabled, IP filtering rules are applied to a bucket and all incoming requests to the bucket are evaluated against these rules. When set to Disabled, IP filtering rules are not applied to a bucket. Note: allow_all_service_agent_access must be supplied when mode is set to Enabled, it can be ommited for other values.
   *
   * @schema BucketSpecInitProviderIpFilter#mode
   */
  readonly mode?: string;

  /**
   * The public network IP address ranges that can access the bucket and its data. Structure is documented below.
   *
   * @schema BucketSpecInitProviderIpFilter#publicNetworkSource
   */
  readonly publicNetworkSource?: BucketSpecInitProviderIpFilterPublicNetworkSource[];

  /**
   * The list of VPC networks that can access the bucket. Structure is documented below.
   *
   * @schema BucketSpecInitProviderIpFilter#vpcNetworkSources
   */
  readonly vpcNetworkSources?: BucketSpecInitProviderIpFilterVpcNetworkSources[];
}

/**
 * Converts an object of type 'BucketSpecInitProviderIpFilter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderIpFilter(obj: BucketSpecInitProviderIpFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAllServiceAgentAccess': obj.allowAllServiceAgentAccess,
    'allowCrossOrgVpcs': obj.allowCrossOrgVpcs,
    'mode': obj.mode,
    'publicNetworkSource': obj.publicNetworkSource?.map(y => toJson_BucketSpecInitProviderIpFilterPublicNetworkSource(y)),
    'vpcNetworkSources': obj.vpcNetworkSources?.map(y => toJson_BucketSpecInitProviderIpFilterVpcNetworkSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderLifecycleRule
 */
export interface BucketSpecInitProviderLifecycleRule {
  /**
   * The Lifecycle Rule's action configuration. A single block of this type is supported. Structure is documented below.
   *
   * @schema BucketSpecInitProviderLifecycleRule#action
   */
  readonly action?: BucketSpecInitProviderLifecycleRuleAction[];

  /**
   * The Lifecycle Rule's condition configuration. A single block of this type is supported. Structure is documented below.
   *
   * @schema BucketSpecInitProviderLifecycleRule#condition
   */
  readonly condition?: BucketSpecInitProviderLifecycleRuleCondition[];
}

/**
 * Converts an object of type 'BucketSpecInitProviderLifecycleRule' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderLifecycleRule(obj: BucketSpecInitProviderLifecycleRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_BucketSpecInitProviderLifecycleRuleAction(y)),
    'condition': obj.condition?.map(y => toJson_BucketSpecInitProviderLifecycleRuleCondition(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderLogging
 */
export interface BucketSpecInitProviderLogging {
  /**
   * The bucket that will receive log objects.
   *
   * @schema BucketSpecInitProviderLogging#logBucket
   */
  readonly logBucket?: string;

  /**
   * The object prefix for log objects. If it's not provided,
   * by default GCS sets this to this bucket's name.
   *
   * @schema BucketSpecInitProviderLogging#logObjectPrefix
   */
  readonly logObjectPrefix?: string;
}

/**
 * Converts an object of type 'BucketSpecInitProviderLogging' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderLogging(obj: BucketSpecInitProviderLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logBucket': obj.logBucket,
    'logObjectPrefix': obj.logObjectPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderRetentionPolicy
 */
export interface BucketSpecInitProviderRetentionPolicy {
  /**
   * If set to true, the bucket will be locked and permanently restrict edits to the bucket's retention policy.  Caution: Locking a bucket is an irreversible action.
   *
   * @schema BucketSpecInitProviderRetentionPolicy#isLocked
   */
  readonly isLocked?: boolean;

  /**
   * The period of time, in seconds, that objects in the bucket must be retained and cannot be deleted, overwritten, or archived. The value must be less than 2,147,483,647 seconds.
   *
   * @schema BucketSpecInitProviderRetentionPolicy#retentionPeriod
   */
  readonly retentionPeriod?: number;
}

/**
 * Converts an object of type 'BucketSpecInitProviderRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderRetentionPolicy(obj: BucketSpecInitProviderRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isLocked': obj.isLocked,
    'retentionPeriod': obj.retentionPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderSoftDeletePolicy
 */
export interface BucketSpecInitProviderSoftDeletePolicy {
  /**
   * The duration in seconds that soft-deleted objects in the bucket will be retained and cannot be permanently deleted. Default value is 604800. The value must be in between 604800(7 days) and 7776000(90 days). Note: To disable the soft delete policy on a bucket, This field must be set to 0.
   *
   * @schema BucketSpecInitProviderSoftDeletePolicy#retentionDurationSeconds
   */
  readonly retentionDurationSeconds?: number;
}

/**
 * Converts an object of type 'BucketSpecInitProviderSoftDeletePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderSoftDeletePolicy(obj: BucketSpecInitProviderSoftDeletePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'retentionDurationSeconds': obj.retentionDurationSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderVersioning
 */
export interface BucketSpecInitProviderVersioning {
  /**
   * While set to true, versioning is fully enabled for this bucket.
   *
   * @schema BucketSpecInitProviderVersioning#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'BucketSpecInitProviderVersioning' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderVersioning(obj: BucketSpecInitProviderVersioning | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderWebsite
 */
export interface BucketSpecInitProviderWebsite {
  /**
   * Behaves as the bucket's directory index where
   * missing objects are treated as potential directories.
   *
   * @schema BucketSpecInitProviderWebsite#mainPageSuffix
   */
  readonly mainPageSuffix?: string;

  /**
   * The custom object to return when a requested
   * resource is not found.
   *
   * @schema BucketSpecInitProviderWebsite#notFoundPage
   */
  readonly notFoundPage?: string;
}

/**
 * Converts an object of type 'BucketSpecInitProviderWebsite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderWebsite(obj: BucketSpecInitProviderWebsite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mainPageSuffix': obj.mainPageSuffix,
    'notFoundPage': obj.notFoundPage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketSpecProviderConfigRefPolicy
 */
export interface BucketSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema BucketSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema BucketSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'BucketSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecProviderConfigRefPolicy(obj: BucketSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderIpFilterPublicNetworkSource
 */
export interface BucketSpecForProviderIpFilterPublicNetworkSource {
  /**
   * The list of public or private IPv4 and IPv6 CIDR ranges that can access the bucket.
   *
   * @schema BucketSpecForProviderIpFilterPublicNetworkSource#allowedIpCidrRanges
   */
  readonly allowedIpCidrRanges?: string[];
}

/**
 * Converts an object of type 'BucketSpecForProviderIpFilterPublicNetworkSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderIpFilterPublicNetworkSource(obj: BucketSpecForProviderIpFilterPublicNetworkSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedIpCidrRanges': obj.allowedIpCidrRanges?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderIpFilterVpcNetworkSources
 */
export interface BucketSpecForProviderIpFilterVpcNetworkSources {
  /**
   * The list of public or private IPv4 and IPv6 CIDR ranges that can access the bucket.
   *
   * @schema BucketSpecForProviderIpFilterVpcNetworkSources#allowedIpCidrRanges
   */
  readonly allowedIpCidrRanges?: string[];

  /**
   * Name of the network. Format: projects/PROJECT_ID/global/networks/NETWORK_NAME
   *
   * @schema BucketSpecForProviderIpFilterVpcNetworkSources#network
   */
  readonly network?: string;
}

/**
 * Converts an object of type 'BucketSpecForProviderIpFilterVpcNetworkSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderIpFilterVpcNetworkSources(obj: BucketSpecForProviderIpFilterVpcNetworkSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedIpCidrRanges': obj.allowedIpCidrRanges?.map(y => y),
    'network': obj.network,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderLifecycleRuleAction
 */
export interface BucketSpecForProviderLifecycleRuleAction {
  /**
   * The Storage Class of the new bucket. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.
   *
   * @schema BucketSpecForProviderLifecycleRuleAction#storageClass
   */
  readonly storageClass?: string;

  /**
   * The type of the action of this Lifecycle Rule. Supported values include: Delete, SetStorageClass and AbortIncompleteMultipartUpload.
   *
   * @schema BucketSpecForProviderLifecycleRuleAction#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleRuleAction' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderLifecycleRuleAction(obj: BucketSpecForProviderLifecycleRuleAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'storageClass': obj.storageClass,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecForProviderLifecycleRuleCondition
 */
export interface BucketSpecForProviderLifecycleRuleCondition {
  /**
   * Minimum age of an object in days to satisfy this condition.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#age
   */
  readonly age?: number;

  /**
   * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when an object is created before midnight of the specified date in UTC.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#createdBefore
   */
  readonly createdBefore?: string;

  /**
   * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when the customTime metadata for the object is set to an earlier date than the date used in this lifecycle condition.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#customTimeBefore
   */
  readonly customTimeBefore?: string;

  /**
   * Days since the date set in the customTime metadata for the object. This condition is satisfied when the current date and time is at least the specified number of days after the customTime.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#daysSinceCustomTime
   */
  readonly daysSinceCustomTime?: number;

  /**
   * Relevant only for versioned objects. Number of days elapsed since the noncurrent timestamp of an object.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#daysSinceNoncurrentTime
   */
  readonly daysSinceNoncurrentTime?: number;

  /**
   * One or more matching name prefixes to satisfy this condition.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#matchesPrefix
   */
  readonly matchesPrefix?: string[];

  /**
   * Storage Class of objects to satisfy this condition. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE, DURABLE_REDUCED_AVAILABILITY.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#matchesStorageClass
   */
  readonly matchesStorageClass?: string[];

  /**
   * One or more matching name suffixes to satisfy this condition.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#matchesSuffix
   */
  readonly matchesSuffix?: string[];

  /**
   * Relevant only for versioned objects. The date in RFC 3339 (e.g. 2017-06-13) when the object became nonconcurrent.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#noncurrentTimeBefore
   */
  readonly noncurrentTimeBefore?: string;

  /**
   * Relevant only for versioned objects. The number of newer versions of an object to satisfy this condition.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#numNewerVersions
   */
  readonly numNewerVersions?: number;

  /**
   * While set true, age value will be sent in the request even for zero value of the field. This field is only useful and required for setting 0 value to the age field. It can be used alone or together with age attribute. NOTE age attibute with 0 value will be ommitted from the API request if send_age_if_zero field is having false value.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#sendAgeIfZero
   */
  readonly sendAgeIfZero?: boolean;

  /**
   * While set true, days_since_custom_time value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the days_since_custom_time field. It can be used alone or together with days_since_custom_time.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#sendDaysSinceCustomTimeIfZero
   */
  readonly sendDaysSinceCustomTimeIfZero?: boolean;

  /**
   * While set true, days_since_noncurrent_time value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the days_since_noncurrent_time field. It can be used alone or together with days_since_noncurrent_time.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#sendDaysSinceNoncurrentTimeIfZero
   */
  readonly sendDaysSinceNoncurrentTimeIfZero?: boolean;

  /**
   * While set true, num_newer_versions value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the num_newer_versions field. It can be used alone or together with num_newer_versions.
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#sendNumNewerVersionsIfZero
   */
  readonly sendNumNewerVersionsIfZero?: boolean;

  /**
   * Match to live and/or archived objects. Unversioned buckets have only live objects. Supported values include: "LIVE", "ARCHIVED", "ANY".
   *
   * @schema BucketSpecForProviderLifecycleRuleCondition#withState
   */
  readonly withState?: string;
}

/**
 * Converts an object of type 'BucketSpecForProviderLifecycleRuleCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecForProviderLifecycleRuleCondition(obj: BucketSpecForProviderLifecycleRuleCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'age': obj.age,
    'createdBefore': obj.createdBefore,
    'customTimeBefore': obj.customTimeBefore,
    'daysSinceCustomTime': obj.daysSinceCustomTime,
    'daysSinceNoncurrentTime': obj.daysSinceNoncurrentTime,
    'matchesPrefix': obj.matchesPrefix?.map(y => y),
    'matchesStorageClass': obj.matchesStorageClass?.map(y => y),
    'matchesSuffix': obj.matchesSuffix?.map(y => y),
    'noncurrentTimeBefore': obj.noncurrentTimeBefore,
    'numNewerVersions': obj.numNewerVersions,
    'sendAgeIfZero': obj.sendAgeIfZero,
    'sendDaysSinceCustomTimeIfZero': obj.sendDaysSinceCustomTimeIfZero,
    'sendDaysSinceNoncurrentTimeIfZero': obj.sendDaysSinceNoncurrentTimeIfZero,
    'sendNumNewerVersionsIfZero': obj.sendNumNewerVersionsIfZero,
    'withState': obj.withState,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderIpFilterPublicNetworkSource
 */
export interface BucketSpecInitProviderIpFilterPublicNetworkSource {
  /**
   * The list of public or private IPv4 and IPv6 CIDR ranges that can access the bucket.
   *
   * @schema BucketSpecInitProviderIpFilterPublicNetworkSource#allowedIpCidrRanges
   */
  readonly allowedIpCidrRanges?: string[];
}

/**
 * Converts an object of type 'BucketSpecInitProviderIpFilterPublicNetworkSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderIpFilterPublicNetworkSource(obj: BucketSpecInitProviderIpFilterPublicNetworkSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedIpCidrRanges': obj.allowedIpCidrRanges?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderIpFilterVpcNetworkSources
 */
export interface BucketSpecInitProviderIpFilterVpcNetworkSources {
  /**
   * The list of public or private IPv4 and IPv6 CIDR ranges that can access the bucket.
   *
   * @schema BucketSpecInitProviderIpFilterVpcNetworkSources#allowedIpCidrRanges
   */
  readonly allowedIpCidrRanges?: string[];

  /**
   * Name of the network. Format: projects/PROJECT_ID/global/networks/NETWORK_NAME
   *
   * @schema BucketSpecInitProviderIpFilterVpcNetworkSources#network
   */
  readonly network?: string;
}

/**
 * Converts an object of type 'BucketSpecInitProviderIpFilterVpcNetworkSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderIpFilterVpcNetworkSources(obj: BucketSpecInitProviderIpFilterVpcNetworkSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedIpCidrRanges': obj.allowedIpCidrRanges?.map(y => y),
    'network': obj.network,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderLifecycleRuleAction
 */
export interface BucketSpecInitProviderLifecycleRuleAction {
  /**
   * The Storage Class of the new bucket. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.
   *
   * @schema BucketSpecInitProviderLifecycleRuleAction#storageClass
   */
  readonly storageClass?: string;

  /**
   * The type of the action of this Lifecycle Rule. Supported values include: Delete, SetStorageClass and AbortIncompleteMultipartUpload.
   *
   * @schema BucketSpecInitProviderLifecycleRuleAction#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'BucketSpecInitProviderLifecycleRuleAction' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderLifecycleRuleAction(obj: BucketSpecInitProviderLifecycleRuleAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'storageClass': obj.storageClass,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketSpecInitProviderLifecycleRuleCondition
 */
export interface BucketSpecInitProviderLifecycleRuleCondition {
  /**
   * Minimum age of an object in days to satisfy this condition.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#age
   */
  readonly age?: number;

  /**
   * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when an object is created before midnight of the specified date in UTC.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#createdBefore
   */
  readonly createdBefore?: string;

  /**
   * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when the customTime metadata for the object is set to an earlier date than the date used in this lifecycle condition.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#customTimeBefore
   */
  readonly customTimeBefore?: string;

  /**
   * Days since the date set in the customTime metadata for the object. This condition is satisfied when the current date and time is at least the specified number of days after the customTime.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#daysSinceCustomTime
   */
  readonly daysSinceCustomTime?: number;

  /**
   * Relevant only for versioned objects. Number of days elapsed since the noncurrent timestamp of an object.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#daysSinceNoncurrentTime
   */
  readonly daysSinceNoncurrentTime?: number;

  /**
   * One or more matching name prefixes to satisfy this condition.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#matchesPrefix
   */
  readonly matchesPrefix?: string[];

  /**
   * Storage Class of objects to satisfy this condition. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE, DURABLE_REDUCED_AVAILABILITY.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#matchesStorageClass
   */
  readonly matchesStorageClass?: string[];

  /**
   * One or more matching name suffixes to satisfy this condition.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#matchesSuffix
   */
  readonly matchesSuffix?: string[];

  /**
   * Relevant only for versioned objects. The date in RFC 3339 (e.g. 2017-06-13) when the object became nonconcurrent.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#noncurrentTimeBefore
   */
  readonly noncurrentTimeBefore?: string;

  /**
   * Relevant only for versioned objects. The number of newer versions of an object to satisfy this condition.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#numNewerVersions
   */
  readonly numNewerVersions?: number;

  /**
   * While set true, age value will be sent in the request even for zero value of the field. This field is only useful and required for setting 0 value to the age field. It can be used alone or together with age attribute. NOTE age attibute with 0 value will be ommitted from the API request if send_age_if_zero field is having false value.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#sendAgeIfZero
   */
  readonly sendAgeIfZero?: boolean;

  /**
   * While set true, days_since_custom_time value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the days_since_custom_time field. It can be used alone or together with days_since_custom_time.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#sendDaysSinceCustomTimeIfZero
   */
  readonly sendDaysSinceCustomTimeIfZero?: boolean;

  /**
   * While set true, days_since_noncurrent_time value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the days_since_noncurrent_time field. It can be used alone or together with days_since_noncurrent_time.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#sendDaysSinceNoncurrentTimeIfZero
   */
  readonly sendDaysSinceNoncurrentTimeIfZero?: boolean;

  /**
   * While set true, num_newer_versions value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the num_newer_versions field. It can be used alone or together with num_newer_versions.
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#sendNumNewerVersionsIfZero
   */
  readonly sendNumNewerVersionsIfZero?: boolean;

  /**
   * Match to live and/or archived objects. Unversioned buckets have only live objects. Supported values include: "LIVE", "ARCHIVED", "ANY".
   *
   * @schema BucketSpecInitProviderLifecycleRuleCondition#withState
   */
  readonly withState?: string;
}

/**
 * Converts an object of type 'BucketSpecInitProviderLifecycleRuleCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketSpecInitProviderLifecycleRuleCondition(obj: BucketSpecInitProviderLifecycleRuleCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'age': obj.age,
    'createdBefore': obj.createdBefore,
    'customTimeBefore': obj.customTimeBefore,
    'daysSinceCustomTime': obj.daysSinceCustomTime,
    'daysSinceNoncurrentTime': obj.daysSinceNoncurrentTime,
    'matchesPrefix': obj.matchesPrefix?.map(y => y),
    'matchesStorageClass': obj.matchesStorageClass?.map(y => y),
    'matchesSuffix': obj.matchesSuffix?.map(y => y),
    'noncurrentTimeBefore': obj.noncurrentTimeBefore,
    'numNewerVersions': obj.numNewerVersions,
    'sendAgeIfZero': obj.sendAgeIfZero,
    'sendDaysSinceCustomTimeIfZero': obj.sendDaysSinceCustomTimeIfZero,
    'sendDaysSinceNoncurrentTimeIfZero': obj.sendDaysSinceNoncurrentTimeIfZero,
    'sendNumNewerVersionsIfZero': obj.sendNumNewerVersionsIfZero,
    'withState': obj.withState,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema BucketSpecProviderConfigRefPolicyResolution
 */
export enum BucketSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema BucketSpecProviderConfigRefPolicyResolve
 */
export enum BucketSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Bucket is the Schema for the Buckets API. Creates a new bucket in Google Cloud Storage.
 *
 * @schema BucketV1Beta2
 */
export class BucketV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta2',
    kind: 'Bucket',
  }

  /**
   * Renders a Kubernetes manifest for "BucketV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketV1Beta2Props): any {
    return {
      ...BucketV1Beta2.GVK,
      ...toJson_BucketV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BucketV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketV1Beta2Props) {
    super(scope, id, {
      ...BucketV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketV1Beta2.GVK,
      ...toJson_BucketV1Beta2Props(resolved),
    };
  }
}

/**
 * Bucket is the Schema for the Buckets API. Creates a new bucket in Google Cloud Storage.
 *
 * @schema BucketV1Beta2
 */
export interface BucketV1Beta2Props {
  /**
   * @schema BucketV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketSpec defines the desired state of Bucket
   *
   * @schema BucketV1Beta2#spec
   */
  readonly spec: BucketV1Beta2Spec;
}

/**
 * Converts an object of type 'BucketV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2Props(obj: BucketV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BucketSpec defines the desired state of Bucket
 *
 * @schema BucketV1Beta2Spec
 */
export interface BucketV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BucketV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: BucketV1Beta2SpecDeletionPolicy;

  /**
   * @schema BucketV1Beta2Spec#forProvider
   */
  readonly forProvider: BucketV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema BucketV1Beta2Spec#initProvider
   */
  readonly initProvider?: BucketV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BucketV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: BucketV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema BucketV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: BucketV1Beta2SpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema BucketV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketV1Beta2SpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'BucketV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2Spec(obj: BucketV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_BucketV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BucketV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_BucketV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BucketV1Beta2SpecDeletionPolicy
 */
export enum BucketV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketV1Beta2SpecForProvider
 */
export interface BucketV1Beta2SpecForProvider {
  /**
   * The bucket's Autoclass configuration.  Structure is documented below.
   *
   * @schema BucketV1Beta2SpecForProvider#autoclass
   */
  readonly autoclass?: BucketV1Beta2SpecForProviderAutoclass;

  /**
   * The bucket's Cross-Origin Resource Sharing (CORS) configuration. Multiple blocks of this type are permitted. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecForProvider#cors
   */
  readonly cors?: BucketV1Beta2SpecForProviderCors[];

  /**
   * The bucket's custom location configuration, which specifies the individual regions that comprise a dual-region bucket. If the bucket is designated a single or multi-region, the parameters are empty. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecForProvider#customPlacementConfig
   */
  readonly customPlacementConfig?: BucketV1Beta2SpecForProviderCustomPlacementConfig;

  /**
   * Whether or not to automatically apply an eventBasedHold to new objects added to the bucket.
   *
   * @schema BucketV1Beta2SpecForProvider#defaultEventBasedHold
   */
  readonly defaultEventBasedHold?: boolean;

  /**
   * Enables object retention on a storage bucket.
   *
   * @schema BucketV1Beta2SpecForProvider#enableObjectRetention
   */
  readonly enableObjectRetention?: boolean;

  /**
   * The bucket's encryption configuration. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecForProvider#encryption
   */
  readonly encryption?: BucketV1Beta2SpecForProviderEncryption;

  /**
   * When deleting a bucket, this
   * boolean option will delete all contained objects.
   *
   * @schema BucketV1Beta2SpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * The bucket's hierarchical namespace policy, which defines the bucket capability to handle folders in logical structure. Structure is documented below. To use this configuration, uniform_bucket_level_access must be enabled on bucket.
   *
   * @schema BucketV1Beta2SpecForProvider#hierarchicalNamespace
   */
  readonly hierarchicalNamespace?: BucketV1Beta2SpecForProviderHierarchicalNamespace;

  /**
   * The bucket IP filtering configuration. Specifies the network sources that can access the bucket, as well as its underlying objects. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecForProvider#ipFilter
   */
  readonly ipFilter?: BucketV1Beta2SpecForProviderIpFilter;

  /**
   * A map of key/value label pairs to assign to the bucket.
   *
   * @schema BucketV1Beta2SpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The bucket's Lifecycle Rules configuration. Multiple blocks of this type are permitted. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecForProvider#lifecycleRule
   */
  readonly lifecycleRule?: BucketV1Beta2SpecForProviderLifecycleRule[];

  /**
   * The GCS location.
   *
   * @schema BucketV1Beta2SpecForProvider#location
   */
  readonly location?: string;

  /**
   * The bucket's Access & Storage Logs configuration. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecForProvider#logging
   */
  readonly logging?: BucketV1Beta2SpecForProviderLogging;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema BucketV1Beta2SpecForProvider#project
   */
  readonly project?: string;

  /**
   * Prevents public access to a bucket. Acceptable values are "inherited" or "enforced". If "inherited", the bucket uses public access prevention only if the bucket is subject to the public access prevention organization policy constraint. Defaults to "inherited".
   *
   * @default inherited".
   * @schema BucketV1Beta2SpecForProvider#publicAccessPrevention
   */
  readonly publicAccessPrevention?: string;

  /**
   * Enables Requester Pays on a storage bucket.
   *
   * @schema BucketV1Beta2SpecForProvider#requesterPays
   */
  readonly requesterPays?: boolean;

  /**
   * Configuration of the bucket's data retention policy for how long objects in the bucket should be retained. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecForProvider#retentionPolicy
   */
  readonly retentionPolicy?: BucketV1Beta2SpecForProviderRetentionPolicy;

  /**
   * The recovery point objective for cross-region replication of the bucket. Applicable only for dual and multi-region buckets. "DEFAULT" sets default replication. "ASYNC_TURBO" value enables turbo replication, valid for dual-region buckets only. See Turbo Replication for more information. If rpo is not specified at bucket creation, it defaults to "DEFAULT" for dual and multi-region buckets. NOTE If used with single-region bucket, It will throw an error.
   *
   * @schema BucketV1Beta2SpecForProvider#rpo
   */
  readonly rpo?: string;

  /**
   * The bucket's soft delete policy, which defines the period of time that soft-deleted objects will be retained, and cannot be permanently deleted. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecForProvider#softDeletePolicy
   */
  readonly softDeletePolicy?: BucketV1Beta2SpecForProviderSoftDeletePolicy;

  /**
   * The Storage Class of the new bucket. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.
   *
   * @schema BucketV1Beta2SpecForProvider#storageClass
   */
  readonly storageClass?: string;

  /**
   * Enables Uniform bucket-level access access to a bucket.
   *
   * @schema BucketV1Beta2SpecForProvider#uniformBucketLevelAccess
   */
  readonly uniformBucketLevelAccess?: boolean;

  /**
   * The bucket's Versioning configuration.  Structure is documented below.
   *
   * @schema BucketV1Beta2SpecForProvider#versioning
   */
  readonly versioning?: BucketV1Beta2SpecForProviderVersioning;

  /**
   * Configuration if the bucket acts as a website. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecForProvider#website
   */
  readonly website?: BucketV1Beta2SpecForProviderWebsite;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProvider(obj: BucketV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoclass': toJson_BucketV1Beta2SpecForProviderAutoclass(obj.autoclass),
    'cors': obj.cors?.map(y => toJson_BucketV1Beta2SpecForProviderCors(y)),
    'customPlacementConfig': toJson_BucketV1Beta2SpecForProviderCustomPlacementConfig(obj.customPlacementConfig),
    'defaultEventBasedHold': obj.defaultEventBasedHold,
    'enableObjectRetention': obj.enableObjectRetention,
    'encryption': toJson_BucketV1Beta2SpecForProviderEncryption(obj.encryption),
    'forceDestroy': obj.forceDestroy,
    'hierarchicalNamespace': toJson_BucketV1Beta2SpecForProviderHierarchicalNamespace(obj.hierarchicalNamespace),
    'ipFilter': toJson_BucketV1Beta2SpecForProviderIpFilter(obj.ipFilter),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'lifecycleRule': obj.lifecycleRule?.map(y => toJson_BucketV1Beta2SpecForProviderLifecycleRule(y)),
    'location': obj.location,
    'logging': toJson_BucketV1Beta2SpecForProviderLogging(obj.logging),
    'project': obj.project,
    'publicAccessPrevention': obj.publicAccessPrevention,
    'requesterPays': obj.requesterPays,
    'retentionPolicy': toJson_BucketV1Beta2SpecForProviderRetentionPolicy(obj.retentionPolicy),
    'rpo': obj.rpo,
    'softDeletePolicy': toJson_BucketV1Beta2SpecForProviderSoftDeletePolicy(obj.softDeletePolicy),
    'storageClass': obj.storageClass,
    'uniformBucketLevelAccess': obj.uniformBucketLevelAccess,
    'versioning': toJson_BucketV1Beta2SpecForProviderVersioning(obj.versioning),
    'website': toJson_BucketV1Beta2SpecForProviderWebsite(obj.website),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema BucketV1Beta2SpecInitProvider
 */
export interface BucketV1Beta2SpecInitProvider {
  /**
   * The bucket's Autoclass configuration.  Structure is documented below.
   *
   * @schema BucketV1Beta2SpecInitProvider#autoclass
   */
  readonly autoclass?: BucketV1Beta2SpecInitProviderAutoclass;

  /**
   * The bucket's Cross-Origin Resource Sharing (CORS) configuration. Multiple blocks of this type are permitted. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecInitProvider#cors
   */
  readonly cors?: BucketV1Beta2SpecInitProviderCors[];

  /**
   * The bucket's custom location configuration, which specifies the individual regions that comprise a dual-region bucket. If the bucket is designated a single or multi-region, the parameters are empty. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecInitProvider#customPlacementConfig
   */
  readonly customPlacementConfig?: BucketV1Beta2SpecInitProviderCustomPlacementConfig;

  /**
   * Whether or not to automatically apply an eventBasedHold to new objects added to the bucket.
   *
   * @schema BucketV1Beta2SpecInitProvider#defaultEventBasedHold
   */
  readonly defaultEventBasedHold?: boolean;

  /**
   * Enables object retention on a storage bucket.
   *
   * @schema BucketV1Beta2SpecInitProvider#enableObjectRetention
   */
  readonly enableObjectRetention?: boolean;

  /**
   * The bucket's encryption configuration. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecInitProvider#encryption
   */
  readonly encryption?: BucketV1Beta2SpecInitProviderEncryption;

  /**
   * When deleting a bucket, this
   * boolean option will delete all contained objects.
   *
   * @schema BucketV1Beta2SpecInitProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * The bucket's hierarchical namespace policy, which defines the bucket capability to handle folders in logical structure. Structure is documented below. To use this configuration, uniform_bucket_level_access must be enabled on bucket.
   *
   * @schema BucketV1Beta2SpecInitProvider#hierarchicalNamespace
   */
  readonly hierarchicalNamespace?: BucketV1Beta2SpecInitProviderHierarchicalNamespace;

  /**
   * The bucket IP filtering configuration. Specifies the network sources that can access the bucket, as well as its underlying objects. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecInitProvider#ipFilter
   */
  readonly ipFilter?: BucketV1Beta2SpecInitProviderIpFilter;

  /**
   * A map of key/value label pairs to assign to the bucket.
   *
   * @schema BucketV1Beta2SpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The bucket's Lifecycle Rules configuration. Multiple blocks of this type are permitted. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecInitProvider#lifecycleRule
   */
  readonly lifecycleRule?: BucketV1Beta2SpecInitProviderLifecycleRule[];

  /**
   * The GCS location.
   *
   * @schema BucketV1Beta2SpecInitProvider#location
   */
  readonly location?: string;

  /**
   * The bucket's Access & Storage Logs configuration. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecInitProvider#logging
   */
  readonly logging?: BucketV1Beta2SpecInitProviderLogging;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema BucketV1Beta2SpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Prevents public access to a bucket. Acceptable values are "inherited" or "enforced". If "inherited", the bucket uses public access prevention only if the bucket is subject to the public access prevention organization policy constraint. Defaults to "inherited".
   *
   * @default inherited".
   * @schema BucketV1Beta2SpecInitProvider#publicAccessPrevention
   */
  readonly publicAccessPrevention?: string;

  /**
   * Enables Requester Pays on a storage bucket.
   *
   * @schema BucketV1Beta2SpecInitProvider#requesterPays
   */
  readonly requesterPays?: boolean;

  /**
   * Configuration of the bucket's data retention policy for how long objects in the bucket should be retained. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecInitProvider#retentionPolicy
   */
  readonly retentionPolicy?: BucketV1Beta2SpecInitProviderRetentionPolicy;

  /**
   * The recovery point objective for cross-region replication of the bucket. Applicable only for dual and multi-region buckets. "DEFAULT" sets default replication. "ASYNC_TURBO" value enables turbo replication, valid for dual-region buckets only. See Turbo Replication for more information. If rpo is not specified at bucket creation, it defaults to "DEFAULT" for dual and multi-region buckets. NOTE If used with single-region bucket, It will throw an error.
   *
   * @schema BucketV1Beta2SpecInitProvider#rpo
   */
  readonly rpo?: string;

  /**
   * The bucket's soft delete policy, which defines the period of time that soft-deleted objects will be retained, and cannot be permanently deleted. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecInitProvider#softDeletePolicy
   */
  readonly softDeletePolicy?: BucketV1Beta2SpecInitProviderSoftDeletePolicy;

  /**
   * The Storage Class of the new bucket. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.
   *
   * @schema BucketV1Beta2SpecInitProvider#storageClass
   */
  readonly storageClass?: string;

  /**
   * Enables Uniform bucket-level access access to a bucket.
   *
   * @schema BucketV1Beta2SpecInitProvider#uniformBucketLevelAccess
   */
  readonly uniformBucketLevelAccess?: boolean;

  /**
   * The bucket's Versioning configuration.  Structure is documented below.
   *
   * @schema BucketV1Beta2SpecInitProvider#versioning
   */
  readonly versioning?: BucketV1Beta2SpecInitProviderVersioning;

  /**
   * Configuration if the bucket acts as a website. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecInitProvider#website
   */
  readonly website?: BucketV1Beta2SpecInitProviderWebsite;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProvider(obj: BucketV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoclass': toJson_BucketV1Beta2SpecInitProviderAutoclass(obj.autoclass),
    'cors': obj.cors?.map(y => toJson_BucketV1Beta2SpecInitProviderCors(y)),
    'customPlacementConfig': toJson_BucketV1Beta2SpecInitProviderCustomPlacementConfig(obj.customPlacementConfig),
    'defaultEventBasedHold': obj.defaultEventBasedHold,
    'enableObjectRetention': obj.enableObjectRetention,
    'encryption': toJson_BucketV1Beta2SpecInitProviderEncryption(obj.encryption),
    'forceDestroy': obj.forceDestroy,
    'hierarchicalNamespace': toJson_BucketV1Beta2SpecInitProviderHierarchicalNamespace(obj.hierarchicalNamespace),
    'ipFilter': toJson_BucketV1Beta2SpecInitProviderIpFilter(obj.ipFilter),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'lifecycleRule': obj.lifecycleRule?.map(y => toJson_BucketV1Beta2SpecInitProviderLifecycleRule(y)),
    'location': obj.location,
    'logging': toJson_BucketV1Beta2SpecInitProviderLogging(obj.logging),
    'project': obj.project,
    'publicAccessPrevention': obj.publicAccessPrevention,
    'requesterPays': obj.requesterPays,
    'retentionPolicy': toJson_BucketV1Beta2SpecInitProviderRetentionPolicy(obj.retentionPolicy),
    'rpo': obj.rpo,
    'softDeletePolicy': toJson_BucketV1Beta2SpecInitProviderSoftDeletePolicy(obj.softDeletePolicy),
    'storageClass': obj.storageClass,
    'uniformBucketLevelAccess': obj.uniformBucketLevelAccess,
    'versioning': toJson_BucketV1Beta2SpecInitProviderVersioning(obj.versioning),
    'website': toJson_BucketV1Beta2SpecInitProviderWebsite(obj.website),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema BucketV1Beta2SpecManagementPolicies
 */
export enum BucketV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema BucketV1Beta2SpecProviderConfigRef
 */
export interface BucketV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: BucketV1Beta2SpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecProviderConfigRef(obj: BucketV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema BucketV1Beta2SpecWriteConnectionSecretToRef
 */
export interface BucketV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecWriteConnectionSecretToRef(obj: BucketV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket's Autoclass configuration.  Structure is documented below.
 *
 * @schema BucketV1Beta2SpecForProviderAutoclass
 */
export interface BucketV1Beta2SpecForProviderAutoclass {
  /**
   * While set to true, autoclass automatically transitions objects in your bucket to appropriate storage classes based on each object's access pattern.
   *
   * @schema BucketV1Beta2SpecForProviderAutoclass#enabled
   */
  readonly enabled?: boolean;

  /**
   * The storage class that objects in the bucket eventually transition to if they are not read for a certain length of time. Supported values include: NEARLINE, ARCHIVE.
   *
   * @schema BucketV1Beta2SpecForProviderAutoclass#terminalStorageClass
   */
  readonly terminalStorageClass?: string;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderAutoclass' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderAutoclass(obj: BucketV1Beta2SpecForProviderAutoclass | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'terminalStorageClass': obj.terminalStorageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketV1Beta2SpecForProviderCors
 */
export interface BucketV1Beta2SpecForProviderCors {
  /**
   * The value, in seconds, to return in the Access-Control-Max-Age header used in preflight responses.
   *
   * @schema BucketV1Beta2SpecForProviderCors#maxAgeSeconds
   */
  readonly maxAgeSeconds?: number;

  /**
   * The list of HTTP methods on which to include CORS response headers, (GET, OPTIONS, POST, etc) Note: "*" is permitted in the list of methods, and means "any method".
   *
   * @schema BucketV1Beta2SpecForProviderCors#method
   */
  readonly method?: string[];

  /**
   * The list of Origins eligible to receive CORS response headers. Note: "*" is permitted in the list of origins, and means "any Origin".
   *
   * @schema BucketV1Beta2SpecForProviderCors#origin
   */
  readonly origin?: string[];

  /**
   * The list of HTTP headers other than the simple response headers to give permission for the user-agent to share across domains.
   *
   * @schema BucketV1Beta2SpecForProviderCors#responseHeader
   */
  readonly responseHeader?: string[];
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderCors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderCors(obj: BucketV1Beta2SpecForProviderCors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxAgeSeconds': obj.maxAgeSeconds,
    'method': obj.method?.map(y => y),
    'origin': obj.origin?.map(y => y),
    'responseHeader': obj.responseHeader?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket's custom location configuration, which specifies the individual regions that comprise a dual-region bucket. If the bucket is designated a single or multi-region, the parameters are empty. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecForProviderCustomPlacementConfig
 */
export interface BucketV1Beta2SpecForProviderCustomPlacementConfig {
  /**
   * The list of individual regions that comprise a dual-region bucket. See Cloud Storage bucket locations for a list of acceptable regions. Note: If any of the data_locations changes, it will recreate the bucket.
   *
   * @schema BucketV1Beta2SpecForProviderCustomPlacementConfig#dataLocations
   */
  readonly dataLocations?: string[];
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderCustomPlacementConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderCustomPlacementConfig(obj: BucketV1Beta2SpecForProviderCustomPlacementConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataLocations': obj.dataLocations?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket's encryption configuration. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecForProviderEncryption
 */
export interface BucketV1Beta2SpecForProviderEncryption {
  /**
   * : The id of a Cloud KMS key that will be used to encrypt objects inserted into this bucket, if no encryption method is specified.
   * You must pay attention to whether the crypto key is available in the location that this bucket is created in.
   * See the docs for more details.
   *
   * @schema BucketV1Beta2SpecForProviderEncryption#defaultKmsKeyName
   */
  readonly defaultKmsKeyName?: string;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderEncryption' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderEncryption(obj: BucketV1Beta2SpecForProviderEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultKmsKeyName': obj.defaultKmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket's hierarchical namespace policy, which defines the bucket capability to handle folders in logical structure. Structure is documented below. To use this configuration, uniform_bucket_level_access must be enabled on bucket.
 *
 * @schema BucketV1Beta2SpecForProviderHierarchicalNamespace
 */
export interface BucketV1Beta2SpecForProviderHierarchicalNamespace {
  /**
   * Enables hierarchical namespace for the bucket.
   *
   * @schema BucketV1Beta2SpecForProviderHierarchicalNamespace#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderHierarchicalNamespace' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderHierarchicalNamespace(obj: BucketV1Beta2SpecForProviderHierarchicalNamespace | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket IP filtering configuration. Specifies the network sources that can access the bucket, as well as its underlying objects. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecForProviderIpFilter
 */
export interface BucketV1Beta2SpecForProviderIpFilter {
  /**
   * While set true, allows all service agents to access the bucket regardless of the IP filter configuration.
   *
   * @schema BucketV1Beta2SpecForProviderIpFilter#allowAllServiceAgentAccess
   */
  readonly allowAllServiceAgentAccess?: boolean;

  /**
   * While set true, allows cross-org VPCs in the bucket's IP filter configuration.
   *
   * @schema BucketV1Beta2SpecForProviderIpFilter#allowCrossOrgVpcs
   */
  readonly allowCrossOrgVpcs?: boolean;

  /**
   * The state of the IP filter configuration. Valid values are Enabled and Disabled. When set to Enabled, IP filtering rules are applied to a bucket and all incoming requests to the bucket are evaluated against these rules. When set to Disabled, IP filtering rules are not applied to a bucket. Note: allow_all_service_agent_access must be supplied when mode is set to Enabled, it can be ommited for other values.
   *
   * @schema BucketV1Beta2SpecForProviderIpFilter#mode
   */
  readonly mode?: string;

  /**
   * The public network IP address ranges that can access the bucket and its data. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecForProviderIpFilter#publicNetworkSource
   */
  readonly publicNetworkSource?: BucketV1Beta2SpecForProviderIpFilterPublicNetworkSource;

  /**
   * The list of VPC networks that can access the bucket. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecForProviderIpFilter#vpcNetworkSources
   */
  readonly vpcNetworkSources?: BucketV1Beta2SpecForProviderIpFilterVpcNetworkSources[];
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderIpFilter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderIpFilter(obj: BucketV1Beta2SpecForProviderIpFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAllServiceAgentAccess': obj.allowAllServiceAgentAccess,
    'allowCrossOrgVpcs': obj.allowCrossOrgVpcs,
    'mode': obj.mode,
    'publicNetworkSource': toJson_BucketV1Beta2SpecForProviderIpFilterPublicNetworkSource(obj.publicNetworkSource),
    'vpcNetworkSources': obj.vpcNetworkSources?.map(y => toJson_BucketV1Beta2SpecForProviderIpFilterVpcNetworkSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketV1Beta2SpecForProviderLifecycleRule
 */
export interface BucketV1Beta2SpecForProviderLifecycleRule {
  /**
   * The Lifecycle Rule's action configuration. A single block of this type is supported. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRule#action
   */
  readonly action?: BucketV1Beta2SpecForProviderLifecycleRuleAction;

  /**
   * The Lifecycle Rule's condition configuration. A single block of this type is supported. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRule#condition
   */
  readonly condition?: BucketV1Beta2SpecForProviderLifecycleRuleCondition;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderLifecycleRule' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderLifecycleRule(obj: BucketV1Beta2SpecForProviderLifecycleRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_BucketV1Beta2SpecForProviderLifecycleRuleAction(obj.action),
    'condition': toJson_BucketV1Beta2SpecForProviderLifecycleRuleCondition(obj.condition),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket's Access & Storage Logs configuration. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecForProviderLogging
 */
export interface BucketV1Beta2SpecForProviderLogging {
  /**
   * The bucket that will receive log objects.
   *
   * @schema BucketV1Beta2SpecForProviderLogging#logBucket
   */
  readonly logBucket?: string;

  /**
   * The object prefix for log objects. If it's not provided,
   * by default GCS sets this to this bucket's name.
   *
   * @schema BucketV1Beta2SpecForProviderLogging#logObjectPrefix
   */
  readonly logObjectPrefix?: string;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderLogging' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderLogging(obj: BucketV1Beta2SpecForProviderLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logBucket': obj.logBucket,
    'logObjectPrefix': obj.logObjectPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of the bucket's data retention policy for how long objects in the bucket should be retained. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecForProviderRetentionPolicy
 */
export interface BucketV1Beta2SpecForProviderRetentionPolicy {
  /**
   * If set to true, the bucket will be locked and permanently restrict edits to the bucket's retention policy.  Caution: Locking a bucket is an irreversible action.
   *
   * @schema BucketV1Beta2SpecForProviderRetentionPolicy#isLocked
   */
  readonly isLocked?: boolean;

  /**
   * The period of time, in seconds, that objects in the bucket must be retained and cannot be deleted, overwritten, or archived. The value must be less than 2,147,483,647 seconds.
   *
   * @schema BucketV1Beta2SpecForProviderRetentionPolicy#retentionPeriod
   */
  readonly retentionPeriod?: number;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderRetentionPolicy(obj: BucketV1Beta2SpecForProviderRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isLocked': obj.isLocked,
    'retentionPeriod': obj.retentionPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket's soft delete policy, which defines the period of time that soft-deleted objects will be retained, and cannot be permanently deleted. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecForProviderSoftDeletePolicy
 */
export interface BucketV1Beta2SpecForProviderSoftDeletePolicy {
  /**
   * The duration in seconds that soft-deleted objects in the bucket will be retained and cannot be permanently deleted. Default value is 604800. The value must be in between 604800(7 days) and 7776000(90 days). Note: To disable the soft delete policy on a bucket, This field must be set to 0.
   *
   * @schema BucketV1Beta2SpecForProviderSoftDeletePolicy#retentionDurationSeconds
   */
  readonly retentionDurationSeconds?: number;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderSoftDeletePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderSoftDeletePolicy(obj: BucketV1Beta2SpecForProviderSoftDeletePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'retentionDurationSeconds': obj.retentionDurationSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket's Versioning configuration.  Structure is documented below.
 *
 * @schema BucketV1Beta2SpecForProviderVersioning
 */
export interface BucketV1Beta2SpecForProviderVersioning {
  /**
   * While set to true, versioning is fully enabled for this bucket.
   *
   * @schema BucketV1Beta2SpecForProviderVersioning#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderVersioning' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderVersioning(obj: BucketV1Beta2SpecForProviderVersioning | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration if the bucket acts as a website. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecForProviderWebsite
 */
export interface BucketV1Beta2SpecForProviderWebsite {
  /**
   * Behaves as the bucket's directory index where
   * missing objects are treated as potential directories.
   *
   * @schema BucketV1Beta2SpecForProviderWebsite#mainPageSuffix
   */
  readonly mainPageSuffix?: string;

  /**
   * The custom object to return when a requested
   * resource is not found.
   *
   * @schema BucketV1Beta2SpecForProviderWebsite#notFoundPage
   */
  readonly notFoundPage?: string;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderWebsite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderWebsite(obj: BucketV1Beta2SpecForProviderWebsite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mainPageSuffix': obj.mainPageSuffix,
    'notFoundPage': obj.notFoundPage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket's Autoclass configuration.  Structure is documented below.
 *
 * @schema BucketV1Beta2SpecInitProviderAutoclass
 */
export interface BucketV1Beta2SpecInitProviderAutoclass {
  /**
   * While set to true, autoclass automatically transitions objects in your bucket to appropriate storage classes based on each object's access pattern.
   *
   * @schema BucketV1Beta2SpecInitProviderAutoclass#enabled
   */
  readonly enabled?: boolean;

  /**
   * The storage class that objects in the bucket eventually transition to if they are not read for a certain length of time. Supported values include: NEARLINE, ARCHIVE.
   *
   * @schema BucketV1Beta2SpecInitProviderAutoclass#terminalStorageClass
   */
  readonly terminalStorageClass?: string;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderAutoclass' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderAutoclass(obj: BucketV1Beta2SpecInitProviderAutoclass | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'terminalStorageClass': obj.terminalStorageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketV1Beta2SpecInitProviderCors
 */
export interface BucketV1Beta2SpecInitProviderCors {
  /**
   * The value, in seconds, to return in the Access-Control-Max-Age header used in preflight responses.
   *
   * @schema BucketV1Beta2SpecInitProviderCors#maxAgeSeconds
   */
  readonly maxAgeSeconds?: number;

  /**
   * The list of HTTP methods on which to include CORS response headers, (GET, OPTIONS, POST, etc) Note: "*" is permitted in the list of methods, and means "any method".
   *
   * @schema BucketV1Beta2SpecInitProviderCors#method
   */
  readonly method?: string[];

  /**
   * The list of Origins eligible to receive CORS response headers. Note: "*" is permitted in the list of origins, and means "any Origin".
   *
   * @schema BucketV1Beta2SpecInitProviderCors#origin
   */
  readonly origin?: string[];

  /**
   * The list of HTTP headers other than the simple response headers to give permission for the user-agent to share across domains.
   *
   * @schema BucketV1Beta2SpecInitProviderCors#responseHeader
   */
  readonly responseHeader?: string[];
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderCors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderCors(obj: BucketV1Beta2SpecInitProviderCors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxAgeSeconds': obj.maxAgeSeconds,
    'method': obj.method?.map(y => y),
    'origin': obj.origin?.map(y => y),
    'responseHeader': obj.responseHeader?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket's custom location configuration, which specifies the individual regions that comprise a dual-region bucket. If the bucket is designated a single or multi-region, the parameters are empty. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecInitProviderCustomPlacementConfig
 */
export interface BucketV1Beta2SpecInitProviderCustomPlacementConfig {
  /**
   * The list of individual regions that comprise a dual-region bucket. See Cloud Storage bucket locations for a list of acceptable regions. Note: If any of the data_locations changes, it will recreate the bucket.
   *
   * @schema BucketV1Beta2SpecInitProviderCustomPlacementConfig#dataLocations
   */
  readonly dataLocations?: string[];
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderCustomPlacementConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderCustomPlacementConfig(obj: BucketV1Beta2SpecInitProviderCustomPlacementConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataLocations': obj.dataLocations?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket's encryption configuration. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecInitProviderEncryption
 */
export interface BucketV1Beta2SpecInitProviderEncryption {
  /**
   * : The id of a Cloud KMS key that will be used to encrypt objects inserted into this bucket, if no encryption method is specified.
   * You must pay attention to whether the crypto key is available in the location that this bucket is created in.
   * See the docs for more details.
   *
   * @schema BucketV1Beta2SpecInitProviderEncryption#defaultKmsKeyName
   */
  readonly defaultKmsKeyName?: string;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderEncryption' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderEncryption(obj: BucketV1Beta2SpecInitProviderEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultKmsKeyName': obj.defaultKmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket's hierarchical namespace policy, which defines the bucket capability to handle folders in logical structure. Structure is documented below. To use this configuration, uniform_bucket_level_access must be enabled on bucket.
 *
 * @schema BucketV1Beta2SpecInitProviderHierarchicalNamespace
 */
export interface BucketV1Beta2SpecInitProviderHierarchicalNamespace {
  /**
   * Enables hierarchical namespace for the bucket.
   *
   * @schema BucketV1Beta2SpecInitProviderHierarchicalNamespace#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderHierarchicalNamespace' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderHierarchicalNamespace(obj: BucketV1Beta2SpecInitProviderHierarchicalNamespace | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket IP filtering configuration. Specifies the network sources that can access the bucket, as well as its underlying objects. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecInitProviderIpFilter
 */
export interface BucketV1Beta2SpecInitProviderIpFilter {
  /**
   * While set true, allows all service agents to access the bucket regardless of the IP filter configuration.
   *
   * @schema BucketV1Beta2SpecInitProviderIpFilter#allowAllServiceAgentAccess
   */
  readonly allowAllServiceAgentAccess?: boolean;

  /**
   * While set true, allows cross-org VPCs in the bucket's IP filter configuration.
   *
   * @schema BucketV1Beta2SpecInitProviderIpFilter#allowCrossOrgVpcs
   */
  readonly allowCrossOrgVpcs?: boolean;

  /**
   * The state of the IP filter configuration. Valid values are Enabled and Disabled. When set to Enabled, IP filtering rules are applied to a bucket and all incoming requests to the bucket are evaluated against these rules. When set to Disabled, IP filtering rules are not applied to a bucket. Note: allow_all_service_agent_access must be supplied when mode is set to Enabled, it can be ommited for other values.
   *
   * @schema BucketV1Beta2SpecInitProviderIpFilter#mode
   */
  readonly mode?: string;

  /**
   * The public network IP address ranges that can access the bucket and its data. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecInitProviderIpFilter#publicNetworkSource
   */
  readonly publicNetworkSource?: BucketV1Beta2SpecInitProviderIpFilterPublicNetworkSource;

  /**
   * The list of VPC networks that can access the bucket. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecInitProviderIpFilter#vpcNetworkSources
   */
  readonly vpcNetworkSources?: BucketV1Beta2SpecInitProviderIpFilterVpcNetworkSources[];
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderIpFilter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderIpFilter(obj: BucketV1Beta2SpecInitProviderIpFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAllServiceAgentAccess': obj.allowAllServiceAgentAccess,
    'allowCrossOrgVpcs': obj.allowCrossOrgVpcs,
    'mode': obj.mode,
    'publicNetworkSource': toJson_BucketV1Beta2SpecInitProviderIpFilterPublicNetworkSource(obj.publicNetworkSource),
    'vpcNetworkSources': obj.vpcNetworkSources?.map(y => toJson_BucketV1Beta2SpecInitProviderIpFilterVpcNetworkSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketV1Beta2SpecInitProviderLifecycleRule
 */
export interface BucketV1Beta2SpecInitProviderLifecycleRule {
  /**
   * The Lifecycle Rule's action configuration. A single block of this type is supported. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRule#action
   */
  readonly action?: BucketV1Beta2SpecInitProviderLifecycleRuleAction;

  /**
   * The Lifecycle Rule's condition configuration. A single block of this type is supported. Structure is documented below.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRule#condition
   */
  readonly condition?: BucketV1Beta2SpecInitProviderLifecycleRuleCondition;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderLifecycleRule' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderLifecycleRule(obj: BucketV1Beta2SpecInitProviderLifecycleRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_BucketV1Beta2SpecInitProviderLifecycleRuleAction(obj.action),
    'condition': toJson_BucketV1Beta2SpecInitProviderLifecycleRuleCondition(obj.condition),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket's Access & Storage Logs configuration. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecInitProviderLogging
 */
export interface BucketV1Beta2SpecInitProviderLogging {
  /**
   * The bucket that will receive log objects.
   *
   * @schema BucketV1Beta2SpecInitProviderLogging#logBucket
   */
  readonly logBucket?: string;

  /**
   * The object prefix for log objects. If it's not provided,
   * by default GCS sets this to this bucket's name.
   *
   * @schema BucketV1Beta2SpecInitProviderLogging#logObjectPrefix
   */
  readonly logObjectPrefix?: string;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderLogging' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderLogging(obj: BucketV1Beta2SpecInitProviderLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logBucket': obj.logBucket,
    'logObjectPrefix': obj.logObjectPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of the bucket's data retention policy for how long objects in the bucket should be retained. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecInitProviderRetentionPolicy
 */
export interface BucketV1Beta2SpecInitProviderRetentionPolicy {
  /**
   * If set to true, the bucket will be locked and permanently restrict edits to the bucket's retention policy.  Caution: Locking a bucket is an irreversible action.
   *
   * @schema BucketV1Beta2SpecInitProviderRetentionPolicy#isLocked
   */
  readonly isLocked?: boolean;

  /**
   * The period of time, in seconds, that objects in the bucket must be retained and cannot be deleted, overwritten, or archived. The value must be less than 2,147,483,647 seconds.
   *
   * @schema BucketV1Beta2SpecInitProviderRetentionPolicy#retentionPeriod
   */
  readonly retentionPeriod?: number;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderRetentionPolicy(obj: BucketV1Beta2SpecInitProviderRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isLocked': obj.isLocked,
    'retentionPeriod': obj.retentionPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket's soft delete policy, which defines the period of time that soft-deleted objects will be retained, and cannot be permanently deleted. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecInitProviderSoftDeletePolicy
 */
export interface BucketV1Beta2SpecInitProviderSoftDeletePolicy {
  /**
   * The duration in seconds that soft-deleted objects in the bucket will be retained and cannot be permanently deleted. Default value is 604800. The value must be in between 604800(7 days) and 7776000(90 days). Note: To disable the soft delete policy on a bucket, This field must be set to 0.
   *
   * @schema BucketV1Beta2SpecInitProviderSoftDeletePolicy#retentionDurationSeconds
   */
  readonly retentionDurationSeconds?: number;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderSoftDeletePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderSoftDeletePolicy(obj: BucketV1Beta2SpecInitProviderSoftDeletePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'retentionDurationSeconds': obj.retentionDurationSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The bucket's Versioning configuration.  Structure is documented below.
 *
 * @schema BucketV1Beta2SpecInitProviderVersioning
 */
export interface BucketV1Beta2SpecInitProviderVersioning {
  /**
   * While set to true, versioning is fully enabled for this bucket.
   *
   * @schema BucketV1Beta2SpecInitProviderVersioning#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderVersioning' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderVersioning(obj: BucketV1Beta2SpecInitProviderVersioning | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration if the bucket acts as a website. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecInitProviderWebsite
 */
export interface BucketV1Beta2SpecInitProviderWebsite {
  /**
   * Behaves as the bucket's directory index where
   * missing objects are treated as potential directories.
   *
   * @schema BucketV1Beta2SpecInitProviderWebsite#mainPageSuffix
   */
  readonly mainPageSuffix?: string;

  /**
   * The custom object to return when a requested
   * resource is not found.
   *
   * @schema BucketV1Beta2SpecInitProviderWebsite#notFoundPage
   */
  readonly notFoundPage?: string;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderWebsite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderWebsite(obj: BucketV1Beta2SpecInitProviderWebsite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mainPageSuffix': obj.mainPageSuffix,
    'notFoundPage': obj.notFoundPage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketV1Beta2SpecProviderConfigRefPolicy
 */
export interface BucketV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema BucketV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema BucketV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketV1Beta2SpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecProviderConfigRefPolicy(obj: BucketV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The public network IP address ranges that can access the bucket and its data. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecForProviderIpFilterPublicNetworkSource
 */
export interface BucketV1Beta2SpecForProviderIpFilterPublicNetworkSource {
  /**
   * The list of public or private IPv4 and IPv6 CIDR ranges that can access the bucket.
   *
   * @schema BucketV1Beta2SpecForProviderIpFilterPublicNetworkSource#allowedIpCidrRanges
   */
  readonly allowedIpCidrRanges?: string[];
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderIpFilterPublicNetworkSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderIpFilterPublicNetworkSource(obj: BucketV1Beta2SpecForProviderIpFilterPublicNetworkSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedIpCidrRanges': obj.allowedIpCidrRanges?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketV1Beta2SpecForProviderIpFilterVpcNetworkSources
 */
export interface BucketV1Beta2SpecForProviderIpFilterVpcNetworkSources {
  /**
   * The list of public or private IPv4 and IPv6 CIDR ranges that can access the bucket.
   *
   * @schema BucketV1Beta2SpecForProviderIpFilterVpcNetworkSources#allowedIpCidrRanges
   */
  readonly allowedIpCidrRanges?: string[];

  /**
   * Name of the network. Format: projects/PROJECT_ID/global/networks/NETWORK_NAME
   *
   * @schema BucketV1Beta2SpecForProviderIpFilterVpcNetworkSources#network
   */
  readonly network?: string;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderIpFilterVpcNetworkSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderIpFilterVpcNetworkSources(obj: BucketV1Beta2SpecForProviderIpFilterVpcNetworkSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedIpCidrRanges': obj.allowedIpCidrRanges?.map(y => y),
    'network': obj.network,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Lifecycle Rule's action configuration. A single block of this type is supported. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecForProviderLifecycleRuleAction
 */
export interface BucketV1Beta2SpecForProviderLifecycleRuleAction {
  /**
   * The Storage Class of the new bucket. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleAction#storageClass
   */
  readonly storageClass?: string;

  /**
   * The type of the action of this Lifecycle Rule. Supported values include: Delete, SetStorageClass and AbortIncompleteMultipartUpload.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleAction#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderLifecycleRuleAction' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderLifecycleRuleAction(obj: BucketV1Beta2SpecForProviderLifecycleRuleAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'storageClass': obj.storageClass,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Lifecycle Rule's condition configuration. A single block of this type is supported. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition
 */
export interface BucketV1Beta2SpecForProviderLifecycleRuleCondition {
  /**
   * Minimum age of an object in days to satisfy this condition. Note To set 0 value of age, send_age_if_zero should be set true otherwise 0 value of age field will be ignored.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition#age
   */
  readonly age?: number;

  /**
   * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when an object is created before midnight of the specified date in UTC.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition#createdBefore
   */
  readonly createdBefore?: string;

  /**
   * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when the customTime metadata for the object is set to an earlier date than the date used in this lifecycle condition.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition#customTimeBefore
   */
  readonly customTimeBefore?: string;

  /**
   * Days since the date set in the customTime metadata for the object. This condition is satisfied when the current date and time is at least the specified number of days after the customTime. When set to 0 it will be ignored, and your state will treat it as though you supplied no days_since_custom_time condition.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition#daysSinceCustomTime
   */
  readonly daysSinceCustomTime?: number;

  /**
   * Relevant only for versioned objects. Number of days elapsed since the noncurrent timestamp of an object. When set to 0 it will be ignored, and your state will treat it as though you supplied no days_since_noncurrent_time condition.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition#daysSinceNoncurrentTime
   */
  readonly daysSinceNoncurrentTime?: number;

  /**
   * One or more matching name prefixes to satisfy this condition.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition#matchesPrefix
   */
  readonly matchesPrefix?: string[];

  /**
   * Storage Class of objects to satisfy this condition. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE, DURABLE_REDUCED_AVAILABILITY.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition#matchesStorageClass
   */
  readonly matchesStorageClass?: string[];

  /**
   * One or more matching name suffixes to satisfy this condition.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition#matchesSuffix
   */
  readonly matchesSuffix?: string[];

  /**
   * Relevant only for versioned objects. The date in RFC 3339 (e.g. 2017-06-13) when the object became nonconcurrent. When set to 0 it will be ignored, and your state will treat it as though you supplied no noncurrent_time_before condition.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition#noncurrentTimeBefore
   */
  readonly noncurrentTimeBefore?: string;

  /**
   * Relevant only for versioned objects. The number of newer versions of an object to satisfy this condition. When set to 0 it will be ignored and your state will treat it as though you supplied no num_newer_versions condition.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition#numNewerVersions
   */
  readonly numNewerVersions?: number;

  /**
   * While set true, age value will be sent in the request even for zero value of the field. This field is only useful and required for setting 0 value to the age field. It can be used alone or together with age attribute. NOTE age attibute with 0 value will be ommitted from the API request if send_age_if_zero field is having false value.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition#sendAgeIfZero
   */
  readonly sendAgeIfZero?: boolean;

  /**
   * While set true, days_since_custom_time value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the days_since_custom_time field. It can be used alone or together with days_since_custom_time.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition#sendDaysSinceCustomTimeIfZero
   */
  readonly sendDaysSinceCustomTimeIfZero?: boolean;

  /**
   * While set true, days_since_noncurrent_time value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the days_since_noncurrent_time field. It can be used alone or together with days_since_noncurrent_time.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition#sendDaysSinceNoncurrentTimeIfZero
   */
  readonly sendDaysSinceNoncurrentTimeIfZero?: boolean;

  /**
   * While set true, num_newer_versions value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the num_newer_versions field. It can be used alone or together with num_newer_versions.
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition#sendNumNewerVersionsIfZero
   */
  readonly sendNumNewerVersionsIfZero?: boolean;

  /**
   * Match to live and/or archived objects. Unversioned buckets have only live objects. Supported values include: "LIVE", "ARCHIVED", "ANY".
   *
   * @schema BucketV1Beta2SpecForProviderLifecycleRuleCondition#withState
   */
  readonly withState?: string;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecForProviderLifecycleRuleCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecForProviderLifecycleRuleCondition(obj: BucketV1Beta2SpecForProviderLifecycleRuleCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'age': obj.age,
    'createdBefore': obj.createdBefore,
    'customTimeBefore': obj.customTimeBefore,
    'daysSinceCustomTime': obj.daysSinceCustomTime,
    'daysSinceNoncurrentTime': obj.daysSinceNoncurrentTime,
    'matchesPrefix': obj.matchesPrefix?.map(y => y),
    'matchesStorageClass': obj.matchesStorageClass?.map(y => y),
    'matchesSuffix': obj.matchesSuffix?.map(y => y),
    'noncurrentTimeBefore': obj.noncurrentTimeBefore,
    'numNewerVersions': obj.numNewerVersions,
    'sendAgeIfZero': obj.sendAgeIfZero,
    'sendDaysSinceCustomTimeIfZero': obj.sendDaysSinceCustomTimeIfZero,
    'sendDaysSinceNoncurrentTimeIfZero': obj.sendDaysSinceNoncurrentTimeIfZero,
    'sendNumNewerVersionsIfZero': obj.sendNumNewerVersionsIfZero,
    'withState': obj.withState,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The public network IP address ranges that can access the bucket and its data. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecInitProviderIpFilterPublicNetworkSource
 */
export interface BucketV1Beta2SpecInitProviderIpFilterPublicNetworkSource {
  /**
   * The list of public or private IPv4 and IPv6 CIDR ranges that can access the bucket.
   *
   * @schema BucketV1Beta2SpecInitProviderIpFilterPublicNetworkSource#allowedIpCidrRanges
   */
  readonly allowedIpCidrRanges?: string[];
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderIpFilterPublicNetworkSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderIpFilterPublicNetworkSource(obj: BucketV1Beta2SpecInitProviderIpFilterPublicNetworkSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedIpCidrRanges': obj.allowedIpCidrRanges?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketV1Beta2SpecInitProviderIpFilterVpcNetworkSources
 */
export interface BucketV1Beta2SpecInitProviderIpFilterVpcNetworkSources {
  /**
   * The list of public or private IPv4 and IPv6 CIDR ranges that can access the bucket.
   *
   * @schema BucketV1Beta2SpecInitProviderIpFilterVpcNetworkSources#allowedIpCidrRanges
   */
  readonly allowedIpCidrRanges?: string[];

  /**
   * Name of the network. Format: projects/PROJECT_ID/global/networks/NETWORK_NAME
   *
   * @schema BucketV1Beta2SpecInitProviderIpFilterVpcNetworkSources#network
   */
  readonly network?: string;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderIpFilterVpcNetworkSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderIpFilterVpcNetworkSources(obj: BucketV1Beta2SpecInitProviderIpFilterVpcNetworkSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedIpCidrRanges': obj.allowedIpCidrRanges?.map(y => y),
    'network': obj.network,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Lifecycle Rule's action configuration. A single block of this type is supported. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecInitProviderLifecycleRuleAction
 */
export interface BucketV1Beta2SpecInitProviderLifecycleRuleAction {
  /**
   * The Storage Class of the new bucket. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleAction#storageClass
   */
  readonly storageClass?: string;

  /**
   * The type of the action of this Lifecycle Rule. Supported values include: Delete, SetStorageClass and AbortIncompleteMultipartUpload.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleAction#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderLifecycleRuleAction' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderLifecycleRuleAction(obj: BucketV1Beta2SpecInitProviderLifecycleRuleAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'storageClass': obj.storageClass,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Lifecycle Rule's condition configuration. A single block of this type is supported. Structure is documented below.
 *
 * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition
 */
export interface BucketV1Beta2SpecInitProviderLifecycleRuleCondition {
  /**
   * Minimum age of an object in days to satisfy this condition. Note To set 0 value of age, send_age_if_zero should be set true otherwise 0 value of age field will be ignored.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition#age
   */
  readonly age?: number;

  /**
   * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when an object is created before midnight of the specified date in UTC.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition#createdBefore
   */
  readonly createdBefore?: string;

  /**
   * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when the customTime metadata for the object is set to an earlier date than the date used in this lifecycle condition.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition#customTimeBefore
   */
  readonly customTimeBefore?: string;

  /**
   * Days since the date set in the customTime metadata for the object. This condition is satisfied when the current date and time is at least the specified number of days after the customTime. When set to 0 it will be ignored, and your state will treat it as though you supplied no days_since_custom_time condition.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition#daysSinceCustomTime
   */
  readonly daysSinceCustomTime?: number;

  /**
   * Relevant only for versioned objects. Number of days elapsed since the noncurrent timestamp of an object. When set to 0 it will be ignored, and your state will treat it as though you supplied no days_since_noncurrent_time condition.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition#daysSinceNoncurrentTime
   */
  readonly daysSinceNoncurrentTime?: number;

  /**
   * One or more matching name prefixes to satisfy this condition.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition#matchesPrefix
   */
  readonly matchesPrefix?: string[];

  /**
   * Storage Class of objects to satisfy this condition. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE, DURABLE_REDUCED_AVAILABILITY.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition#matchesStorageClass
   */
  readonly matchesStorageClass?: string[];

  /**
   * One or more matching name suffixes to satisfy this condition.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition#matchesSuffix
   */
  readonly matchesSuffix?: string[];

  /**
   * Relevant only for versioned objects. The date in RFC 3339 (e.g. 2017-06-13) when the object became nonconcurrent. When set to 0 it will be ignored, and your state will treat it as though you supplied no noncurrent_time_before condition.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition#noncurrentTimeBefore
   */
  readonly noncurrentTimeBefore?: string;

  /**
   * Relevant only for versioned objects. The number of newer versions of an object to satisfy this condition. When set to 0 it will be ignored and your state will treat it as though you supplied no num_newer_versions condition.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition#numNewerVersions
   */
  readonly numNewerVersions?: number;

  /**
   * While set true, age value will be sent in the request even for zero value of the field. This field is only useful and required for setting 0 value to the age field. It can be used alone or together with age attribute. NOTE age attibute with 0 value will be ommitted from the API request if send_age_if_zero field is having false value.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition#sendAgeIfZero
   */
  readonly sendAgeIfZero?: boolean;

  /**
   * While set true, days_since_custom_time value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the days_since_custom_time field. It can be used alone or together with days_since_custom_time.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition#sendDaysSinceCustomTimeIfZero
   */
  readonly sendDaysSinceCustomTimeIfZero?: boolean;

  /**
   * While set true, days_since_noncurrent_time value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the days_since_noncurrent_time field. It can be used alone or together with days_since_noncurrent_time.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition#sendDaysSinceNoncurrentTimeIfZero
   */
  readonly sendDaysSinceNoncurrentTimeIfZero?: boolean;

  /**
   * While set true, num_newer_versions value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the num_newer_versions field. It can be used alone or together with num_newer_versions.
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition#sendNumNewerVersionsIfZero
   */
  readonly sendNumNewerVersionsIfZero?: boolean;

  /**
   * Match to live and/or archived objects. Unversioned buckets have only live objects. Supported values include: "LIVE", "ARCHIVED", "ANY".
   *
   * @schema BucketV1Beta2SpecInitProviderLifecycleRuleCondition#withState
   */
  readonly withState?: string;
}

/**
 * Converts an object of type 'BucketV1Beta2SpecInitProviderLifecycleRuleCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketV1Beta2SpecInitProviderLifecycleRuleCondition(obj: BucketV1Beta2SpecInitProviderLifecycleRuleCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'age': obj.age,
    'createdBefore': obj.createdBefore,
    'customTimeBefore': obj.customTimeBefore,
    'daysSinceCustomTime': obj.daysSinceCustomTime,
    'daysSinceNoncurrentTime': obj.daysSinceNoncurrentTime,
    'matchesPrefix': obj.matchesPrefix?.map(y => y),
    'matchesStorageClass': obj.matchesStorageClass?.map(y => y),
    'matchesSuffix': obj.matchesSuffix?.map(y => y),
    'noncurrentTimeBefore': obj.noncurrentTimeBefore,
    'numNewerVersions': obj.numNewerVersions,
    'sendAgeIfZero': obj.sendAgeIfZero,
    'sendDaysSinceCustomTimeIfZero': obj.sendDaysSinceCustomTimeIfZero,
    'sendDaysSinceNoncurrentTimeIfZero': obj.sendDaysSinceNoncurrentTimeIfZero,
    'sendNumNewerVersionsIfZero': obj.sendNumNewerVersionsIfZero,
    'withState': obj.withState,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema BucketV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum BucketV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema BucketV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum BucketV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketIAMMember is the Schema for the BucketIAMMembers API. <no value>
 *
 * @schema BucketIAMMember
 */
export class BucketIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta1',
    kind: 'BucketIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "BucketIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketIamMemberProps): any {
    return {
      ...BucketIamMember.GVK,
      ...toJson_BucketIamMemberProps(props),
    };
  }

  /**
   * Defines a "BucketIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketIamMemberProps) {
    super(scope, id, {
      ...BucketIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketIamMember.GVK,
      ...toJson_BucketIamMemberProps(resolved),
    };
  }
}

/**
 * BucketIAMMember is the Schema for the BucketIAMMembers API. <no value>
 *
 * @schema BucketIAMMember
 */
export interface BucketIamMemberProps {
  /**
   * @schema BucketIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketIAMMemberSpec defines the desired state of BucketIAMMember
   *
   * @schema BucketIAMMember#spec
   */
  readonly spec: BucketIamMemberSpec;
}

/**
 * Converts an object of type 'BucketIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberProps(obj: BucketIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BucketIAMMemberSpec defines the desired state of BucketIAMMember
 *
 * @schema BucketIamMemberSpec
 */
export interface BucketIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BucketIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketIamMemberSpecDeletionPolicy;

  /**
   * @schema BucketIamMemberSpec#forProvider
   */
  readonly forProvider: BucketIamMemberSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema BucketIamMemberSpec#initProvider
   */
  readonly initProvider?: BucketIamMemberSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BucketIamMemberSpec#managementPolicies
   */
  readonly managementPolicies?: BucketIamMemberSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema BucketIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketIamMemberSpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema BucketIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketIamMemberSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'BucketIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpec(obj: BucketIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketIamMemberSpecForProvider(obj.forProvider),
    'initProvider': toJson_BucketIamMemberSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BucketIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_BucketIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BucketIamMemberSpecDeletionPolicy
 */
export enum BucketIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketIamMemberSpecForProvider
 */
export interface BucketIamMemberSpecForProvider {
  /**
   * @schema BucketIamMemberSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema BucketIamMemberSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketIamMemberSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema BucketIamMemberSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketIamMemberSpecForProviderBucketSelector;

  /**
   * @schema BucketIamMemberSpecForProvider#condition
   */
  readonly condition?: BucketIamMemberSpecForProviderCondition[];

  /**
   * @schema BucketIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema BucketIamMemberSpecForProvider#role
   */
  readonly role?: string;
}

/**
 * Converts an object of type 'BucketIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpecForProvider(obj: BucketIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketIamMemberSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketIamMemberSpecForProviderBucketSelector(obj.bucketSelector),
    'condition': obj.condition?.map(y => toJson_BucketIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema BucketIamMemberSpecInitProvider
 */
export interface BucketIamMemberSpecInitProvider {
  /**
   * @schema BucketIamMemberSpecInitProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema BucketIamMemberSpecInitProvider#bucketRef
   */
  readonly bucketRef?: BucketIamMemberSpecInitProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema BucketIamMemberSpecInitProvider#bucketSelector
   */
  readonly bucketSelector?: BucketIamMemberSpecInitProviderBucketSelector;

  /**
   * @schema BucketIamMemberSpecInitProvider#condition
   */
  readonly condition?: BucketIamMemberSpecInitProviderCondition[];

  /**
   * @schema BucketIamMemberSpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema BucketIamMemberSpecInitProvider#role
   */
  readonly role?: string;
}

/**
 * Converts an object of type 'BucketIamMemberSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpecInitProvider(obj: BucketIamMemberSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketIamMemberSpecInitProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketIamMemberSpecInitProviderBucketSelector(obj.bucketSelector),
    'condition': obj.condition?.map(y => toJson_BucketIamMemberSpecInitProviderCondition(y)),
    'member': obj.member,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema BucketIamMemberSpecManagementPolicies
 */
export enum BucketIamMemberSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema BucketIamMemberSpecProviderConfigRef
 */
export interface BucketIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: BucketIamMemberSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'BucketIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpecProviderConfigRef(obj: BucketIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema BucketIamMemberSpecWriteConnectionSecretToRef
 */
export interface BucketIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'BucketIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpecWriteConnectionSecretToRef(obj: BucketIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema BucketIamMemberSpecForProviderBucketRef
 */
export interface BucketIamMemberSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIamMemberSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIamMemberSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketIamMemberSpecForProviderBucketRefPolicy;
}

/**
 * Converts an object of type 'BucketIamMemberSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpecForProviderBucketRef(obj: BucketIamMemberSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIamMemberSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema BucketIamMemberSpecForProviderBucketSelector
 */
export interface BucketIamMemberSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema BucketIamMemberSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketIamMemberSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketIamMemberSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketIamMemberSpecForProviderBucketSelectorPolicy;
}

/**
 * Converts an object of type 'BucketIamMemberSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpecForProviderBucketSelector(obj: BucketIamMemberSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketIamMemberSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketIamMemberSpecForProviderCondition
 */
export interface BucketIamMemberSpecForProviderCondition {
  /**
   * @schema BucketIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema BucketIamMemberSpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema BucketIamMemberSpecForProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'BucketIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpecForProviderCondition(obj: BucketIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema BucketIamMemberSpecInitProviderBucketRef
 */
export interface BucketIamMemberSpecInitProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIamMemberSpecInitProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIamMemberSpecInitProviderBucketRef#policy
   */
  readonly policy?: BucketIamMemberSpecInitProviderBucketRefPolicy;
}

/**
 * Converts an object of type 'BucketIamMemberSpecInitProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpecInitProviderBucketRef(obj: BucketIamMemberSpecInitProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIamMemberSpecInitProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema BucketIamMemberSpecInitProviderBucketSelector
 */
export interface BucketIamMemberSpecInitProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema BucketIamMemberSpecInitProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketIamMemberSpecInitProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketIamMemberSpecInitProviderBucketSelector#policy
   */
  readonly policy?: BucketIamMemberSpecInitProviderBucketSelectorPolicy;
}

/**
 * Converts an object of type 'BucketIamMemberSpecInitProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpecInitProviderBucketSelector(obj: BucketIamMemberSpecInitProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketIamMemberSpecInitProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketIamMemberSpecInitProviderCondition
 */
export interface BucketIamMemberSpecInitProviderCondition {
  /**
   * @schema BucketIamMemberSpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema BucketIamMemberSpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema BucketIamMemberSpecInitProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'BucketIamMemberSpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpecInitProviderCondition(obj: BucketIamMemberSpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketIamMemberSpecProviderConfigRefPolicy
 */
export interface BucketIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema BucketIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketIamMemberSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'BucketIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpecProviderConfigRefPolicy(obj: BucketIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketIamMemberSpecForProviderBucketRefPolicy
 */
export interface BucketIamMemberSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketIamMemberSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema BucketIamMemberSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketIamMemberSpecForProviderBucketRefPolicyResolve;
}

/**
 * Converts an object of type 'BucketIamMemberSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpecForProviderBucketRefPolicy(obj: BucketIamMemberSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketIamMemberSpecForProviderBucketSelectorPolicy
 */
export interface BucketIamMemberSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketIamMemberSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema BucketIamMemberSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketIamMemberSpecForProviderBucketSelectorPolicyResolve;
}

/**
 * Converts an object of type 'BucketIamMemberSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpecForProviderBucketSelectorPolicy(obj: BucketIamMemberSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketIamMemberSpecInitProviderBucketRefPolicy
 */
export interface BucketIamMemberSpecInitProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberSpecInitProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketIamMemberSpecInitProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema BucketIamMemberSpecInitProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketIamMemberSpecInitProviderBucketRefPolicyResolve;
}

/**
 * Converts an object of type 'BucketIamMemberSpecInitProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpecInitProviderBucketRefPolicy(obj: BucketIamMemberSpecInitProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketIamMemberSpecInitProviderBucketSelectorPolicy
 */
export interface BucketIamMemberSpecInitProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberSpecInitProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketIamMemberSpecInitProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema BucketIamMemberSpecInitProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketIamMemberSpecInitProviderBucketSelectorPolicyResolve;
}

/**
 * Converts an object of type 'BucketIamMemberSpecInitProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberSpecInitProviderBucketSelectorPolicy(obj: BucketIamMemberSpecInitProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum BucketIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema BucketIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum BucketIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberSpecForProviderBucketRefPolicyResolution
 */
export enum BucketIamMemberSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema BucketIamMemberSpecForProviderBucketRefPolicyResolve
 */
export enum BucketIamMemberSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketIamMemberSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema BucketIamMemberSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketIamMemberSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberSpecInitProviderBucketRefPolicyResolution
 */
export enum BucketIamMemberSpecInitProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema BucketIamMemberSpecInitProviderBucketRefPolicyResolve
 */
export enum BucketIamMemberSpecInitProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberSpecInitProviderBucketSelectorPolicyResolution
 */
export enum BucketIamMemberSpecInitProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema BucketIamMemberSpecInitProviderBucketSelectorPolicyResolve
 */
export enum BucketIamMemberSpecInitProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketIAMMember is the Schema for the BucketIAMMembers API. <no value>
 *
 * @schema BucketIAMMemberV1Beta2
 */
export class BucketIamMemberV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketIAMMemberV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'storage.gcp.upbound.io/v1beta2',
    kind: 'BucketIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "BucketIAMMemberV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketIamMemberV1Beta2Props): any {
    return {
      ...BucketIamMemberV1Beta2.GVK,
      ...toJson_BucketIamMemberV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BucketIAMMemberV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketIamMemberV1Beta2Props) {
    super(scope, id, {
      ...BucketIamMemberV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketIamMemberV1Beta2.GVK,
      ...toJson_BucketIamMemberV1Beta2Props(resolved),
    };
  }
}

/**
 * BucketIAMMember is the Schema for the BucketIAMMembers API. <no value>
 *
 * @schema BucketIAMMemberV1Beta2
 */
export interface BucketIamMemberV1Beta2Props {
  /**
   * @schema BucketIAMMemberV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketIAMMemberSpec defines the desired state of BucketIAMMember
   *
   * @schema BucketIAMMemberV1Beta2#spec
   */
  readonly spec: BucketIamMemberV1Beta2Spec;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2Props(obj: BucketIamMemberV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketIamMemberV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BucketIAMMemberSpec defines the desired state of BucketIAMMember
 *
 * @schema BucketIamMemberV1Beta2Spec
 */
export interface BucketIamMemberV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BucketIamMemberV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: BucketIamMemberV1Beta2SpecDeletionPolicy;

  /**
   * @schema BucketIamMemberV1Beta2Spec#forProvider
   */
  readonly forProvider: BucketIamMemberV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema BucketIamMemberV1Beta2Spec#initProvider
   */
  readonly initProvider?: BucketIamMemberV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BucketIamMemberV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: BucketIamMemberV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema BucketIamMemberV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: BucketIamMemberV1Beta2SpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema BucketIamMemberV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketIamMemberV1Beta2SpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2Spec(obj: BucketIamMemberV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketIamMemberV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_BucketIamMemberV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BucketIamMemberV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_BucketIamMemberV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BucketIamMemberV1Beta2SpecDeletionPolicy
 */
export enum BucketIamMemberV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketIamMemberV1Beta2SpecForProvider
 */
export interface BucketIamMemberV1Beta2SpecForProvider {
  /**
   * @schema BucketIamMemberV1Beta2SpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema BucketIamMemberV1Beta2SpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketIamMemberV1Beta2SpecForProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema BucketIamMemberV1Beta2SpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketIamMemberV1Beta2SpecForProviderBucketSelector;

  /**
   * @schema BucketIamMemberV1Beta2SpecForProvider#condition
   */
  readonly condition?: BucketIamMemberV1Beta2SpecForProviderCondition;

  /**
   * @schema BucketIamMemberV1Beta2SpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema BucketIamMemberV1Beta2SpecForProvider#role
   */
  readonly role?: string;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2SpecForProvider(obj: BucketIamMemberV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketIamMemberV1Beta2SpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketIamMemberV1Beta2SpecForProviderBucketSelector(obj.bucketSelector),
    'condition': toJson_BucketIamMemberV1Beta2SpecForProviderCondition(obj.condition),
    'member': obj.member,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema BucketIamMemberV1Beta2SpecInitProvider
 */
export interface BucketIamMemberV1Beta2SpecInitProvider {
  /**
   * @schema BucketIamMemberV1Beta2SpecInitProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in storage to populate bucket.
   *
   * @schema BucketIamMemberV1Beta2SpecInitProvider#bucketRef
   */
  readonly bucketRef?: BucketIamMemberV1Beta2SpecInitProviderBucketRef;

  /**
   * Selector for a Bucket in storage to populate bucket.
   *
   * @schema BucketIamMemberV1Beta2SpecInitProvider#bucketSelector
   */
  readonly bucketSelector?: BucketIamMemberV1Beta2SpecInitProviderBucketSelector;

  /**
   * @schema BucketIamMemberV1Beta2SpecInitProvider#condition
   */
  readonly condition?: BucketIamMemberV1Beta2SpecInitProviderCondition;

  /**
   * @schema BucketIamMemberV1Beta2SpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema BucketIamMemberV1Beta2SpecInitProvider#role
   */
  readonly role?: string;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2SpecInitProvider(obj: BucketIamMemberV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketIamMemberV1Beta2SpecInitProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketIamMemberV1Beta2SpecInitProviderBucketSelector(obj.bucketSelector),
    'condition': toJson_BucketIamMemberV1Beta2SpecInitProviderCondition(obj.condition),
    'member': obj.member,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema BucketIamMemberV1Beta2SpecManagementPolicies
 */
export enum BucketIamMemberV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema BucketIamMemberV1Beta2SpecProviderConfigRef
 */
export interface BucketIamMemberV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIamMemberV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIamMemberV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: BucketIamMemberV1Beta2SpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2SpecProviderConfigRef(obj: BucketIamMemberV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIamMemberV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema BucketIamMemberV1Beta2SpecWriteConnectionSecretToRef
 */
export interface BucketIamMemberV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketIamMemberV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketIamMemberV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2SpecWriteConnectionSecretToRef(obj: BucketIamMemberV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema BucketIamMemberV1Beta2SpecForProviderBucketRef
 */
export interface BucketIamMemberV1Beta2SpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIamMemberV1Beta2SpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIamMemberV1Beta2SpecForProviderBucketRef#policy
   */
  readonly policy?: BucketIamMemberV1Beta2SpecForProviderBucketRefPolicy;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2SpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2SpecForProviderBucketRef(obj: BucketIamMemberV1Beta2SpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIamMemberV1Beta2SpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema BucketIamMemberV1Beta2SpecForProviderBucketSelector
 */
export interface BucketIamMemberV1Beta2SpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema BucketIamMemberV1Beta2SpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketIamMemberV1Beta2SpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketIamMemberV1Beta2SpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketIamMemberV1Beta2SpecForProviderBucketSelectorPolicy;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2SpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2SpecForProviderBucketSelector(obj: BucketIamMemberV1Beta2SpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketIamMemberV1Beta2SpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketIamMemberV1Beta2SpecForProviderCondition
 */
export interface BucketIamMemberV1Beta2SpecForProviderCondition {
  /**
   * @schema BucketIamMemberV1Beta2SpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema BucketIamMemberV1Beta2SpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema BucketIamMemberV1Beta2SpecForProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2SpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2SpecForProviderCondition(obj: BucketIamMemberV1Beta2SpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Bucket in storage to populate bucket.
 *
 * @schema BucketIamMemberV1Beta2SpecInitProviderBucketRef
 */
export interface BucketIamMemberV1Beta2SpecInitProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIamMemberV1Beta2SpecInitProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIamMemberV1Beta2SpecInitProviderBucketRef#policy
   */
  readonly policy?: BucketIamMemberV1Beta2SpecInitProviderBucketRefPolicy;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2SpecInitProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2SpecInitProviderBucketRef(obj: BucketIamMemberV1Beta2SpecInitProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIamMemberV1Beta2SpecInitProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Bucket in storage to populate bucket.
 *
 * @schema BucketIamMemberV1Beta2SpecInitProviderBucketSelector
 */
export interface BucketIamMemberV1Beta2SpecInitProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema BucketIamMemberV1Beta2SpecInitProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketIamMemberV1Beta2SpecInitProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketIamMemberV1Beta2SpecInitProviderBucketSelector#policy
   */
  readonly policy?: BucketIamMemberV1Beta2SpecInitProviderBucketSelectorPolicy;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2SpecInitProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2SpecInitProviderBucketSelector(obj: BucketIamMemberV1Beta2SpecInitProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketIamMemberV1Beta2SpecInitProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BucketIamMemberV1Beta2SpecInitProviderCondition
 */
export interface BucketIamMemberV1Beta2SpecInitProviderCondition {
  /**
   * @schema BucketIamMemberV1Beta2SpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema BucketIamMemberV1Beta2SpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema BucketIamMemberV1Beta2SpecInitProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2SpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2SpecInitProviderCondition(obj: BucketIamMemberV1Beta2SpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketIamMemberV1Beta2SpecProviderConfigRefPolicy
 */
export interface BucketIamMemberV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketIamMemberV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema BucketIamMemberV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketIamMemberV1Beta2SpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2SpecProviderConfigRefPolicy(obj: BucketIamMemberV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketIamMemberV1Beta2SpecForProviderBucketRefPolicy
 */
export interface BucketIamMemberV1Beta2SpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberV1Beta2SpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketIamMemberV1Beta2SpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema BucketIamMemberV1Beta2SpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketIamMemberV1Beta2SpecForProviderBucketRefPolicyResolve;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2SpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2SpecForProviderBucketRefPolicy(obj: BucketIamMemberV1Beta2SpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketIamMemberV1Beta2SpecForProviderBucketSelectorPolicy
 */
export interface BucketIamMemberV1Beta2SpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberV1Beta2SpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketIamMemberV1Beta2SpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema BucketIamMemberV1Beta2SpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketIamMemberV1Beta2SpecForProviderBucketSelectorPolicyResolve;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2SpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2SpecForProviderBucketSelectorPolicy(obj: BucketIamMemberV1Beta2SpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketIamMemberV1Beta2SpecInitProviderBucketRefPolicy
 */
export interface BucketIamMemberV1Beta2SpecInitProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberV1Beta2SpecInitProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketIamMemberV1Beta2SpecInitProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema BucketIamMemberV1Beta2SpecInitProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketIamMemberV1Beta2SpecInitProviderBucketRefPolicyResolve;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2SpecInitProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2SpecInitProviderBucketRefPolicy(obj: BucketIamMemberV1Beta2SpecInitProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketIamMemberV1Beta2SpecInitProviderBucketSelectorPolicy
 */
export interface BucketIamMemberV1Beta2SpecInitProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema BucketIamMemberV1Beta2SpecInitProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketIamMemberV1Beta2SpecInitProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema BucketIamMemberV1Beta2SpecInitProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketIamMemberV1Beta2SpecInitProviderBucketSelectorPolicyResolve;
}

/**
 * Converts an object of type 'BucketIamMemberV1Beta2SpecInitProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BucketIamMemberV1Beta2SpecInitProviderBucketSelectorPolicy(obj: BucketIamMemberV1Beta2SpecInitProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum BucketIamMemberV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema BucketIamMemberV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum BucketIamMemberV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberV1Beta2SpecForProviderBucketRefPolicyResolution
 */
export enum BucketIamMemberV1Beta2SpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema BucketIamMemberV1Beta2SpecForProviderBucketRefPolicyResolve
 */
export enum BucketIamMemberV1Beta2SpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberV1Beta2SpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketIamMemberV1Beta2SpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema BucketIamMemberV1Beta2SpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketIamMemberV1Beta2SpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberV1Beta2SpecInitProviderBucketRefPolicyResolution
 */
export enum BucketIamMemberV1Beta2SpecInitProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema BucketIamMemberV1Beta2SpecInitProviderBucketRefPolicyResolve
 */
export enum BucketIamMemberV1Beta2SpecInitProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema BucketIamMemberV1Beta2SpecInitProviderBucketSelectorPolicyResolution
 */
export enum BucketIamMemberV1Beta2SpecInitProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema BucketIamMemberV1Beta2SpecInitProviderBucketSelectorPolicyResolve
 */
export enum BucketIamMemberV1Beta2SpecInitProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

