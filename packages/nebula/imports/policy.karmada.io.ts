// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ClusterOverridePolicy represents the cluster-wide policy that overrides a group of resources to one or more clusters.
 *
 * @schema ClusterOverridePolicy
 */
export class ClusterOverridePolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterOverridePolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'policy.karmada.io/v1alpha1',
    kind: 'ClusterOverridePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterOverridePolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterOverridePolicyProps): any {
    return {
      ...ClusterOverridePolicy.GVK,
      ...toJson_ClusterOverridePolicyProps(props),
    };
  }

  /**
   * Defines a "ClusterOverridePolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterOverridePolicyProps) {
    super(scope, id, {
      ...ClusterOverridePolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterOverridePolicy.GVK,
      ...toJson_ClusterOverridePolicyProps(resolved),
    };
  }
}

/**
 * ClusterOverridePolicy represents the cluster-wide policy that overrides a group of resources to one or more clusters.
 *
 * @schema ClusterOverridePolicy
 */
export interface ClusterOverridePolicyProps {
  /**
   * @schema ClusterOverridePolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec represents the desired behavior of ClusterOverridePolicy.
   *
   * @schema ClusterOverridePolicy#spec
   */
  readonly spec: ClusterOverridePolicySpec;
}

/**
 * Converts an object of type 'ClusterOverridePolicyProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicyProps(obj: ClusterOverridePolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterOverridePolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec represents the desired behavior of ClusterOverridePolicy.
 *
 * @schema ClusterOverridePolicySpec
 */
export interface ClusterOverridePolicySpec {
  /**
   * OverrideRules defines a collection of override rules on target clusters.
   *
   * @schema ClusterOverridePolicySpec#overrideRules
   */
  readonly overrideRules?: ClusterOverridePolicySpecOverrideRules[];

  /**
   * Overriders represents the override rules that would apply on resources
   *
   * Deprecated: This filed is deprecated in v1.0 and please use the OverrideRules instead.
   *
   * @schema ClusterOverridePolicySpec#overriders
   */
  readonly overriders?: ClusterOverridePolicySpecOverriders;

  /**
   * ResourceSelectors restricts resource types that this override policy applies to.
   * nil means matching all resources.
   *
   * @schema ClusterOverridePolicySpec#resourceSelectors
   */
  readonly resourceSelectors?: ClusterOverridePolicySpecResourceSelectors[];

  /**
   * TargetCluster defines restrictions on this override policy
   * that only applies to resources propagated to the matching clusters.
   * nil means matching all clusters.
   *
   * Deprecated: This filed is deprecated in v1.0 and please use the OverrideRules instead.
   *
   * @schema ClusterOverridePolicySpec#targetCluster
   */
  readonly targetCluster?: ClusterOverridePolicySpecTargetCluster;
}

/**
 * Converts an object of type 'ClusterOverridePolicySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpec(obj: ClusterOverridePolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'overrideRules': obj.overrideRules?.map(y => toJson_ClusterOverridePolicySpecOverrideRules(y)),
    'overriders': toJson_ClusterOverridePolicySpecOverriders(obj.overriders),
    'resourceSelectors': obj.resourceSelectors?.map(y => toJson_ClusterOverridePolicySpecResourceSelectors(y)),
    'targetCluster': toJson_ClusterOverridePolicySpecTargetCluster(obj.targetCluster),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RuleWithCluster defines the override rules on clusters.
 *
 * @schema ClusterOverridePolicySpecOverrideRules
 */
export interface ClusterOverridePolicySpecOverrideRules {
  /**
   * Overriders represents the override rules that would apply on resources
   *
   * @schema ClusterOverridePolicySpecOverrideRules#overriders
   */
  readonly overriders: ClusterOverridePolicySpecOverrideRulesOverriders;

  /**
   * TargetCluster defines restrictions on this override policy
   * that only applies to resources propagated to the matching clusters.
   * nil means matching all clusters.
   *
   * @schema ClusterOverridePolicySpecOverrideRules#targetCluster
   */
  readonly targetCluster?: ClusterOverridePolicySpecOverrideRulesTargetCluster;
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRules(obj: ClusterOverridePolicySpecOverrideRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'overriders': toJson_ClusterOverridePolicySpecOverrideRulesOverriders(obj.overriders),
    'targetCluster': toJson_ClusterOverridePolicySpecOverrideRulesTargetCluster(obj.targetCluster),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Overriders represents the override rules that would apply on resources
 *
 * Deprecated: This filed is deprecated in v1.0 and please use the OverrideRules instead.
 *
 * @schema ClusterOverridePolicySpecOverriders
 */
export interface ClusterOverridePolicySpecOverriders {
  /**
   * AnnotationsOverrider represents the rules dedicated to handling workload annotations
   *
   * @schema ClusterOverridePolicySpecOverriders#annotationsOverrider
   */
  readonly annotationsOverrider?: ClusterOverridePolicySpecOverridersAnnotationsOverrider[];

  /**
   * ArgsOverrider represents the rules dedicated to handling container args
   *
   * @schema ClusterOverridePolicySpecOverriders#argsOverrider
   */
  readonly argsOverrider?: ClusterOverridePolicySpecOverridersArgsOverrider[];

  /**
   * CommandOverrider represents the rules dedicated to handling container command
   *
   * @schema ClusterOverridePolicySpecOverriders#commandOverrider
   */
  readonly commandOverrider?: ClusterOverridePolicySpecOverridersCommandOverrider[];

  /**
   * FieldOverrider represents the rules dedicated to modifying a specific field in any Kubernetes resource.
   * This allows changing a single field within the resource with multiple operations.
   * It is designed to handle structured field values such as those found in ConfigMaps or Secrets.
   * The current implementation supports JSON and YAML formats, but can easily be extended to support XML in the future.
   *
   * @schema ClusterOverridePolicySpecOverriders#fieldOverrider
   */
  readonly fieldOverrider?: ClusterOverridePolicySpecOverridersFieldOverrider[];

  /**
   * ImageOverrider represents the rules dedicated to handling image overrides.
   *
   * @schema ClusterOverridePolicySpecOverriders#imageOverrider
   */
  readonly imageOverrider?: ClusterOverridePolicySpecOverridersImageOverrider[];

  /**
   * LabelsOverrider represents the rules dedicated to handling workload labels
   *
   * @schema ClusterOverridePolicySpecOverriders#labelsOverrider
   */
  readonly labelsOverrider?: ClusterOverridePolicySpecOverridersLabelsOverrider[];

  /**
   * Plaintext represents override rules defined with plaintext overriders.
   *
   * @schema ClusterOverridePolicySpecOverriders#plaintext
   */
  readonly plaintext?: ClusterOverridePolicySpecOverridersPlaintext[];
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverriders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverriders(obj: ClusterOverridePolicySpecOverriders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotationsOverrider': obj.annotationsOverrider?.map(y => toJson_ClusterOverridePolicySpecOverridersAnnotationsOverrider(y)),
    'argsOverrider': obj.argsOverrider?.map(y => toJson_ClusterOverridePolicySpecOverridersArgsOverrider(y)),
    'commandOverrider': obj.commandOverrider?.map(y => toJson_ClusterOverridePolicySpecOverridersCommandOverrider(y)),
    'fieldOverrider': obj.fieldOverrider?.map(y => toJson_ClusterOverridePolicySpecOverridersFieldOverrider(y)),
    'imageOverrider': obj.imageOverrider?.map(y => toJson_ClusterOverridePolicySpecOverridersImageOverrider(y)),
    'labelsOverrider': obj.labelsOverrider?.map(y => toJson_ClusterOverridePolicySpecOverridersLabelsOverrider(y)),
    'plaintext': obj.plaintext?.map(y => toJson_ClusterOverridePolicySpecOverridersPlaintext(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceSelector the resources will be selected.
 *
 * @schema ClusterOverridePolicySpecResourceSelectors
 */
export interface ClusterOverridePolicySpecResourceSelectors {
  /**
   * APIVersion represents the API version of the target resources.
   *
   * @schema ClusterOverridePolicySpecResourceSelectors#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind represents the Kind of the target resources.
   *
   * @schema ClusterOverridePolicySpecResourceSelectors#kind
   */
  readonly kind: string;

  /**
   * A label query over a set of resources.
   * If name is not empty, labelSelector will be ignored.
   *
   * @schema ClusterOverridePolicySpecResourceSelectors#labelSelector
   */
  readonly labelSelector?: ClusterOverridePolicySpecResourceSelectorsLabelSelector;

  /**
   * Name of the target resource.
   * Default is empty, which means selecting all resources.
   *
   * @default empty, which means selecting all resources.
   * @schema ClusterOverridePolicySpecResourceSelectors#name
   */
  readonly name?: string;

  /**
   * Namespace of the target resource.
   * Default is empty, which means inherit from the parent object scope.
   *
   * @default empty, which means inherit from the parent object scope.
   * @schema ClusterOverridePolicySpecResourceSelectors#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecResourceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecResourceSelectors(obj: ClusterOverridePolicySpecResourceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'labelSelector': toJson_ClusterOverridePolicySpecResourceSelectorsLabelSelector(obj.labelSelector),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetCluster defines restrictions on this override policy
 * that only applies to resources propagated to the matching clusters.
 * nil means matching all clusters.
 *
 * Deprecated: This filed is deprecated in v1.0 and please use the OverrideRules instead.
 *
 * @schema ClusterOverridePolicySpecTargetCluster
 */
export interface ClusterOverridePolicySpecTargetCluster {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema ClusterOverridePolicySpecTargetCluster#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema ClusterOverridePolicySpecTargetCluster#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterOverridePolicySpecTargetCluster#fieldSelector
   */
  readonly fieldSelector?: ClusterOverridePolicySpecTargetClusterFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterOverridePolicySpecTargetCluster#labelSelector
   */
  readonly labelSelector?: ClusterOverridePolicySpecTargetClusterLabelSelector;
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecTargetCluster' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecTargetCluster(obj: ClusterOverridePolicySpecTargetCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_ClusterOverridePolicySpecTargetClusterFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_ClusterOverridePolicySpecTargetClusterLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Overriders represents the override rules that would apply on resources
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverriders
 */
export interface ClusterOverridePolicySpecOverrideRulesOverriders {
  /**
   * AnnotationsOverrider represents the rules dedicated to handling workload annotations
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverriders#annotationsOverrider
   */
  readonly annotationsOverrider?: ClusterOverridePolicySpecOverrideRulesOverridersAnnotationsOverrider[];

  /**
   * ArgsOverrider represents the rules dedicated to handling container args
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverriders#argsOverrider
   */
  readonly argsOverrider?: ClusterOverridePolicySpecOverrideRulesOverridersArgsOverrider[];

  /**
   * CommandOverrider represents the rules dedicated to handling container command
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverriders#commandOverrider
   */
  readonly commandOverrider?: ClusterOverridePolicySpecOverrideRulesOverridersCommandOverrider[];

  /**
   * FieldOverrider represents the rules dedicated to modifying a specific field in any Kubernetes resource.
   * This allows changing a single field within the resource with multiple operations.
   * It is designed to handle structured field values such as those found in ConfigMaps or Secrets.
   * The current implementation supports JSON and YAML formats, but can easily be extended to support XML in the future.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverriders#fieldOverrider
   */
  readonly fieldOverrider?: ClusterOverridePolicySpecOverrideRulesOverridersFieldOverrider[];

  /**
   * ImageOverrider represents the rules dedicated to handling image overrides.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverriders#imageOverrider
   */
  readonly imageOverrider?: ClusterOverridePolicySpecOverrideRulesOverridersImageOverrider[];

  /**
   * LabelsOverrider represents the rules dedicated to handling workload labels
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverriders#labelsOverrider
   */
  readonly labelsOverrider?: ClusterOverridePolicySpecOverrideRulesOverridersLabelsOverrider[];

  /**
   * Plaintext represents override rules defined with plaintext overriders.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverriders#plaintext
   */
  readonly plaintext?: ClusterOverridePolicySpecOverrideRulesOverridersPlaintext[];
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesOverriders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesOverriders(obj: ClusterOverridePolicySpecOverrideRulesOverriders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotationsOverrider': obj.annotationsOverrider?.map(y => toJson_ClusterOverridePolicySpecOverrideRulesOverridersAnnotationsOverrider(y)),
    'argsOverrider': obj.argsOverrider?.map(y => toJson_ClusterOverridePolicySpecOverrideRulesOverridersArgsOverrider(y)),
    'commandOverrider': obj.commandOverrider?.map(y => toJson_ClusterOverridePolicySpecOverrideRulesOverridersCommandOverrider(y)),
    'fieldOverrider': obj.fieldOverrider?.map(y => toJson_ClusterOverridePolicySpecOverrideRulesOverridersFieldOverrider(y)),
    'imageOverrider': obj.imageOverrider?.map(y => toJson_ClusterOverridePolicySpecOverrideRulesOverridersImageOverrider(y)),
    'labelsOverrider': obj.labelsOverrider?.map(y => toJson_ClusterOverridePolicySpecOverrideRulesOverridersLabelsOverrider(y)),
    'plaintext': obj.plaintext?.map(y => toJson_ClusterOverridePolicySpecOverrideRulesOverridersPlaintext(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetCluster defines restrictions on this override policy
 * that only applies to resources propagated to the matching clusters.
 * nil means matching all clusters.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesTargetCluster
 */
export interface ClusterOverridePolicySpecOverrideRulesTargetCluster {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesTargetCluster#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesTargetCluster#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesTargetCluster#fieldSelector
   */
  readonly fieldSelector?: ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesTargetCluster#labelSelector
   */
  readonly labelSelector?: ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelector;
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesTargetCluster' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesTargetCluster(obj: ClusterOverridePolicySpecOverrideRulesTargetCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelAnnotationOverrider represents the rules dedicated to handling workload labels/annotations
 *
 * @schema ClusterOverridePolicySpecOverridersAnnotationsOverrider
 */
export interface ClusterOverridePolicySpecOverridersAnnotationsOverrider {
  /**
   * Operator represents the operator which will apply on the workload.
   *
   * @schema ClusterOverridePolicySpecOverridersAnnotationsOverrider#operator
   */
  readonly operator: ClusterOverridePolicySpecOverridersAnnotationsOverriderOperator;

  /**
   * Value to be applied to annotations/labels of workload.
   * Items in Value which will be appended after annotations/labels when Operator is 'add'.
   * Items in Value which match in annotations/labels will be deleted when Operator is 'remove'.
   * Items in Value which match in annotations/labels will be replaced when Operator is 'replace'.
   *
   * @schema ClusterOverridePolicySpecOverridersAnnotationsOverrider#value
   */
  readonly value: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverridersAnnotationsOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverridersAnnotationsOverrider(obj: ClusterOverridePolicySpecOverridersAnnotationsOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'value': ((obj.value) === undefined) ? undefined : (Object.entries(obj.value).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CommandArgsOverrider represents the rules dedicated to handling command/args overrides.
 *
 * @schema ClusterOverridePolicySpecOverridersArgsOverrider
 */
export interface ClusterOverridePolicySpecOverridersArgsOverrider {
  /**
   * The name of container
   *
   * @schema ClusterOverridePolicySpecOverridersArgsOverrider#containerName
   */
  readonly containerName: string;

  /**
   * Operator represents the operator which will apply on the command/args.
   *
   * @schema ClusterOverridePolicySpecOverridersArgsOverrider#operator
   */
  readonly operator: ClusterOverridePolicySpecOverridersArgsOverriderOperator;

  /**
   * Value to be applied to command/args.
   * Items in Value which will be appended after command/args when Operator is 'add'.
   * Items in Value which match in command/args will be deleted when Operator is 'remove'.
   * If Value is empty, then the command/args will remain the same.
   *
   * @schema ClusterOverridePolicySpecOverridersArgsOverrider#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverridersArgsOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverridersArgsOverrider(obj: ClusterOverridePolicySpecOverridersArgsOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'operator': obj.operator,
    'value': obj.value?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CommandArgsOverrider represents the rules dedicated to handling command/args overrides.
 *
 * @schema ClusterOverridePolicySpecOverridersCommandOverrider
 */
export interface ClusterOverridePolicySpecOverridersCommandOverrider {
  /**
   * The name of container
   *
   * @schema ClusterOverridePolicySpecOverridersCommandOverrider#containerName
   */
  readonly containerName: string;

  /**
   * Operator represents the operator which will apply on the command/args.
   *
   * @schema ClusterOverridePolicySpecOverridersCommandOverrider#operator
   */
  readonly operator: ClusterOverridePolicySpecOverridersCommandOverriderOperator;

  /**
   * Value to be applied to command/args.
   * Items in Value which will be appended after command/args when Operator is 'add'.
   * Items in Value which match in command/args will be deleted when Operator is 'remove'.
   * If Value is empty, then the command/args will remain the same.
   *
   * @schema ClusterOverridePolicySpecOverridersCommandOverrider#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverridersCommandOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverridersCommandOverrider(obj: ClusterOverridePolicySpecOverridersCommandOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'operator': obj.operator,
    'value': obj.value?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldOverrider represents the rules dedicated to modifying a specific field in any Kubernetes resource.
 * This allows changing a single field within the resource with multiple operations.
 * It is designed to handle structured field values such as those found in ConfigMaps or Secrets.
 * The current implementation supports JSON and YAML formats, but can easily be extended to support XML in the future.
 * Note: In any given instance, FieldOverrider processes either JSON or YAML fields, but not both simultaneously.
 *
 * @schema ClusterOverridePolicySpecOverridersFieldOverrider
 */
export interface ClusterOverridePolicySpecOverridersFieldOverrider {
  /**
   * FieldPath specifies the initial location in the instance document where the operation should take place.
   * The path uses RFC 6901 for navigating into nested structures. For example, the path "/data/db-config.yaml"
   * specifies the configuration data key named "db-config.yaml" in a ConfigMap: "/data/db-config.yaml".
   *
   * @schema ClusterOverridePolicySpecOverridersFieldOverrider#fieldPath
   */
  readonly fieldPath: string;

  /**
   * JSON represents the operations performed on the JSON document specified by the FieldPath.
   *
   * @schema ClusterOverridePolicySpecOverridersFieldOverrider#json
   */
  readonly json?: ClusterOverridePolicySpecOverridersFieldOverriderJson[];

  /**
   * YAML represents the operations performed on the YAML document specified by the FieldPath.
   *
   * @schema ClusterOverridePolicySpecOverridersFieldOverrider#yaml
   */
  readonly yaml?: ClusterOverridePolicySpecOverridersFieldOverriderYaml[];
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverridersFieldOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverridersFieldOverrider(obj: ClusterOverridePolicySpecOverridersFieldOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldPath': obj.fieldPath,
    'json': obj.json?.map(y => toJson_ClusterOverridePolicySpecOverridersFieldOverriderJson(y)),
    'yaml': obj.yaml?.map(y => toJson_ClusterOverridePolicySpecOverridersFieldOverriderYaml(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ImageOverrider represents the rules dedicated to handling image overrides.
 *
 * @schema ClusterOverridePolicySpecOverridersImageOverrider
 */
export interface ClusterOverridePolicySpecOverridersImageOverrider {
  /**
   * Component is part of image name.
   * Basically we presume an image can be made of '[registry/]repository[:tag]'.
   * The registry could be:
   * - registry.k8s.io
   * - fictional.registry.example:10443
   * The repository could be:
   * - kube-apiserver
   * - fictional/nginx
   * The tag cloud be:
   * - latest
   * - v1.19.1
   * - @sha256:dbcc1c35ac38df41fd2f5e4130b32ffdb93ebae8b3dbe638c23575912276fc9c
   *
   * @schema ClusterOverridePolicySpecOverridersImageOverrider#component
   */
  readonly component: ClusterOverridePolicySpecOverridersImageOverriderComponent;

  /**
   * Operator represents the operator which will apply on the image.
   *
   * @schema ClusterOverridePolicySpecOverridersImageOverrider#operator
   */
  readonly operator: ClusterOverridePolicySpecOverridersImageOverriderOperator;

  /**
   * Predicate filters images before applying the rule.
   *
   * Defaults to nil, in that case, the system will automatically detect image fields if the resource type is
   * Pod, ReplicaSet, Deployment, StatefulSet, DaemonSet or Job by following rule:
   * - Pod: /spec/containers/<N>/image
   * - ReplicaSet: /spec/template/spec/containers/<N>/image
   * - Deployment: /spec/template/spec/containers/<N>/image
   * - DaemonSet: /spec/template/spec/containers/<N>/image
   * - StatefulSet: /spec/template/spec/containers/<N>/image
   * - Job: /spec/template/spec/containers/<N>/image
   * In addition, all images will be processed if the resource object has more than one container.
   *
   * If not nil, only images matches the filters will be processed.
   *
   * @default nil, in that case, the system will automatically detect image fields if the resource type is
   * @schema ClusterOverridePolicySpecOverridersImageOverrider#predicate
   */
  readonly predicate?: ClusterOverridePolicySpecOverridersImageOverriderPredicate;

  /**
   * Value to be applied to image.
   * Must not be empty when operator is 'add' or 'replace'.
   * Defaults to empty and ignored when operator is 'remove'.
   *
   * @default empty and ignored when operator is 'remove'.
   * @schema ClusterOverridePolicySpecOverridersImageOverrider#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverridersImageOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverridersImageOverrider(obj: ClusterOverridePolicySpecOverridersImageOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'component': obj.component,
    'operator': obj.operator,
    'predicate': toJson_ClusterOverridePolicySpecOverridersImageOverriderPredicate(obj.predicate),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelAnnotationOverrider represents the rules dedicated to handling workload labels/annotations
 *
 * @schema ClusterOverridePolicySpecOverridersLabelsOverrider
 */
export interface ClusterOverridePolicySpecOverridersLabelsOverrider {
  /**
   * Operator represents the operator which will apply on the workload.
   *
   * @schema ClusterOverridePolicySpecOverridersLabelsOverrider#operator
   */
  readonly operator: ClusterOverridePolicySpecOverridersLabelsOverriderOperator;

  /**
   * Value to be applied to annotations/labels of workload.
   * Items in Value which will be appended after annotations/labels when Operator is 'add'.
   * Items in Value which match in annotations/labels will be deleted when Operator is 'remove'.
   * Items in Value which match in annotations/labels will be replaced when Operator is 'replace'.
   *
   * @schema ClusterOverridePolicySpecOverridersLabelsOverrider#value
   */
  readonly value: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverridersLabelsOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverridersLabelsOverrider(obj: ClusterOverridePolicySpecOverridersLabelsOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'value': ((obj.value) === undefined) ? undefined : (Object.entries(obj.value).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PlaintextOverrider is a simple overrider that overrides target fields
 * according to path, operator and value.
 *
 * @schema ClusterOverridePolicySpecOverridersPlaintext
 */
export interface ClusterOverridePolicySpecOverridersPlaintext {
  /**
   * Operator indicates the operation on target field.
   * Available operators are: add, replace and remove.
   *
   * @schema ClusterOverridePolicySpecOverridersPlaintext#operator
   */
  readonly operator: ClusterOverridePolicySpecOverridersPlaintextOperator;

  /**
   * Path indicates the path of target field
   *
   * @schema ClusterOverridePolicySpecOverridersPlaintext#path
   */
  readonly path: string;

  /**
   * Value to be applied to target field.
   * Must be empty when operator is Remove.
   *
   * @schema ClusterOverridePolicySpecOverridersPlaintext#value
   */
  readonly value?: any;
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverridersPlaintext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverridersPlaintext(obj: ClusterOverridePolicySpecOverridersPlaintext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'path': obj.path,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources.
 * If name is not empty, labelSelector will be ignored.
 *
 * @schema ClusterOverridePolicySpecResourceSelectorsLabelSelector
 */
export interface ClusterOverridePolicySpecResourceSelectorsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterOverridePolicySpecResourceSelectorsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterOverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterOverridePolicySpecResourceSelectorsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecResourceSelectorsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecResourceSelectorsLabelSelector(obj: ClusterOverridePolicySpecResourceSelectorsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterOverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterOverridePolicySpecTargetClusterFieldSelector
 */
export interface ClusterOverridePolicySpecTargetClusterFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema ClusterOverridePolicySpecTargetClusterFieldSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterOverridePolicySpecTargetClusterFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecTargetClusterFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecTargetClusterFieldSelector(obj: ClusterOverridePolicySpecTargetClusterFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterOverridePolicySpecTargetClusterFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterOverridePolicySpecTargetClusterLabelSelector
 */
export interface ClusterOverridePolicySpecTargetClusterLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterOverridePolicySpecTargetClusterLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterOverridePolicySpecTargetClusterLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterOverridePolicySpecTargetClusterLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecTargetClusterLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecTargetClusterLabelSelector(obj: ClusterOverridePolicySpecTargetClusterLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterOverridePolicySpecTargetClusterLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelAnnotationOverrider represents the rules dedicated to handling workload labels/annotations
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersAnnotationsOverrider
 */
export interface ClusterOverridePolicySpecOverrideRulesOverridersAnnotationsOverrider {
  /**
   * Operator represents the operator which will apply on the workload.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersAnnotationsOverrider#operator
   */
  readonly operator: ClusterOverridePolicySpecOverrideRulesOverridersAnnotationsOverriderOperator;

  /**
   * Value to be applied to annotations/labels of workload.
   * Items in Value which will be appended after annotations/labels when Operator is 'add'.
   * Items in Value which match in annotations/labels will be deleted when Operator is 'remove'.
   * Items in Value which match in annotations/labels will be replaced when Operator is 'replace'.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersAnnotationsOverrider#value
   */
  readonly value: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesOverridersAnnotationsOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesOverridersAnnotationsOverrider(obj: ClusterOverridePolicySpecOverrideRulesOverridersAnnotationsOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'value': ((obj.value) === undefined) ? undefined : (Object.entries(obj.value).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CommandArgsOverrider represents the rules dedicated to handling command/args overrides.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersArgsOverrider
 */
export interface ClusterOverridePolicySpecOverrideRulesOverridersArgsOverrider {
  /**
   * The name of container
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersArgsOverrider#containerName
   */
  readonly containerName: string;

  /**
   * Operator represents the operator which will apply on the command/args.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersArgsOverrider#operator
   */
  readonly operator: ClusterOverridePolicySpecOverrideRulesOverridersArgsOverriderOperator;

  /**
   * Value to be applied to command/args.
   * Items in Value which will be appended after command/args when Operator is 'add'.
   * Items in Value which match in command/args will be deleted when Operator is 'remove'.
   * If Value is empty, then the command/args will remain the same.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersArgsOverrider#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesOverridersArgsOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesOverridersArgsOverrider(obj: ClusterOverridePolicySpecOverrideRulesOverridersArgsOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'operator': obj.operator,
    'value': obj.value?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CommandArgsOverrider represents the rules dedicated to handling command/args overrides.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersCommandOverrider
 */
export interface ClusterOverridePolicySpecOverrideRulesOverridersCommandOverrider {
  /**
   * The name of container
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersCommandOverrider#containerName
   */
  readonly containerName: string;

  /**
   * Operator represents the operator which will apply on the command/args.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersCommandOverrider#operator
   */
  readonly operator: ClusterOverridePolicySpecOverrideRulesOverridersCommandOverriderOperator;

  /**
   * Value to be applied to command/args.
   * Items in Value which will be appended after command/args when Operator is 'add'.
   * Items in Value which match in command/args will be deleted when Operator is 'remove'.
   * If Value is empty, then the command/args will remain the same.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersCommandOverrider#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesOverridersCommandOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesOverridersCommandOverrider(obj: ClusterOverridePolicySpecOverrideRulesOverridersCommandOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'operator': obj.operator,
    'value': obj.value?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldOverrider represents the rules dedicated to modifying a specific field in any Kubernetes resource.
 * This allows changing a single field within the resource with multiple operations.
 * It is designed to handle structured field values such as those found in ConfigMaps or Secrets.
 * The current implementation supports JSON and YAML formats, but can easily be extended to support XML in the future.
 * Note: In any given instance, FieldOverrider processes either JSON or YAML fields, but not both simultaneously.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersFieldOverrider
 */
export interface ClusterOverridePolicySpecOverrideRulesOverridersFieldOverrider {
  /**
   * FieldPath specifies the initial location in the instance document where the operation should take place.
   * The path uses RFC 6901 for navigating into nested structures. For example, the path "/data/db-config.yaml"
   * specifies the configuration data key named "db-config.yaml" in a ConfigMap: "/data/db-config.yaml".
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersFieldOverrider#fieldPath
   */
  readonly fieldPath: string;

  /**
   * JSON represents the operations performed on the JSON document specified by the FieldPath.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersFieldOverrider#json
   */
  readonly json?: ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderJson[];

  /**
   * YAML represents the operations performed on the YAML document specified by the FieldPath.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersFieldOverrider#yaml
   */
  readonly yaml?: ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderYaml[];
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesOverridersFieldOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesOverridersFieldOverrider(obj: ClusterOverridePolicySpecOverrideRulesOverridersFieldOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldPath': obj.fieldPath,
    'json': obj.json?.map(y => toJson_ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderJson(y)),
    'yaml': obj.yaml?.map(y => toJson_ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderYaml(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ImageOverrider represents the rules dedicated to handling image overrides.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersImageOverrider
 */
export interface ClusterOverridePolicySpecOverrideRulesOverridersImageOverrider {
  /**
   * Component is part of image name.
   * Basically we presume an image can be made of '[registry/]repository[:tag]'.
   * The registry could be:
   * - registry.k8s.io
   * - fictional.registry.example:10443
   * The repository could be:
   * - kube-apiserver
   * - fictional/nginx
   * The tag cloud be:
   * - latest
   * - v1.19.1
   * - @sha256:dbcc1c35ac38df41fd2f5e4130b32ffdb93ebae8b3dbe638c23575912276fc9c
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersImageOverrider#component
   */
  readonly component: ClusterOverridePolicySpecOverrideRulesOverridersImageOverriderComponent;

  /**
   * Operator represents the operator which will apply on the image.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersImageOverrider#operator
   */
  readonly operator: ClusterOverridePolicySpecOverrideRulesOverridersImageOverriderOperator;

  /**
   * Predicate filters images before applying the rule.
   *
   * Defaults to nil, in that case, the system will automatically detect image fields if the resource type is
   * Pod, ReplicaSet, Deployment, StatefulSet, DaemonSet or Job by following rule:
   * - Pod: /spec/containers/<N>/image
   * - ReplicaSet: /spec/template/spec/containers/<N>/image
   * - Deployment: /spec/template/spec/containers/<N>/image
   * - DaemonSet: /spec/template/spec/containers/<N>/image
   * - StatefulSet: /spec/template/spec/containers/<N>/image
   * - Job: /spec/template/spec/containers/<N>/image
   * In addition, all images will be processed if the resource object has more than one container.
   *
   * If not nil, only images matches the filters will be processed.
   *
   * @default nil, in that case, the system will automatically detect image fields if the resource type is
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersImageOverrider#predicate
   */
  readonly predicate?: ClusterOverridePolicySpecOverrideRulesOverridersImageOverriderPredicate;

  /**
   * Value to be applied to image.
   * Must not be empty when operator is 'add' or 'replace'.
   * Defaults to empty and ignored when operator is 'remove'.
   *
   * @default empty and ignored when operator is 'remove'.
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersImageOverrider#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesOverridersImageOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesOverridersImageOverrider(obj: ClusterOverridePolicySpecOverrideRulesOverridersImageOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'component': obj.component,
    'operator': obj.operator,
    'predicate': toJson_ClusterOverridePolicySpecOverrideRulesOverridersImageOverriderPredicate(obj.predicate),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelAnnotationOverrider represents the rules dedicated to handling workload labels/annotations
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersLabelsOverrider
 */
export interface ClusterOverridePolicySpecOverrideRulesOverridersLabelsOverrider {
  /**
   * Operator represents the operator which will apply on the workload.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersLabelsOverrider#operator
   */
  readonly operator: ClusterOverridePolicySpecOverrideRulesOverridersLabelsOverriderOperator;

  /**
   * Value to be applied to annotations/labels of workload.
   * Items in Value which will be appended after annotations/labels when Operator is 'add'.
   * Items in Value which match in annotations/labels will be deleted when Operator is 'remove'.
   * Items in Value which match in annotations/labels will be replaced when Operator is 'replace'.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersLabelsOverrider#value
   */
  readonly value: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesOverridersLabelsOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesOverridersLabelsOverrider(obj: ClusterOverridePolicySpecOverrideRulesOverridersLabelsOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'value': ((obj.value) === undefined) ? undefined : (Object.entries(obj.value).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PlaintextOverrider is a simple overrider that overrides target fields
 * according to path, operator and value.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersPlaintext
 */
export interface ClusterOverridePolicySpecOverrideRulesOverridersPlaintext {
  /**
   * Operator indicates the operation on target field.
   * Available operators are: add, replace and remove.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersPlaintext#operator
   */
  readonly operator: ClusterOverridePolicySpecOverrideRulesOverridersPlaintextOperator;

  /**
   * Path indicates the path of target field
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersPlaintext#path
   */
  readonly path: string;

  /**
   * Value to be applied to target field.
   * Must be empty when operator is Remove.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersPlaintext#value
   */
  readonly value?: any;
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesOverridersPlaintext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesOverridersPlaintext(obj: ClusterOverridePolicySpecOverrideRulesOverridersPlaintext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'path': obj.path,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelector
 */
export interface ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelector(obj: ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelector
 */
export interface ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelector(obj: ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Operator represents the operator which will apply on the workload.
 *
 * @schema ClusterOverridePolicySpecOverridersAnnotationsOverriderOperator
 */
export enum ClusterOverridePolicySpecOverridersAnnotationsOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Operator represents the operator which will apply on the command/args.
 *
 * @schema ClusterOverridePolicySpecOverridersArgsOverriderOperator
 */
export enum ClusterOverridePolicySpecOverridersArgsOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
}

/**
 * Operator represents the operator which will apply on the command/args.
 *
 * @schema ClusterOverridePolicySpecOverridersCommandOverriderOperator
 */
export enum ClusterOverridePolicySpecOverridersCommandOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
}

/**
 * JSONPatchOperation represents a single field modification operation for JSON format.
 *
 * @schema ClusterOverridePolicySpecOverridersFieldOverriderJson
 */
export interface ClusterOverridePolicySpecOverridersFieldOverriderJson {
  /**
   * Operator indicates the operation on target field.
   * Available operators are: "add", "remove", and "replace".
   *
   * @schema ClusterOverridePolicySpecOverridersFieldOverriderJson#operator
   */
  readonly operator: ClusterOverridePolicySpecOverridersFieldOverriderJsonOperator;

  /**
   * SubPath specifies the relative location within the initial FieldPath where the operation should take place.
   * The path uses RFC 6901 for navigating into nested structures.
   *
   * @schema ClusterOverridePolicySpecOverridersFieldOverriderJson#subPath
   */
  readonly subPath: string;

  /**
   * Value is the new value to set for the specified field if the operation is "add" or "replace".
   * For "remove" operation, this field is ignored.
   *
   * @schema ClusterOverridePolicySpecOverridersFieldOverriderJson#value
   */
  readonly value?: any;
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverridersFieldOverriderJson' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverridersFieldOverriderJson(obj: ClusterOverridePolicySpecOverridersFieldOverriderJson | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'subPath': obj.subPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * YAMLPatchOperation represents a single field modification operation for YAML format.
 *
 * @schema ClusterOverridePolicySpecOverridersFieldOverriderYaml
 */
export interface ClusterOverridePolicySpecOverridersFieldOverriderYaml {
  /**
   * Operator indicates the operation on target field.
   * Available operators are: "add", "remove", and "replace".
   *
   * @schema ClusterOverridePolicySpecOverridersFieldOverriderYaml#operator
   */
  readonly operator: ClusterOverridePolicySpecOverridersFieldOverriderYamlOperator;

  /**
   * SubPath specifies the relative location within the initial FieldPath where the operation should take place.
   * The path uses RFC 6901 for navigating into nested structures.
   *
   * @schema ClusterOverridePolicySpecOverridersFieldOverriderYaml#subPath
   */
  readonly subPath: string;

  /**
   * Value is the new value to set for the specified field if the operation is "add" or "replace".
   * For "remove" operation, this field is ignored.
   *
   * @schema ClusterOverridePolicySpecOverridersFieldOverriderYaml#value
   */
  readonly value?: any;
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverridersFieldOverriderYaml' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverridersFieldOverriderYaml(obj: ClusterOverridePolicySpecOverridersFieldOverriderYaml | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'subPath': obj.subPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Component is part of image name.
 * Basically we presume an image can be made of '[registry/]repository[:tag]'.
 * The registry could be:
 * - registry.k8s.io
 * - fictional.registry.example:10443
 * The repository could be:
 * - kube-apiserver
 * - fictional/nginx
 * The tag cloud be:
 * - latest
 * - v1.19.1
 * - @sha256:dbcc1c35ac38df41fd2f5e4130b32ffdb93ebae8b3dbe638c23575912276fc9c
 *
 * @schema ClusterOverridePolicySpecOverridersImageOverriderComponent
 */
export enum ClusterOverridePolicySpecOverridersImageOverriderComponent {
  /** Registry */
  REGISTRY = "Registry",
  /** Repository */
  REPOSITORY = "Repository",
  /** Tag */
  TAG = "Tag",
}

/**
 * Operator represents the operator which will apply on the image.
 *
 * @schema ClusterOverridePolicySpecOverridersImageOverriderOperator
 */
export enum ClusterOverridePolicySpecOverridersImageOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Predicate filters images before applying the rule.
 *
 * Defaults to nil, in that case, the system will automatically detect image fields if the resource type is
 * Pod, ReplicaSet, Deployment, StatefulSet, DaemonSet or Job by following rule:
 * - Pod: /spec/containers/<N>/image
 * - ReplicaSet: /spec/template/spec/containers/<N>/image
 * - Deployment: /spec/template/spec/containers/<N>/image
 * - DaemonSet: /spec/template/spec/containers/<N>/image
 * - StatefulSet: /spec/template/spec/containers/<N>/image
 * - Job: /spec/template/spec/containers/<N>/image
 * In addition, all images will be processed if the resource object has more than one container.
 *
 * If not nil, only images matches the filters will be processed.
 *
 * @default nil, in that case, the system will automatically detect image fields if the resource type is
 * @schema ClusterOverridePolicySpecOverridersImageOverriderPredicate
 */
export interface ClusterOverridePolicySpecOverridersImageOverriderPredicate {
  /**
   * Path indicates the path of target field
   *
   * @schema ClusterOverridePolicySpecOverridersImageOverriderPredicate#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverridersImageOverriderPredicate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverridersImageOverriderPredicate(obj: ClusterOverridePolicySpecOverridersImageOverriderPredicate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Operator represents the operator which will apply on the workload.
 *
 * @schema ClusterOverridePolicySpecOverridersLabelsOverriderOperator
 */
export enum ClusterOverridePolicySpecOverridersLabelsOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Operator indicates the operation on target field.
 * Available operators are: add, replace and remove.
 *
 * @schema ClusterOverridePolicySpecOverridersPlaintextOperator
 */
export enum ClusterOverridePolicySpecOverridersPlaintextOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterOverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions
 */
export interface ClusterOverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterOverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterOverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterOverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions(obj: ClusterOverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterOverridePolicySpecTargetClusterFieldSelectorMatchExpressions
 */
export interface ClusterOverridePolicySpecTargetClusterFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterOverridePolicySpecTargetClusterFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterOverridePolicySpecTargetClusterFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterOverridePolicySpecTargetClusterFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecTargetClusterFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecTargetClusterFieldSelectorMatchExpressions(obj: ClusterOverridePolicySpecTargetClusterFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterOverridePolicySpecTargetClusterLabelSelectorMatchExpressions
 */
export interface ClusterOverridePolicySpecTargetClusterLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterOverridePolicySpecTargetClusterLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterOverridePolicySpecTargetClusterLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterOverridePolicySpecTargetClusterLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecTargetClusterLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecTargetClusterLabelSelectorMatchExpressions(obj: ClusterOverridePolicySpecTargetClusterLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Operator represents the operator which will apply on the workload.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersAnnotationsOverriderOperator
 */
export enum ClusterOverridePolicySpecOverrideRulesOverridersAnnotationsOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Operator represents the operator which will apply on the command/args.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersArgsOverriderOperator
 */
export enum ClusterOverridePolicySpecOverrideRulesOverridersArgsOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
}

/**
 * Operator represents the operator which will apply on the command/args.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersCommandOverriderOperator
 */
export enum ClusterOverridePolicySpecOverrideRulesOverridersCommandOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
}

/**
 * JSONPatchOperation represents a single field modification operation for JSON format.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderJson
 */
export interface ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderJson {
  /**
   * Operator indicates the operation on target field.
   * Available operators are: "add", "remove", and "replace".
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderJson#operator
   */
  readonly operator: ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderJsonOperator;

  /**
   * SubPath specifies the relative location within the initial FieldPath where the operation should take place.
   * The path uses RFC 6901 for navigating into nested structures.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderJson#subPath
   */
  readonly subPath: string;

  /**
   * Value is the new value to set for the specified field if the operation is "add" or "replace".
   * For "remove" operation, this field is ignored.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderJson#value
   */
  readonly value?: any;
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderJson' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderJson(obj: ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderJson | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'subPath': obj.subPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * YAMLPatchOperation represents a single field modification operation for YAML format.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderYaml
 */
export interface ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderYaml {
  /**
   * Operator indicates the operation on target field.
   * Available operators are: "add", "remove", and "replace".
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderYaml#operator
   */
  readonly operator: ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderYamlOperator;

  /**
   * SubPath specifies the relative location within the initial FieldPath where the operation should take place.
   * The path uses RFC 6901 for navigating into nested structures.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderYaml#subPath
   */
  readonly subPath: string;

  /**
   * Value is the new value to set for the specified field if the operation is "add" or "replace".
   * For "remove" operation, this field is ignored.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderYaml#value
   */
  readonly value?: any;
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderYaml' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderYaml(obj: ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderYaml | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'subPath': obj.subPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Component is part of image name.
 * Basically we presume an image can be made of '[registry/]repository[:tag]'.
 * The registry could be:
 * - registry.k8s.io
 * - fictional.registry.example:10443
 * The repository could be:
 * - kube-apiserver
 * - fictional/nginx
 * The tag cloud be:
 * - latest
 * - v1.19.1
 * - @sha256:dbcc1c35ac38df41fd2f5e4130b32ffdb93ebae8b3dbe638c23575912276fc9c
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersImageOverriderComponent
 */
export enum ClusterOverridePolicySpecOverrideRulesOverridersImageOverriderComponent {
  /** Registry */
  REGISTRY = "Registry",
  /** Repository */
  REPOSITORY = "Repository",
  /** Tag */
  TAG = "Tag",
}

/**
 * Operator represents the operator which will apply on the image.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersImageOverriderOperator
 */
export enum ClusterOverridePolicySpecOverrideRulesOverridersImageOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Predicate filters images before applying the rule.
 *
 * Defaults to nil, in that case, the system will automatically detect image fields if the resource type is
 * Pod, ReplicaSet, Deployment, StatefulSet, DaemonSet or Job by following rule:
 * - Pod: /spec/containers/<N>/image
 * - ReplicaSet: /spec/template/spec/containers/<N>/image
 * - Deployment: /spec/template/spec/containers/<N>/image
 * - DaemonSet: /spec/template/spec/containers/<N>/image
 * - StatefulSet: /spec/template/spec/containers/<N>/image
 * - Job: /spec/template/spec/containers/<N>/image
 * In addition, all images will be processed if the resource object has more than one container.
 *
 * If not nil, only images matches the filters will be processed.
 *
 * @default nil, in that case, the system will automatically detect image fields if the resource type is
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersImageOverriderPredicate
 */
export interface ClusterOverridePolicySpecOverrideRulesOverridersImageOverriderPredicate {
  /**
   * Path indicates the path of target field
   *
   * @schema ClusterOverridePolicySpecOverrideRulesOverridersImageOverriderPredicate#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesOverridersImageOverriderPredicate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesOverridersImageOverriderPredicate(obj: ClusterOverridePolicySpecOverrideRulesOverridersImageOverriderPredicate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Operator represents the operator which will apply on the workload.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersLabelsOverriderOperator
 */
export enum ClusterOverridePolicySpecOverrideRulesOverridersLabelsOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Operator indicates the operation on target field.
 * Available operators are: add, replace and remove.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersPlaintextOperator
 */
export enum ClusterOverridePolicySpecOverrideRulesOverridersPlaintextOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions
 */
export interface ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions(obj: ClusterOverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions
 */
export interface ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions(obj: ClusterOverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Operator indicates the operation on target field.
 * Available operators are: "add", "remove", and "replace".
 *
 * @schema ClusterOverridePolicySpecOverridersFieldOverriderJsonOperator
 */
export enum ClusterOverridePolicySpecOverridersFieldOverriderJsonOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Operator indicates the operation on target field.
 * Available operators are: "add", "remove", and "replace".
 *
 * @schema ClusterOverridePolicySpecOverridersFieldOverriderYamlOperator
 */
export enum ClusterOverridePolicySpecOverridersFieldOverriderYamlOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Operator indicates the operation on target field.
 * Available operators are: "add", "remove", and "replace".
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderJsonOperator
 */
export enum ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderJsonOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Operator indicates the operation on target field.
 * Available operators are: "add", "remove", and "replace".
 *
 * @schema ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderYamlOperator
 */
export enum ClusterOverridePolicySpecOverrideRulesOverridersFieldOverriderYamlOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}


/**
 * ClusterPropagationPolicy represents the cluster-wide policy that propagates a group of resources to one or more clusters.
Different with PropagationPolicy that could only propagate resources in its own namespace, ClusterPropagationPolicy
is able to propagate cluster level resources and resources in any namespace other than system reserved ones.
System reserved namespaces are: karmada-system, karmada-cluster, karmada-es-*.
 *
 * @schema ClusterPropagationPolicy
 */
export class ClusterPropagationPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterPropagationPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'policy.karmada.io/v1alpha1',
    kind: 'ClusterPropagationPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterPropagationPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterPropagationPolicyProps): any {
    return {
      ...ClusterPropagationPolicy.GVK,
      ...toJson_ClusterPropagationPolicyProps(props),
    };
  }

  /**
   * Defines a "ClusterPropagationPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterPropagationPolicyProps) {
    super(scope, id, {
      ...ClusterPropagationPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterPropagationPolicy.GVK,
      ...toJson_ClusterPropagationPolicyProps(resolved),
    };
  }
}

/**
 * ClusterPropagationPolicy represents the cluster-wide policy that propagates a group of resources to one or more clusters.
 * Different with PropagationPolicy that could only propagate resources in its own namespace, ClusterPropagationPolicy
 * is able to propagate cluster level resources and resources in any namespace other than system reserved ones.
 * System reserved namespaces are: karmada-system, karmada-cluster, karmada-es-*.
 *
 * @schema ClusterPropagationPolicy
 */
export interface ClusterPropagationPolicyProps {
  /**
   * @schema ClusterPropagationPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec represents the desired behavior of ClusterPropagationPolicy.
   *
   * @schema ClusterPropagationPolicy#spec
   */
  readonly spec: ClusterPropagationPolicySpec;
}

/**
 * Converts an object of type 'ClusterPropagationPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicyProps(obj: ClusterPropagationPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterPropagationPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec represents the desired behavior of ClusterPropagationPolicy.
 *
 * @schema ClusterPropagationPolicySpec
 */
export interface ClusterPropagationPolicySpec {
  /**
   * ActivationPreference indicates how the referencing resource template will
   * be propagated, in case of policy changes.
   *
   * If empty, the resource template will respond to policy changes
   * immediately, in other words, any policy changes will drive the resource
   * template to be propagated immediately as per the current propagation rules.
   *
   * If the value is 'Lazy' means the policy changes will not take effect for now
   * but defer to the resource template changes, in other words, the resource
   * template will not be propagated as per the current propagation rules until
   * there is an update on it.
   * This is an experimental feature that might help in a scenario where a policy
   * manages huge amount of resource templates, changes to a policy typically
   * affect numerous applications simultaneously. A minor misconfiguration
   * could lead to widespread failures. With this feature, the change can be
   * gradually rolled out through iterative modifications of resource templates.
   *
   * @schema ClusterPropagationPolicySpec#activationPreference
   */
  readonly activationPreference?: ClusterPropagationPolicySpecActivationPreference;

  /**
   * Association tells if relevant resources should be selected automatically.
   * e.g. a ConfigMap referred by a Deployment.
   * default false.
   * Deprecated: in favor of PropagateDeps.
   *
   * @schema ClusterPropagationPolicySpec#association
   */
  readonly association?: boolean;

  /**
   * ConflictResolution declares how potential conflict should be handled when
   * a resource that is being propagated already exists in the target cluster.
   *
   * It defaults to "Abort" which means stop propagating to avoid unexpected
   * overwrites. The "Overwrite" might be useful when migrating legacy cluster
   * resources to Karmada, in which case conflict is predictable and can be
   * instructed to Karmada take over the resource by overwriting.
   *
   * @schema ClusterPropagationPolicySpec#conflictResolution
   */
  readonly conflictResolution?: ClusterPropagationPolicySpecConflictResolution;

  /**
   * DependentOverrides represents the list of overrides(OverridePolicy)
   * which must present before the current PropagationPolicy takes effect.
   *
   * It used to explicitly specify overrides which current PropagationPolicy rely on.
   * A typical scenario is the users create OverridePolicy(ies) and resources at the same time,
   * they want to ensure the new-created policies would be adopted.
   *
   * Note: For the overrides, OverridePolicy(ies) in current namespace and ClusterOverridePolicy(ies),
   * which not present in this list will still be applied if they matches the resources.
   *
   * @schema ClusterPropagationPolicySpec#dependentOverrides
   */
  readonly dependentOverrides?: string[];

  /**
   * Failover indicates how Karmada migrates applications in case of failures.
   * If this value is nil, failover is disabled.
   *
   * @schema ClusterPropagationPolicySpec#failover
   */
  readonly failover?: ClusterPropagationPolicySpecFailover;

  /**
   * Placement represents the rule for select clusters to propagate resources.
   *
   * @schema ClusterPropagationPolicySpec#placement
   */
  readonly placement?: ClusterPropagationPolicySpecPlacement;

  /**
   * Preemption declares the behaviors for preempting.
   * Valid options are "Always" and "Never".
   *
   * @schema ClusterPropagationPolicySpec#preemption
   */
  readonly preemption?: ClusterPropagationPolicySpecPreemption;

  /**
   * PreserveResourcesOnDeletion controls whether resources should be preserved on the
   * member clusters when the resource template is deleted.
   * If set to true, resources will be preserved on the member clusters.
   * Default is false, which means resources will be deleted along with the resource template.
   *
   * This setting is particularly useful during workload migration scenarios to ensure
   * that rollback can occur quickly without affecting the workloads running on the
   * member clusters.
   *
   * Additionally, this setting applies uniformly across all member clusters and will not
   * selectively control preservation on only some clusters.
   *
   * Note: This setting does not apply to the deletion of the policy itself.
   * When the policy is deleted, the resource templates and their corresponding
   * propagated resources in member clusters will remain unchanged unless explicitly deleted.
   *
   * @default false, which means resources will be deleted along with the resource template.
   * @schema ClusterPropagationPolicySpec#preserveResourcesOnDeletion
   */
  readonly preserveResourcesOnDeletion?: boolean;

  /**
   * Priority indicates the importance of a policy(PropagationPolicy or ClusterPropagationPolicy).
   * A policy will be applied for the matched resource templates if there is
   * no other policies with higher priority at the point of the resource
   * template be processed.
   * Once a resource template has been claimed by a policy, by default it will
   * not be preempted by following policies even with a higher priority.
   * See Preemption for more details.
   *
   * In case of two policies have the same priority, the one with a more precise
   * matching rules in ResourceSelectors wins:
   * - matching by name(resourceSelector.name) has higher priority than
   * by selector(resourceSelector.labelSelector)
   * - matching by selector(resourceSelector.labelSelector) has higher priority
   * than by APIVersion(resourceSelector.apiVersion) and Kind(resourceSelector.kind).
   * If there is still no winner at this point, the one with the lower alphabetic
   * order wins, e.g. policy 'bar' has higher priority than 'foo'.
   *
   * The higher the value, the higher the priority. Defaults to zero.
   *
   * @default zero.
   * @schema ClusterPropagationPolicySpec#priority
   */
  readonly priority?: number;

  /**
   * PropagateDeps tells if relevant resources should be propagated automatically.
   * Take 'Deployment' which referencing 'ConfigMap' and 'Secret' as an example, when 'propagateDeps' is 'true',
   * the referencing resources could be omitted(for saving config effort) from 'resourceSelectors' as they will be
   * propagated along with the Deployment. In addition to the propagating process, the referencing resources will be
   * migrated along with the Deployment in the fail-over scenario.
   *
   * Defaults to false.
   *
   * @default false.
   * @schema ClusterPropagationPolicySpec#propagateDeps
   */
  readonly propagateDeps?: boolean;

  /**
   * ResourceSelectors used to select resources.
   * Nil or empty selector is not allowed and doesn't mean match all kinds
   * of resources for security concerns that sensitive resources(like Secret)
   * might be accidentally propagated.
   *
   * @schema ClusterPropagationPolicySpec#resourceSelectors
   */
  readonly resourceSelectors: ClusterPropagationPolicySpecResourceSelectors[];

  /**
   * SchedulePriority defines how Karmada should resolve the priority and preemption policy
   * for workload scheduling.
   *
   * This setting is useful for controlling the scheduling behavior of offline workloads.
   * By setting a higher or lower priority, users can control which workloads are scheduled first.
   * Additionally, it allows specifying a preemption policy where higher-priority workloads can
   * preempt lower-priority ones in scenarios of resource contention.
   *
   * Note: This feature is currently in the alpha stage. The priority-based scheduling functionality is
   * controlled by the PriorityBasedScheduling feature gate, and preemption is controlled by the
   * PriorityBasedPreemptiveScheduling feature gate. Currently, only priority-based scheduling is
   * supported. Preemption functionality is not yet available and will be introduced in future
   * releases as the feature matures.
   *
   * @schema ClusterPropagationPolicySpec#schedulePriority
   */
  readonly schedulePriority?: ClusterPropagationPolicySpecSchedulePriority;

  /**
   * SchedulerName represents which scheduler to proceed the scheduling.
   * If specified, the policy will be dispatched by specified scheduler.
   * If not specified, the policy will be dispatched by default scheduler.
   *
   * @schema ClusterPropagationPolicySpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Suspension declares the policy for suspending different aspects of propagation.
   * nil means no suspension. no default values.
   *
   * @schema ClusterPropagationPolicySpec#suspension
   */
  readonly suspension?: ClusterPropagationPolicySpecSuspension;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpec(obj: ClusterPropagationPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activationPreference': obj.activationPreference,
    'association': obj.association,
    'conflictResolution': obj.conflictResolution,
    'dependentOverrides': obj.dependentOverrides?.map(y => y),
    'failover': toJson_ClusterPropagationPolicySpecFailover(obj.failover),
    'placement': toJson_ClusterPropagationPolicySpecPlacement(obj.placement),
    'preemption': obj.preemption,
    'preserveResourcesOnDeletion': obj.preserveResourcesOnDeletion,
    'priority': obj.priority,
    'propagateDeps': obj.propagateDeps,
    'resourceSelectors': obj.resourceSelectors?.map(y => toJson_ClusterPropagationPolicySpecResourceSelectors(y)),
    'schedulePriority': toJson_ClusterPropagationPolicySpecSchedulePriority(obj.schedulePriority),
    'schedulerName': obj.schedulerName,
    'suspension': toJson_ClusterPropagationPolicySpecSuspension(obj.suspension),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ActivationPreference indicates how the referencing resource template will
 * be propagated, in case of policy changes.
 *
 * If empty, the resource template will respond to policy changes
 * immediately, in other words, any policy changes will drive the resource
 * template to be propagated immediately as per the current propagation rules.
 *
 * If the value is 'Lazy' means the policy changes will not take effect for now
 * but defer to the resource template changes, in other words, the resource
 * template will not be propagated as per the current propagation rules until
 * there is an update on it.
 * This is an experimental feature that might help in a scenario where a policy
 * manages huge amount of resource templates, changes to a policy typically
 * affect numerous applications simultaneously. A minor misconfiguration
 * could lead to widespread failures. With this feature, the change can be
 * gradually rolled out through iterative modifications of resource templates.
 *
 * @schema ClusterPropagationPolicySpecActivationPreference
 */
export enum ClusterPropagationPolicySpecActivationPreference {
  /** Lazy */
  LAZY = "Lazy",
}

/**
 * ConflictResolution declares how potential conflict should be handled when
 * a resource that is being propagated already exists in the target cluster.
 *
 * It defaults to "Abort" which means stop propagating to avoid unexpected
 * overwrites. The "Overwrite" might be useful when migrating legacy cluster
 * resources to Karmada, in which case conflict is predictable and can be
 * instructed to Karmada take over the resource by overwriting.
 *
 * @schema ClusterPropagationPolicySpecConflictResolution
 */
export enum ClusterPropagationPolicySpecConflictResolution {
  /** Abort */
  ABORT = "Abort",
  /** Overwrite */
  OVERWRITE = "Overwrite",
}

/**
 * Failover indicates how Karmada migrates applications in case of failures.
 * If this value is nil, failover is disabled.
 *
 * @schema ClusterPropagationPolicySpecFailover
 */
export interface ClusterPropagationPolicySpecFailover {
  /**
   * Application indicates failover behaviors in case of application failure.
   * If this value is nil, failover is disabled.
   * If set, the PropagateDeps should be true so that the dependencies could
   * be migrated along with the application.
   *
   * @schema ClusterPropagationPolicySpecFailover#application
   */
  readonly application?: ClusterPropagationPolicySpecFailoverApplication;

  /**
   * Cluster indicates failover behaviors in case of cluster failure.
   * If this value is nil, the failover behavior in case of cluster failure
   * will be controlled by the controller's no-execute-taint-eviction-purge-mode
   * parameter.
   * If set, the failover behavior in case of cluster failure will be defined
   * by this value.
   *
   * @schema ClusterPropagationPolicySpecFailover#cluster
   */
  readonly cluster?: ClusterPropagationPolicySpecFailoverCluster;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecFailover(obj: ClusterPropagationPolicySpecFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'application': toJson_ClusterPropagationPolicySpecFailoverApplication(obj.application),
    'cluster': toJson_ClusterPropagationPolicySpecFailoverCluster(obj.cluster),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Placement represents the rule for select clusters to propagate resources.
 *
 * @schema ClusterPropagationPolicySpecPlacement
 */
export interface ClusterPropagationPolicySpecPlacement {
  /**
   * ClusterAffinities represents scheduling restrictions to multiple cluster
   * groups that indicated by ClusterAffinityTerm.
   *
   * The scheduler will evaluate these groups one by one in the order they
   * appear in the spec, the group that does not satisfy scheduling restrictions
   * will be ignored which means all clusters in this group will not be selected
   * unless it also belongs to the next group(a cluster could belong to multiple
   * groups).
   *
   * If none of the groups satisfy the scheduling restrictions, then scheduling
   * fails, which means no cluster will be selected.
   *
   * Note:
   * 1. ClusterAffinities can not co-exist with ClusterAffinity.
   * 2. If both ClusterAffinity and ClusterAffinities are not set, any cluster
   * can be scheduling candidates.
   *
   * Potential use case 1:
   * The private clusters in the local data center could be the main group, and
   * the managed clusters provided by cluster providers could be the secondary
   * group. So that the Karmada scheduler would prefer to schedule workloads
   * to the main group and the second group will only be considered in case of
   * the main group does not satisfy restrictions(like, lack of resources).
   *
   * Potential use case 2:
   * For the disaster recovery scenario, the clusters could be organized to
   * primary and backup groups, the workloads would be scheduled to primary
   * clusters firstly, and when primary cluster fails(like data center power off),
   * Karmada scheduler could migrate workloads to the backup clusters.
   *
   * @schema ClusterPropagationPolicySpecPlacement#clusterAffinities
   */
  readonly clusterAffinities?: ClusterPropagationPolicySpecPlacementClusterAffinities[];

  /**
   * ClusterAffinity represents scheduling restrictions to a certain set of clusters.
   * Note:
   * 1. ClusterAffinity can not co-exist with ClusterAffinities.
   * 2. If both ClusterAffinity and ClusterAffinities are not set, any cluster
   * can be scheduling candidates.
   *
   * @schema ClusterPropagationPolicySpecPlacement#clusterAffinity
   */
  readonly clusterAffinity?: ClusterPropagationPolicySpecPlacementClusterAffinity;

  /**
   * ClusterTolerations represents the tolerations.
   *
   * @schema ClusterPropagationPolicySpecPlacement#clusterTolerations
   */
  readonly clusterTolerations?: ClusterPropagationPolicySpecPlacementClusterTolerations[];

  /**
   * ReplicaScheduling represents the scheduling policy on dealing with the number of replicas
   * when propagating resources that have replicas in spec (e.g. deployments, statefulsets) to member clusters.
   *
   * @schema ClusterPropagationPolicySpecPlacement#replicaScheduling
   */
  readonly replicaScheduling?: ClusterPropagationPolicySpecPlacementReplicaScheduling;

  /**
   * SpreadConstraints represents a list of the scheduling constraints.
   *
   * @schema ClusterPropagationPolicySpecPlacement#spreadConstraints
   */
  readonly spreadConstraints?: ClusterPropagationPolicySpecPlacementSpreadConstraints[];
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacement' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacement(obj: ClusterPropagationPolicySpecPlacement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterAffinities': obj.clusterAffinities?.map(y => toJson_ClusterPropagationPolicySpecPlacementClusterAffinities(y)),
    'clusterAffinity': toJson_ClusterPropagationPolicySpecPlacementClusterAffinity(obj.clusterAffinity),
    'clusterTolerations': obj.clusterTolerations?.map(y => toJson_ClusterPropagationPolicySpecPlacementClusterTolerations(y)),
    'replicaScheduling': toJson_ClusterPropagationPolicySpecPlacementReplicaScheduling(obj.replicaScheduling),
    'spreadConstraints': obj.spreadConstraints?.map(y => toJson_ClusterPropagationPolicySpecPlacementSpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Preemption declares the behaviors for preempting.
 * Valid options are "Always" and "Never".
 *
 * @schema ClusterPropagationPolicySpecPreemption
 */
export enum ClusterPropagationPolicySpecPreemption {
  /** Always */
  ALWAYS = "Always",
  /** Never */
  NEVER = "Never",
}

/**
 * ResourceSelector the resources will be selected.
 *
 * @schema ClusterPropagationPolicySpecResourceSelectors
 */
export interface ClusterPropagationPolicySpecResourceSelectors {
  /**
   * APIVersion represents the API version of the target resources.
   *
   * @schema ClusterPropagationPolicySpecResourceSelectors#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind represents the Kind of the target resources.
   *
   * @schema ClusterPropagationPolicySpecResourceSelectors#kind
   */
  readonly kind: string;

  /**
   * A label query over a set of resources.
   * If name is not empty, labelSelector will be ignored.
   *
   * @schema ClusterPropagationPolicySpecResourceSelectors#labelSelector
   */
  readonly labelSelector?: ClusterPropagationPolicySpecResourceSelectorsLabelSelector;

  /**
   * Name of the target resource.
   * Default is empty, which means selecting all resources.
   *
   * @default empty, which means selecting all resources.
   * @schema ClusterPropagationPolicySpecResourceSelectors#name
   */
  readonly name?: string;

  /**
   * Namespace of the target resource.
   * Default is empty, which means inherit from the parent object scope.
   *
   * @default empty, which means inherit from the parent object scope.
   * @schema ClusterPropagationPolicySpecResourceSelectors#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecResourceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecResourceSelectors(obj: ClusterPropagationPolicySpecResourceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'labelSelector': toJson_ClusterPropagationPolicySpecResourceSelectorsLabelSelector(obj.labelSelector),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SchedulePriority defines how Karmada should resolve the priority and preemption policy
 * for workload scheduling.
 *
 * This setting is useful for controlling the scheduling behavior of offline workloads.
 * By setting a higher or lower priority, users can control which workloads are scheduled first.
 * Additionally, it allows specifying a preemption policy where higher-priority workloads can
 * preempt lower-priority ones in scenarios of resource contention.
 *
 * Note: This feature is currently in the alpha stage. The priority-based scheduling functionality is
 * controlled by the PriorityBasedScheduling feature gate, and preemption is controlled by the
 * PriorityBasedPreemptiveScheduling feature gate. Currently, only priority-based scheduling is
 * supported. Preemption functionality is not yet available and will be introduced in future
 * releases as the feature matures.
 *
 * @schema ClusterPropagationPolicySpecSchedulePriority
 */
export interface ClusterPropagationPolicySpecSchedulePriority {
  /**
   * PriorityClassName specifies which PriorityClass to use. Its behavior depends on PriorityClassSource:
   *
   * Behavior of PriorityClassName:
   *
   * For KubePriorityClass:
   * - When specified: Uses the named Kubernetes PriorityClass.
   *
   * For PodPriorityClass:
   * - Uses PriorityClassName from the PodTemplate.
   * - Not yet implemented.
   *
   * For FederatedPriorityClass:
   * - Not yet implemented.
   *
   * @schema ClusterPropagationPolicySpecSchedulePriority#priorityClassName
   */
  readonly priorityClassName: string;

  /**
   * PriorityClassSource specifies where Karmada should look for the PriorityClass definition.
   * Available options:
   * - KubePriorityClass: Uses Kubernetes PriorityClass (scheduling.k8s.io/v1)
   * - PodPriorityClass: Uses PriorityClassName from PodTemplate: PodSpec.PriorityClassName (not yet implemented)
   * - FederatedPriorityClass: Uses Karmada FederatedPriorityClass (not yet implemented)
   *
   * @schema ClusterPropagationPolicySpecSchedulePriority#priorityClassSource
   */
  readonly priorityClassSource: ClusterPropagationPolicySpecSchedulePriorityPriorityClassSource;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecSchedulePriority' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecSchedulePriority(obj: ClusterPropagationPolicySpecSchedulePriority | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'priorityClassName': obj.priorityClassName,
    'priorityClassSource': obj.priorityClassSource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Suspension declares the policy for suspending different aspects of propagation.
 * nil means no suspension. no default values.
 *
 * @schema ClusterPropagationPolicySpecSuspension
 */
export interface ClusterPropagationPolicySpecSuspension {
  /**
   * Dispatching controls whether dispatching should be suspended.
   * nil means not suspend, no default value, only accepts 'true'.
   * Note: true means stop propagating to all clusters. Can not co-exist
   * with DispatchingOnClusters which is used to suspend particular clusters.
   *
   * @schema ClusterPropagationPolicySpecSuspension#dispatching
   */
  readonly dispatching?: boolean;

  /**
   * DispatchingOnClusters declares a list of clusters to which the dispatching
   * should be suspended.
   * Note: Can not co-exist with Dispatching which is used to suspend all.
   *
   * @schema ClusterPropagationPolicySpecSuspension#dispatchingOnClusters
   */
  readonly dispatchingOnClusters?: ClusterPropagationPolicySpecSuspensionDispatchingOnClusters;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecSuspension' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecSuspension(obj: ClusterPropagationPolicySpecSuspension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dispatching': obj.dispatching,
    'dispatchingOnClusters': toJson_ClusterPropagationPolicySpecSuspensionDispatchingOnClusters(obj.dispatchingOnClusters),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Application indicates failover behaviors in case of application failure.
 * If this value is nil, failover is disabled.
 * If set, the PropagateDeps should be true so that the dependencies could
 * be migrated along with the application.
 *
 * @schema ClusterPropagationPolicySpecFailoverApplication
 */
export interface ClusterPropagationPolicySpecFailoverApplication {
  /**
   * DecisionConditions indicates the decision conditions of performing the failover process.
   * Only when all conditions are met can the failover process be performed.
   * Currently, DecisionConditions includes several conditions:
   * - TolerationSeconds (optional)
   *
   * @schema ClusterPropagationPolicySpecFailoverApplication#decisionConditions
   */
  readonly decisionConditions: ClusterPropagationPolicySpecFailoverApplicationDecisionConditions;

  /**
   * GracePeriodSeconds is the maximum waiting duration in seconds before
   * application on the migrated cluster should be deleted.
   * Required only when PurgeMode is "Graciously" and defaults to 600s.
   * If the application on the new cluster cannot reach a Healthy state,
   * Karmada will delete the application after GracePeriodSeconds is reached.
   * Value must be positive integer.
   *
   * @schema ClusterPropagationPolicySpecFailoverApplication#gracePeriodSeconds
   */
  readonly gracePeriodSeconds?: number;

  /**
   * PurgeMode represents how to deal with the legacy applications on the
   * cluster from which the application is migrated.
   * Valid options are "Directly", "Gracefully", "Never", "Immediately"(deprecated),
   * and "Graciously"(deprecated).
   * Defaults to "Gracefully".
   *
   * @default Gracefully".
   * @schema ClusterPropagationPolicySpecFailoverApplication#purgeMode
   */
  readonly purgeMode?: ClusterPropagationPolicySpecFailoverApplicationPurgeMode;

  /**
   * StatePreservation defines the policy for preserving and restoring state data
   * during failover events for stateful applications.
   *
   * When an application fails over from one cluster to another, this policy enables
   * the extraction of critical data from the original resource configuration.
   * Upon successful migration, the extracted data is then re-injected into the new
   * resource, ensuring that the application can resume operation with its previous
   * state intact.
   * This is particularly useful for stateful applications where maintaining data
   * consistency across failover events is crucial.
   * If not specified, means no state data will be preserved.
   *
   * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
   * which is alpha.
   *
   * @schema ClusterPropagationPolicySpecFailoverApplication#statePreservation
   */
  readonly statePreservation?: ClusterPropagationPolicySpecFailoverApplicationStatePreservation;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecFailoverApplication' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecFailoverApplication(obj: ClusterPropagationPolicySpecFailoverApplication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'decisionConditions': toJson_ClusterPropagationPolicySpecFailoverApplicationDecisionConditions(obj.decisionConditions),
    'gracePeriodSeconds': obj.gracePeriodSeconds,
    'purgeMode': obj.purgeMode,
    'statePreservation': toJson_ClusterPropagationPolicySpecFailoverApplicationStatePreservation(obj.statePreservation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cluster indicates failover behaviors in case of cluster failure.
 * If this value is nil, the failover behavior in case of cluster failure
 * will be controlled by the controller's no-execute-taint-eviction-purge-mode
 * parameter.
 * If set, the failover behavior in case of cluster failure will be defined
 * by this value.
 *
 * @schema ClusterPropagationPolicySpecFailoverCluster
 */
export interface ClusterPropagationPolicySpecFailoverCluster {
  /**
   * PurgeMode represents how to deal with the legacy applications on the
   * cluster from which the application is migrated.
   * Valid options are "Directly", "Gracefully".
   * Defaults to "Gracefully".
   *
   * @default Gracefully".
   * @schema ClusterPropagationPolicySpecFailoverCluster#purgeMode
   */
  readonly purgeMode?: ClusterPropagationPolicySpecFailoverClusterPurgeMode;

  /**
   * StatePreservation defines the policy for preserving and restoring state data
   * during failover events for stateful applications.
   *
   * When an application fails over from one cluster to another, this policy enables
   * the extraction of critical data from the original resource configuration.
   * Upon successful migration, the extracted data is then re-injected into the new
   * resource, ensuring that the application can resume operation with its previous
   * state intact.
   * This is particularly useful for stateful applications where maintaining data
   * consistency across failover events is crucial.
   * If not specified, means no state data will be preserved.
   *
   * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
   * which is alpha.
   *
   * @schema ClusterPropagationPolicySpecFailoverCluster#statePreservation
   */
  readonly statePreservation?: ClusterPropagationPolicySpecFailoverClusterStatePreservation;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecFailoverCluster' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecFailoverCluster(obj: ClusterPropagationPolicySpecFailoverCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'purgeMode': obj.purgeMode,
    'statePreservation': toJson_ClusterPropagationPolicySpecFailoverClusterStatePreservation(obj.statePreservation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterAffinityTerm selects a set of cluster.
 *
 * @schema ClusterPropagationPolicySpecPlacementClusterAffinities
 */
export interface ClusterPropagationPolicySpecPlacementClusterAffinities {
  /**
   * AffinityName is the name of the cluster group.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinities#affinityName
   */
  readonly affinityName: string;

  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinities#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinities#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinities#fieldSelector
   */
  readonly fieldSelector?: ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinities#labelSelector
   */
  readonly labelSelector?: ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelector;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementClusterAffinities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementClusterAffinities(obj: ClusterPropagationPolicySpecPlacementClusterAffinities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinityName': obj.affinityName,
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterAffinity represents scheduling restrictions to a certain set of clusters.
 * Note:
 * 1. ClusterAffinity can not co-exist with ClusterAffinities.
 * 2. If both ClusterAffinity and ClusterAffinities are not set, any cluster
 * can be scheduling candidates.
 *
 * @schema ClusterPropagationPolicySpecPlacementClusterAffinity
 */
export interface ClusterPropagationPolicySpecPlacementClusterAffinity {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinity#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinity#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinity#fieldSelector
   */
  readonly fieldSelector?: ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinity#labelSelector
   */
  readonly labelSelector?: ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelector;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementClusterAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementClusterAffinity(obj: ClusterPropagationPolicySpecPlacementClusterAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ClusterPropagationPolicySpecPlacementClusterTolerations
 */
export interface ClusterPropagationPolicySpecPlacementClusterTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema ClusterPropagationPolicySpecPlacementClusterTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementClusterTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementClusterTolerations(obj: ClusterPropagationPolicySpecPlacementClusterTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReplicaScheduling represents the scheduling policy on dealing with the number of replicas
 * when propagating resources that have replicas in spec (e.g. deployments, statefulsets) to member clusters.
 *
 * @schema ClusterPropagationPolicySpecPlacementReplicaScheduling
 */
export interface ClusterPropagationPolicySpecPlacementReplicaScheduling {
  /**
   * ReplicaDivisionPreference determines how the replicas is divided
   * when ReplicaSchedulingType is "Divided". Valid options are Aggregated and Weighted.
   * "Aggregated" divides replicas into clusters as few as possible,
   * while respecting clusters' resource availabilities during the division.
   * "Weighted" divides replicas by weight according to WeightPreference.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaScheduling#replicaDivisionPreference
   */
  readonly replicaDivisionPreference?: ClusterPropagationPolicySpecPlacementReplicaSchedulingReplicaDivisionPreference;

  /**
   * ReplicaSchedulingType determines how the replicas is scheduled when karmada propagating
   * a resource. Valid options are Duplicated and Divided.
   * "Duplicated" duplicates the same replicas to each candidate member cluster from resource.
   * "Divided" divides replicas into parts according to number of valid candidate member
   * clusters, and exact replicas for each cluster are determined by ReplicaDivisionPreference.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaScheduling#replicaSchedulingType
   */
  readonly replicaSchedulingType?: ClusterPropagationPolicySpecPlacementReplicaSchedulingReplicaSchedulingType;

  /**
   * WeightPreference describes weight for each cluster or for each group of cluster
   * If ReplicaDivisionPreference is set to "Weighted", and WeightPreference is not set, scheduler will weight all clusters the same.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaScheduling#weightPreference
   */
  readonly weightPreference?: ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreference;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementReplicaScheduling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementReplicaScheduling(obj: ClusterPropagationPolicySpecPlacementReplicaScheduling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replicaDivisionPreference': obj.replicaDivisionPreference,
    'replicaSchedulingType': obj.replicaSchedulingType,
    'weightPreference': toJson_ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreference(obj.weightPreference),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SpreadConstraint represents the spread constraints on resources.
 *
 * @schema ClusterPropagationPolicySpecPlacementSpreadConstraints
 */
export interface ClusterPropagationPolicySpecPlacementSpreadConstraints {
  /**
   * MaxGroups restricts the maximum number of cluster groups to be selected.
   *
   * @schema ClusterPropagationPolicySpecPlacementSpreadConstraints#maxGroups
   */
  readonly maxGroups?: number;

  /**
   * MinGroups restricts the minimum number of cluster groups to be selected.
   * Defaults to 1.
   *
   * @default 1.
   * @schema ClusterPropagationPolicySpecPlacementSpreadConstraints#minGroups
   */
  readonly minGroups?: number;

  /**
   * SpreadByField represents the fields on Karmada cluster API used for
   * dynamically grouping member clusters into different groups.
   * Resources will be spread among different cluster groups.
   * Available fields for spreading are: cluster, region, zone, and provider.
   * SpreadByField should not co-exist with SpreadByLabel.
   * If both SpreadByField and SpreadByLabel are empty, SpreadByField will be set to "cluster" by system.
   *
   * @schema ClusterPropagationPolicySpecPlacementSpreadConstraints#spreadByField
   */
  readonly spreadByField?: ClusterPropagationPolicySpecPlacementSpreadConstraintsSpreadByField;

  /**
   * SpreadByLabel represents the label key used for
   * grouping member clusters into different groups.
   * Resources will be spread among different cluster groups.
   * SpreadByLabel should not co-exist with SpreadByField.
   *
   * @schema ClusterPropagationPolicySpecPlacementSpreadConstraints#spreadByLabel
   */
  readonly spreadByLabel?: string;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementSpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementSpreadConstraints(obj: ClusterPropagationPolicySpecPlacementSpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxGroups': obj.maxGroups,
    'minGroups': obj.minGroups,
    'spreadByField': obj.spreadByField,
    'spreadByLabel': obj.spreadByLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources.
 * If name is not empty, labelSelector will be ignored.
 *
 * @schema ClusterPropagationPolicySpecResourceSelectorsLabelSelector
 */
export interface ClusterPropagationPolicySpecResourceSelectorsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPropagationPolicySpecResourceSelectorsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPropagationPolicySpecResourceSelectorsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecResourceSelectorsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecResourceSelectorsLabelSelector(obj: ClusterPropagationPolicySpecResourceSelectorsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PriorityClassSource specifies where Karmada should look for the PriorityClass definition.
 * Available options:
 * - KubePriorityClass: Uses Kubernetes PriorityClass (scheduling.k8s.io/v1)
 * - PodPriorityClass: Uses PriorityClassName from PodTemplate: PodSpec.PriorityClassName (not yet implemented)
 * - FederatedPriorityClass: Uses Karmada FederatedPriorityClass (not yet implemented)
 *
 * @schema ClusterPropagationPolicySpecSchedulePriorityPriorityClassSource
 */
export enum ClusterPropagationPolicySpecSchedulePriorityPriorityClassSource {
  /** KubePriorityClass */
  KUBE_PRIORITY_CLASS = "KubePriorityClass",
}

/**
 * DispatchingOnClusters declares a list of clusters to which the dispatching
 * should be suspended.
 * Note: Can not co-exist with Dispatching which is used to suspend all.
 *
 * @schema ClusterPropagationPolicySpecSuspensionDispatchingOnClusters
 */
export interface ClusterPropagationPolicySpecSuspensionDispatchingOnClusters {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema ClusterPropagationPolicySpecSuspensionDispatchingOnClusters#clusterNames
   */
  readonly clusterNames?: string[];
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecSuspensionDispatchingOnClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecSuspensionDispatchingOnClusters(obj: ClusterPropagationPolicySpecSuspensionDispatchingOnClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DecisionConditions indicates the decision conditions of performing the failover process.
 * Only when all conditions are met can the failover process be performed.
 * Currently, DecisionConditions includes several conditions:
 * - TolerationSeconds (optional)
 *
 * @schema ClusterPropagationPolicySpecFailoverApplicationDecisionConditions
 */
export interface ClusterPropagationPolicySpecFailoverApplicationDecisionConditions {
  /**
   * TolerationSeconds represents the period of time Karmada should wait
   * after reaching the desired state before performing failover process.
   * If not specified, Karmada will immediately perform failover process.
   * Defaults to 300s.
   *
   * @default 300s.
   * @schema ClusterPropagationPolicySpecFailoverApplicationDecisionConditions#tolerationSeconds
   */
  readonly tolerationSeconds?: number;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecFailoverApplicationDecisionConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecFailoverApplicationDecisionConditions(obj: ClusterPropagationPolicySpecFailoverApplicationDecisionConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tolerationSeconds': obj.tolerationSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PurgeMode represents how to deal with the legacy applications on the
 * cluster from which the application is migrated.
 * Valid options are "Directly", "Gracefully", "Never", "Immediately"(deprecated),
 * and "Graciously"(deprecated).
 * Defaults to "Gracefully".
 *
 * @default Gracefully".
 * @schema ClusterPropagationPolicySpecFailoverApplicationPurgeMode
 */
export enum ClusterPropagationPolicySpecFailoverApplicationPurgeMode {
  /** Directly */
  DIRECTLY = "Directly",
  /** Gracefully */
  GRACEFULLY = "Gracefully",
  /** Never */
  NEVER = "Never",
  /** Immediately */
  IMMEDIATELY = "Immediately",
  /** Graciously */
  GRACIOUSLY = "Graciously",
}

/**
 * StatePreservation defines the policy for preserving and restoring state data
 * during failover events for stateful applications.
 *
 * When an application fails over from one cluster to another, this policy enables
 * the extraction of critical data from the original resource configuration.
 * Upon successful migration, the extracted data is then re-injected into the new
 * resource, ensuring that the application can resume operation with its previous
 * state intact.
 * This is particularly useful for stateful applications where maintaining data
 * consistency across failover events is crucial.
 * If not specified, means no state data will be preserved.
 *
 * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
 * which is alpha.
 *
 * @schema ClusterPropagationPolicySpecFailoverApplicationStatePreservation
 */
export interface ClusterPropagationPolicySpecFailoverApplicationStatePreservation {
  /**
   * Rules contains a list of StatePreservationRule configurations.
   * Each rule specifies a JSONPath expression targeting specific pieces of
   * state data to be preserved during failover events. An AliasLabelName is associated
   * with each rule, serving as a label key when the preserved data is passed
   * to the new cluster.
   *
   * @schema ClusterPropagationPolicySpecFailoverApplicationStatePreservation#rules
   */
  readonly rules: ClusterPropagationPolicySpecFailoverApplicationStatePreservationRules[];
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecFailoverApplicationStatePreservation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecFailoverApplicationStatePreservation(obj: ClusterPropagationPolicySpecFailoverApplicationStatePreservation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_ClusterPropagationPolicySpecFailoverApplicationStatePreservationRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PurgeMode represents how to deal with the legacy applications on the
 * cluster from which the application is migrated.
 * Valid options are "Directly", "Gracefully".
 * Defaults to "Gracefully".
 *
 * @default Gracefully".
 * @schema ClusterPropagationPolicySpecFailoverClusterPurgeMode
 */
export enum ClusterPropagationPolicySpecFailoverClusterPurgeMode {
  /** Directly */
  DIRECTLY = "Directly",
  /** Gracefully */
  GRACEFULLY = "Gracefully",
}

/**
 * StatePreservation defines the policy for preserving and restoring state data
 * during failover events for stateful applications.
 *
 * When an application fails over from one cluster to another, this policy enables
 * the extraction of critical data from the original resource configuration.
 * Upon successful migration, the extracted data is then re-injected into the new
 * resource, ensuring that the application can resume operation with its previous
 * state intact.
 * This is particularly useful for stateful applications where maintaining data
 * consistency across failover events is crucial.
 * If not specified, means no state data will be preserved.
 *
 * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
 * which is alpha.
 *
 * @schema ClusterPropagationPolicySpecFailoverClusterStatePreservation
 */
export interface ClusterPropagationPolicySpecFailoverClusterStatePreservation {
  /**
   * Rules contains a list of StatePreservationRule configurations.
   * Each rule specifies a JSONPath expression targeting specific pieces of
   * state data to be preserved during failover events. An AliasLabelName is associated
   * with each rule, serving as a label key when the preserved data is passed
   * to the new cluster.
   *
   * @schema ClusterPropagationPolicySpecFailoverClusterStatePreservation#rules
   */
  readonly rules: ClusterPropagationPolicySpecFailoverClusterStatePreservationRules[];
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecFailoverClusterStatePreservation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecFailoverClusterStatePreservation(obj: ClusterPropagationPolicySpecFailoverClusterStatePreservation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_ClusterPropagationPolicySpecFailoverClusterStatePreservationRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelector
 */
export interface ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelector(obj: ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelector
 */
export interface ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelector(obj: ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelector
 */
export interface ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelector(obj: ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelector
 */
export interface ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelector(obj: ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReplicaDivisionPreference determines how the replicas is divided
 * when ReplicaSchedulingType is "Divided". Valid options are Aggregated and Weighted.
 * "Aggregated" divides replicas into clusters as few as possible,
 * while respecting clusters' resource availabilities during the division.
 * "Weighted" divides replicas by weight according to WeightPreference.
 *
 * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingReplicaDivisionPreference
 */
export enum ClusterPropagationPolicySpecPlacementReplicaSchedulingReplicaDivisionPreference {
  /** Aggregated */
  AGGREGATED = "Aggregated",
  /** Weighted */
  WEIGHTED = "Weighted",
}

/**
 * ReplicaSchedulingType determines how the replicas is scheduled when karmada propagating
 * a resource. Valid options are Duplicated and Divided.
 * "Duplicated" duplicates the same replicas to each candidate member cluster from resource.
 * "Divided" divides replicas into parts according to number of valid candidate member
 * clusters, and exact replicas for each cluster are determined by ReplicaDivisionPreference.
 *
 * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingReplicaSchedulingType
 */
export enum ClusterPropagationPolicySpecPlacementReplicaSchedulingReplicaSchedulingType {
  /** Duplicated */
  DUPLICATED = "Duplicated",
  /** Divided */
  DIVIDED = "Divided",
}

/**
 * WeightPreference describes weight for each cluster or for each group of cluster
 * If ReplicaDivisionPreference is set to "Weighted", and WeightPreference is not set, scheduler will weight all clusters the same.
 *
 * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreference
 */
export interface ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreference {
  /**
   * DynamicWeight specifies the factor to generates dynamic weight list.
   * If specified, StaticWeightList will be ignored.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreference#dynamicWeight
   */
  readonly dynamicWeight?: ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceDynamicWeight;

  /**
   * StaticWeightList defines the static cluster weight.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreference#staticWeightList
   */
  readonly staticWeightList?: ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList[];
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreference(obj: ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dynamicWeight': obj.dynamicWeight,
    'staticWeightList': obj.staticWeightList?.map(y => toJson_ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SpreadByField represents the fields on Karmada cluster API used for
 * dynamically grouping member clusters into different groups.
 * Resources will be spread among different cluster groups.
 * Available fields for spreading are: cluster, region, zone, and provider.
 * SpreadByField should not co-exist with SpreadByLabel.
 * If both SpreadByField and SpreadByLabel are empty, SpreadByField will be set to "cluster" by system.
 *
 * @schema ClusterPropagationPolicySpecPlacementSpreadConstraintsSpreadByField
 */
export enum ClusterPropagationPolicySpecPlacementSpreadConstraintsSpreadByField {
  /** cluster */
  CLUSTER = "cluster",
  /** region */
  REGION = "region",
  /** zone */
  ZONE = "zone",
  /** provider */
  PROVIDER = "provider",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions
 */
export interface ClusterPropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions(obj: ClusterPropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StatePreservationRule defines a single rule for state preservation.
 * It includes a JSONPath expression and an alias name that will be used
 * as a label key when passing state information to the new cluster.
 *
 * @schema ClusterPropagationPolicySpecFailoverApplicationStatePreservationRules
 */
export interface ClusterPropagationPolicySpecFailoverApplicationStatePreservationRules {
  /**
   * AliasLabelName is the name that will be used as a label key when the preserved
   * data is passed to the new cluster. This facilitates the injection of the
   * preserved state back into the application resources during recovery.
   *
   * @schema ClusterPropagationPolicySpecFailoverApplicationStatePreservationRules#aliasLabelName
   */
  readonly aliasLabelName: string;

  /**
   * JSONPath is the JSONPath template used to identify the state data
   * to be preserved from the original resource configuration.
   * The JSONPath syntax follows the Kubernetes specification:
   * https://kubernetes.io/docs/reference/kubectl/jsonpath/
   *
   * Note: The JSONPath expression will start searching from the "status" field of
   * the API resource object by default. For example, to extract the "availableReplicas"
   * from a Deployment, the JSONPath expression should be "{.availableReplicas}", not
   * "{.status.availableReplicas}".
   *
   * @schema ClusterPropagationPolicySpecFailoverApplicationStatePreservationRules#jsonPath
   */
  readonly jsonPath: string;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecFailoverApplicationStatePreservationRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecFailoverApplicationStatePreservationRules(obj: ClusterPropagationPolicySpecFailoverApplicationStatePreservationRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aliasLabelName': obj.aliasLabelName,
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StatePreservationRule defines a single rule for state preservation.
 * It includes a JSONPath expression and an alias name that will be used
 * as a label key when passing state information to the new cluster.
 *
 * @schema ClusterPropagationPolicySpecFailoverClusterStatePreservationRules
 */
export interface ClusterPropagationPolicySpecFailoverClusterStatePreservationRules {
  /**
   * AliasLabelName is the name that will be used as a label key when the preserved
   * data is passed to the new cluster. This facilitates the injection of the
   * preserved state back into the application resources during recovery.
   *
   * @schema ClusterPropagationPolicySpecFailoverClusterStatePreservationRules#aliasLabelName
   */
  readonly aliasLabelName: string;

  /**
   * JSONPath is the JSONPath template used to identify the state data
   * to be preserved from the original resource configuration.
   * The JSONPath syntax follows the Kubernetes specification:
   * https://kubernetes.io/docs/reference/kubectl/jsonpath/
   *
   * Note: The JSONPath expression will start searching from the "status" field of
   * the API resource object by default. For example, to extract the "availableReplicas"
   * from a Deployment, the JSONPath expression should be "{.availableReplicas}", not
   * "{.status.availableReplicas}".
   *
   * @schema ClusterPropagationPolicySpecFailoverClusterStatePreservationRules#jsonPath
   */
  readonly jsonPath: string;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecFailoverClusterStatePreservationRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecFailoverClusterStatePreservationRules(obj: ClusterPropagationPolicySpecFailoverClusterStatePreservationRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aliasLabelName': obj.aliasLabelName,
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions
 */
export interface ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions(obj: ClusterPropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions
 */
export interface ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions(obj: ClusterPropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions
 */
export interface ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions(obj: ClusterPropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions
 */
export interface ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions(obj: ClusterPropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DynamicWeight specifies the factor to generates dynamic weight list.
 * If specified, StaticWeightList will be ignored.
 *
 * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceDynamicWeight
 */
export enum ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceDynamicWeight {
  /** AvailableReplicas */
  AVAILABLE_REPLICAS = "AvailableReplicas",
}

/**
 * StaticClusterWeight defines the static cluster weight.
 *
 * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList
 */
export interface ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList {
  /**
   * TargetCluster describes the filter to select clusters.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList#targetCluster
   */
  readonly targetCluster: ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster;

  /**
   * Weight expressing the preference to the cluster(s) specified by 'TargetCluster'.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList(obj: ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetCluster': toJson_ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster(obj.targetCluster),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetCluster describes the filter to select clusters.
 *
 * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster
 */
export interface ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#fieldSelector
   */
  readonly fieldSelector?: ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#labelSelector
   */
  readonly labelSelector?: ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector;
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster(obj: ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector
 */
export interface ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector(obj: ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector
 */
export interface ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector(obj: ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions
 */
export interface ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions(obj: ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions
 */
export interface ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions(obj: ClusterPropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * OverridePolicy represents the policy that overrides a group of resources to one or more clusters.
 *
 * @schema OverridePolicy
 */
export class OverridePolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OverridePolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'policy.karmada.io/v1alpha1',
    kind: 'OverridePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "OverridePolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OverridePolicyProps): any {
    return {
      ...OverridePolicy.GVK,
      ...toJson_OverridePolicyProps(props),
    };
  }

  /**
   * Defines a "OverridePolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OverridePolicyProps) {
    super(scope, id, {
      ...OverridePolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...OverridePolicy.GVK,
      ...toJson_OverridePolicyProps(resolved),
    };
  }
}

/**
 * OverridePolicy represents the policy that overrides a group of resources to one or more clusters.
 *
 * @schema OverridePolicy
 */
export interface OverridePolicyProps {
  /**
   * @schema OverridePolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec represents the desired behavior of OverridePolicy.
   *
   * @schema OverridePolicy#spec
   */
  readonly spec: OverridePolicySpec;
}

/**
 * Converts an object of type 'OverridePolicyProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicyProps(obj: OverridePolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OverridePolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec represents the desired behavior of OverridePolicy.
 *
 * @schema OverridePolicySpec
 */
export interface OverridePolicySpec {
  /**
   * OverrideRules defines a collection of override rules on target clusters.
   *
   * @schema OverridePolicySpec#overrideRules
   */
  readonly overrideRules?: OverridePolicySpecOverrideRules[];

  /**
   * Overriders represents the override rules that would apply on resources
   *
   * Deprecated: This filed is deprecated in v1.0 and please use the OverrideRules instead.
   *
   * @schema OverridePolicySpec#overriders
   */
  readonly overriders?: OverridePolicySpecOverriders;

  /**
   * ResourceSelectors restricts resource types that this override policy applies to.
   * nil means matching all resources.
   *
   * @schema OverridePolicySpec#resourceSelectors
   */
  readonly resourceSelectors?: OverridePolicySpecResourceSelectors[];

  /**
   * TargetCluster defines restrictions on this override policy
   * that only applies to resources propagated to the matching clusters.
   * nil means matching all clusters.
   *
   * Deprecated: This filed is deprecated in v1.0 and please use the OverrideRules instead.
   *
   * @schema OverridePolicySpec#targetCluster
   */
  readonly targetCluster?: OverridePolicySpecTargetCluster;
}

/**
 * Converts an object of type 'OverridePolicySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpec(obj: OverridePolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'overrideRules': obj.overrideRules?.map(y => toJson_OverridePolicySpecOverrideRules(y)),
    'overriders': toJson_OverridePolicySpecOverriders(obj.overriders),
    'resourceSelectors': obj.resourceSelectors?.map(y => toJson_OverridePolicySpecResourceSelectors(y)),
    'targetCluster': toJson_OverridePolicySpecTargetCluster(obj.targetCluster),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RuleWithCluster defines the override rules on clusters.
 *
 * @schema OverridePolicySpecOverrideRules
 */
export interface OverridePolicySpecOverrideRules {
  /**
   * Overriders represents the override rules that would apply on resources
   *
   * @schema OverridePolicySpecOverrideRules#overriders
   */
  readonly overriders: OverridePolicySpecOverrideRulesOverriders;

  /**
   * TargetCluster defines restrictions on this override policy
   * that only applies to resources propagated to the matching clusters.
   * nil means matching all clusters.
   *
   * @schema OverridePolicySpecOverrideRules#targetCluster
   */
  readonly targetCluster?: OverridePolicySpecOverrideRulesTargetCluster;
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRules(obj: OverridePolicySpecOverrideRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'overriders': toJson_OverridePolicySpecOverrideRulesOverriders(obj.overriders),
    'targetCluster': toJson_OverridePolicySpecOverrideRulesTargetCluster(obj.targetCluster),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Overriders represents the override rules that would apply on resources
 *
 * Deprecated: This filed is deprecated in v1.0 and please use the OverrideRules instead.
 *
 * @schema OverridePolicySpecOverriders
 */
export interface OverridePolicySpecOverriders {
  /**
   * AnnotationsOverrider represents the rules dedicated to handling workload annotations
   *
   * @schema OverridePolicySpecOverriders#annotationsOverrider
   */
  readonly annotationsOverrider?: OverridePolicySpecOverridersAnnotationsOverrider[];

  /**
   * ArgsOverrider represents the rules dedicated to handling container args
   *
   * @schema OverridePolicySpecOverriders#argsOverrider
   */
  readonly argsOverrider?: OverridePolicySpecOverridersArgsOverrider[];

  /**
   * CommandOverrider represents the rules dedicated to handling container command
   *
   * @schema OverridePolicySpecOverriders#commandOverrider
   */
  readonly commandOverrider?: OverridePolicySpecOverridersCommandOverrider[];

  /**
   * FieldOverrider represents the rules dedicated to modifying a specific field in any Kubernetes resource.
   * This allows changing a single field within the resource with multiple operations.
   * It is designed to handle structured field values such as those found in ConfigMaps or Secrets.
   * The current implementation supports JSON and YAML formats, but can easily be extended to support XML in the future.
   *
   * @schema OverridePolicySpecOverriders#fieldOverrider
   */
  readonly fieldOverrider?: OverridePolicySpecOverridersFieldOverrider[];

  /**
   * ImageOverrider represents the rules dedicated to handling image overrides.
   *
   * @schema OverridePolicySpecOverriders#imageOverrider
   */
  readonly imageOverrider?: OverridePolicySpecOverridersImageOverrider[];

  /**
   * LabelsOverrider represents the rules dedicated to handling workload labels
   *
   * @schema OverridePolicySpecOverriders#labelsOverrider
   */
  readonly labelsOverrider?: OverridePolicySpecOverridersLabelsOverrider[];

  /**
   * Plaintext represents override rules defined with plaintext overriders.
   *
   * @schema OverridePolicySpecOverriders#plaintext
   */
  readonly plaintext?: OverridePolicySpecOverridersPlaintext[];
}

/**
 * Converts an object of type 'OverridePolicySpecOverriders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverriders(obj: OverridePolicySpecOverriders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotationsOverrider': obj.annotationsOverrider?.map(y => toJson_OverridePolicySpecOverridersAnnotationsOverrider(y)),
    'argsOverrider': obj.argsOverrider?.map(y => toJson_OverridePolicySpecOverridersArgsOverrider(y)),
    'commandOverrider': obj.commandOverrider?.map(y => toJson_OverridePolicySpecOverridersCommandOverrider(y)),
    'fieldOverrider': obj.fieldOverrider?.map(y => toJson_OverridePolicySpecOverridersFieldOverrider(y)),
    'imageOverrider': obj.imageOverrider?.map(y => toJson_OverridePolicySpecOverridersImageOverrider(y)),
    'labelsOverrider': obj.labelsOverrider?.map(y => toJson_OverridePolicySpecOverridersLabelsOverrider(y)),
    'plaintext': obj.plaintext?.map(y => toJson_OverridePolicySpecOverridersPlaintext(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceSelector the resources will be selected.
 *
 * @schema OverridePolicySpecResourceSelectors
 */
export interface OverridePolicySpecResourceSelectors {
  /**
   * APIVersion represents the API version of the target resources.
   *
   * @schema OverridePolicySpecResourceSelectors#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind represents the Kind of the target resources.
   *
   * @schema OverridePolicySpecResourceSelectors#kind
   */
  readonly kind: string;

  /**
   * A label query over a set of resources.
   * If name is not empty, labelSelector will be ignored.
   *
   * @schema OverridePolicySpecResourceSelectors#labelSelector
   */
  readonly labelSelector?: OverridePolicySpecResourceSelectorsLabelSelector;

  /**
   * Name of the target resource.
   * Default is empty, which means selecting all resources.
   *
   * @default empty, which means selecting all resources.
   * @schema OverridePolicySpecResourceSelectors#name
   */
  readonly name?: string;

  /**
   * Namespace of the target resource.
   * Default is empty, which means inherit from the parent object scope.
   *
   * @default empty, which means inherit from the parent object scope.
   * @schema OverridePolicySpecResourceSelectors#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'OverridePolicySpecResourceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecResourceSelectors(obj: OverridePolicySpecResourceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'labelSelector': toJson_OverridePolicySpecResourceSelectorsLabelSelector(obj.labelSelector),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetCluster defines restrictions on this override policy
 * that only applies to resources propagated to the matching clusters.
 * nil means matching all clusters.
 *
 * Deprecated: This filed is deprecated in v1.0 and please use the OverrideRules instead.
 *
 * @schema OverridePolicySpecTargetCluster
 */
export interface OverridePolicySpecTargetCluster {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema OverridePolicySpecTargetCluster#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema OverridePolicySpecTargetCluster#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema OverridePolicySpecTargetCluster#fieldSelector
   */
  readonly fieldSelector?: OverridePolicySpecTargetClusterFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema OverridePolicySpecTargetCluster#labelSelector
   */
  readonly labelSelector?: OverridePolicySpecTargetClusterLabelSelector;
}

/**
 * Converts an object of type 'OverridePolicySpecTargetCluster' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecTargetCluster(obj: OverridePolicySpecTargetCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_OverridePolicySpecTargetClusterFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_OverridePolicySpecTargetClusterLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Overriders represents the override rules that would apply on resources
 *
 * @schema OverridePolicySpecOverrideRulesOverriders
 */
export interface OverridePolicySpecOverrideRulesOverriders {
  /**
   * AnnotationsOverrider represents the rules dedicated to handling workload annotations
   *
   * @schema OverridePolicySpecOverrideRulesOverriders#annotationsOverrider
   */
  readonly annotationsOverrider?: OverridePolicySpecOverrideRulesOverridersAnnotationsOverrider[];

  /**
   * ArgsOverrider represents the rules dedicated to handling container args
   *
   * @schema OverridePolicySpecOverrideRulesOverriders#argsOverrider
   */
  readonly argsOverrider?: OverridePolicySpecOverrideRulesOverridersArgsOverrider[];

  /**
   * CommandOverrider represents the rules dedicated to handling container command
   *
   * @schema OverridePolicySpecOverrideRulesOverriders#commandOverrider
   */
  readonly commandOverrider?: OverridePolicySpecOverrideRulesOverridersCommandOverrider[];

  /**
   * FieldOverrider represents the rules dedicated to modifying a specific field in any Kubernetes resource.
   * This allows changing a single field within the resource with multiple operations.
   * It is designed to handle structured field values such as those found in ConfigMaps or Secrets.
   * The current implementation supports JSON and YAML formats, but can easily be extended to support XML in the future.
   *
   * @schema OverridePolicySpecOverrideRulesOverriders#fieldOverrider
   */
  readonly fieldOverrider?: OverridePolicySpecOverrideRulesOverridersFieldOverrider[];

  /**
   * ImageOverrider represents the rules dedicated to handling image overrides.
   *
   * @schema OverridePolicySpecOverrideRulesOverriders#imageOverrider
   */
  readonly imageOverrider?: OverridePolicySpecOverrideRulesOverridersImageOverrider[];

  /**
   * LabelsOverrider represents the rules dedicated to handling workload labels
   *
   * @schema OverridePolicySpecOverrideRulesOverriders#labelsOverrider
   */
  readonly labelsOverrider?: OverridePolicySpecOverrideRulesOverridersLabelsOverrider[];

  /**
   * Plaintext represents override rules defined with plaintext overriders.
   *
   * @schema OverridePolicySpecOverrideRulesOverriders#plaintext
   */
  readonly plaintext?: OverridePolicySpecOverrideRulesOverridersPlaintext[];
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesOverriders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesOverriders(obj: OverridePolicySpecOverrideRulesOverriders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotationsOverrider': obj.annotationsOverrider?.map(y => toJson_OverridePolicySpecOverrideRulesOverridersAnnotationsOverrider(y)),
    'argsOverrider': obj.argsOverrider?.map(y => toJson_OverridePolicySpecOverrideRulesOverridersArgsOverrider(y)),
    'commandOverrider': obj.commandOverrider?.map(y => toJson_OverridePolicySpecOverrideRulesOverridersCommandOverrider(y)),
    'fieldOverrider': obj.fieldOverrider?.map(y => toJson_OverridePolicySpecOverrideRulesOverridersFieldOverrider(y)),
    'imageOverrider': obj.imageOverrider?.map(y => toJson_OverridePolicySpecOverrideRulesOverridersImageOverrider(y)),
    'labelsOverrider': obj.labelsOverrider?.map(y => toJson_OverridePolicySpecOverrideRulesOverridersLabelsOverrider(y)),
    'plaintext': obj.plaintext?.map(y => toJson_OverridePolicySpecOverrideRulesOverridersPlaintext(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetCluster defines restrictions on this override policy
 * that only applies to resources propagated to the matching clusters.
 * nil means matching all clusters.
 *
 * @schema OverridePolicySpecOverrideRulesTargetCluster
 */
export interface OverridePolicySpecOverrideRulesTargetCluster {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema OverridePolicySpecOverrideRulesTargetCluster#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema OverridePolicySpecOverrideRulesTargetCluster#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema OverridePolicySpecOverrideRulesTargetCluster#fieldSelector
   */
  readonly fieldSelector?: OverridePolicySpecOverrideRulesTargetClusterFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema OverridePolicySpecOverrideRulesTargetCluster#labelSelector
   */
  readonly labelSelector?: OverridePolicySpecOverrideRulesTargetClusterLabelSelector;
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesTargetCluster' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesTargetCluster(obj: OverridePolicySpecOverrideRulesTargetCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_OverridePolicySpecOverrideRulesTargetClusterFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_OverridePolicySpecOverrideRulesTargetClusterLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelAnnotationOverrider represents the rules dedicated to handling workload labels/annotations
 *
 * @schema OverridePolicySpecOverridersAnnotationsOverrider
 */
export interface OverridePolicySpecOverridersAnnotationsOverrider {
  /**
   * Operator represents the operator which will apply on the workload.
   *
   * @schema OverridePolicySpecOverridersAnnotationsOverrider#operator
   */
  readonly operator: OverridePolicySpecOverridersAnnotationsOverriderOperator;

  /**
   * Value to be applied to annotations/labels of workload.
   * Items in Value which will be appended after annotations/labels when Operator is 'add'.
   * Items in Value which match in annotations/labels will be deleted when Operator is 'remove'.
   * Items in Value which match in annotations/labels will be replaced when Operator is 'replace'.
   *
   * @schema OverridePolicySpecOverridersAnnotationsOverrider#value
   */
  readonly value: { [key: string]: string };
}

/**
 * Converts an object of type 'OverridePolicySpecOverridersAnnotationsOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverridersAnnotationsOverrider(obj: OverridePolicySpecOverridersAnnotationsOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'value': ((obj.value) === undefined) ? undefined : (Object.entries(obj.value).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CommandArgsOverrider represents the rules dedicated to handling command/args overrides.
 *
 * @schema OverridePolicySpecOverridersArgsOverrider
 */
export interface OverridePolicySpecOverridersArgsOverrider {
  /**
   * The name of container
   *
   * @schema OverridePolicySpecOverridersArgsOverrider#containerName
   */
  readonly containerName: string;

  /**
   * Operator represents the operator which will apply on the command/args.
   *
   * @schema OverridePolicySpecOverridersArgsOverrider#operator
   */
  readonly operator: OverridePolicySpecOverridersArgsOverriderOperator;

  /**
   * Value to be applied to command/args.
   * Items in Value which will be appended after command/args when Operator is 'add'.
   * Items in Value which match in command/args will be deleted when Operator is 'remove'.
   * If Value is empty, then the command/args will remain the same.
   *
   * @schema OverridePolicySpecOverridersArgsOverrider#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'OverridePolicySpecOverridersArgsOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverridersArgsOverrider(obj: OverridePolicySpecOverridersArgsOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'operator': obj.operator,
    'value': obj.value?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CommandArgsOverrider represents the rules dedicated to handling command/args overrides.
 *
 * @schema OverridePolicySpecOverridersCommandOverrider
 */
export interface OverridePolicySpecOverridersCommandOverrider {
  /**
   * The name of container
   *
   * @schema OverridePolicySpecOverridersCommandOverrider#containerName
   */
  readonly containerName: string;

  /**
   * Operator represents the operator which will apply on the command/args.
   *
   * @schema OverridePolicySpecOverridersCommandOverrider#operator
   */
  readonly operator: OverridePolicySpecOverridersCommandOverriderOperator;

  /**
   * Value to be applied to command/args.
   * Items in Value which will be appended after command/args when Operator is 'add'.
   * Items in Value which match in command/args will be deleted when Operator is 'remove'.
   * If Value is empty, then the command/args will remain the same.
   *
   * @schema OverridePolicySpecOverridersCommandOverrider#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'OverridePolicySpecOverridersCommandOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverridersCommandOverrider(obj: OverridePolicySpecOverridersCommandOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'operator': obj.operator,
    'value': obj.value?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldOverrider represents the rules dedicated to modifying a specific field in any Kubernetes resource.
 * This allows changing a single field within the resource with multiple operations.
 * It is designed to handle structured field values such as those found in ConfigMaps or Secrets.
 * The current implementation supports JSON and YAML formats, but can easily be extended to support XML in the future.
 * Note: In any given instance, FieldOverrider processes either JSON or YAML fields, but not both simultaneously.
 *
 * @schema OverridePolicySpecOverridersFieldOverrider
 */
export interface OverridePolicySpecOverridersFieldOverrider {
  /**
   * FieldPath specifies the initial location in the instance document where the operation should take place.
   * The path uses RFC 6901 for navigating into nested structures. For example, the path "/data/db-config.yaml"
   * specifies the configuration data key named "db-config.yaml" in a ConfigMap: "/data/db-config.yaml".
   *
   * @schema OverridePolicySpecOverridersFieldOverrider#fieldPath
   */
  readonly fieldPath: string;

  /**
   * JSON represents the operations performed on the JSON document specified by the FieldPath.
   *
   * @schema OverridePolicySpecOverridersFieldOverrider#json
   */
  readonly json?: OverridePolicySpecOverridersFieldOverriderJson[];

  /**
   * YAML represents the operations performed on the YAML document specified by the FieldPath.
   *
   * @schema OverridePolicySpecOverridersFieldOverrider#yaml
   */
  readonly yaml?: OverridePolicySpecOverridersFieldOverriderYaml[];
}

/**
 * Converts an object of type 'OverridePolicySpecOverridersFieldOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverridersFieldOverrider(obj: OverridePolicySpecOverridersFieldOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldPath': obj.fieldPath,
    'json': obj.json?.map(y => toJson_OverridePolicySpecOverridersFieldOverriderJson(y)),
    'yaml': obj.yaml?.map(y => toJson_OverridePolicySpecOverridersFieldOverriderYaml(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ImageOverrider represents the rules dedicated to handling image overrides.
 *
 * @schema OverridePolicySpecOverridersImageOverrider
 */
export interface OverridePolicySpecOverridersImageOverrider {
  /**
   * Component is part of image name.
   * Basically we presume an image can be made of '[registry/]repository[:tag]'.
   * The registry could be:
   * - registry.k8s.io
   * - fictional.registry.example:10443
   * The repository could be:
   * - kube-apiserver
   * - fictional/nginx
   * The tag cloud be:
   * - latest
   * - v1.19.1
   * - @sha256:dbcc1c35ac38df41fd2f5e4130b32ffdb93ebae8b3dbe638c23575912276fc9c
   *
   * @schema OverridePolicySpecOverridersImageOverrider#component
   */
  readonly component: OverridePolicySpecOverridersImageOverriderComponent;

  /**
   * Operator represents the operator which will apply on the image.
   *
   * @schema OverridePolicySpecOverridersImageOverrider#operator
   */
  readonly operator: OverridePolicySpecOverridersImageOverriderOperator;

  /**
   * Predicate filters images before applying the rule.
   *
   * Defaults to nil, in that case, the system will automatically detect image fields if the resource type is
   * Pod, ReplicaSet, Deployment, StatefulSet, DaemonSet or Job by following rule:
   * - Pod: /spec/containers/<N>/image
   * - ReplicaSet: /spec/template/spec/containers/<N>/image
   * - Deployment: /spec/template/spec/containers/<N>/image
   * - DaemonSet: /spec/template/spec/containers/<N>/image
   * - StatefulSet: /spec/template/spec/containers/<N>/image
   * - Job: /spec/template/spec/containers/<N>/image
   * In addition, all images will be processed if the resource object has more than one container.
   *
   * If not nil, only images matches the filters will be processed.
   *
   * @default nil, in that case, the system will automatically detect image fields if the resource type is
   * @schema OverridePolicySpecOverridersImageOverrider#predicate
   */
  readonly predicate?: OverridePolicySpecOverridersImageOverriderPredicate;

  /**
   * Value to be applied to image.
   * Must not be empty when operator is 'add' or 'replace'.
   * Defaults to empty and ignored when operator is 'remove'.
   *
   * @default empty and ignored when operator is 'remove'.
   * @schema OverridePolicySpecOverridersImageOverrider#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'OverridePolicySpecOverridersImageOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverridersImageOverrider(obj: OverridePolicySpecOverridersImageOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'component': obj.component,
    'operator': obj.operator,
    'predicate': toJson_OverridePolicySpecOverridersImageOverriderPredicate(obj.predicate),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelAnnotationOverrider represents the rules dedicated to handling workload labels/annotations
 *
 * @schema OverridePolicySpecOverridersLabelsOverrider
 */
export interface OverridePolicySpecOverridersLabelsOverrider {
  /**
   * Operator represents the operator which will apply on the workload.
   *
   * @schema OverridePolicySpecOverridersLabelsOverrider#operator
   */
  readonly operator: OverridePolicySpecOverridersLabelsOverriderOperator;

  /**
   * Value to be applied to annotations/labels of workload.
   * Items in Value which will be appended after annotations/labels when Operator is 'add'.
   * Items in Value which match in annotations/labels will be deleted when Operator is 'remove'.
   * Items in Value which match in annotations/labels will be replaced when Operator is 'replace'.
   *
   * @schema OverridePolicySpecOverridersLabelsOverrider#value
   */
  readonly value: { [key: string]: string };
}

/**
 * Converts an object of type 'OverridePolicySpecOverridersLabelsOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverridersLabelsOverrider(obj: OverridePolicySpecOverridersLabelsOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'value': ((obj.value) === undefined) ? undefined : (Object.entries(obj.value).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PlaintextOverrider is a simple overrider that overrides target fields
 * according to path, operator and value.
 *
 * @schema OverridePolicySpecOverridersPlaintext
 */
export interface OverridePolicySpecOverridersPlaintext {
  /**
   * Operator indicates the operation on target field.
   * Available operators are: add, replace and remove.
   *
   * @schema OverridePolicySpecOverridersPlaintext#operator
   */
  readonly operator: OverridePolicySpecOverridersPlaintextOperator;

  /**
   * Path indicates the path of target field
   *
   * @schema OverridePolicySpecOverridersPlaintext#path
   */
  readonly path: string;

  /**
   * Value to be applied to target field.
   * Must be empty when operator is Remove.
   *
   * @schema OverridePolicySpecOverridersPlaintext#value
   */
  readonly value?: any;
}

/**
 * Converts an object of type 'OverridePolicySpecOverridersPlaintext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverridersPlaintext(obj: OverridePolicySpecOverridersPlaintext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'path': obj.path,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources.
 * If name is not empty, labelSelector will be ignored.
 *
 * @schema OverridePolicySpecResourceSelectorsLabelSelector
 */
export interface OverridePolicySpecResourceSelectorsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema OverridePolicySpecResourceSelectorsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: OverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema OverridePolicySpecResourceSelectorsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'OverridePolicySpecResourceSelectorsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecResourceSelectorsLabelSelector(obj: OverridePolicySpecResourceSelectorsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_OverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema OverridePolicySpecTargetClusterFieldSelector
 */
export interface OverridePolicySpecTargetClusterFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema OverridePolicySpecTargetClusterFieldSelector#matchExpressions
   */
  readonly matchExpressions?: OverridePolicySpecTargetClusterFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'OverridePolicySpecTargetClusterFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecTargetClusterFieldSelector(obj: OverridePolicySpecTargetClusterFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_OverridePolicySpecTargetClusterFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema OverridePolicySpecTargetClusterLabelSelector
 */
export interface OverridePolicySpecTargetClusterLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema OverridePolicySpecTargetClusterLabelSelector#matchExpressions
   */
  readonly matchExpressions?: OverridePolicySpecTargetClusterLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema OverridePolicySpecTargetClusterLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'OverridePolicySpecTargetClusterLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecTargetClusterLabelSelector(obj: OverridePolicySpecTargetClusterLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_OverridePolicySpecTargetClusterLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelAnnotationOverrider represents the rules dedicated to handling workload labels/annotations
 *
 * @schema OverridePolicySpecOverrideRulesOverridersAnnotationsOverrider
 */
export interface OverridePolicySpecOverrideRulesOverridersAnnotationsOverrider {
  /**
   * Operator represents the operator which will apply on the workload.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersAnnotationsOverrider#operator
   */
  readonly operator: OverridePolicySpecOverrideRulesOverridersAnnotationsOverriderOperator;

  /**
   * Value to be applied to annotations/labels of workload.
   * Items in Value which will be appended after annotations/labels when Operator is 'add'.
   * Items in Value which match in annotations/labels will be deleted when Operator is 'remove'.
   * Items in Value which match in annotations/labels will be replaced when Operator is 'replace'.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersAnnotationsOverrider#value
   */
  readonly value: { [key: string]: string };
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesOverridersAnnotationsOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesOverridersAnnotationsOverrider(obj: OverridePolicySpecOverrideRulesOverridersAnnotationsOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'value': ((obj.value) === undefined) ? undefined : (Object.entries(obj.value).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CommandArgsOverrider represents the rules dedicated to handling command/args overrides.
 *
 * @schema OverridePolicySpecOverrideRulesOverridersArgsOverrider
 */
export interface OverridePolicySpecOverrideRulesOverridersArgsOverrider {
  /**
   * The name of container
   *
   * @schema OverridePolicySpecOverrideRulesOverridersArgsOverrider#containerName
   */
  readonly containerName: string;

  /**
   * Operator represents the operator which will apply on the command/args.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersArgsOverrider#operator
   */
  readonly operator: OverridePolicySpecOverrideRulesOverridersArgsOverriderOperator;

  /**
   * Value to be applied to command/args.
   * Items in Value which will be appended after command/args when Operator is 'add'.
   * Items in Value which match in command/args will be deleted when Operator is 'remove'.
   * If Value is empty, then the command/args will remain the same.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersArgsOverrider#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesOverridersArgsOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesOverridersArgsOverrider(obj: OverridePolicySpecOverrideRulesOverridersArgsOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'operator': obj.operator,
    'value': obj.value?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CommandArgsOverrider represents the rules dedicated to handling command/args overrides.
 *
 * @schema OverridePolicySpecOverrideRulesOverridersCommandOverrider
 */
export interface OverridePolicySpecOverrideRulesOverridersCommandOverrider {
  /**
   * The name of container
   *
   * @schema OverridePolicySpecOverrideRulesOverridersCommandOverrider#containerName
   */
  readonly containerName: string;

  /**
   * Operator represents the operator which will apply on the command/args.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersCommandOverrider#operator
   */
  readonly operator: OverridePolicySpecOverrideRulesOverridersCommandOverriderOperator;

  /**
   * Value to be applied to command/args.
   * Items in Value which will be appended after command/args when Operator is 'add'.
   * Items in Value which match in command/args will be deleted when Operator is 'remove'.
   * If Value is empty, then the command/args will remain the same.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersCommandOverrider#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesOverridersCommandOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesOverridersCommandOverrider(obj: OverridePolicySpecOverrideRulesOverridersCommandOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'operator': obj.operator,
    'value': obj.value?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldOverrider represents the rules dedicated to modifying a specific field in any Kubernetes resource.
 * This allows changing a single field within the resource with multiple operations.
 * It is designed to handle structured field values such as those found in ConfigMaps or Secrets.
 * The current implementation supports JSON and YAML formats, but can easily be extended to support XML in the future.
 * Note: In any given instance, FieldOverrider processes either JSON or YAML fields, but not both simultaneously.
 *
 * @schema OverridePolicySpecOverrideRulesOverridersFieldOverrider
 */
export interface OverridePolicySpecOverrideRulesOverridersFieldOverrider {
  /**
   * FieldPath specifies the initial location in the instance document where the operation should take place.
   * The path uses RFC 6901 for navigating into nested structures. For example, the path "/data/db-config.yaml"
   * specifies the configuration data key named "db-config.yaml" in a ConfigMap: "/data/db-config.yaml".
   *
   * @schema OverridePolicySpecOverrideRulesOverridersFieldOverrider#fieldPath
   */
  readonly fieldPath: string;

  /**
   * JSON represents the operations performed on the JSON document specified by the FieldPath.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersFieldOverrider#json
   */
  readonly json?: OverridePolicySpecOverrideRulesOverridersFieldOverriderJson[];

  /**
   * YAML represents the operations performed on the YAML document specified by the FieldPath.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersFieldOverrider#yaml
   */
  readonly yaml?: OverridePolicySpecOverrideRulesOverridersFieldOverriderYaml[];
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesOverridersFieldOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesOverridersFieldOverrider(obj: OverridePolicySpecOverrideRulesOverridersFieldOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldPath': obj.fieldPath,
    'json': obj.json?.map(y => toJson_OverridePolicySpecOverrideRulesOverridersFieldOverriderJson(y)),
    'yaml': obj.yaml?.map(y => toJson_OverridePolicySpecOverrideRulesOverridersFieldOverriderYaml(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ImageOverrider represents the rules dedicated to handling image overrides.
 *
 * @schema OverridePolicySpecOverrideRulesOverridersImageOverrider
 */
export interface OverridePolicySpecOverrideRulesOverridersImageOverrider {
  /**
   * Component is part of image name.
   * Basically we presume an image can be made of '[registry/]repository[:tag]'.
   * The registry could be:
   * - registry.k8s.io
   * - fictional.registry.example:10443
   * The repository could be:
   * - kube-apiserver
   * - fictional/nginx
   * The tag cloud be:
   * - latest
   * - v1.19.1
   * - @sha256:dbcc1c35ac38df41fd2f5e4130b32ffdb93ebae8b3dbe638c23575912276fc9c
   *
   * @schema OverridePolicySpecOverrideRulesOverridersImageOverrider#component
   */
  readonly component: OverridePolicySpecOverrideRulesOverridersImageOverriderComponent;

  /**
   * Operator represents the operator which will apply on the image.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersImageOverrider#operator
   */
  readonly operator: OverridePolicySpecOverrideRulesOverridersImageOverriderOperator;

  /**
   * Predicate filters images before applying the rule.
   *
   * Defaults to nil, in that case, the system will automatically detect image fields if the resource type is
   * Pod, ReplicaSet, Deployment, StatefulSet, DaemonSet or Job by following rule:
   * - Pod: /spec/containers/<N>/image
   * - ReplicaSet: /spec/template/spec/containers/<N>/image
   * - Deployment: /spec/template/spec/containers/<N>/image
   * - DaemonSet: /spec/template/spec/containers/<N>/image
   * - StatefulSet: /spec/template/spec/containers/<N>/image
   * - Job: /spec/template/spec/containers/<N>/image
   * In addition, all images will be processed if the resource object has more than one container.
   *
   * If not nil, only images matches the filters will be processed.
   *
   * @default nil, in that case, the system will automatically detect image fields if the resource type is
   * @schema OverridePolicySpecOverrideRulesOverridersImageOverrider#predicate
   */
  readonly predicate?: OverridePolicySpecOverrideRulesOverridersImageOverriderPredicate;

  /**
   * Value to be applied to image.
   * Must not be empty when operator is 'add' or 'replace'.
   * Defaults to empty and ignored when operator is 'remove'.
   *
   * @default empty and ignored when operator is 'remove'.
   * @schema OverridePolicySpecOverrideRulesOverridersImageOverrider#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesOverridersImageOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesOverridersImageOverrider(obj: OverridePolicySpecOverrideRulesOverridersImageOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'component': obj.component,
    'operator': obj.operator,
    'predicate': toJson_OverridePolicySpecOverrideRulesOverridersImageOverriderPredicate(obj.predicate),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelAnnotationOverrider represents the rules dedicated to handling workload labels/annotations
 *
 * @schema OverridePolicySpecOverrideRulesOverridersLabelsOverrider
 */
export interface OverridePolicySpecOverrideRulesOverridersLabelsOverrider {
  /**
   * Operator represents the operator which will apply on the workload.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersLabelsOverrider#operator
   */
  readonly operator: OverridePolicySpecOverrideRulesOverridersLabelsOverriderOperator;

  /**
   * Value to be applied to annotations/labels of workload.
   * Items in Value which will be appended after annotations/labels when Operator is 'add'.
   * Items in Value which match in annotations/labels will be deleted when Operator is 'remove'.
   * Items in Value which match in annotations/labels will be replaced when Operator is 'replace'.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersLabelsOverrider#value
   */
  readonly value: { [key: string]: string };
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesOverridersLabelsOverrider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesOverridersLabelsOverrider(obj: OverridePolicySpecOverrideRulesOverridersLabelsOverrider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'value': ((obj.value) === undefined) ? undefined : (Object.entries(obj.value).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PlaintextOverrider is a simple overrider that overrides target fields
 * according to path, operator and value.
 *
 * @schema OverridePolicySpecOverrideRulesOverridersPlaintext
 */
export interface OverridePolicySpecOverrideRulesOverridersPlaintext {
  /**
   * Operator indicates the operation on target field.
   * Available operators are: add, replace and remove.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersPlaintext#operator
   */
  readonly operator: OverridePolicySpecOverrideRulesOverridersPlaintextOperator;

  /**
   * Path indicates the path of target field
   *
   * @schema OverridePolicySpecOverrideRulesOverridersPlaintext#path
   */
  readonly path: string;

  /**
   * Value to be applied to target field.
   * Must be empty when operator is Remove.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersPlaintext#value
   */
  readonly value?: any;
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesOverridersPlaintext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesOverridersPlaintext(obj: OverridePolicySpecOverrideRulesOverridersPlaintext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'path': obj.path,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema OverridePolicySpecOverrideRulesTargetClusterFieldSelector
 */
export interface OverridePolicySpecOverrideRulesTargetClusterFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema OverridePolicySpecOverrideRulesTargetClusterFieldSelector#matchExpressions
   */
  readonly matchExpressions?: OverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesTargetClusterFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesTargetClusterFieldSelector(obj: OverridePolicySpecOverrideRulesTargetClusterFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_OverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema OverridePolicySpecOverrideRulesTargetClusterLabelSelector
 */
export interface OverridePolicySpecOverrideRulesTargetClusterLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema OverridePolicySpecOverrideRulesTargetClusterLabelSelector#matchExpressions
   */
  readonly matchExpressions?: OverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema OverridePolicySpecOverrideRulesTargetClusterLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesTargetClusterLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesTargetClusterLabelSelector(obj: OverridePolicySpecOverrideRulesTargetClusterLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_OverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Operator represents the operator which will apply on the workload.
 *
 * @schema OverridePolicySpecOverridersAnnotationsOverriderOperator
 */
export enum OverridePolicySpecOverridersAnnotationsOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Operator represents the operator which will apply on the command/args.
 *
 * @schema OverridePolicySpecOverridersArgsOverriderOperator
 */
export enum OverridePolicySpecOverridersArgsOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
}

/**
 * Operator represents the operator which will apply on the command/args.
 *
 * @schema OverridePolicySpecOverridersCommandOverriderOperator
 */
export enum OverridePolicySpecOverridersCommandOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
}

/**
 * JSONPatchOperation represents a single field modification operation for JSON format.
 *
 * @schema OverridePolicySpecOverridersFieldOverriderJson
 */
export interface OverridePolicySpecOverridersFieldOverriderJson {
  /**
   * Operator indicates the operation on target field.
   * Available operators are: "add", "remove", and "replace".
   *
   * @schema OverridePolicySpecOverridersFieldOverriderJson#operator
   */
  readonly operator: OverridePolicySpecOverridersFieldOverriderJsonOperator;

  /**
   * SubPath specifies the relative location within the initial FieldPath where the operation should take place.
   * The path uses RFC 6901 for navigating into nested structures.
   *
   * @schema OverridePolicySpecOverridersFieldOverriderJson#subPath
   */
  readonly subPath: string;

  /**
   * Value is the new value to set for the specified field if the operation is "add" or "replace".
   * For "remove" operation, this field is ignored.
   *
   * @schema OverridePolicySpecOverridersFieldOverriderJson#value
   */
  readonly value?: any;
}

/**
 * Converts an object of type 'OverridePolicySpecOverridersFieldOverriderJson' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverridersFieldOverriderJson(obj: OverridePolicySpecOverridersFieldOverriderJson | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'subPath': obj.subPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * YAMLPatchOperation represents a single field modification operation for YAML format.
 *
 * @schema OverridePolicySpecOverridersFieldOverriderYaml
 */
export interface OverridePolicySpecOverridersFieldOverriderYaml {
  /**
   * Operator indicates the operation on target field.
   * Available operators are: "add", "remove", and "replace".
   *
   * @schema OverridePolicySpecOverridersFieldOverriderYaml#operator
   */
  readonly operator: OverridePolicySpecOverridersFieldOverriderYamlOperator;

  /**
   * SubPath specifies the relative location within the initial FieldPath where the operation should take place.
   * The path uses RFC 6901 for navigating into nested structures.
   *
   * @schema OverridePolicySpecOverridersFieldOverriderYaml#subPath
   */
  readonly subPath: string;

  /**
   * Value is the new value to set for the specified field if the operation is "add" or "replace".
   * For "remove" operation, this field is ignored.
   *
   * @schema OverridePolicySpecOverridersFieldOverriderYaml#value
   */
  readonly value?: any;
}

/**
 * Converts an object of type 'OverridePolicySpecOverridersFieldOverriderYaml' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverridersFieldOverriderYaml(obj: OverridePolicySpecOverridersFieldOverriderYaml | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'subPath': obj.subPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Component is part of image name.
 * Basically we presume an image can be made of '[registry/]repository[:tag]'.
 * The registry could be:
 * - registry.k8s.io
 * - fictional.registry.example:10443
 * The repository could be:
 * - kube-apiserver
 * - fictional/nginx
 * The tag cloud be:
 * - latest
 * - v1.19.1
 * - @sha256:dbcc1c35ac38df41fd2f5e4130b32ffdb93ebae8b3dbe638c23575912276fc9c
 *
 * @schema OverridePolicySpecOverridersImageOverriderComponent
 */
export enum OverridePolicySpecOverridersImageOverriderComponent {
  /** Registry */
  REGISTRY = "Registry",
  /** Repository */
  REPOSITORY = "Repository",
  /** Tag */
  TAG = "Tag",
}

/**
 * Operator represents the operator which will apply on the image.
 *
 * @schema OverridePolicySpecOverridersImageOverriderOperator
 */
export enum OverridePolicySpecOverridersImageOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Predicate filters images before applying the rule.
 *
 * Defaults to nil, in that case, the system will automatically detect image fields if the resource type is
 * Pod, ReplicaSet, Deployment, StatefulSet, DaemonSet or Job by following rule:
 * - Pod: /spec/containers/<N>/image
 * - ReplicaSet: /spec/template/spec/containers/<N>/image
 * - Deployment: /spec/template/spec/containers/<N>/image
 * - DaemonSet: /spec/template/spec/containers/<N>/image
 * - StatefulSet: /spec/template/spec/containers/<N>/image
 * - Job: /spec/template/spec/containers/<N>/image
 * In addition, all images will be processed if the resource object has more than one container.
 *
 * If not nil, only images matches the filters will be processed.
 *
 * @default nil, in that case, the system will automatically detect image fields if the resource type is
 * @schema OverridePolicySpecOverridersImageOverriderPredicate
 */
export interface OverridePolicySpecOverridersImageOverriderPredicate {
  /**
   * Path indicates the path of target field
   *
   * @schema OverridePolicySpecOverridersImageOverriderPredicate#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'OverridePolicySpecOverridersImageOverriderPredicate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverridersImageOverriderPredicate(obj: OverridePolicySpecOverridersImageOverriderPredicate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Operator represents the operator which will apply on the workload.
 *
 * @schema OverridePolicySpecOverridersLabelsOverriderOperator
 */
export enum OverridePolicySpecOverridersLabelsOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Operator indicates the operation on target field.
 * Available operators are: add, replace and remove.
 *
 * @schema OverridePolicySpecOverridersPlaintextOperator
 */
export enum OverridePolicySpecOverridersPlaintextOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema OverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions
 */
export interface OverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema OverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema OverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema OverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'OverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions(obj: OverridePolicySpecResourceSelectorsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema OverridePolicySpecTargetClusterFieldSelectorMatchExpressions
 */
export interface OverridePolicySpecTargetClusterFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema OverridePolicySpecTargetClusterFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema OverridePolicySpecTargetClusterFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema OverridePolicySpecTargetClusterFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'OverridePolicySpecTargetClusterFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecTargetClusterFieldSelectorMatchExpressions(obj: OverridePolicySpecTargetClusterFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema OverridePolicySpecTargetClusterLabelSelectorMatchExpressions
 */
export interface OverridePolicySpecTargetClusterLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema OverridePolicySpecTargetClusterLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema OverridePolicySpecTargetClusterLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema OverridePolicySpecTargetClusterLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'OverridePolicySpecTargetClusterLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecTargetClusterLabelSelectorMatchExpressions(obj: OverridePolicySpecTargetClusterLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Operator represents the operator which will apply on the workload.
 *
 * @schema OverridePolicySpecOverrideRulesOverridersAnnotationsOverriderOperator
 */
export enum OverridePolicySpecOverrideRulesOverridersAnnotationsOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Operator represents the operator which will apply on the command/args.
 *
 * @schema OverridePolicySpecOverrideRulesOverridersArgsOverriderOperator
 */
export enum OverridePolicySpecOverrideRulesOverridersArgsOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
}

/**
 * Operator represents the operator which will apply on the command/args.
 *
 * @schema OverridePolicySpecOverrideRulesOverridersCommandOverriderOperator
 */
export enum OverridePolicySpecOverrideRulesOverridersCommandOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
}

/**
 * JSONPatchOperation represents a single field modification operation for JSON format.
 *
 * @schema OverridePolicySpecOverrideRulesOverridersFieldOverriderJson
 */
export interface OverridePolicySpecOverrideRulesOverridersFieldOverriderJson {
  /**
   * Operator indicates the operation on target field.
   * Available operators are: "add", "remove", and "replace".
   *
   * @schema OverridePolicySpecOverrideRulesOverridersFieldOverriderJson#operator
   */
  readonly operator: OverridePolicySpecOverrideRulesOverridersFieldOverriderJsonOperator;

  /**
   * SubPath specifies the relative location within the initial FieldPath where the operation should take place.
   * The path uses RFC 6901 for navigating into nested structures.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersFieldOverriderJson#subPath
   */
  readonly subPath: string;

  /**
   * Value is the new value to set for the specified field if the operation is "add" or "replace".
   * For "remove" operation, this field is ignored.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersFieldOverriderJson#value
   */
  readonly value?: any;
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesOverridersFieldOverriderJson' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesOverridersFieldOverriderJson(obj: OverridePolicySpecOverrideRulesOverridersFieldOverriderJson | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'subPath': obj.subPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * YAMLPatchOperation represents a single field modification operation for YAML format.
 *
 * @schema OverridePolicySpecOverrideRulesOverridersFieldOverriderYaml
 */
export interface OverridePolicySpecOverrideRulesOverridersFieldOverriderYaml {
  /**
   * Operator indicates the operation on target field.
   * Available operators are: "add", "remove", and "replace".
   *
   * @schema OverridePolicySpecOverrideRulesOverridersFieldOverriderYaml#operator
   */
  readonly operator: OverridePolicySpecOverrideRulesOverridersFieldOverriderYamlOperator;

  /**
   * SubPath specifies the relative location within the initial FieldPath where the operation should take place.
   * The path uses RFC 6901 for navigating into nested structures.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersFieldOverriderYaml#subPath
   */
  readonly subPath: string;

  /**
   * Value is the new value to set for the specified field if the operation is "add" or "replace".
   * For "remove" operation, this field is ignored.
   *
   * @schema OverridePolicySpecOverrideRulesOverridersFieldOverriderYaml#value
   */
  readonly value?: any;
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesOverridersFieldOverriderYaml' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesOverridersFieldOverriderYaml(obj: OverridePolicySpecOverrideRulesOverridersFieldOverriderYaml | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'subPath': obj.subPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Component is part of image name.
 * Basically we presume an image can be made of '[registry/]repository[:tag]'.
 * The registry could be:
 * - registry.k8s.io
 * - fictional.registry.example:10443
 * The repository could be:
 * - kube-apiserver
 * - fictional/nginx
 * The tag cloud be:
 * - latest
 * - v1.19.1
 * - @sha256:dbcc1c35ac38df41fd2f5e4130b32ffdb93ebae8b3dbe638c23575912276fc9c
 *
 * @schema OverridePolicySpecOverrideRulesOverridersImageOverriderComponent
 */
export enum OverridePolicySpecOverrideRulesOverridersImageOverriderComponent {
  /** Registry */
  REGISTRY = "Registry",
  /** Repository */
  REPOSITORY = "Repository",
  /** Tag */
  TAG = "Tag",
}

/**
 * Operator represents the operator which will apply on the image.
 *
 * @schema OverridePolicySpecOverrideRulesOverridersImageOverriderOperator
 */
export enum OverridePolicySpecOverrideRulesOverridersImageOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Predicate filters images before applying the rule.
 *
 * Defaults to nil, in that case, the system will automatically detect image fields if the resource type is
 * Pod, ReplicaSet, Deployment, StatefulSet, DaemonSet or Job by following rule:
 * - Pod: /spec/containers/<N>/image
 * - ReplicaSet: /spec/template/spec/containers/<N>/image
 * - Deployment: /spec/template/spec/containers/<N>/image
 * - DaemonSet: /spec/template/spec/containers/<N>/image
 * - StatefulSet: /spec/template/spec/containers/<N>/image
 * - Job: /spec/template/spec/containers/<N>/image
 * In addition, all images will be processed if the resource object has more than one container.
 *
 * If not nil, only images matches the filters will be processed.
 *
 * @default nil, in that case, the system will automatically detect image fields if the resource type is
 * @schema OverridePolicySpecOverrideRulesOverridersImageOverriderPredicate
 */
export interface OverridePolicySpecOverrideRulesOverridersImageOverriderPredicate {
  /**
   * Path indicates the path of target field
   *
   * @schema OverridePolicySpecOverrideRulesOverridersImageOverriderPredicate#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesOverridersImageOverriderPredicate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesOverridersImageOverriderPredicate(obj: OverridePolicySpecOverrideRulesOverridersImageOverriderPredicate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Operator represents the operator which will apply on the workload.
 *
 * @schema OverridePolicySpecOverrideRulesOverridersLabelsOverriderOperator
 */
export enum OverridePolicySpecOverrideRulesOverridersLabelsOverriderOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Operator indicates the operation on target field.
 * Available operators are: add, replace and remove.
 *
 * @schema OverridePolicySpecOverrideRulesOverridersPlaintextOperator
 */
export enum OverridePolicySpecOverrideRulesOverridersPlaintextOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema OverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions
 */
export interface OverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema OverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema OverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema OverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions(obj: OverridePolicySpecOverrideRulesTargetClusterFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema OverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions
 */
export interface OverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema OverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema OverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema OverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'OverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions(obj: OverridePolicySpecOverrideRulesTargetClusterLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Operator indicates the operation on target field.
 * Available operators are: "add", "remove", and "replace".
 *
 * @schema OverridePolicySpecOverridersFieldOverriderJsonOperator
 */
export enum OverridePolicySpecOverridersFieldOverriderJsonOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Operator indicates the operation on target field.
 * Available operators are: "add", "remove", and "replace".
 *
 * @schema OverridePolicySpecOverridersFieldOverriderYamlOperator
 */
export enum OverridePolicySpecOverridersFieldOverriderYamlOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Operator indicates the operation on target field.
 * Available operators are: "add", "remove", and "replace".
 *
 * @schema OverridePolicySpecOverrideRulesOverridersFieldOverriderJsonOperator
 */
export enum OverridePolicySpecOverrideRulesOverridersFieldOverriderJsonOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}

/**
 * Operator indicates the operation on target field.
 * Available operators are: "add", "remove", and "replace".
 *
 * @schema OverridePolicySpecOverrideRulesOverridersFieldOverriderYamlOperator
 */
export enum OverridePolicySpecOverrideRulesOverridersFieldOverriderYamlOperator {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
}


/**
 * PropagationPolicy represents the policy that propagates a group of resources to one or more clusters.
 *
 * @schema PropagationPolicy
 */
export class PropagationPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PropagationPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'policy.karmada.io/v1alpha1',
    kind: 'PropagationPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "PropagationPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PropagationPolicyProps): any {
    return {
      ...PropagationPolicy.GVK,
      ...toJson_PropagationPolicyProps(props),
    };
  }

  /**
   * Defines a "PropagationPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PropagationPolicyProps) {
    super(scope, id, {
      ...PropagationPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...PropagationPolicy.GVK,
      ...toJson_PropagationPolicyProps(resolved),
    };
  }
}

/**
 * PropagationPolicy represents the policy that propagates a group of resources to one or more clusters.
 *
 * @schema PropagationPolicy
 */
export interface PropagationPolicyProps {
  /**
   * @schema PropagationPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec represents the desired behavior of PropagationPolicy.
   *
   * @schema PropagationPolicy#spec
   */
  readonly spec: PropagationPolicySpec;
}

/**
 * Converts an object of type 'PropagationPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicyProps(obj: PropagationPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PropagationPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec represents the desired behavior of PropagationPolicy.
 *
 * @schema PropagationPolicySpec
 */
export interface PropagationPolicySpec {
  /**
   * ActivationPreference indicates how the referencing resource template will
   * be propagated, in case of policy changes.
   *
   * If empty, the resource template will respond to policy changes
   * immediately, in other words, any policy changes will drive the resource
   * template to be propagated immediately as per the current propagation rules.
   *
   * If the value is 'Lazy' means the policy changes will not take effect for now
   * but defer to the resource template changes, in other words, the resource
   * template will not be propagated as per the current propagation rules until
   * there is an update on it.
   * This is an experimental feature that might help in a scenario where a policy
   * manages huge amount of resource templates, changes to a policy typically
   * affect numerous applications simultaneously. A minor misconfiguration
   * could lead to widespread failures. With this feature, the change can be
   * gradually rolled out through iterative modifications of resource templates.
   *
   * @schema PropagationPolicySpec#activationPreference
   */
  readonly activationPreference?: PropagationPolicySpecActivationPreference;

  /**
   * Association tells if relevant resources should be selected automatically.
   * e.g. a ConfigMap referred by a Deployment.
   * default false.
   * Deprecated: in favor of PropagateDeps.
   *
   * @schema PropagationPolicySpec#association
   */
  readonly association?: boolean;

  /**
   * ConflictResolution declares how potential conflict should be handled when
   * a resource that is being propagated already exists in the target cluster.
   *
   * It defaults to "Abort" which means stop propagating to avoid unexpected
   * overwrites. The "Overwrite" might be useful when migrating legacy cluster
   * resources to Karmada, in which case conflict is predictable and can be
   * instructed to Karmada take over the resource by overwriting.
   *
   * @schema PropagationPolicySpec#conflictResolution
   */
  readonly conflictResolution?: PropagationPolicySpecConflictResolution;

  /**
   * DependentOverrides represents the list of overrides(OverridePolicy)
   * which must present before the current PropagationPolicy takes effect.
   *
   * It used to explicitly specify overrides which current PropagationPolicy rely on.
   * A typical scenario is the users create OverridePolicy(ies) and resources at the same time,
   * they want to ensure the new-created policies would be adopted.
   *
   * Note: For the overrides, OverridePolicy(ies) in current namespace and ClusterOverridePolicy(ies),
   * which not present in this list will still be applied if they matches the resources.
   *
   * @schema PropagationPolicySpec#dependentOverrides
   */
  readonly dependentOverrides?: string[];

  /**
   * Failover indicates how Karmada migrates applications in case of failures.
   * If this value is nil, failover is disabled.
   *
   * @schema PropagationPolicySpec#failover
   */
  readonly failover?: PropagationPolicySpecFailover;

  /**
   * Placement represents the rule for select clusters to propagate resources.
   *
   * @schema PropagationPolicySpec#placement
   */
  readonly placement?: PropagationPolicySpecPlacement;

  /**
   * Preemption declares the behaviors for preempting.
   * Valid options are "Always" and "Never".
   *
   * @schema PropagationPolicySpec#preemption
   */
  readonly preemption?: PropagationPolicySpecPreemption;

  /**
   * PreserveResourcesOnDeletion controls whether resources should be preserved on the
   * member clusters when the resource template is deleted.
   * If set to true, resources will be preserved on the member clusters.
   * Default is false, which means resources will be deleted along with the resource template.
   *
   * This setting is particularly useful during workload migration scenarios to ensure
   * that rollback can occur quickly without affecting the workloads running on the
   * member clusters.
   *
   * Additionally, this setting applies uniformly across all member clusters and will not
   * selectively control preservation on only some clusters.
   *
   * Note: This setting does not apply to the deletion of the policy itself.
   * When the policy is deleted, the resource templates and their corresponding
   * propagated resources in member clusters will remain unchanged unless explicitly deleted.
   *
   * @default false, which means resources will be deleted along with the resource template.
   * @schema PropagationPolicySpec#preserveResourcesOnDeletion
   */
  readonly preserveResourcesOnDeletion?: boolean;

  /**
   * Priority indicates the importance of a policy(PropagationPolicy or ClusterPropagationPolicy).
   * A policy will be applied for the matched resource templates if there is
   * no other policies with higher priority at the point of the resource
   * template be processed.
   * Once a resource template has been claimed by a policy, by default it will
   * not be preempted by following policies even with a higher priority.
   * See Preemption for more details.
   *
   * In case of two policies have the same priority, the one with a more precise
   * matching rules in ResourceSelectors wins:
   * - matching by name(resourceSelector.name) has higher priority than
   * by selector(resourceSelector.labelSelector)
   * - matching by selector(resourceSelector.labelSelector) has higher priority
   * than by APIVersion(resourceSelector.apiVersion) and Kind(resourceSelector.kind).
   * If there is still no winner at this point, the one with the lower alphabetic
   * order wins, e.g. policy 'bar' has higher priority than 'foo'.
   *
   * The higher the value, the higher the priority. Defaults to zero.
   *
   * @default zero.
   * @schema PropagationPolicySpec#priority
   */
  readonly priority?: number;

  /**
   * PropagateDeps tells if relevant resources should be propagated automatically.
   * Take 'Deployment' which referencing 'ConfigMap' and 'Secret' as an example, when 'propagateDeps' is 'true',
   * the referencing resources could be omitted(for saving config effort) from 'resourceSelectors' as they will be
   * propagated along with the Deployment. In addition to the propagating process, the referencing resources will be
   * migrated along with the Deployment in the fail-over scenario.
   *
   * Defaults to false.
   *
   * @default false.
   * @schema PropagationPolicySpec#propagateDeps
   */
  readonly propagateDeps?: boolean;

  /**
   * ResourceSelectors used to select resources.
   * Nil or empty selector is not allowed and doesn't mean match all kinds
   * of resources for security concerns that sensitive resources(like Secret)
   * might be accidentally propagated.
   *
   * @schema PropagationPolicySpec#resourceSelectors
   */
  readonly resourceSelectors: PropagationPolicySpecResourceSelectors[];

  /**
   * SchedulePriority defines how Karmada should resolve the priority and preemption policy
   * for workload scheduling.
   *
   * This setting is useful for controlling the scheduling behavior of offline workloads.
   * By setting a higher or lower priority, users can control which workloads are scheduled first.
   * Additionally, it allows specifying a preemption policy where higher-priority workloads can
   * preempt lower-priority ones in scenarios of resource contention.
   *
   * Note: This feature is currently in the alpha stage. The priority-based scheduling functionality is
   * controlled by the PriorityBasedScheduling feature gate, and preemption is controlled by the
   * PriorityBasedPreemptiveScheduling feature gate. Currently, only priority-based scheduling is
   * supported. Preemption functionality is not yet available and will be introduced in future
   * releases as the feature matures.
   *
   * @schema PropagationPolicySpec#schedulePriority
   */
  readonly schedulePriority?: PropagationPolicySpecSchedulePriority;

  /**
   * SchedulerName represents which scheduler to proceed the scheduling.
   * If specified, the policy will be dispatched by specified scheduler.
   * If not specified, the policy will be dispatched by default scheduler.
   *
   * @schema PropagationPolicySpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Suspension declares the policy for suspending different aspects of propagation.
   * nil means no suspension. no default values.
   *
   * @schema PropagationPolicySpec#suspension
   */
  readonly suspension?: PropagationPolicySpecSuspension;
}

/**
 * Converts an object of type 'PropagationPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpec(obj: PropagationPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activationPreference': obj.activationPreference,
    'association': obj.association,
    'conflictResolution': obj.conflictResolution,
    'dependentOverrides': obj.dependentOverrides?.map(y => y),
    'failover': toJson_PropagationPolicySpecFailover(obj.failover),
    'placement': toJson_PropagationPolicySpecPlacement(obj.placement),
    'preemption': obj.preemption,
    'preserveResourcesOnDeletion': obj.preserveResourcesOnDeletion,
    'priority': obj.priority,
    'propagateDeps': obj.propagateDeps,
    'resourceSelectors': obj.resourceSelectors?.map(y => toJson_PropagationPolicySpecResourceSelectors(y)),
    'schedulePriority': toJson_PropagationPolicySpecSchedulePriority(obj.schedulePriority),
    'schedulerName': obj.schedulerName,
    'suspension': toJson_PropagationPolicySpecSuspension(obj.suspension),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ActivationPreference indicates how the referencing resource template will
 * be propagated, in case of policy changes.
 *
 * If empty, the resource template will respond to policy changes
 * immediately, in other words, any policy changes will drive the resource
 * template to be propagated immediately as per the current propagation rules.
 *
 * If the value is 'Lazy' means the policy changes will not take effect for now
 * but defer to the resource template changes, in other words, the resource
 * template will not be propagated as per the current propagation rules until
 * there is an update on it.
 * This is an experimental feature that might help in a scenario where a policy
 * manages huge amount of resource templates, changes to a policy typically
 * affect numerous applications simultaneously. A minor misconfiguration
 * could lead to widespread failures. With this feature, the change can be
 * gradually rolled out through iterative modifications of resource templates.
 *
 * @schema PropagationPolicySpecActivationPreference
 */
export enum PropagationPolicySpecActivationPreference {
  /** Lazy */
  LAZY = "Lazy",
}

/**
 * ConflictResolution declares how potential conflict should be handled when
 * a resource that is being propagated already exists in the target cluster.
 *
 * It defaults to "Abort" which means stop propagating to avoid unexpected
 * overwrites. The "Overwrite" might be useful when migrating legacy cluster
 * resources to Karmada, in which case conflict is predictable and can be
 * instructed to Karmada take over the resource by overwriting.
 *
 * @schema PropagationPolicySpecConflictResolution
 */
export enum PropagationPolicySpecConflictResolution {
  /** Abort */
  ABORT = "Abort",
  /** Overwrite */
  OVERWRITE = "Overwrite",
}

/**
 * Failover indicates how Karmada migrates applications in case of failures.
 * If this value is nil, failover is disabled.
 *
 * @schema PropagationPolicySpecFailover
 */
export interface PropagationPolicySpecFailover {
  /**
   * Application indicates failover behaviors in case of application failure.
   * If this value is nil, failover is disabled.
   * If set, the PropagateDeps should be true so that the dependencies could
   * be migrated along with the application.
   *
   * @schema PropagationPolicySpecFailover#application
   */
  readonly application?: PropagationPolicySpecFailoverApplication;

  /**
   * Cluster indicates failover behaviors in case of cluster failure.
   * If this value is nil, the failover behavior in case of cluster failure
   * will be controlled by the controller's no-execute-taint-eviction-purge-mode
   * parameter.
   * If set, the failover behavior in case of cluster failure will be defined
   * by this value.
   *
   * @schema PropagationPolicySpecFailover#cluster
   */
  readonly cluster?: PropagationPolicySpecFailoverCluster;
}

/**
 * Converts an object of type 'PropagationPolicySpecFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecFailover(obj: PropagationPolicySpecFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'application': toJson_PropagationPolicySpecFailoverApplication(obj.application),
    'cluster': toJson_PropagationPolicySpecFailoverCluster(obj.cluster),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Placement represents the rule for select clusters to propagate resources.
 *
 * @schema PropagationPolicySpecPlacement
 */
export interface PropagationPolicySpecPlacement {
  /**
   * ClusterAffinities represents scheduling restrictions to multiple cluster
   * groups that indicated by ClusterAffinityTerm.
   *
   * The scheduler will evaluate these groups one by one in the order they
   * appear in the spec, the group that does not satisfy scheduling restrictions
   * will be ignored which means all clusters in this group will not be selected
   * unless it also belongs to the next group(a cluster could belong to multiple
   * groups).
   *
   * If none of the groups satisfy the scheduling restrictions, then scheduling
   * fails, which means no cluster will be selected.
   *
   * Note:
   * 1. ClusterAffinities can not co-exist with ClusterAffinity.
   * 2. If both ClusterAffinity and ClusterAffinities are not set, any cluster
   * can be scheduling candidates.
   *
   * Potential use case 1:
   * The private clusters in the local data center could be the main group, and
   * the managed clusters provided by cluster providers could be the secondary
   * group. So that the Karmada scheduler would prefer to schedule workloads
   * to the main group and the second group will only be considered in case of
   * the main group does not satisfy restrictions(like, lack of resources).
   *
   * Potential use case 2:
   * For the disaster recovery scenario, the clusters could be organized to
   * primary and backup groups, the workloads would be scheduled to primary
   * clusters firstly, and when primary cluster fails(like data center power off),
   * Karmada scheduler could migrate workloads to the backup clusters.
   *
   * @schema PropagationPolicySpecPlacement#clusterAffinities
   */
  readonly clusterAffinities?: PropagationPolicySpecPlacementClusterAffinities[];

  /**
   * ClusterAffinity represents scheduling restrictions to a certain set of clusters.
   * Note:
   * 1. ClusterAffinity can not co-exist with ClusterAffinities.
   * 2. If both ClusterAffinity and ClusterAffinities are not set, any cluster
   * can be scheduling candidates.
   *
   * @schema PropagationPolicySpecPlacement#clusterAffinity
   */
  readonly clusterAffinity?: PropagationPolicySpecPlacementClusterAffinity;

  /**
   * ClusterTolerations represents the tolerations.
   *
   * @schema PropagationPolicySpecPlacement#clusterTolerations
   */
  readonly clusterTolerations?: PropagationPolicySpecPlacementClusterTolerations[];

  /**
   * ReplicaScheduling represents the scheduling policy on dealing with the number of replicas
   * when propagating resources that have replicas in spec (e.g. deployments, statefulsets) to member clusters.
   *
   * @schema PropagationPolicySpecPlacement#replicaScheduling
   */
  readonly replicaScheduling?: PropagationPolicySpecPlacementReplicaScheduling;

  /**
   * SpreadConstraints represents a list of the scheduling constraints.
   *
   * @schema PropagationPolicySpecPlacement#spreadConstraints
   */
  readonly spreadConstraints?: PropagationPolicySpecPlacementSpreadConstraints[];
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacement' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacement(obj: PropagationPolicySpecPlacement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterAffinities': obj.clusterAffinities?.map(y => toJson_PropagationPolicySpecPlacementClusterAffinities(y)),
    'clusterAffinity': toJson_PropagationPolicySpecPlacementClusterAffinity(obj.clusterAffinity),
    'clusterTolerations': obj.clusterTolerations?.map(y => toJson_PropagationPolicySpecPlacementClusterTolerations(y)),
    'replicaScheduling': toJson_PropagationPolicySpecPlacementReplicaScheduling(obj.replicaScheduling),
    'spreadConstraints': obj.spreadConstraints?.map(y => toJson_PropagationPolicySpecPlacementSpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Preemption declares the behaviors for preempting.
 * Valid options are "Always" and "Never".
 *
 * @schema PropagationPolicySpecPreemption
 */
export enum PropagationPolicySpecPreemption {
  /** Always */
  ALWAYS = "Always",
  /** Never */
  NEVER = "Never",
}

/**
 * ResourceSelector the resources will be selected.
 *
 * @schema PropagationPolicySpecResourceSelectors
 */
export interface PropagationPolicySpecResourceSelectors {
  /**
   * APIVersion represents the API version of the target resources.
   *
   * @schema PropagationPolicySpecResourceSelectors#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind represents the Kind of the target resources.
   *
   * @schema PropagationPolicySpecResourceSelectors#kind
   */
  readonly kind: string;

  /**
   * A label query over a set of resources.
   * If name is not empty, labelSelector will be ignored.
   *
   * @schema PropagationPolicySpecResourceSelectors#labelSelector
   */
  readonly labelSelector?: PropagationPolicySpecResourceSelectorsLabelSelector;

  /**
   * Name of the target resource.
   * Default is empty, which means selecting all resources.
   *
   * @default empty, which means selecting all resources.
   * @schema PropagationPolicySpecResourceSelectors#name
   */
  readonly name?: string;

  /**
   * Namespace of the target resource.
   * Default is empty, which means inherit from the parent object scope.
   *
   * @default empty, which means inherit from the parent object scope.
   * @schema PropagationPolicySpecResourceSelectors#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'PropagationPolicySpecResourceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecResourceSelectors(obj: PropagationPolicySpecResourceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'labelSelector': toJson_PropagationPolicySpecResourceSelectorsLabelSelector(obj.labelSelector),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SchedulePriority defines how Karmada should resolve the priority and preemption policy
 * for workload scheduling.
 *
 * This setting is useful for controlling the scheduling behavior of offline workloads.
 * By setting a higher or lower priority, users can control which workloads are scheduled first.
 * Additionally, it allows specifying a preemption policy where higher-priority workloads can
 * preempt lower-priority ones in scenarios of resource contention.
 *
 * Note: This feature is currently in the alpha stage. The priority-based scheduling functionality is
 * controlled by the PriorityBasedScheduling feature gate, and preemption is controlled by the
 * PriorityBasedPreemptiveScheduling feature gate. Currently, only priority-based scheduling is
 * supported. Preemption functionality is not yet available and will be introduced in future
 * releases as the feature matures.
 *
 * @schema PropagationPolicySpecSchedulePriority
 */
export interface PropagationPolicySpecSchedulePriority {
  /**
   * PriorityClassName specifies which PriorityClass to use. Its behavior depends on PriorityClassSource:
   *
   * Behavior of PriorityClassName:
   *
   * For KubePriorityClass:
   * - When specified: Uses the named Kubernetes PriorityClass.
   *
   * For PodPriorityClass:
   * - Uses PriorityClassName from the PodTemplate.
   * - Not yet implemented.
   *
   * For FederatedPriorityClass:
   * - Not yet implemented.
   *
   * @schema PropagationPolicySpecSchedulePriority#priorityClassName
   */
  readonly priorityClassName: string;

  /**
   * PriorityClassSource specifies where Karmada should look for the PriorityClass definition.
   * Available options:
   * - KubePriorityClass: Uses Kubernetes PriorityClass (scheduling.k8s.io/v1)
   * - PodPriorityClass: Uses PriorityClassName from PodTemplate: PodSpec.PriorityClassName (not yet implemented)
   * - FederatedPriorityClass: Uses Karmada FederatedPriorityClass (not yet implemented)
   *
   * @schema PropagationPolicySpecSchedulePriority#priorityClassSource
   */
  readonly priorityClassSource: PropagationPolicySpecSchedulePriorityPriorityClassSource;
}

/**
 * Converts an object of type 'PropagationPolicySpecSchedulePriority' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecSchedulePriority(obj: PropagationPolicySpecSchedulePriority | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'priorityClassName': obj.priorityClassName,
    'priorityClassSource': obj.priorityClassSource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Suspension declares the policy for suspending different aspects of propagation.
 * nil means no suspension. no default values.
 *
 * @schema PropagationPolicySpecSuspension
 */
export interface PropagationPolicySpecSuspension {
  /**
   * Dispatching controls whether dispatching should be suspended.
   * nil means not suspend, no default value, only accepts 'true'.
   * Note: true means stop propagating to all clusters. Can not co-exist
   * with DispatchingOnClusters which is used to suspend particular clusters.
   *
   * @schema PropagationPolicySpecSuspension#dispatching
   */
  readonly dispatching?: boolean;

  /**
   * DispatchingOnClusters declares a list of clusters to which the dispatching
   * should be suspended.
   * Note: Can not co-exist with Dispatching which is used to suspend all.
   *
   * @schema PropagationPolicySpecSuspension#dispatchingOnClusters
   */
  readonly dispatchingOnClusters?: PropagationPolicySpecSuspensionDispatchingOnClusters;
}

/**
 * Converts an object of type 'PropagationPolicySpecSuspension' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecSuspension(obj: PropagationPolicySpecSuspension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dispatching': obj.dispatching,
    'dispatchingOnClusters': toJson_PropagationPolicySpecSuspensionDispatchingOnClusters(obj.dispatchingOnClusters),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Application indicates failover behaviors in case of application failure.
 * If this value is nil, failover is disabled.
 * If set, the PropagateDeps should be true so that the dependencies could
 * be migrated along with the application.
 *
 * @schema PropagationPolicySpecFailoverApplication
 */
export interface PropagationPolicySpecFailoverApplication {
  /**
   * DecisionConditions indicates the decision conditions of performing the failover process.
   * Only when all conditions are met can the failover process be performed.
   * Currently, DecisionConditions includes several conditions:
   * - TolerationSeconds (optional)
   *
   * @schema PropagationPolicySpecFailoverApplication#decisionConditions
   */
  readonly decisionConditions: PropagationPolicySpecFailoverApplicationDecisionConditions;

  /**
   * GracePeriodSeconds is the maximum waiting duration in seconds before
   * application on the migrated cluster should be deleted.
   * Required only when PurgeMode is "Graciously" and defaults to 600s.
   * If the application on the new cluster cannot reach a Healthy state,
   * Karmada will delete the application after GracePeriodSeconds is reached.
   * Value must be positive integer.
   *
   * @schema PropagationPolicySpecFailoverApplication#gracePeriodSeconds
   */
  readonly gracePeriodSeconds?: number;

  /**
   * PurgeMode represents how to deal with the legacy applications on the
   * cluster from which the application is migrated.
   * Valid options are "Directly", "Gracefully", "Never", "Immediately"(deprecated),
   * and "Graciously"(deprecated).
   * Defaults to "Gracefully".
   *
   * @default Gracefully".
   * @schema PropagationPolicySpecFailoverApplication#purgeMode
   */
  readonly purgeMode?: PropagationPolicySpecFailoverApplicationPurgeMode;

  /**
   * StatePreservation defines the policy for preserving and restoring state data
   * during failover events for stateful applications.
   *
   * When an application fails over from one cluster to another, this policy enables
   * the extraction of critical data from the original resource configuration.
   * Upon successful migration, the extracted data is then re-injected into the new
   * resource, ensuring that the application can resume operation with its previous
   * state intact.
   * This is particularly useful for stateful applications where maintaining data
   * consistency across failover events is crucial.
   * If not specified, means no state data will be preserved.
   *
   * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
   * which is alpha.
   *
   * @schema PropagationPolicySpecFailoverApplication#statePreservation
   */
  readonly statePreservation?: PropagationPolicySpecFailoverApplicationStatePreservation;
}

/**
 * Converts an object of type 'PropagationPolicySpecFailoverApplication' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecFailoverApplication(obj: PropagationPolicySpecFailoverApplication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'decisionConditions': toJson_PropagationPolicySpecFailoverApplicationDecisionConditions(obj.decisionConditions),
    'gracePeriodSeconds': obj.gracePeriodSeconds,
    'purgeMode': obj.purgeMode,
    'statePreservation': toJson_PropagationPolicySpecFailoverApplicationStatePreservation(obj.statePreservation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cluster indicates failover behaviors in case of cluster failure.
 * If this value is nil, the failover behavior in case of cluster failure
 * will be controlled by the controller's no-execute-taint-eviction-purge-mode
 * parameter.
 * If set, the failover behavior in case of cluster failure will be defined
 * by this value.
 *
 * @schema PropagationPolicySpecFailoverCluster
 */
export interface PropagationPolicySpecFailoverCluster {
  /**
   * PurgeMode represents how to deal with the legacy applications on the
   * cluster from which the application is migrated.
   * Valid options are "Directly", "Gracefully".
   * Defaults to "Gracefully".
   *
   * @default Gracefully".
   * @schema PropagationPolicySpecFailoverCluster#purgeMode
   */
  readonly purgeMode?: PropagationPolicySpecFailoverClusterPurgeMode;

  /**
   * StatePreservation defines the policy for preserving and restoring state data
   * during failover events for stateful applications.
   *
   * When an application fails over from one cluster to another, this policy enables
   * the extraction of critical data from the original resource configuration.
   * Upon successful migration, the extracted data is then re-injected into the new
   * resource, ensuring that the application can resume operation with its previous
   * state intact.
   * This is particularly useful for stateful applications where maintaining data
   * consistency across failover events is crucial.
   * If not specified, means no state data will be preserved.
   *
   * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
   * which is alpha.
   *
   * @schema PropagationPolicySpecFailoverCluster#statePreservation
   */
  readonly statePreservation?: PropagationPolicySpecFailoverClusterStatePreservation;
}

/**
 * Converts an object of type 'PropagationPolicySpecFailoverCluster' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecFailoverCluster(obj: PropagationPolicySpecFailoverCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'purgeMode': obj.purgeMode,
    'statePreservation': toJson_PropagationPolicySpecFailoverClusterStatePreservation(obj.statePreservation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterAffinityTerm selects a set of cluster.
 *
 * @schema PropagationPolicySpecPlacementClusterAffinities
 */
export interface PropagationPolicySpecPlacementClusterAffinities {
  /**
   * AffinityName is the name of the cluster group.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinities#affinityName
   */
  readonly affinityName: string;

  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinities#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinities#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinities#fieldSelector
   */
  readonly fieldSelector?: PropagationPolicySpecPlacementClusterAffinitiesFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinities#labelSelector
   */
  readonly labelSelector?: PropagationPolicySpecPlacementClusterAffinitiesLabelSelector;
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementClusterAffinities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementClusterAffinities(obj: PropagationPolicySpecPlacementClusterAffinities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinityName': obj.affinityName,
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_PropagationPolicySpecPlacementClusterAffinitiesFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_PropagationPolicySpecPlacementClusterAffinitiesLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterAffinity represents scheduling restrictions to a certain set of clusters.
 * Note:
 * 1. ClusterAffinity can not co-exist with ClusterAffinities.
 * 2. If both ClusterAffinity and ClusterAffinities are not set, any cluster
 * can be scheduling candidates.
 *
 * @schema PropagationPolicySpecPlacementClusterAffinity
 */
export interface PropagationPolicySpecPlacementClusterAffinity {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinity#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinity#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinity#fieldSelector
   */
  readonly fieldSelector?: PropagationPolicySpecPlacementClusterAffinityFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinity#labelSelector
   */
  readonly labelSelector?: PropagationPolicySpecPlacementClusterAffinityLabelSelector;
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementClusterAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementClusterAffinity(obj: PropagationPolicySpecPlacementClusterAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_PropagationPolicySpecPlacementClusterAffinityFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_PropagationPolicySpecPlacementClusterAffinityLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema PropagationPolicySpecPlacementClusterTolerations
 */
export interface PropagationPolicySpecPlacementClusterTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema PropagationPolicySpecPlacementClusterTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema PropagationPolicySpecPlacementClusterTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema PropagationPolicySpecPlacementClusterTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema PropagationPolicySpecPlacementClusterTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema PropagationPolicySpecPlacementClusterTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementClusterTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementClusterTolerations(obj: PropagationPolicySpecPlacementClusterTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReplicaScheduling represents the scheduling policy on dealing with the number of replicas
 * when propagating resources that have replicas in spec (e.g. deployments, statefulsets) to member clusters.
 *
 * @schema PropagationPolicySpecPlacementReplicaScheduling
 */
export interface PropagationPolicySpecPlacementReplicaScheduling {
  /**
   * ReplicaDivisionPreference determines how the replicas is divided
   * when ReplicaSchedulingType is "Divided". Valid options are Aggregated and Weighted.
   * "Aggregated" divides replicas into clusters as few as possible,
   * while respecting clusters' resource availabilities during the division.
   * "Weighted" divides replicas by weight according to WeightPreference.
   *
   * @schema PropagationPolicySpecPlacementReplicaScheduling#replicaDivisionPreference
   */
  readonly replicaDivisionPreference?: PropagationPolicySpecPlacementReplicaSchedulingReplicaDivisionPreference;

  /**
   * ReplicaSchedulingType determines how the replicas is scheduled when karmada propagating
   * a resource. Valid options are Duplicated and Divided.
   * "Duplicated" duplicates the same replicas to each candidate member cluster from resource.
   * "Divided" divides replicas into parts according to number of valid candidate member
   * clusters, and exact replicas for each cluster are determined by ReplicaDivisionPreference.
   *
   * @schema PropagationPolicySpecPlacementReplicaScheduling#replicaSchedulingType
   */
  readonly replicaSchedulingType?: PropagationPolicySpecPlacementReplicaSchedulingReplicaSchedulingType;

  /**
   * WeightPreference describes weight for each cluster or for each group of cluster
   * If ReplicaDivisionPreference is set to "Weighted", and WeightPreference is not set, scheduler will weight all clusters the same.
   *
   * @schema PropagationPolicySpecPlacementReplicaScheduling#weightPreference
   */
  readonly weightPreference?: PropagationPolicySpecPlacementReplicaSchedulingWeightPreference;
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementReplicaScheduling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementReplicaScheduling(obj: PropagationPolicySpecPlacementReplicaScheduling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replicaDivisionPreference': obj.replicaDivisionPreference,
    'replicaSchedulingType': obj.replicaSchedulingType,
    'weightPreference': toJson_PropagationPolicySpecPlacementReplicaSchedulingWeightPreference(obj.weightPreference),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SpreadConstraint represents the spread constraints on resources.
 *
 * @schema PropagationPolicySpecPlacementSpreadConstraints
 */
export interface PropagationPolicySpecPlacementSpreadConstraints {
  /**
   * MaxGroups restricts the maximum number of cluster groups to be selected.
   *
   * @schema PropagationPolicySpecPlacementSpreadConstraints#maxGroups
   */
  readonly maxGroups?: number;

  /**
   * MinGroups restricts the minimum number of cluster groups to be selected.
   * Defaults to 1.
   *
   * @default 1.
   * @schema PropagationPolicySpecPlacementSpreadConstraints#minGroups
   */
  readonly minGroups?: number;

  /**
   * SpreadByField represents the fields on Karmada cluster API used for
   * dynamically grouping member clusters into different groups.
   * Resources will be spread among different cluster groups.
   * Available fields for spreading are: cluster, region, zone, and provider.
   * SpreadByField should not co-exist with SpreadByLabel.
   * If both SpreadByField and SpreadByLabel are empty, SpreadByField will be set to "cluster" by system.
   *
   * @schema PropagationPolicySpecPlacementSpreadConstraints#spreadByField
   */
  readonly spreadByField?: PropagationPolicySpecPlacementSpreadConstraintsSpreadByField;

  /**
   * SpreadByLabel represents the label key used for
   * grouping member clusters into different groups.
   * Resources will be spread among different cluster groups.
   * SpreadByLabel should not co-exist with SpreadByField.
   *
   * @schema PropagationPolicySpecPlacementSpreadConstraints#spreadByLabel
   */
  readonly spreadByLabel?: string;
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementSpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementSpreadConstraints(obj: PropagationPolicySpecPlacementSpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxGroups': obj.maxGroups,
    'minGroups': obj.minGroups,
    'spreadByField': obj.spreadByField,
    'spreadByLabel': obj.spreadByLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources.
 * If name is not empty, labelSelector will be ignored.
 *
 * @schema PropagationPolicySpecResourceSelectorsLabelSelector
 */
export interface PropagationPolicySpecResourceSelectorsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PropagationPolicySpecResourceSelectorsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PropagationPolicySpecResourceSelectorsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PropagationPolicySpecResourceSelectorsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecResourceSelectorsLabelSelector(obj: PropagationPolicySpecResourceSelectorsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PriorityClassSource specifies where Karmada should look for the PriorityClass definition.
 * Available options:
 * - KubePriorityClass: Uses Kubernetes PriorityClass (scheduling.k8s.io/v1)
 * - PodPriorityClass: Uses PriorityClassName from PodTemplate: PodSpec.PriorityClassName (not yet implemented)
 * - FederatedPriorityClass: Uses Karmada FederatedPriorityClass (not yet implemented)
 *
 * @schema PropagationPolicySpecSchedulePriorityPriorityClassSource
 */
export enum PropagationPolicySpecSchedulePriorityPriorityClassSource {
  /** KubePriorityClass */
  KUBE_PRIORITY_CLASS = "KubePriorityClass",
}

/**
 * DispatchingOnClusters declares a list of clusters to which the dispatching
 * should be suspended.
 * Note: Can not co-exist with Dispatching which is used to suspend all.
 *
 * @schema PropagationPolicySpecSuspensionDispatchingOnClusters
 */
export interface PropagationPolicySpecSuspensionDispatchingOnClusters {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema PropagationPolicySpecSuspensionDispatchingOnClusters#clusterNames
   */
  readonly clusterNames?: string[];
}

/**
 * Converts an object of type 'PropagationPolicySpecSuspensionDispatchingOnClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecSuspensionDispatchingOnClusters(obj: PropagationPolicySpecSuspensionDispatchingOnClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DecisionConditions indicates the decision conditions of performing the failover process.
 * Only when all conditions are met can the failover process be performed.
 * Currently, DecisionConditions includes several conditions:
 * - TolerationSeconds (optional)
 *
 * @schema PropagationPolicySpecFailoverApplicationDecisionConditions
 */
export interface PropagationPolicySpecFailoverApplicationDecisionConditions {
  /**
   * TolerationSeconds represents the period of time Karmada should wait
   * after reaching the desired state before performing failover process.
   * If not specified, Karmada will immediately perform failover process.
   * Defaults to 300s.
   *
   * @default 300s.
   * @schema PropagationPolicySpecFailoverApplicationDecisionConditions#tolerationSeconds
   */
  readonly tolerationSeconds?: number;
}

/**
 * Converts an object of type 'PropagationPolicySpecFailoverApplicationDecisionConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecFailoverApplicationDecisionConditions(obj: PropagationPolicySpecFailoverApplicationDecisionConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tolerationSeconds': obj.tolerationSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PurgeMode represents how to deal with the legacy applications on the
 * cluster from which the application is migrated.
 * Valid options are "Directly", "Gracefully", "Never", "Immediately"(deprecated),
 * and "Graciously"(deprecated).
 * Defaults to "Gracefully".
 *
 * @default Gracefully".
 * @schema PropagationPolicySpecFailoverApplicationPurgeMode
 */
export enum PropagationPolicySpecFailoverApplicationPurgeMode {
  /** Directly */
  DIRECTLY = "Directly",
  /** Gracefully */
  GRACEFULLY = "Gracefully",
  /** Never */
  NEVER = "Never",
  /** Immediately */
  IMMEDIATELY = "Immediately",
  /** Graciously */
  GRACIOUSLY = "Graciously",
}

/**
 * StatePreservation defines the policy for preserving and restoring state data
 * during failover events for stateful applications.
 *
 * When an application fails over from one cluster to another, this policy enables
 * the extraction of critical data from the original resource configuration.
 * Upon successful migration, the extracted data is then re-injected into the new
 * resource, ensuring that the application can resume operation with its previous
 * state intact.
 * This is particularly useful for stateful applications where maintaining data
 * consistency across failover events is crucial.
 * If not specified, means no state data will be preserved.
 *
 * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
 * which is alpha.
 *
 * @schema PropagationPolicySpecFailoverApplicationStatePreservation
 */
export interface PropagationPolicySpecFailoverApplicationStatePreservation {
  /**
   * Rules contains a list of StatePreservationRule configurations.
   * Each rule specifies a JSONPath expression targeting specific pieces of
   * state data to be preserved during failover events. An AliasLabelName is associated
   * with each rule, serving as a label key when the preserved data is passed
   * to the new cluster.
   *
   * @schema PropagationPolicySpecFailoverApplicationStatePreservation#rules
   */
  readonly rules: PropagationPolicySpecFailoverApplicationStatePreservationRules[];
}

/**
 * Converts an object of type 'PropagationPolicySpecFailoverApplicationStatePreservation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecFailoverApplicationStatePreservation(obj: PropagationPolicySpecFailoverApplicationStatePreservation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_PropagationPolicySpecFailoverApplicationStatePreservationRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PurgeMode represents how to deal with the legacy applications on the
 * cluster from which the application is migrated.
 * Valid options are "Directly", "Gracefully".
 * Defaults to "Gracefully".
 *
 * @default Gracefully".
 * @schema PropagationPolicySpecFailoverClusterPurgeMode
 */
export enum PropagationPolicySpecFailoverClusterPurgeMode {
  /** Directly */
  DIRECTLY = "Directly",
  /** Gracefully */
  GRACEFULLY = "Gracefully",
}

/**
 * StatePreservation defines the policy for preserving and restoring state data
 * during failover events for stateful applications.
 *
 * When an application fails over from one cluster to another, this policy enables
 * the extraction of critical data from the original resource configuration.
 * Upon successful migration, the extracted data is then re-injected into the new
 * resource, ensuring that the application can resume operation with its previous
 * state intact.
 * This is particularly useful for stateful applications where maintaining data
 * consistency across failover events is crucial.
 * If not specified, means no state data will be preserved.
 *
 * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
 * which is alpha.
 *
 * @schema PropagationPolicySpecFailoverClusterStatePreservation
 */
export interface PropagationPolicySpecFailoverClusterStatePreservation {
  /**
   * Rules contains a list of StatePreservationRule configurations.
   * Each rule specifies a JSONPath expression targeting specific pieces of
   * state data to be preserved during failover events. An AliasLabelName is associated
   * with each rule, serving as a label key when the preserved data is passed
   * to the new cluster.
   *
   * @schema PropagationPolicySpecFailoverClusterStatePreservation#rules
   */
  readonly rules: PropagationPolicySpecFailoverClusterStatePreservationRules[];
}

/**
 * Converts an object of type 'PropagationPolicySpecFailoverClusterStatePreservation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecFailoverClusterStatePreservation(obj: PropagationPolicySpecFailoverClusterStatePreservation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_PropagationPolicySpecFailoverClusterStatePreservationRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema PropagationPolicySpecPlacementClusterAffinitiesFieldSelector
 */
export interface PropagationPolicySpecPlacementClusterAffinitiesFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinitiesFieldSelector#matchExpressions
   */
  readonly matchExpressions?: PropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementClusterAffinitiesFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementClusterAffinitiesFieldSelector(obj: PropagationPolicySpecPlacementClusterAffinitiesFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema PropagationPolicySpecPlacementClusterAffinitiesLabelSelector
 */
export interface PropagationPolicySpecPlacementClusterAffinitiesLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinitiesLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinitiesLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementClusterAffinitiesLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementClusterAffinitiesLabelSelector(obj: PropagationPolicySpecPlacementClusterAffinitiesLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema PropagationPolicySpecPlacementClusterAffinityFieldSelector
 */
export interface PropagationPolicySpecPlacementClusterAffinityFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinityFieldSelector#matchExpressions
   */
  readonly matchExpressions?: PropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementClusterAffinityFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementClusterAffinityFieldSelector(obj: PropagationPolicySpecPlacementClusterAffinityFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema PropagationPolicySpecPlacementClusterAffinityLabelSelector
 */
export interface PropagationPolicySpecPlacementClusterAffinityLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinityLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinityLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementClusterAffinityLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementClusterAffinityLabelSelector(obj: PropagationPolicySpecPlacementClusterAffinityLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReplicaDivisionPreference determines how the replicas is divided
 * when ReplicaSchedulingType is "Divided". Valid options are Aggregated and Weighted.
 * "Aggregated" divides replicas into clusters as few as possible,
 * while respecting clusters' resource availabilities during the division.
 * "Weighted" divides replicas by weight according to WeightPreference.
 *
 * @schema PropagationPolicySpecPlacementReplicaSchedulingReplicaDivisionPreference
 */
export enum PropagationPolicySpecPlacementReplicaSchedulingReplicaDivisionPreference {
  /** Aggregated */
  AGGREGATED = "Aggregated",
  /** Weighted */
  WEIGHTED = "Weighted",
}

/**
 * ReplicaSchedulingType determines how the replicas is scheduled when karmada propagating
 * a resource. Valid options are Duplicated and Divided.
 * "Duplicated" duplicates the same replicas to each candidate member cluster from resource.
 * "Divided" divides replicas into parts according to number of valid candidate member
 * clusters, and exact replicas for each cluster are determined by ReplicaDivisionPreference.
 *
 * @schema PropagationPolicySpecPlacementReplicaSchedulingReplicaSchedulingType
 */
export enum PropagationPolicySpecPlacementReplicaSchedulingReplicaSchedulingType {
  /** Duplicated */
  DUPLICATED = "Duplicated",
  /** Divided */
  DIVIDED = "Divided",
}

/**
 * WeightPreference describes weight for each cluster or for each group of cluster
 * If ReplicaDivisionPreference is set to "Weighted", and WeightPreference is not set, scheduler will weight all clusters the same.
 *
 * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreference
 */
export interface PropagationPolicySpecPlacementReplicaSchedulingWeightPreference {
  /**
   * DynamicWeight specifies the factor to generates dynamic weight list.
   * If specified, StaticWeightList will be ignored.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreference#dynamicWeight
   */
  readonly dynamicWeight?: PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceDynamicWeight;

  /**
   * StaticWeightList defines the static cluster weight.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreference#staticWeightList
   */
  readonly staticWeightList?: PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList[];
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementReplicaSchedulingWeightPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementReplicaSchedulingWeightPreference(obj: PropagationPolicySpecPlacementReplicaSchedulingWeightPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dynamicWeight': obj.dynamicWeight,
    'staticWeightList': obj.staticWeightList?.map(y => toJson_PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SpreadByField represents the fields on Karmada cluster API used for
 * dynamically grouping member clusters into different groups.
 * Resources will be spread among different cluster groups.
 * Available fields for spreading are: cluster, region, zone, and provider.
 * SpreadByField should not co-exist with SpreadByLabel.
 * If both SpreadByField and SpreadByLabel are empty, SpreadByField will be set to "cluster" by system.
 *
 * @schema PropagationPolicySpecPlacementSpreadConstraintsSpreadByField
 */
export enum PropagationPolicySpecPlacementSpreadConstraintsSpreadByField {
  /** cluster */
  CLUSTER = "cluster",
  /** region */
  REGION = "region",
  /** zone */
  ZONE = "zone",
  /** provider */
  PROVIDER = "provider",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions
 */
export interface PropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions(obj: PropagationPolicySpecResourceSelectorsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StatePreservationRule defines a single rule for state preservation.
 * It includes a JSONPath expression and an alias name that will be used
 * as a label key when passing state information to the new cluster.
 *
 * @schema PropagationPolicySpecFailoverApplicationStatePreservationRules
 */
export interface PropagationPolicySpecFailoverApplicationStatePreservationRules {
  /**
   * AliasLabelName is the name that will be used as a label key when the preserved
   * data is passed to the new cluster. This facilitates the injection of the
   * preserved state back into the application resources during recovery.
   *
   * @schema PropagationPolicySpecFailoverApplicationStatePreservationRules#aliasLabelName
   */
  readonly aliasLabelName: string;

  /**
   * JSONPath is the JSONPath template used to identify the state data
   * to be preserved from the original resource configuration.
   * The JSONPath syntax follows the Kubernetes specification:
   * https://kubernetes.io/docs/reference/kubectl/jsonpath/
   *
   * Note: The JSONPath expression will start searching from the "status" field of
   * the API resource object by default. For example, to extract the "availableReplicas"
   * from a Deployment, the JSONPath expression should be "{.availableReplicas}", not
   * "{.status.availableReplicas}".
   *
   * @schema PropagationPolicySpecFailoverApplicationStatePreservationRules#jsonPath
   */
  readonly jsonPath: string;
}

/**
 * Converts an object of type 'PropagationPolicySpecFailoverApplicationStatePreservationRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecFailoverApplicationStatePreservationRules(obj: PropagationPolicySpecFailoverApplicationStatePreservationRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aliasLabelName': obj.aliasLabelName,
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StatePreservationRule defines a single rule for state preservation.
 * It includes a JSONPath expression and an alias name that will be used
 * as a label key when passing state information to the new cluster.
 *
 * @schema PropagationPolicySpecFailoverClusterStatePreservationRules
 */
export interface PropagationPolicySpecFailoverClusterStatePreservationRules {
  /**
   * AliasLabelName is the name that will be used as a label key when the preserved
   * data is passed to the new cluster. This facilitates the injection of the
   * preserved state back into the application resources during recovery.
   *
   * @schema PropagationPolicySpecFailoverClusterStatePreservationRules#aliasLabelName
   */
  readonly aliasLabelName: string;

  /**
   * JSONPath is the JSONPath template used to identify the state data
   * to be preserved from the original resource configuration.
   * The JSONPath syntax follows the Kubernetes specification:
   * https://kubernetes.io/docs/reference/kubectl/jsonpath/
   *
   * Note: The JSONPath expression will start searching from the "status" field of
   * the API resource object by default. For example, to extract the "availableReplicas"
   * from a Deployment, the JSONPath expression should be "{.availableReplicas}", not
   * "{.status.availableReplicas}".
   *
   * @schema PropagationPolicySpecFailoverClusterStatePreservationRules#jsonPath
   */
  readonly jsonPath: string;
}

/**
 * Converts an object of type 'PropagationPolicySpecFailoverClusterStatePreservationRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecFailoverClusterStatePreservationRules(obj: PropagationPolicySpecFailoverClusterStatePreservationRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aliasLabelName': obj.aliasLabelName,
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema PropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions
 */
export interface PropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions(obj: PropagationPolicySpecPlacementClusterAffinitiesFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions
 */
export interface PropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions(obj: PropagationPolicySpecPlacementClusterAffinitiesLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema PropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions
 */
export interface PropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions(obj: PropagationPolicySpecPlacementClusterAffinityFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions
 */
export interface PropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions(obj: PropagationPolicySpecPlacementClusterAffinityLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DynamicWeight specifies the factor to generates dynamic weight list.
 * If specified, StaticWeightList will be ignored.
 *
 * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceDynamicWeight
 */
export enum PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceDynamicWeight {
  /** AvailableReplicas */
  AVAILABLE_REPLICAS = "AvailableReplicas",
}

/**
 * StaticClusterWeight defines the static cluster weight.
 *
 * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList
 */
export interface PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList {
  /**
   * TargetCluster describes the filter to select clusters.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList#targetCluster
   */
  readonly targetCluster: PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster;

  /**
   * Weight expressing the preference to the cluster(s) specified by 'TargetCluster'.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList(obj: PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetCluster': toJson_PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster(obj.targetCluster),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetCluster describes the filter to select clusters.
 *
 * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster
 */
export interface PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#fieldSelector
   */
  readonly fieldSelector?: PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#labelSelector
   */
  readonly labelSelector?: PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector;
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster(obj: PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector
 */
export interface PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector#matchExpressions
   */
  readonly matchExpressions?: PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector(obj: PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector
 */
export interface PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector(obj: PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions
 */
export interface PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions(obj: PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions
 */
export interface PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions(obj: PropagationPolicySpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

