// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ManagedZone is the Schema for the ManagedZones API. A zone is a subtree of the DNS namespace under one administrative responsibility.
 *
 * @schema ManagedZone
 */
export class ManagedZone extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ManagedZone"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dns.gcp.upbound.io/v1beta1',
    kind: 'ManagedZone',
  }

  /**
   * Renders a Kubernetes manifest for "ManagedZone".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ManagedZoneProps): any {
    return {
      ...ManagedZone.GVK,
      ...toJson_ManagedZoneProps(props),
    };
  }

  /**
   * Defines a "ManagedZone" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ManagedZoneProps) {
    super(scope, id, {
      ...ManagedZone.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ManagedZone.GVK,
      ...toJson_ManagedZoneProps(resolved),
    };
  }
}

/**
 * ManagedZone is the Schema for the ManagedZones API. A zone is a subtree of the DNS namespace under one administrative responsibility.
 *
 * @schema ManagedZone
 */
export interface ManagedZoneProps {
  /**
   * @schema ManagedZone#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ManagedZoneSpec defines the desired state of ManagedZone
   *
   * @schema ManagedZone#spec
   */
  readonly spec: ManagedZoneSpec;
}

/**
 * Converts an object of type 'ManagedZoneProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneProps(obj: ManagedZoneProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ManagedZoneSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ManagedZoneSpec defines the desired state of ManagedZone
 *
 * @schema ManagedZoneSpec
 */
export interface ManagedZoneSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ManagedZoneSpec#deletionPolicy
   */
  readonly deletionPolicy?: ManagedZoneSpecDeletionPolicy;

  /**
   * @schema ManagedZoneSpec#forProvider
   */
  readonly forProvider: ManagedZoneSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ManagedZoneSpec#initProvider
   */
  readonly initProvider?: ManagedZoneSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ManagedZoneSpec#managementPolicies
   */
  readonly managementPolicies?: ManagedZoneSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ManagedZoneSpec#providerConfigRef
   */
  readonly providerConfigRef?: ManagedZoneSpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ManagedZoneSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ManagedZoneSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ManagedZoneSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpec(obj: ManagedZoneSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ManagedZoneSpecForProvider(obj.forProvider),
    'initProvider': toJson_ManagedZoneSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ManagedZoneSpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_ManagedZoneSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ManagedZoneSpecDeletionPolicy
 */
export enum ManagedZoneSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ManagedZoneSpecForProvider
 */
export interface ManagedZoneSpecForProvider {
  /**
   * Cloud logging configuration
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecForProvider#cloudLoggingConfig
   */
  readonly cloudLoggingConfig?: ManagedZoneSpecForProviderCloudLoggingConfig[];

  /**
   * A textual description field.
   *
   * @schema ManagedZoneSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The DNS name of this managed zone, for instance "example.com.".
   *
   * @schema ManagedZoneSpecForProvider#dnsName
   */
  readonly dnsName?: string;

  /**
   * DNSSEC configuration
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecForProvider#dnssecConfig
   */
  readonly dnssecConfig?: ManagedZoneSpecForProviderDnssecConfig[];

  /**
   * Set this true to delete all records in the zone.
   *
   * @schema ManagedZoneSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * The presence for this field indicates that outbound forwarding is enabled
   * for this zone. The value of this field contains the set of destinations
   * to forward to.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecForProvider#forwardingConfig
   */
  readonly forwardingConfig?: ManagedZoneSpecForProviderForwardingConfig[];

  /**
   * A set of key/value label pairs to assign to this ManagedZone.
   *
   * @schema ManagedZoneSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The presence of this field indicates that DNS Peering is enabled for this
   * zone. The value of this field contains the network to peer with.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecForProvider#peeringConfig
   */
  readonly peeringConfig?: ManagedZoneSpecForProviderPeeringConfig[];

  /**
   * For privately visible zones, the set of Virtual Private Cloud
   * resources that the zone is visible from. At least one of gke_clusters or networks must be specified.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecForProvider#privateVisibilityConfig
   */
  readonly privateVisibilityConfig?: ManagedZoneSpecForProviderPrivateVisibilityConfig[];

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema ManagedZoneSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The zone's visibility: public zones are exposed to the Internet,
   * while private zones are visible only to Virtual Private Cloud resources.
   * Default value is public.
   * Possible values are: private, public.
   *
   * @schema ManagedZoneSpecForProvider#visibility
   */
  readonly visibility?: string;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProvider(obj: ManagedZoneSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudLoggingConfig': obj.cloudLoggingConfig?.map(y => toJson_ManagedZoneSpecForProviderCloudLoggingConfig(y)),
    'description': obj.description,
    'dnsName': obj.dnsName,
    'dnssecConfig': obj.dnssecConfig?.map(y => toJson_ManagedZoneSpecForProviderDnssecConfig(y)),
    'forceDestroy': obj.forceDestroy,
    'forwardingConfig': obj.forwardingConfig?.map(y => toJson_ManagedZoneSpecForProviderForwardingConfig(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'peeringConfig': obj.peeringConfig?.map(y => toJson_ManagedZoneSpecForProviderPeeringConfig(y)),
    'privateVisibilityConfig': obj.privateVisibilityConfig?.map(y => toJson_ManagedZoneSpecForProviderPrivateVisibilityConfig(y)),
    'project': obj.project,
    'visibility': obj.visibility,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ManagedZoneSpecInitProvider
 */
export interface ManagedZoneSpecInitProvider {
  /**
   * Cloud logging configuration
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecInitProvider#cloudLoggingConfig
   */
  readonly cloudLoggingConfig?: ManagedZoneSpecInitProviderCloudLoggingConfig[];

  /**
   * A textual description field.
   *
   * @schema ManagedZoneSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The DNS name of this managed zone, for instance "example.com.".
   *
   * @schema ManagedZoneSpecInitProvider#dnsName
   */
  readonly dnsName?: string;

  /**
   * DNSSEC configuration
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecInitProvider#dnssecConfig
   */
  readonly dnssecConfig?: ManagedZoneSpecInitProviderDnssecConfig[];

  /**
   * Set this true to delete all records in the zone.
   *
   * @schema ManagedZoneSpecInitProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * The presence for this field indicates that outbound forwarding is enabled
   * for this zone. The value of this field contains the set of destinations
   * to forward to.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecInitProvider#forwardingConfig
   */
  readonly forwardingConfig?: ManagedZoneSpecInitProviderForwardingConfig[];

  /**
   * A set of key/value label pairs to assign to this ManagedZone.
   *
   * @schema ManagedZoneSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The presence of this field indicates that DNS Peering is enabled for this
   * zone. The value of this field contains the network to peer with.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecInitProvider#peeringConfig
   */
  readonly peeringConfig?: ManagedZoneSpecInitProviderPeeringConfig[];

  /**
   * For privately visible zones, the set of Virtual Private Cloud
   * resources that the zone is visible from. At least one of gke_clusters or networks must be specified.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecInitProvider#privateVisibilityConfig
   */
  readonly privateVisibilityConfig?: ManagedZoneSpecInitProviderPrivateVisibilityConfig[];

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema ManagedZoneSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The zone's visibility: public zones are exposed to the Internet,
   * while private zones are visible only to Virtual Private Cloud resources.
   * Default value is public.
   * Possible values are: private, public.
   *
   * @schema ManagedZoneSpecInitProvider#visibility
   */
  readonly visibility?: string;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProvider(obj: ManagedZoneSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudLoggingConfig': obj.cloudLoggingConfig?.map(y => toJson_ManagedZoneSpecInitProviderCloudLoggingConfig(y)),
    'description': obj.description,
    'dnsName': obj.dnsName,
    'dnssecConfig': obj.dnssecConfig?.map(y => toJson_ManagedZoneSpecInitProviderDnssecConfig(y)),
    'forceDestroy': obj.forceDestroy,
    'forwardingConfig': obj.forwardingConfig?.map(y => toJson_ManagedZoneSpecInitProviderForwardingConfig(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'peeringConfig': obj.peeringConfig?.map(y => toJson_ManagedZoneSpecInitProviderPeeringConfig(y)),
    'privateVisibilityConfig': obj.privateVisibilityConfig?.map(y => toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfig(y)),
    'project': obj.project,
    'visibility': obj.visibility,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ManagedZoneSpecManagementPolicies
 */
export enum ManagedZoneSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ManagedZoneSpecProviderConfigRef
 */
export interface ManagedZoneSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneSpecProviderConfigRef#policy
   */
  readonly policy?: ManagedZoneSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ManagedZoneSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecProviderConfigRef(obj: ManagedZoneSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ManagedZoneSpecWriteConnectionSecretToRef
 */
export interface ManagedZoneSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ManagedZoneSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ManagedZoneSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ManagedZoneSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecWriteConnectionSecretToRef(obj: ManagedZoneSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecForProviderCloudLoggingConfig
 */
export interface ManagedZoneSpecForProviderCloudLoggingConfig {
  /**
   * If set, enable query logging for this ManagedZone. False by default, making logging opt-in.
   *
   * @schema ManagedZoneSpecForProviderCloudLoggingConfig#enableLogging
   */
  readonly enableLogging?: boolean;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderCloudLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderCloudLoggingConfig(obj: ManagedZoneSpecForProviderCloudLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableLogging': obj.enableLogging,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecForProviderDnssecConfig
 */
export interface ManagedZoneSpecForProviderDnssecConfig {
  /**
   * Specifies parameters that will be used for generating initial DnsKeys
   * for this ManagedZone. If you provide a spec for keySigning or zoneSigning,
   * you must also provide one for the other.
   * default_key_specs can only be updated when the state is off.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecForProviderDnssecConfig#defaultKeySpecs
   */
  readonly defaultKeySpecs?: ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs[];

  /**
   * Identifies what kind of resource this is
   *
   * @schema ManagedZoneSpecForProviderDnssecConfig#kind
   */
  readonly kind?: string;

  /**
   * Specifies the mechanism used to provide authenticated denial-of-existence responses.
   * non_existence can only be updated when the state is off.
   * Possible values are: nsec, nsec3.
   *
   * @schema ManagedZoneSpecForProviderDnssecConfig#nonExistence
   */
  readonly nonExistence?: string;

  /**
   * Specifies whether DNSSEC is enabled, and what mode it is in
   * Possible values are: off, on, transfer.
   *
   * @schema ManagedZoneSpecForProviderDnssecConfig#state
   */
  readonly state?: string;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderDnssecConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderDnssecConfig(obj: ManagedZoneSpecForProviderDnssecConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultKeySpecs': obj.defaultKeySpecs?.map(y => toJson_ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs(y)),
    'kind': obj.kind,
    'nonExistence': obj.nonExistence,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecForProviderForwardingConfig
 */
export interface ManagedZoneSpecForProviderForwardingConfig {
  /**
   * List of target name servers to forward to. Cloud DNS will
   * select the best available name server if more than
   * one target is given.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecForProviderForwardingConfig#targetNameServers
   */
  readonly targetNameServers?: ManagedZoneSpecForProviderForwardingConfigTargetNameServers[];
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderForwardingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderForwardingConfig(obj: ManagedZoneSpecForProviderForwardingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetNameServers': obj.targetNameServers?.map(y => toJson_ManagedZoneSpecForProviderForwardingConfigTargetNameServers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecForProviderPeeringConfig
 */
export interface ManagedZoneSpecForProviderPeeringConfig {
  /**
   * The network with which to peer.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfig#targetNetwork
   */
  readonly targetNetwork?: ManagedZoneSpecForProviderPeeringConfigTargetNetwork[];
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPeeringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPeeringConfig(obj: ManagedZoneSpecForProviderPeeringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetNetwork': obj.targetNetwork?.map(y => toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetwork(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfig
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfig {
  /**
   * The list of Google Kubernetes Engine clusters that can see this zone.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfig#gkeClusters
   */
  readonly gkeClusters?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters[];

  /**
   * The list of VPC networks that can see this zone.12 SDK in a future release, you
   * may experience issues with this resource while updating. If you encounter this issue, remove all networks
   * blocks in an update and then apply another update adding all of them back simultaneously.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfig#networks
   */
  readonly networks?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks[];
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfig(obj: ManagedZoneSpecForProviderPrivateVisibilityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gkeClusters': obj.gkeClusters?.map(y => toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters(y)),
    'networks': obj.networks?.map(y => toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecInitProviderCloudLoggingConfig
 */
export interface ManagedZoneSpecInitProviderCloudLoggingConfig {
  /**
   * If set, enable query logging for this ManagedZone. False by default, making logging opt-in.
   *
   * @schema ManagedZoneSpecInitProviderCloudLoggingConfig#enableLogging
   */
  readonly enableLogging?: boolean;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderCloudLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderCloudLoggingConfig(obj: ManagedZoneSpecInitProviderCloudLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableLogging': obj.enableLogging,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecInitProviderDnssecConfig
 */
export interface ManagedZoneSpecInitProviderDnssecConfig {
  /**
   * Specifies parameters that will be used for generating initial DnsKeys
   * for this ManagedZone. If you provide a spec for keySigning or zoneSigning,
   * you must also provide one for the other.
   * default_key_specs can only be updated when the state is off.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecInitProviderDnssecConfig#defaultKeySpecs
   */
  readonly defaultKeySpecs?: ManagedZoneSpecInitProviderDnssecConfigDefaultKeySpecs[];

  /**
   * Identifies what kind of resource this is
   *
   * @schema ManagedZoneSpecInitProviderDnssecConfig#kind
   */
  readonly kind?: string;

  /**
   * Specifies the mechanism used to provide authenticated denial-of-existence responses.
   * non_existence can only be updated when the state is off.
   * Possible values are: nsec, nsec3.
   *
   * @schema ManagedZoneSpecInitProviderDnssecConfig#nonExistence
   */
  readonly nonExistence?: string;

  /**
   * Specifies whether DNSSEC is enabled, and what mode it is in
   * Possible values are: off, on, transfer.
   *
   * @schema ManagedZoneSpecInitProviderDnssecConfig#state
   */
  readonly state?: string;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderDnssecConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderDnssecConfig(obj: ManagedZoneSpecInitProviderDnssecConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultKeySpecs': obj.defaultKeySpecs?.map(y => toJson_ManagedZoneSpecInitProviderDnssecConfigDefaultKeySpecs(y)),
    'kind': obj.kind,
    'nonExistence': obj.nonExistence,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecInitProviderForwardingConfig
 */
export interface ManagedZoneSpecInitProviderForwardingConfig {
  /**
   * List of target name servers to forward to. Cloud DNS will
   * select the best available name server if more than
   * one target is given.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecInitProviderForwardingConfig#targetNameServers
   */
  readonly targetNameServers?: ManagedZoneSpecInitProviderForwardingConfigTargetNameServers[];
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderForwardingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderForwardingConfig(obj: ManagedZoneSpecInitProviderForwardingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetNameServers': obj.targetNameServers?.map(y => toJson_ManagedZoneSpecInitProviderForwardingConfigTargetNameServers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecInitProviderPeeringConfig
 */
export interface ManagedZoneSpecInitProviderPeeringConfig {
  /**
   * The network with which to peer.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecInitProviderPeeringConfig#targetNetwork
   */
  readonly targetNetwork?: ManagedZoneSpecInitProviderPeeringConfigTargetNetwork[];
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPeeringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPeeringConfig(obj: ManagedZoneSpecInitProviderPeeringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetNetwork': obj.targetNetwork?.map(y => toJson_ManagedZoneSpecInitProviderPeeringConfigTargetNetwork(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfig
 */
export interface ManagedZoneSpecInitProviderPrivateVisibilityConfig {
  /**
   * The list of Google Kubernetes Engine clusters that can see this zone.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfig#gkeClusters
   */
  readonly gkeClusters?: ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClusters[];

  /**
   * The list of VPC networks that can see this zone.12 SDK in a future release, you
   * may experience issues with this resource while updating. If you encounter this issue, remove all networks
   * blocks in an update and then apply another update adding all of them back simultaneously.
   * Structure is documented below.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfig#networks
   */
  readonly networks?: ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworks[];
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPrivateVisibilityConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfig(obj: ManagedZoneSpecInitProviderPrivateVisibilityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gkeClusters': obj.gkeClusters?.map(y => toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClusters(y)),
    'networks': obj.networks?.map(y => toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworks(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneSpecProviderConfigRefPolicy
 */
export interface ManagedZoneSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecProviderConfigRefPolicy(obj: ManagedZoneSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs
 */
export interface ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs {
  /**
   * String mnemonic specifying the DNSSEC algorithm of this key
   * Possible values are: ecdsap256sha256, ecdsap384sha384, rsasha1, rsasha256, rsasha512.
   *
   * @schema ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs#algorithm
   */
  readonly algorithm?: string;

  /**
   * Length of the keys in bits
   *
   * @schema ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs#keyLength
   */
  readonly keyLength?: number;

  /**
   * Specifies whether this is a key signing key (KSK) or a zone
   * signing key (ZSK). Key signing keys have the Secure Entry
   * Point flag set and, when active, will only be used to sign
   * resource record sets of type DNSKEY. Zone signing keys do
   * not have the Secure Entry Point flag set and will be used
   * to sign all other types of resource record sets.
   * Possible values are: keySigning, zoneSigning.
   *
   * @schema ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs#keyType
   */
  readonly keyType?: string;

  /**
   * Identifies what kind of resource this is
   *
   * @schema ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs#kind
   */
  readonly kind?: string;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs(obj: ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'algorithm': obj.algorithm,
    'keyLength': obj.keyLength,
    'keyType': obj.keyType,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecForProviderForwardingConfigTargetNameServers
 */
export interface ManagedZoneSpecForProviderForwardingConfigTargetNameServers {
  /**
   * Fully qualified domain name for the forwarding target.
   *
   * @schema ManagedZoneSpecForProviderForwardingConfigTargetNameServers#domainName
   */
  readonly domainName?: string;

  /**
   * Forwarding path for this TargetNameServer. If unset or default Cloud DNS will make forwarding
   * decision based on address ranges, i.e. RFC1918 addresses go to the VPC, Non-RFC1918 addresses go
   * to the Internet. When set to private, Cloud DNS will always send queries through VPC for this target
   * Possible values are: default, private.
   *
   * @schema ManagedZoneSpecForProviderForwardingConfigTargetNameServers#forwardingPath
   */
  readonly forwardingPath?: string;

  /**
   * IPv4 address of a target name server.
   *
   * @schema ManagedZoneSpecForProviderForwardingConfigTargetNameServers#ipv4Address
   */
  readonly ipv4Address?: string;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderForwardingConfigTargetNameServers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderForwardingConfigTargetNameServers(obj: ManagedZoneSpecForProviderForwardingConfigTargetNameServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainName': obj.domainName,
    'forwardingPath': obj.forwardingPath,
    'ipv4Address': obj.ipv4Address,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetwork
 */
export interface ManagedZoneSpecForProviderPeeringConfigTargetNetwork {
  /**
   * The id or fully qualified URL of the VPC network to forward queries to.
   * This should be formatted like projects/{project}/global/networks/{network} or
   * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetwork#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetwork#networkUrlRef
   */
  readonly networkUrlRef?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetwork#networkUrlSelector
   */
  readonly networkUrlSelector?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPeeringConfigTargetNetwork' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetwork(obj: ManagedZoneSpecForProviderPeeringConfigTargetNetwork | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkUrl': obj.networkUrl,
    'networkUrlRef': toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef(obj.networkUrlRef),
    'networkUrlSelector': toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector(obj.networkUrlSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters {
  /**
   * The resource name of the cluster to bind this ManagedZone to.
   * This should be specified in the format like
   * projects/_/locations/_/clusters/*
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters#gkeClusterName
   */
  readonly gkeClusterName?: string;

  /**
   * Reference to a Cluster in container to populate gkeClusterName.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters#gkeClusterNameRef
   */
  readonly gkeClusterNameRef?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef;

  /**
   * Selector for a Cluster in container to populate gkeClusterName.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters#gkeClusterNameSelector
   */
  readonly gkeClusterNameSelector?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gkeClusterName': obj.gkeClusterName,
    'gkeClusterNameRef': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef(obj.gkeClusterNameRef),
    'gkeClusterNameSelector': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector(obj.gkeClusterNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks {
  /**
   * The id or fully qualified URL of the VPC network to forward queries to.
   * This should be formatted like projects/{project}/global/networks/{network} or
   * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks#networkUrlRef
   */
  readonly networkUrlRef?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks#networkUrlSelector
   */
  readonly networkUrlSelector?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkUrl': obj.networkUrl,
    'networkUrlRef': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef(obj.networkUrlRef),
    'networkUrlSelector': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector(obj.networkUrlSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecInitProviderDnssecConfigDefaultKeySpecs
 */
export interface ManagedZoneSpecInitProviderDnssecConfigDefaultKeySpecs {
  /**
   * String mnemonic specifying the DNSSEC algorithm of this key
   * Possible values are: ecdsap256sha256, ecdsap384sha384, rsasha1, rsasha256, rsasha512.
   *
   * @schema ManagedZoneSpecInitProviderDnssecConfigDefaultKeySpecs#algorithm
   */
  readonly algorithm?: string;

  /**
   * Length of the keys in bits
   *
   * @schema ManagedZoneSpecInitProviderDnssecConfigDefaultKeySpecs#keyLength
   */
  readonly keyLength?: number;

  /**
   * Specifies whether this is a key signing key (KSK) or a zone
   * signing key (ZSK). Key signing keys have the Secure Entry
   * Point flag set and, when active, will only be used to sign
   * resource record sets of type DNSKEY. Zone signing keys do
   * not have the Secure Entry Point flag set and will be used
   * to sign all other types of resource record sets.
   * Possible values are: keySigning, zoneSigning.
   *
   * @schema ManagedZoneSpecInitProviderDnssecConfigDefaultKeySpecs#keyType
   */
  readonly keyType?: string;

  /**
   * Identifies what kind of resource this is
   *
   * @schema ManagedZoneSpecInitProviderDnssecConfigDefaultKeySpecs#kind
   */
  readonly kind?: string;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderDnssecConfigDefaultKeySpecs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderDnssecConfigDefaultKeySpecs(obj: ManagedZoneSpecInitProviderDnssecConfigDefaultKeySpecs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'algorithm': obj.algorithm,
    'keyLength': obj.keyLength,
    'keyType': obj.keyType,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecInitProviderForwardingConfigTargetNameServers
 */
export interface ManagedZoneSpecInitProviderForwardingConfigTargetNameServers {
  /**
   * Fully qualified domain name for the forwarding target.
   *
   * @schema ManagedZoneSpecInitProviderForwardingConfigTargetNameServers#domainName
   */
  readonly domainName?: string;

  /**
   * Forwarding path for this TargetNameServer. If unset or default Cloud DNS will make forwarding
   * decision based on address ranges, i.e. RFC1918 addresses go to the VPC, Non-RFC1918 addresses go
   * to the Internet. When set to private, Cloud DNS will always send queries through VPC for this target
   * Possible values are: default, private.
   *
   * @schema ManagedZoneSpecInitProviderForwardingConfigTargetNameServers#forwardingPath
   */
  readonly forwardingPath?: string;

  /**
   * IPv4 address of a target name server.
   *
   * @schema ManagedZoneSpecInitProviderForwardingConfigTargetNameServers#ipv4Address
   */
  readonly ipv4Address?: string;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderForwardingConfigTargetNameServers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderForwardingConfigTargetNameServers(obj: ManagedZoneSpecInitProviderForwardingConfigTargetNameServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainName': obj.domainName,
    'forwardingPath': obj.forwardingPath,
    'ipv4Address': obj.ipv4Address,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetwork
 */
export interface ManagedZoneSpecInitProviderPeeringConfigTargetNetwork {
  /**
   * The id or fully qualified URL of the VPC network to forward queries to.
   * This should be formatted like projects/{project}/global/networks/{network} or
   * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
   *
   * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetwork#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetwork#networkUrlRef
   */
  readonly networkUrlRef?: ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetwork#networkUrlSelector
   */
  readonly networkUrlSelector?: ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPeeringConfigTargetNetwork' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPeeringConfigTargetNetwork(obj: ManagedZoneSpecInitProviderPeeringConfigTargetNetwork | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkUrl': obj.networkUrl,
    'networkUrlRef': toJson_ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef(obj.networkUrlRef),
    'networkUrlSelector': toJson_ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector(obj.networkUrlSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClusters
 */
export interface ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClusters {
  /**
   * The resource name of the cluster to bind this ManagedZone to.
   * This should be specified in the format like
   * projects/_/locations/_/clusters/*
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClusters#gkeClusterName
   */
  readonly gkeClusterName?: string;

  /**
   * Reference to a Cluster in container to populate gkeClusterName.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClusters#gkeClusterNameRef
   */
  readonly gkeClusterNameRef?: ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef;

  /**
   * Selector for a Cluster in container to populate gkeClusterName.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClusters#gkeClusterNameSelector
   */
  readonly gkeClusterNameSelector?: ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClusters(obj: ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gkeClusterName': obj.gkeClusterName,
    'gkeClusterNameRef': toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef(obj.gkeClusterNameRef),
    'gkeClusterNameSelector': toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector(obj.gkeClusterNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworks
 */
export interface ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworks {
  /**
   * The id or fully qualified URL of the VPC network to forward queries to.
   * This should be formatted like projects/{project}/global/networks/{network} or
   * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworks#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworks#networkUrlRef
   */
  readonly networkUrlRef?: ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworks#networkUrlSelector
   */
  readonly networkUrlSelector?: ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworks(obj: ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkUrl': obj.networkUrl,
    'networkUrlRef': toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef(obj.networkUrlRef),
    'networkUrlSelector': toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector(obj.networkUrlSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecProviderConfigRefPolicyResolution
 */
export enum ManagedZoneSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneSpecProviderConfigRefPolicyResolve
 */
export enum ManagedZoneSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef
 */
export interface ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef#policy
   */
  readonly policy?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef(obj: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector
 */
export interface ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector#policy
   */
  readonly policy?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector(obj: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Cluster in container to populate gkeClusterName.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef#policy
   */
  readonly policy?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Cluster in container to populate gkeClusterName.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector#policy
   */
  readonly policy?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef#policy
   */
  readonly policy?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector#policy
   */
  readonly policy?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef
 */
export interface ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef#policy
   */
  readonly policy?: ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef(obj: ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector
 */
export interface ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector#policy
   */
  readonly policy?: ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector(obj: ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Cluster in container to populate gkeClusterName.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef
 */
export interface ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef#policy
   */
  readonly policy?: ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef(obj: ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Cluster in container to populate gkeClusterName.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector
 */
export interface ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector#policy
   */
  readonly policy?: ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector(obj: ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef
 */
export interface ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef#policy
   */
  readonly policy?: ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef(obj: ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector
 */
export interface ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector#policy
   */
  readonly policy?: ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector(obj: ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy
 */
export interface ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy(obj: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy
 */
export interface ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy(obj: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy
 */
export interface ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy(obj: ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy
 */
export interface ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy(obj: ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy
 */
export interface ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy(obj: ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy
 */
export interface ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy(obj: ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy
 */
export interface ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy(obj: ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy
 */
export interface ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy(obj: ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolution
 */
export enum ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolve
 */
export enum ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolution
 */
export enum ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolve
 */
export enum ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolution
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolve
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolution
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolve
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolution
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolve
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolution
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolve
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolution
 */
export enum ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolve
 */
export enum ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolution
 */
export enum ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolve
 */
export enum ManagedZoneSpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolution
 */
export enum ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolve
 */
export enum ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolution
 */
export enum ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolve
 */
export enum ManagedZoneSpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolution
 */
export enum ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolve
 */
export enum ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolution
 */
export enum ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolve
 */
export enum ManagedZoneSpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ManagedZone is the Schema for the ManagedZones API. A zone is a subtree of the DNS namespace under one administrative responsibility.
 *
 * @schema ManagedZoneV1Beta2
 */
export class ManagedZoneV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ManagedZoneV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dns.gcp.upbound.io/v1beta2',
    kind: 'ManagedZone',
  }

  /**
   * Renders a Kubernetes manifest for "ManagedZoneV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ManagedZoneV1Beta2Props): any {
    return {
      ...ManagedZoneV1Beta2.GVK,
      ...toJson_ManagedZoneV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ManagedZoneV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ManagedZoneV1Beta2Props) {
    super(scope, id, {
      ...ManagedZoneV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ManagedZoneV1Beta2.GVK,
      ...toJson_ManagedZoneV1Beta2Props(resolved),
    };
  }
}

/**
 * ManagedZone is the Schema for the ManagedZones API. A zone is a subtree of the DNS namespace under one administrative responsibility.
 *
 * @schema ManagedZoneV1Beta2
 */
export interface ManagedZoneV1Beta2Props {
  /**
   * @schema ManagedZoneV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ManagedZoneSpec defines the desired state of ManagedZone
   *
   * @schema ManagedZoneV1Beta2#spec
   */
  readonly spec: ManagedZoneV1Beta2Spec;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2Props(obj: ManagedZoneV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ManagedZoneV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ManagedZoneSpec defines the desired state of ManagedZone
 *
 * @schema ManagedZoneV1Beta2Spec
 */
export interface ManagedZoneV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ManagedZoneV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: ManagedZoneV1Beta2SpecDeletionPolicy;

  /**
   * @schema ManagedZoneV1Beta2Spec#forProvider
   */
  readonly forProvider: ManagedZoneV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ManagedZoneV1Beta2Spec#initProvider
   */
  readonly initProvider?: ManagedZoneV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ManagedZoneV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: ManagedZoneV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ManagedZoneV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: ManagedZoneV1Beta2SpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ManagedZoneV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ManagedZoneV1Beta2SpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2Spec(obj: ManagedZoneV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ManagedZoneV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_ManagedZoneV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ManagedZoneV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_ManagedZoneV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ManagedZoneV1Beta2SpecDeletionPolicy
 */
export enum ManagedZoneV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ManagedZoneV1Beta2SpecForProvider
 */
export interface ManagedZoneV1Beta2SpecForProvider {
  /**
   * Cloud logging configuration
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecForProvider#cloudLoggingConfig
   */
  readonly cloudLoggingConfig?: ManagedZoneV1Beta2SpecForProviderCloudLoggingConfig;

  /**
   * A textual description field.
   *
   * @schema ManagedZoneV1Beta2SpecForProvider#description
   */
  readonly description?: string;

  /**
   * The DNS name of this managed zone, for instance "example.com.".
   *
   * @schema ManagedZoneV1Beta2SpecForProvider#dnsName
   */
  readonly dnsName?: string;

  /**
   * DNSSEC configuration
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecForProvider#dnssecConfig
   */
  readonly dnssecConfig?: ManagedZoneV1Beta2SpecForProviderDnssecConfig;

  /**
   * Set this true to delete all records in the zone.
   *
   * @schema ManagedZoneV1Beta2SpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * The presence for this field indicates that outbound forwarding is enabled
   * for this zone. The value of this field contains the set of destinations
   * to forward to.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecForProvider#forwardingConfig
   */
  readonly forwardingConfig?: ManagedZoneV1Beta2SpecForProviderForwardingConfig;

  /**
   * A set of key/value label pairs to assign to this ManagedZone.
   *
   * @schema ManagedZoneV1Beta2SpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The presence of this field indicates that DNS Peering is enabled for this
   * zone. The value of this field contains the network to peer with.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecForProvider#peeringConfig
   */
  readonly peeringConfig?: ManagedZoneV1Beta2SpecForProviderPeeringConfig;

  /**
   * For privately visible zones, the set of Virtual Private Cloud
   * resources that the zone is visible from. At least one of gke_clusters or networks must be specified.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecForProvider#privateVisibilityConfig
   */
  readonly privateVisibilityConfig?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfig;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema ManagedZoneV1Beta2SpecForProvider#project
   */
  readonly project?: string;

  /**
   * The zone's visibility: public zones are exposed to the Internet,
   * while private zones are visible only to Virtual Private Cloud resources.
   * Default value is public.
   * Possible values are: private, public.
   *
   * @schema ManagedZoneV1Beta2SpecForProvider#visibility
   */
  readonly visibility?: string;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProvider(obj: ManagedZoneV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudLoggingConfig': toJson_ManagedZoneV1Beta2SpecForProviderCloudLoggingConfig(obj.cloudLoggingConfig),
    'description': obj.description,
    'dnsName': obj.dnsName,
    'dnssecConfig': toJson_ManagedZoneV1Beta2SpecForProviderDnssecConfig(obj.dnssecConfig),
    'forceDestroy': obj.forceDestroy,
    'forwardingConfig': toJson_ManagedZoneV1Beta2SpecForProviderForwardingConfig(obj.forwardingConfig),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'peeringConfig': toJson_ManagedZoneV1Beta2SpecForProviderPeeringConfig(obj.peeringConfig),
    'privateVisibilityConfig': toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfig(obj.privateVisibilityConfig),
    'project': obj.project,
    'visibility': obj.visibility,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ManagedZoneV1Beta2SpecInitProvider
 */
export interface ManagedZoneV1Beta2SpecInitProvider {
  /**
   * Cloud logging configuration
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecInitProvider#cloudLoggingConfig
   */
  readonly cloudLoggingConfig?: ManagedZoneV1Beta2SpecInitProviderCloudLoggingConfig;

  /**
   * A textual description field.
   *
   * @schema ManagedZoneV1Beta2SpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The DNS name of this managed zone, for instance "example.com.".
   *
   * @schema ManagedZoneV1Beta2SpecInitProvider#dnsName
   */
  readonly dnsName?: string;

  /**
   * DNSSEC configuration
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecInitProvider#dnssecConfig
   */
  readonly dnssecConfig?: ManagedZoneV1Beta2SpecInitProviderDnssecConfig;

  /**
   * Set this true to delete all records in the zone.
   *
   * @schema ManagedZoneV1Beta2SpecInitProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * The presence for this field indicates that outbound forwarding is enabled
   * for this zone. The value of this field contains the set of destinations
   * to forward to.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecInitProvider#forwardingConfig
   */
  readonly forwardingConfig?: ManagedZoneV1Beta2SpecInitProviderForwardingConfig;

  /**
   * A set of key/value label pairs to assign to this ManagedZone.
   *
   * @schema ManagedZoneV1Beta2SpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The presence of this field indicates that DNS Peering is enabled for this
   * zone. The value of this field contains the network to peer with.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecInitProvider#peeringConfig
   */
  readonly peeringConfig?: ManagedZoneV1Beta2SpecInitProviderPeeringConfig;

  /**
   * For privately visible zones, the set of Virtual Private Cloud
   * resources that the zone is visible from. At least one of gke_clusters or networks must be specified.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecInitProvider#privateVisibilityConfig
   */
  readonly privateVisibilityConfig?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfig;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema ManagedZoneV1Beta2SpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The zone's visibility: public zones are exposed to the Internet,
   * while private zones are visible only to Virtual Private Cloud resources.
   * Default value is public.
   * Possible values are: private, public.
   *
   * @schema ManagedZoneV1Beta2SpecInitProvider#visibility
   */
  readonly visibility?: string;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProvider(obj: ManagedZoneV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudLoggingConfig': toJson_ManagedZoneV1Beta2SpecInitProviderCloudLoggingConfig(obj.cloudLoggingConfig),
    'description': obj.description,
    'dnsName': obj.dnsName,
    'dnssecConfig': toJson_ManagedZoneV1Beta2SpecInitProviderDnssecConfig(obj.dnssecConfig),
    'forceDestroy': obj.forceDestroy,
    'forwardingConfig': toJson_ManagedZoneV1Beta2SpecInitProviderForwardingConfig(obj.forwardingConfig),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'peeringConfig': toJson_ManagedZoneV1Beta2SpecInitProviderPeeringConfig(obj.peeringConfig),
    'privateVisibilityConfig': toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfig(obj.privateVisibilityConfig),
    'project': obj.project,
    'visibility': obj.visibility,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ManagedZoneV1Beta2SpecManagementPolicies
 */
export enum ManagedZoneV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ManagedZoneV1Beta2SpecProviderConfigRef
 */
export interface ManagedZoneV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: ManagedZoneV1Beta2SpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecProviderConfigRef(obj: ManagedZoneV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ManagedZoneV1Beta2SpecWriteConnectionSecretToRef
 */
export interface ManagedZoneV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ManagedZoneV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ManagedZoneV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecWriteConnectionSecretToRef(obj: ManagedZoneV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cloud logging configuration
 * Structure is documented below.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderCloudLoggingConfig
 */
export interface ManagedZoneV1Beta2SpecForProviderCloudLoggingConfig {
  /**
   * If set, enable query logging for this ManagedZone. False by default, making logging opt-in.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderCloudLoggingConfig#enableLogging
   */
  readonly enableLogging?: boolean;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderCloudLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderCloudLoggingConfig(obj: ManagedZoneV1Beta2SpecForProviderCloudLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableLogging': obj.enableLogging,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DNSSEC configuration
 * Structure is documented below.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderDnssecConfig
 */
export interface ManagedZoneV1Beta2SpecForProviderDnssecConfig {
  /**
   * Specifies parameters that will be used for generating initial DnsKeys
   * for this ManagedZone. If you provide a spec for keySigning or zoneSigning,
   * you must also provide one for the other.
   * default_key_specs can only be updated when the state is off.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderDnssecConfig#defaultKeySpecs
   */
  readonly defaultKeySpecs?: ManagedZoneV1Beta2SpecForProviderDnssecConfigDefaultKeySpecs[];

  /**
   * Identifies what kind of resource this is
   *
   * @schema ManagedZoneV1Beta2SpecForProviderDnssecConfig#kind
   */
  readonly kind?: string;

  /**
   * Specifies the mechanism used to provide authenticated denial-of-existence responses.
   * non_existence can only be updated when the state is off.
   * Possible values are: nsec, nsec3.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderDnssecConfig#nonExistence
   */
  readonly nonExistence?: string;

  /**
   * Specifies whether DNSSEC is enabled, and what mode it is in
   * Possible values are: off, on, transfer.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderDnssecConfig#state
   */
  readonly state?: string;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderDnssecConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderDnssecConfig(obj: ManagedZoneV1Beta2SpecForProviderDnssecConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultKeySpecs': obj.defaultKeySpecs?.map(y => toJson_ManagedZoneV1Beta2SpecForProviderDnssecConfigDefaultKeySpecs(y)),
    'kind': obj.kind,
    'nonExistence': obj.nonExistence,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The presence for this field indicates that outbound forwarding is enabled
 * for this zone. The value of this field contains the set of destinations
 * to forward to.
 * Structure is documented below.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderForwardingConfig
 */
export interface ManagedZoneV1Beta2SpecForProviderForwardingConfig {
  /**
   * List of target name servers to forward to. Cloud DNS will
   * select the best available name server if more than
   * one target is given.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderForwardingConfig#targetNameServers
   */
  readonly targetNameServers?: ManagedZoneV1Beta2SpecForProviderForwardingConfigTargetNameServers[];
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderForwardingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderForwardingConfig(obj: ManagedZoneV1Beta2SpecForProviderForwardingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetNameServers': obj.targetNameServers?.map(y => toJson_ManagedZoneV1Beta2SpecForProviderForwardingConfigTargetNameServers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The presence of this field indicates that DNS Peering is enabled for this
 * zone. The value of this field contains the network to peer with.
 * Structure is documented below.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfig
 */
export interface ManagedZoneV1Beta2SpecForProviderPeeringConfig {
  /**
   * The network with which to peer.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfig#targetNetwork
   */
  readonly targetNetwork?: ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetwork;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPeeringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPeeringConfig(obj: ManagedZoneV1Beta2SpecForProviderPeeringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetNetwork': toJson_ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetwork(obj.targetNetwork),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * For privately visible zones, the set of Virtual Private Cloud
 * resources that the zone is visible from. At least one of gke_clusters or networks must be specified.
 * Structure is documented below.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfig
 */
export interface ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfig {
  /**
   * The list of Google Kubernetes Engine clusters that can see this zone.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfig#gkeClusters
   */
  readonly gkeClusters?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClusters[];

  /**
   * The list of VPC networks that can see this zone.12 SDK in a future release, you
   * may experience issues with this resource while updating. If you encounter this issue, remove all networks
   * blocks in an update and then apply another update adding all of them back simultaneously.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfig#networks
   */
  readonly networks?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworks[];
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfig(obj: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gkeClusters': obj.gkeClusters?.map(y => toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClusters(y)),
    'networks': obj.networks?.map(y => toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworks(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cloud logging configuration
 * Structure is documented below.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderCloudLoggingConfig
 */
export interface ManagedZoneV1Beta2SpecInitProviderCloudLoggingConfig {
  /**
   * If set, enable query logging for this ManagedZone. False by default, making logging opt-in.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderCloudLoggingConfig#enableLogging
   */
  readonly enableLogging?: boolean;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderCloudLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderCloudLoggingConfig(obj: ManagedZoneV1Beta2SpecInitProviderCloudLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableLogging': obj.enableLogging,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DNSSEC configuration
 * Structure is documented below.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderDnssecConfig
 */
export interface ManagedZoneV1Beta2SpecInitProviderDnssecConfig {
  /**
   * Specifies parameters that will be used for generating initial DnsKeys
   * for this ManagedZone. If you provide a spec for keySigning or zoneSigning,
   * you must also provide one for the other.
   * default_key_specs can only be updated when the state is off.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderDnssecConfig#defaultKeySpecs
   */
  readonly defaultKeySpecs?: ManagedZoneV1Beta2SpecInitProviderDnssecConfigDefaultKeySpecs[];

  /**
   * Identifies what kind of resource this is
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderDnssecConfig#kind
   */
  readonly kind?: string;

  /**
   * Specifies the mechanism used to provide authenticated denial-of-existence responses.
   * non_existence can only be updated when the state is off.
   * Possible values are: nsec, nsec3.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderDnssecConfig#nonExistence
   */
  readonly nonExistence?: string;

  /**
   * Specifies whether DNSSEC is enabled, and what mode it is in
   * Possible values are: off, on, transfer.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderDnssecConfig#state
   */
  readonly state?: string;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderDnssecConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderDnssecConfig(obj: ManagedZoneV1Beta2SpecInitProviderDnssecConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultKeySpecs': obj.defaultKeySpecs?.map(y => toJson_ManagedZoneV1Beta2SpecInitProviderDnssecConfigDefaultKeySpecs(y)),
    'kind': obj.kind,
    'nonExistence': obj.nonExistence,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The presence for this field indicates that outbound forwarding is enabled
 * for this zone. The value of this field contains the set of destinations
 * to forward to.
 * Structure is documented below.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderForwardingConfig
 */
export interface ManagedZoneV1Beta2SpecInitProviderForwardingConfig {
  /**
   * List of target name servers to forward to. Cloud DNS will
   * select the best available name server if more than
   * one target is given.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderForwardingConfig#targetNameServers
   */
  readonly targetNameServers?: ManagedZoneV1Beta2SpecInitProviderForwardingConfigTargetNameServers[];
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderForwardingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderForwardingConfig(obj: ManagedZoneV1Beta2SpecInitProviderForwardingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetNameServers': obj.targetNameServers?.map(y => toJson_ManagedZoneV1Beta2SpecInitProviderForwardingConfigTargetNameServers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The presence of this field indicates that DNS Peering is enabled for this
 * zone. The value of this field contains the network to peer with.
 * Structure is documented below.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfig
 */
export interface ManagedZoneV1Beta2SpecInitProviderPeeringConfig {
  /**
   * The network with which to peer.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfig#targetNetwork
   */
  readonly targetNetwork?: ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetwork;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPeeringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPeeringConfig(obj: ManagedZoneV1Beta2SpecInitProviderPeeringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetNetwork': toJson_ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetwork(obj.targetNetwork),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * For privately visible zones, the set of Virtual Private Cloud
 * resources that the zone is visible from. At least one of gke_clusters or networks must be specified.
 * Structure is documented below.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfig
 */
export interface ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfig {
  /**
   * The list of Google Kubernetes Engine clusters that can see this zone.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfig#gkeClusters
   */
  readonly gkeClusters?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClusters[];

  /**
   * The list of VPC networks that can see this zone.12 SDK in a future release, you
   * may experience issues with this resource while updating. If you encounter this issue, remove all networks
   * blocks in an update and then apply another update adding all of them back simultaneously.
   * Structure is documented below.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfig#networks
   */
  readonly networks?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworks[];
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfig(obj: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gkeClusters': obj.gkeClusters?.map(y => toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClusters(y)),
    'networks': obj.networks?.map(y => toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworks(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneV1Beta2SpecProviderConfigRefPolicy
 */
export interface ManagedZoneV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneV1Beta2SpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecProviderConfigRefPolicy(obj: ManagedZoneV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneV1Beta2SpecForProviderDnssecConfigDefaultKeySpecs
 */
export interface ManagedZoneV1Beta2SpecForProviderDnssecConfigDefaultKeySpecs {
  /**
   * String mnemonic specifying the DNSSEC algorithm of this key
   * Possible values are: ecdsap256sha256, ecdsap384sha384, rsasha1, rsasha256, rsasha512.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderDnssecConfigDefaultKeySpecs#algorithm
   */
  readonly algorithm?: string;

  /**
   * Length of the keys in bits
   *
   * @schema ManagedZoneV1Beta2SpecForProviderDnssecConfigDefaultKeySpecs#keyLength
   */
  readonly keyLength?: number;

  /**
   * Specifies whether this is a key signing key (KSK) or a zone
   * signing key (ZSK). Key signing keys have the Secure Entry
   * Point flag set and, when active, will only be used to sign
   * resource record sets of type DNSKEY. Zone signing keys do
   * not have the Secure Entry Point flag set and will be used
   * to sign all other types of resource record sets.
   * Possible values are: keySigning, zoneSigning.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderDnssecConfigDefaultKeySpecs#keyType
   */
  readonly keyType?: string;

  /**
   * Identifies what kind of resource this is
   *
   * @schema ManagedZoneV1Beta2SpecForProviderDnssecConfigDefaultKeySpecs#kind
   */
  readonly kind?: string;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderDnssecConfigDefaultKeySpecs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderDnssecConfigDefaultKeySpecs(obj: ManagedZoneV1Beta2SpecForProviderDnssecConfigDefaultKeySpecs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'algorithm': obj.algorithm,
    'keyLength': obj.keyLength,
    'keyType': obj.keyType,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneV1Beta2SpecForProviderForwardingConfigTargetNameServers
 */
export interface ManagedZoneV1Beta2SpecForProviderForwardingConfigTargetNameServers {
  /**
   * Fully qualified domain name for the forwarding target.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderForwardingConfigTargetNameServers#domainName
   */
  readonly domainName?: string;

  /**
   * Forwarding path for this TargetNameServer. If unset or default Cloud DNS will make forwarding
   * decision based on address ranges, i.e. RFC1918 addresses go to the VPC, Non-RFC1918 addresses go
   * to the Internet. When set to private, Cloud DNS will always send queries through VPC for this target
   * Possible values are: default, private.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderForwardingConfigTargetNameServers#forwardingPath
   */
  readonly forwardingPath?: string;

  /**
   * IPv4 address of a target name server.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderForwardingConfigTargetNameServers#ipv4Address
   */
  readonly ipv4Address?: string;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderForwardingConfigTargetNameServers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderForwardingConfigTargetNameServers(obj: ManagedZoneV1Beta2SpecForProviderForwardingConfigTargetNameServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainName': obj.domainName,
    'forwardingPath': obj.forwardingPath,
    'ipv4Address': obj.ipv4Address,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The network with which to peer.
 * Structure is documented below.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetwork
 */
export interface ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetwork {
  /**
   * The id or fully qualified URL of the VPC network to forward queries to.
   * This should be formatted like projects/{project}/global/networks/{network} or
   * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetwork#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetwork#networkUrlRef
   */
  readonly networkUrlRef?: ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetwork#networkUrlSelector
   */
  readonly networkUrlSelector?: ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetwork' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetwork(obj: ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetwork | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkUrl': obj.networkUrl,
    'networkUrlRef': toJson_ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRef(obj.networkUrlRef),
    'networkUrlSelector': toJson_ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector(obj.networkUrlSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClusters
 */
export interface ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClusters {
  /**
   * The resource name of the cluster to bind this ManagedZone to.
   * This should be specified in the format like
   * projects/_/locations/_/clusters/*
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClusters#gkeClusterName
   */
  readonly gkeClusterName?: string;

  /**
   * Reference to a Cluster in container to populate gkeClusterName.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClusters#gkeClusterNameRef
   */
  readonly gkeClusterNameRef?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef;

  /**
   * Selector for a Cluster in container to populate gkeClusterName.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClusters#gkeClusterNameSelector
   */
  readonly gkeClusterNameSelector?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClusters(obj: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gkeClusterName': obj.gkeClusterName,
    'gkeClusterNameRef': toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef(obj.gkeClusterNameRef),
    'gkeClusterNameSelector': toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector(obj.gkeClusterNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworks
 */
export interface ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworks {
  /**
   * The id or fully qualified URL of the VPC network to forward queries to.
   * This should be formatted like projects/{project}/global/networks/{network} or
   * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworks#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworks#networkUrlRef
   */
  readonly networkUrlRef?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworks#networkUrlSelector
   */
  readonly networkUrlSelector?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworks(obj: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkUrl': obj.networkUrl,
    'networkUrlRef': toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef(obj.networkUrlRef),
    'networkUrlSelector': toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector(obj.networkUrlSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneV1Beta2SpecInitProviderDnssecConfigDefaultKeySpecs
 */
export interface ManagedZoneV1Beta2SpecInitProviderDnssecConfigDefaultKeySpecs {
  /**
   * String mnemonic specifying the DNSSEC algorithm of this key
   * Possible values are: ecdsap256sha256, ecdsap384sha384, rsasha1, rsasha256, rsasha512.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderDnssecConfigDefaultKeySpecs#algorithm
   */
  readonly algorithm?: string;

  /**
   * Length of the keys in bits
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderDnssecConfigDefaultKeySpecs#keyLength
   */
  readonly keyLength?: number;

  /**
   * Specifies whether this is a key signing key (KSK) or a zone
   * signing key (ZSK). Key signing keys have the Secure Entry
   * Point flag set and, when active, will only be used to sign
   * resource record sets of type DNSKEY. Zone signing keys do
   * not have the Secure Entry Point flag set and will be used
   * to sign all other types of resource record sets.
   * Possible values are: keySigning, zoneSigning.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderDnssecConfigDefaultKeySpecs#keyType
   */
  readonly keyType?: string;

  /**
   * Identifies what kind of resource this is
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderDnssecConfigDefaultKeySpecs#kind
   */
  readonly kind?: string;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderDnssecConfigDefaultKeySpecs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderDnssecConfigDefaultKeySpecs(obj: ManagedZoneV1Beta2SpecInitProviderDnssecConfigDefaultKeySpecs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'algorithm': obj.algorithm,
    'keyLength': obj.keyLength,
    'keyType': obj.keyType,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneV1Beta2SpecInitProviderForwardingConfigTargetNameServers
 */
export interface ManagedZoneV1Beta2SpecInitProviderForwardingConfigTargetNameServers {
  /**
   * Fully qualified domain name for the forwarding target.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderForwardingConfigTargetNameServers#domainName
   */
  readonly domainName?: string;

  /**
   * Forwarding path for this TargetNameServer. If unset or default Cloud DNS will make forwarding
   * decision based on address ranges, i.e. RFC1918 addresses go to the VPC, Non-RFC1918 addresses go
   * to the Internet. When set to private, Cloud DNS will always send queries through VPC for this target
   * Possible values are: default, private.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderForwardingConfigTargetNameServers#forwardingPath
   */
  readonly forwardingPath?: string;

  /**
   * IPv4 address of a target name server.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderForwardingConfigTargetNameServers#ipv4Address
   */
  readonly ipv4Address?: string;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderForwardingConfigTargetNameServers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderForwardingConfigTargetNameServers(obj: ManagedZoneV1Beta2SpecInitProviderForwardingConfigTargetNameServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainName': obj.domainName,
    'forwardingPath': obj.forwardingPath,
    'ipv4Address': obj.ipv4Address,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The network with which to peer.
 * Structure is documented below.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetwork
 */
export interface ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetwork {
  /**
   * The id or fully qualified URL of the VPC network to forward queries to.
   * This should be formatted like projects/{project}/global/networks/{network} or
   * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetwork#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetwork#networkUrlRef
   */
  readonly networkUrlRef?: ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetwork#networkUrlSelector
   */
  readonly networkUrlSelector?: ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetwork' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetwork(obj: ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetwork | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkUrl': obj.networkUrl,
    'networkUrlRef': toJson_ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef(obj.networkUrlRef),
    'networkUrlSelector': toJson_ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector(obj.networkUrlSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClusters
 */
export interface ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClusters {
  /**
   * The resource name of the cluster to bind this ManagedZone to.
   * This should be specified in the format like
   * projects/_/locations/_/clusters/*
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClusters#gkeClusterName
   */
  readonly gkeClusterName?: string;

  /**
   * Reference to a Cluster in container to populate gkeClusterName.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClusters#gkeClusterNameRef
   */
  readonly gkeClusterNameRef?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef;

  /**
   * Selector for a Cluster in container to populate gkeClusterName.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClusters#gkeClusterNameSelector
   */
  readonly gkeClusterNameSelector?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClusters(obj: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gkeClusterName': obj.gkeClusterName,
    'gkeClusterNameRef': toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef(obj.gkeClusterNameRef),
    'gkeClusterNameSelector': toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector(obj.gkeClusterNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworks
 */
export interface ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworks {
  /**
   * The id or fully qualified URL of the VPC network to forward queries to.
   * This should be formatted like projects/{project}/global/networks/{network} or
   * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworks#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworks#networkUrlRef
   */
  readonly networkUrlRef?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworks#networkUrlSelector
   */
  readonly networkUrlSelector?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworks(obj: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkUrl': obj.networkUrl,
    'networkUrlRef': toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef(obj.networkUrlRef),
    'networkUrlSelector': toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector(obj.networkUrlSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum ManagedZoneV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum ManagedZoneV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRef
 */
export interface ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRef#policy
   */
  readonly policy?: ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRef(obj: ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector
 */
export interface ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector#policy
   */
  readonly policy?: ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector(obj: ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Cluster in container to populate gkeClusterName.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef
 */
export interface ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef#policy
   */
  readonly policy?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef(obj: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Cluster in container to populate gkeClusterName.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector
 */
export interface ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector#policy
   */
  readonly policy?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector(obj: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef
 */
export interface ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef#policy
   */
  readonly policy?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef(obj: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector
 */
export interface ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector#policy
   */
  readonly policy?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector(obj: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef
 */
export interface ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef#policy
   */
  readonly policy?: ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef(obj: ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector
 */
export interface ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector#policy
   */
  readonly policy?: ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector(obj: ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Cluster in container to populate gkeClusterName.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef
 */
export interface ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef#policy
   */
  readonly policy?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef(obj: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Cluster in container to populate gkeClusterName.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector
 */
export interface ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector#policy
   */
  readonly policy?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector(obj: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef
 */
export interface ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef#policy
   */
  readonly policy?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef(obj: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector
 */
export interface ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector#policy
   */
  readonly policy?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector(obj: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy
 */
export interface ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy(obj: ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy
 */
export interface ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy#resolution
   */
  readonly resolution?: ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy#resolve
   */
  readonly resolve?: ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy(obj: ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy
 */
export interface ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy(obj: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy
 */
export interface ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy(obj: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy
 */
export interface ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy(obj: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy
 */
export interface ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy#resolution
   */
  readonly resolution?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy#resolve
   */
  readonly resolve?: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy(obj: ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy
 */
export interface ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy(obj: ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy
 */
export interface ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy#resolution
   */
  readonly resolution?: ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy#resolve
   */
  readonly resolve?: ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy(obj: ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy
 */
export interface ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy(obj: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy
 */
export interface ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy(obj: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy
 */
export interface ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy(obj: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy
 */
export interface ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy#resolution
   */
  readonly resolution?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy#resolve
   */
  readonly resolve?: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy(obj: ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolution
 */
export enum ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolve
 */
export enum ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolution
 */
export enum ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolve
 */
export enum ManagedZoneV1Beta2SpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolution
 */
export enum ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolve
 */
export enum ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolution
 */
export enum ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolve
 */
export enum ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolution
 */
export enum ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolve
 */
export enum ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolution
 */
export enum ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolve
 */
export enum ManagedZoneV1Beta2SpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolution
 */
export enum ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolve
 */
export enum ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolution
 */
export enum ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolve
 */
export enum ManagedZoneV1Beta2SpecInitProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolution
 */
export enum ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolve
 */
export enum ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolution
 */
export enum ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolve
 */
export enum ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolution
 */
export enum ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolve
 */
export enum ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolution
 */
export enum ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolve
 */
export enum ManagedZoneV1Beta2SpecInitProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RecordSet is the Schema for the RecordSets API. Manages a set of DNS records within Google Cloud DNS.
 *
 * @schema RecordSet
 */
export class RecordSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RecordSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dns.gcp.upbound.io/v1beta1',
    kind: 'RecordSet',
  }

  /**
   * Renders a Kubernetes manifest for "RecordSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RecordSetProps): any {
    return {
      ...RecordSet.GVK,
      ...toJson_RecordSetProps(props),
    };
  }

  /**
   * Defines a "RecordSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RecordSetProps) {
    super(scope, id, {
      ...RecordSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...RecordSet.GVK,
      ...toJson_RecordSetProps(resolved),
    };
  }
}

/**
 * RecordSet is the Schema for the RecordSets API. Manages a set of DNS records within Google Cloud DNS.
 *
 * @schema RecordSet
 */
export interface RecordSetProps {
  /**
   * @schema RecordSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RecordSetSpec defines the desired state of RecordSet
   *
   * @schema RecordSet#spec
   */
  readonly spec: RecordSetSpec;
}

/**
 * Converts an object of type 'RecordSetProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetProps(obj: RecordSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RecordSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RecordSetSpec defines the desired state of RecordSet
 *
 * @schema RecordSetSpec
 */
export interface RecordSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RecordSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: RecordSetSpecDeletionPolicy;

  /**
   * @schema RecordSetSpec#forProvider
   */
  readonly forProvider: RecordSetSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema RecordSetSpec#initProvider
   */
  readonly initProvider?: RecordSetSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RecordSetSpec#managementPolicies
   */
  readonly managementPolicies?: RecordSetSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema RecordSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: RecordSetSpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema RecordSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RecordSetSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'RecordSetSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpec(obj: RecordSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RecordSetSpecForProvider(obj.forProvider),
    'initProvider': toJson_RecordSetSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RecordSetSpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_RecordSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RecordSetSpecDeletionPolicy
 */
export enum RecordSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RecordSetSpecForProvider
 */
export interface RecordSetSpecForProvider {
  /**
   * The name of the zone in which this record set will
   * reside.
   *
   * @schema RecordSetSpecForProvider#managedZone
   */
  readonly managedZone?: string;

  /**
   * Reference to a ManagedZone in dns to populate managedZone.
   *
   * @schema RecordSetSpecForProvider#managedZoneRef
   */
  readonly managedZoneRef?: RecordSetSpecForProviderManagedZoneRef;

  /**
   * Selector for a ManagedZone in dns to populate managedZone.
   *
   * @schema RecordSetSpecForProvider#managedZoneSelector
   */
  readonly managedZoneSelector?: RecordSetSpecForProviderManagedZoneSelector;

  /**
   * The DNS name this record set will apply to.
   *
   * @schema RecordSetSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The configuration for steering traffic based on query.
   * Now you can specify either Weighted Round Robin(WRR) type or Geolocation(GEO) type.
   * Structure is documented below.
   *
   * @schema RecordSetSpecForProvider#routingPolicy
   */
  readonly routingPolicy?: RecordSetSpecForProviderRoutingPolicy[];

  /**
   * The string data for the records in this record set
   * whose meaning depends on the DNS type. For TXT record, if the string data contains spaces, add surrounding \" if you don't want your string to get split on spaces.g. "first255characters\" \"morecharacters").
   *
   * @schema RecordSetSpecForProvider#rrdatas
   */
  readonly rrdatas?: string[];

  /**
   * The time-to-live of this record set (seconds).
   *
   * @schema RecordSetSpecForProvider#ttl
   */
  readonly ttl?: number;

  /**
   * The DNS record set type.
   *
   * @schema RecordSetSpecForProvider#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'RecordSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProvider(obj: RecordSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'managedZone': obj.managedZone,
    'managedZoneRef': toJson_RecordSetSpecForProviderManagedZoneRef(obj.managedZoneRef),
    'managedZoneSelector': toJson_RecordSetSpecForProviderManagedZoneSelector(obj.managedZoneSelector),
    'name': obj.name,
    'project': obj.project,
    'routingPolicy': obj.routingPolicy?.map(y => toJson_RecordSetSpecForProviderRoutingPolicy(y)),
    'rrdatas': obj.rrdatas?.map(y => y),
    'ttl': obj.ttl,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema RecordSetSpecInitProvider
 */
export interface RecordSetSpecInitProvider {
  /**
   * The name of the zone in which this record set will
   * reside.
   *
   * @schema RecordSetSpecInitProvider#managedZone
   */
  readonly managedZone?: string;

  /**
   * Reference to a ManagedZone in dns to populate managedZone.
   *
   * @schema RecordSetSpecInitProvider#managedZoneRef
   */
  readonly managedZoneRef?: RecordSetSpecInitProviderManagedZoneRef;

  /**
   * Selector for a ManagedZone in dns to populate managedZone.
   *
   * @schema RecordSetSpecInitProvider#managedZoneSelector
   */
  readonly managedZoneSelector?: RecordSetSpecInitProviderManagedZoneSelector;

  /**
   * The DNS name this record set will apply to.
   *
   * @schema RecordSetSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The configuration for steering traffic based on query.
   * Now you can specify either Weighted Round Robin(WRR) type or Geolocation(GEO) type.
   * Structure is documented below.
   *
   * @schema RecordSetSpecInitProvider#routingPolicy
   */
  readonly routingPolicy?: RecordSetSpecInitProviderRoutingPolicy[];

  /**
   * The string data for the records in this record set
   * whose meaning depends on the DNS type. For TXT record, if the string data contains spaces, add surrounding \" if you don't want your string to get split on spaces.g. "first255characters\" \"morecharacters").
   *
   * @schema RecordSetSpecInitProvider#rrdatas
   */
  readonly rrdatas?: string[];

  /**
   * The time-to-live of this record set (seconds).
   *
   * @schema RecordSetSpecInitProvider#ttl
   */
  readonly ttl?: number;

  /**
   * The DNS record set type.
   *
   * @schema RecordSetSpecInitProvider#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'RecordSetSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProvider(obj: RecordSetSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'managedZone': obj.managedZone,
    'managedZoneRef': toJson_RecordSetSpecInitProviderManagedZoneRef(obj.managedZoneRef),
    'managedZoneSelector': toJson_RecordSetSpecInitProviderManagedZoneSelector(obj.managedZoneSelector),
    'name': obj.name,
    'project': obj.project,
    'routingPolicy': obj.routingPolicy?.map(y => toJson_RecordSetSpecInitProviderRoutingPolicy(y)),
    'rrdatas': obj.rrdatas?.map(y => y),
    'ttl': obj.ttl,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema RecordSetSpecManagementPolicies
 */
export enum RecordSetSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema RecordSetSpecProviderConfigRef
 */
export interface RecordSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecProviderConfigRef#policy
   */
  readonly policy?: RecordSetSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecProviderConfigRef(obj: RecordSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema RecordSetSpecWriteConnectionSecretToRef
 */
export interface RecordSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RecordSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RecordSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'RecordSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecWriteConnectionSecretToRef(obj: RecordSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ManagedZone in dns to populate managedZone.
 *
 * @schema RecordSetSpecForProviderManagedZoneRef
 */
export interface RecordSetSpecForProviderManagedZoneRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecForProviderManagedZoneRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecForProviderManagedZoneRef#policy
   */
  readonly policy?: RecordSetSpecForProviderManagedZoneRefPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderManagedZoneRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderManagedZoneRef(obj: RecordSetSpecForProviderManagedZoneRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecForProviderManagedZoneRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ManagedZone in dns to populate managedZone.
 *
 * @schema RecordSetSpecForProviderManagedZoneSelector
 */
export interface RecordSetSpecForProviderManagedZoneSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetSpecForProviderManagedZoneSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecForProviderManagedZoneSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecForProviderManagedZoneSelector#policy
   */
  readonly policy?: RecordSetSpecForProviderManagedZoneSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderManagedZoneSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderManagedZoneSelector(obj: RecordSetSpecForProviderManagedZoneSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecForProviderManagedZoneSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicy {
  /**
   * Specifies whether to enable fencing for geo queries.
   *
   * @schema RecordSetSpecForProviderRoutingPolicy#enableGeoFencing
   */
  readonly enableGeoFencing?: boolean;

  /**
   * The configuration for Geolocation based routing policy.
   * Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicy#geo
   */
  readonly geo?: RecordSetSpecForProviderRoutingPolicyGeo[];

  /**
   * Specifies the health check (used with external endpoints).
   *
   * @schema RecordSetSpecForProviderRoutingPolicy#healthCheck
   */
  readonly healthCheck?: string;

  /**
   * Reference to a HealthCheck in compute to populate healthCheck.
   *
   * @schema RecordSetSpecForProviderRoutingPolicy#healthCheckRef
   */
  readonly healthCheckRef?: RecordSetSpecForProviderRoutingPolicyHealthCheckRef;

  /**
   * Selector for a HealthCheck in compute to populate healthCheck.
   *
   * @schema RecordSetSpecForProviderRoutingPolicy#healthCheckSelector
   */
  readonly healthCheckSelector?: RecordSetSpecForProviderRoutingPolicyHealthCheckSelector;

  /**
   * The configuration for a primary-backup policy with global to regional failover. Queries are responded to with the global primary targets, but if none of the primary targets are healthy, then we fallback to a regional failover policy.
   * Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicy#primaryBackup
   */
  readonly primaryBackup?: RecordSetSpecForProviderRoutingPolicyPrimaryBackup[];

  /**
   * The configuration for Weighted Round Robin based routing policy.
   * Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicy#wrr
   */
  readonly wrr?: RecordSetSpecForProviderRoutingPolicyWrr[];
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicy(obj: RecordSetSpecForProviderRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableGeoFencing': obj.enableGeoFencing,
    'geo': obj.geo?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyGeo(y)),
    'healthCheck': obj.healthCheck,
    'healthCheckRef': toJson_RecordSetSpecForProviderRoutingPolicyHealthCheckRef(obj.healthCheckRef),
    'healthCheckSelector': toJson_RecordSetSpecForProviderRoutingPolicyHealthCheckSelector(obj.healthCheckSelector),
    'primaryBackup': obj.primaryBackup?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackup(y)),
    'wrr': obj.wrr?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyWrr(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ManagedZone in dns to populate managedZone.
 *
 * @schema RecordSetSpecInitProviderManagedZoneRef
 */
export interface RecordSetSpecInitProviderManagedZoneRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecInitProviderManagedZoneRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecInitProviderManagedZoneRef#policy
   */
  readonly policy?: RecordSetSpecInitProviderManagedZoneRefPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderManagedZoneRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderManagedZoneRef(obj: RecordSetSpecInitProviderManagedZoneRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecInitProviderManagedZoneRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ManagedZone in dns to populate managedZone.
 *
 * @schema RecordSetSpecInitProviderManagedZoneSelector
 */
export interface RecordSetSpecInitProviderManagedZoneSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetSpecInitProviderManagedZoneSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecInitProviderManagedZoneSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecInitProviderManagedZoneSelector#policy
   */
  readonly policy?: RecordSetSpecInitProviderManagedZoneSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderManagedZoneSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderManagedZoneSelector(obj: RecordSetSpecInitProviderManagedZoneSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecInitProviderManagedZoneSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecInitProviderRoutingPolicy
 */
export interface RecordSetSpecInitProviderRoutingPolicy {
  /**
   * Specifies whether to enable fencing for geo queries.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicy#enableGeoFencing
   */
  readonly enableGeoFencing?: boolean;

  /**
   * The configuration for Geolocation based routing policy.
   * Structure is document below.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicy#geo
   */
  readonly geo?: RecordSetSpecInitProviderRoutingPolicyGeo[];

  /**
   * Specifies the health check (used with external endpoints).
   *
   * @schema RecordSetSpecInitProviderRoutingPolicy#healthCheck
   */
  readonly healthCheck?: string;

  /**
   * Reference to a HealthCheck in compute to populate healthCheck.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicy#healthCheckRef
   */
  readonly healthCheckRef?: RecordSetSpecInitProviderRoutingPolicyHealthCheckRef;

  /**
   * Selector for a HealthCheck in compute to populate healthCheck.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicy#healthCheckSelector
   */
  readonly healthCheckSelector?: RecordSetSpecInitProviderRoutingPolicyHealthCheckSelector;

  /**
   * The configuration for a primary-backup policy with global to regional failover. Queries are responded to with the global primary targets, but if none of the primary targets are healthy, then we fallback to a regional failover policy.
   * Structure is document below.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicy#primaryBackup
   */
  readonly primaryBackup?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackup[];

  /**
   * The configuration for Weighted Round Robin based routing policy.
   * Structure is document below.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicy#wrr
   */
  readonly wrr?: RecordSetSpecInitProviderRoutingPolicyWrr[];
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicy(obj: RecordSetSpecInitProviderRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableGeoFencing': obj.enableGeoFencing,
    'geo': obj.geo?.map(y => toJson_RecordSetSpecInitProviderRoutingPolicyGeo(y)),
    'healthCheck': obj.healthCheck,
    'healthCheckRef': toJson_RecordSetSpecInitProviderRoutingPolicyHealthCheckRef(obj.healthCheckRef),
    'healthCheckSelector': toJson_RecordSetSpecInitProviderRoutingPolicyHealthCheckSelector(obj.healthCheckSelector),
    'primaryBackup': obj.primaryBackup?.map(y => toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackup(y)),
    'wrr': obj.wrr?.map(y => toJson_RecordSetSpecInitProviderRoutingPolicyWrr(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecProviderConfigRefPolicy
 */
export interface RecordSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecProviderConfigRefPolicy(obj: RecordSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecForProviderManagedZoneRefPolicy
 */
export interface RecordSetSpecForProviderManagedZoneRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderManagedZoneRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderManagedZoneRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderManagedZoneRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderManagedZoneRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderManagedZoneRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderManagedZoneRefPolicy(obj: RecordSetSpecForProviderManagedZoneRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecForProviderManagedZoneSelectorPolicy
 */
export interface RecordSetSpecForProviderManagedZoneSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderManagedZoneSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderManagedZoneSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderManagedZoneSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderManagedZoneSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderManagedZoneSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderManagedZoneSelectorPolicy(obj: RecordSetSpecForProviderManagedZoneSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyGeo
 */
export interface RecordSetSpecForProviderRoutingPolicyGeo {
  /**
   * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
   * Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeo#healthCheckedTargets
   */
  readonly healthCheckedTargets?: RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets[];

  /**
   * The location name defined in Google Cloud.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeo#location
   */
  readonly location?: string;

  /**
   * Same as rrdatas above.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeo#rrdatas
   */
  readonly rrdatas?: string[];
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyGeo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyGeo(obj: RecordSetSpecForProviderRoutingPolicyGeo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckedTargets': obj.healthCheckedTargets?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets(y)),
    'location': obj.location,
    'rrdatas': obj.rrdatas?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a HealthCheck in compute to populate healthCheck.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckRef
 */
export interface RecordSetSpecForProviderRoutingPolicyHealthCheckRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckRef#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyHealthCheckRefPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyHealthCheckRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyHealthCheckRef(obj: RecordSetSpecForProviderRoutingPolicyHealthCheckRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyHealthCheckRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a HealthCheck in compute to populate healthCheck.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckSelector
 */
export interface RecordSetSpecForProviderRoutingPolicyHealthCheckSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckSelector#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyHealthCheckSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyHealthCheckSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyHealthCheckSelector(obj: RecordSetSpecForProviderRoutingPolicyHealthCheckSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyHealthCheckSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackup
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackup {
  /**
   * The backup geo targets, which provide a regional failover policy for the otherwise global primary targets.
   * Structure is document above.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackup#backupGeo
   */
  readonly backupGeo?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo[];

  /**
   * Specifies whether to enable fencing for backup geo queries.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackup#enableGeoFencingForBackups
   */
  readonly enableGeoFencingForBackups?: boolean;

  /**
   * The list of global primary targets to be health checked.
   * Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackup#primary
   */
  readonly primary?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary[];

  /**
   * Specifies the percentage of traffic to send to the backup targets even when the primary targets are healthy.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackup#trickleRatio
   */
  readonly trickleRatio?: number;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackup(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupGeo': obj.backupGeo?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo(y)),
    'enableGeoFencingForBackups': obj.enableGeoFencingForBackups,
    'primary': obj.primary?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary(y)),
    'trickleRatio': obj.trickleRatio,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyWrr
 */
export interface RecordSetSpecForProviderRoutingPolicyWrr {
  /**
   * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
   * Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrr#healthCheckedTargets
   */
  readonly healthCheckedTargets?: RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets[];

  /**
   * Same as rrdatas above.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrr#rrdatas
   */
  readonly rrdatas?: string[];

  /**
   * The ratio of traffic routed to the target.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrr#weight
   */
  readonly weight?: number;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyWrr' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyWrr(obj: RecordSetSpecForProviderRoutingPolicyWrr | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckedTargets': obj.healthCheckedTargets?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets(y)),
    'rrdatas': obj.rrdatas?.map(y => y),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecInitProviderManagedZoneRefPolicy
 */
export interface RecordSetSpecInitProviderManagedZoneRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecInitProviderManagedZoneRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecInitProviderManagedZoneRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecInitProviderManagedZoneRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecInitProviderManagedZoneRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderManagedZoneRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderManagedZoneRefPolicy(obj: RecordSetSpecInitProviderManagedZoneRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecInitProviderManagedZoneSelectorPolicy
 */
export interface RecordSetSpecInitProviderManagedZoneSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecInitProviderManagedZoneSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecInitProviderManagedZoneSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecInitProviderManagedZoneSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecInitProviderManagedZoneSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderManagedZoneSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderManagedZoneSelectorPolicy(obj: RecordSetSpecInitProviderManagedZoneSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecInitProviderRoutingPolicyGeo
 */
export interface RecordSetSpecInitProviderRoutingPolicyGeo {
  /**
   * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
   * Structure is document below.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyGeo#healthCheckedTargets
   */
  readonly healthCheckedTargets?: RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargets[];

  /**
   * The location name defined in Google Cloud.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyGeo#location
   */
  readonly location?: string;

  /**
   * Same as rrdatas above.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyGeo#rrdatas
   */
  readonly rrdatas?: string[];
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyGeo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyGeo(obj: RecordSetSpecInitProviderRoutingPolicyGeo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckedTargets': obj.healthCheckedTargets?.map(y => toJson_RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargets(y)),
    'location': obj.location,
    'rrdatas': obj.rrdatas?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a HealthCheck in compute to populate healthCheck.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckRef
 */
export interface RecordSetSpecInitProviderRoutingPolicyHealthCheckRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckRef#policy
   */
  readonly policy?: RecordSetSpecInitProviderRoutingPolicyHealthCheckRefPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyHealthCheckRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyHealthCheckRef(obj: RecordSetSpecInitProviderRoutingPolicyHealthCheckRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecInitProviderRoutingPolicyHealthCheckRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a HealthCheck in compute to populate healthCheck.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckSelector
 */
export interface RecordSetSpecInitProviderRoutingPolicyHealthCheckSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckSelector#policy
   */
  readonly policy?: RecordSetSpecInitProviderRoutingPolicyHealthCheckSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyHealthCheckSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyHealthCheckSelector(obj: RecordSetSpecInitProviderRoutingPolicyHealthCheckSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecInitProviderRoutingPolicyHealthCheckSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackup
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackup {
  /**
   * The backup geo targets, which provide a regional failover policy for the otherwise global primary targets.
   * Structure is document above.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackup#backupGeo
   */
  readonly backupGeo?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeo[];

  /**
   * Specifies whether to enable fencing for backup geo queries.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackup#enableGeoFencingForBackups
   */
  readonly enableGeoFencingForBackups?: boolean;

  /**
   * The list of global primary targets to be health checked.
   * Structure is document below.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackup#primary
   */
  readonly primary?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimary[];

  /**
   * Specifies the percentage of traffic to send to the backup targets even when the primary targets are healthy.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackup#trickleRatio
   */
  readonly trickleRatio?: number;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackup(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupGeo': obj.backupGeo?.map(y => toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeo(y)),
    'enableGeoFencingForBackups': obj.enableGeoFencingForBackups,
    'primary': obj.primary?.map(y => toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimary(y)),
    'trickleRatio': obj.trickleRatio,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecInitProviderRoutingPolicyWrr
 */
export interface RecordSetSpecInitProviderRoutingPolicyWrr {
  /**
   * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
   * Structure is document below.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyWrr#healthCheckedTargets
   */
  readonly healthCheckedTargets?: RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargets[];

  /**
   * Same as rrdatas above.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyWrr#rrdatas
   */
  readonly rrdatas?: string[];

  /**
   * The ratio of traffic routed to the target.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyWrr#weight
   */
  readonly weight?: number;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyWrr' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyWrr(obj: RecordSetSpecInitProviderRoutingPolicyWrr | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckedTargets': obj.healthCheckedTargets?.map(y => toJson_RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargets(y)),
    'rrdatas': obj.rrdatas?.map(y => y),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecProviderConfigRefPolicyResolution
 */
export enum RecordSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecProviderConfigRefPolicyResolve
 */
export enum RecordSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderManagedZoneRefPolicyResolution
 */
export enum RecordSetSpecForProviderManagedZoneRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderManagedZoneRefPolicyResolve
 */
export enum RecordSetSpecForProviderManagedZoneRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderManagedZoneSelectorPolicyResolution
 */
export enum RecordSetSpecForProviderManagedZoneSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderManagedZoneSelectorPolicyResolve
 */
export enum RecordSetSpecForProviderManagedZoneSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets
 */
export interface RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets(obj: RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckRefPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyHealthCheckRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyHealthCheckRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyHealthCheckRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyHealthCheckRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyHealthCheckRefPolicy(obj: RecordSetSpecForProviderRoutingPolicyHealthCheckRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckSelectorPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyHealthCheckSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyHealthCheckSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyHealthCheckSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyHealthCheckSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyHealthCheckSelectorPolicy(obj: RecordSetSpecForProviderRoutingPolicyHealthCheckSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo {
  /**
   * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
   * Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo#healthCheckedTargets
   */
  readonly healthCheckedTargets?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets[];

  /**
   * The location name defined in Google Cloud.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo#location
   */
  readonly location?: string;

  /**
   * Same as rrdatas above.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo#rrdatas
   */
  readonly rrdatas?: string[];
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckedTargets': obj.healthCheckedTargets?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets(y)),
    'location': obj.location,
    'rrdatas': obj.rrdatas?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets
 */
export interface RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets(obj: RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecInitProviderManagedZoneRefPolicyResolution
 */
export enum RecordSetSpecInitProviderManagedZoneRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecInitProviderManagedZoneRefPolicyResolve
 */
export enum RecordSetSpecInitProviderManagedZoneRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecInitProviderManagedZoneSelectorPolicyResolution
 */
export enum RecordSetSpecInitProviderManagedZoneSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecInitProviderManagedZoneSelectorPolicyResolve
 */
export enum RecordSetSpecInitProviderManagedZoneSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargets
 */
export interface RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargets {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargets#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is document below.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargets#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargets(obj: RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckRefPolicy
 */
export interface RecordSetSpecInitProviderRoutingPolicyHealthCheckRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecInitProviderRoutingPolicyHealthCheckRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecInitProviderRoutingPolicyHealthCheckRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyHealthCheckRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyHealthCheckRefPolicy(obj: RecordSetSpecInitProviderRoutingPolicyHealthCheckRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckSelectorPolicy
 */
export interface RecordSetSpecInitProviderRoutingPolicyHealthCheckSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecInitProviderRoutingPolicyHealthCheckSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecInitProviderRoutingPolicyHealthCheckSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyHealthCheckSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyHealthCheckSelectorPolicy(obj: RecordSetSpecInitProviderRoutingPolicyHealthCheckSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeo
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeo {
  /**
   * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
   * Structure is document below.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeo#healthCheckedTargets
   */
  readonly healthCheckedTargets?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets[];

  /**
   * The location name defined in Google Cloud.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeo#location
   */
  readonly location?: string;

  /**
   * Same as rrdatas above.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeo#rrdatas
   */
  readonly rrdatas?: string[];
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeo(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckedTargets': obj.healthCheckedTargets?.map(y => toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets(y)),
    'location': obj.location,
    'rrdatas': obj.rrdatas?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimary
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimary {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimary#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is document below.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimary#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimary' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimary(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargets
 */
export interface RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargets {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargets#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is document below.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargets#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargets(obj: RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers
 */
export interface RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#region
   */
  readonly region?: string;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers(obj: RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckRefPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyHealthCheckRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckRefPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyHealthCheckRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckSelectorPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyHealthCheckSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyHealthCheckSelectorPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyHealthCheckSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * Reference to a ForwardingRule in compute to populate ipAddress.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipAddressRef
   */
  readonly ipAddressRef?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef;

  /**
   * Selector for a ForwardingRule in compute to populate ipAddress.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipAddressSelector
   */
  readonly ipAddressSelector?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#networkUrlRef
   */
  readonly networkUrlRef?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#networkUrlSelector
   */
  readonly networkUrlSelector?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * Reference to a ForwardingRule in compute to populate project.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#projectRef
   */
  readonly projectRef?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef;

  /**
   * Selector for a ForwardingRule in compute to populate project.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#projectSelector
   */
  readonly projectSelector?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#region
   */
  readonly region?: string;

  /**
   * Reference to a ForwardingRule in compute to populate region.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#regionRef
   */
  readonly regionRef?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef;

  /**
   * Selector for a ForwardingRule in compute to populate region.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#regionSelector
   */
  readonly regionSelector?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipAddressRef': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef(obj.ipAddressRef),
    'ipAddressSelector': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector(obj.ipAddressSelector),
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'networkUrlRef': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef(obj.networkUrlRef),
    'networkUrlSelector': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector(obj.networkUrlSelector),
    'port': obj.port,
    'project': obj.project,
    'projectRef': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef(obj.projectRef),
    'projectSelector': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector(obj.projectSelector),
    'region': obj.region,
    'regionRef': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef(obj.regionRef),
    'regionSelector': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector(obj.regionSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers
 */
export interface RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#region
   */
  readonly region?: string;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers(obj: RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers
 */
export interface RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#region
   */
  readonly region?: string;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers(obj: RecordSetSpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckRefPolicyResolution
 */
export enum RecordSetSpecInitProviderRoutingPolicyHealthCheckRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckRefPolicyResolve
 */
export enum RecordSetSpecInitProviderRoutingPolicyHealthCheckRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckSelectorPolicyResolution
 */
export enum RecordSetSpecInitProviderRoutingPolicyHealthCheckSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyHealthCheckSelectorPolicyResolve
 */
export enum RecordSetSpecInitProviderRoutingPolicyHealthCheckSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is document below.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * Reference to a ForwardingRule in compute to populate ipAddress.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipAddressRef
   */
  readonly ipAddressRef?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef;

  /**
   * Selector for a ForwardingRule in compute to populate ipAddress.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipAddressSelector
   */
  readonly ipAddressSelector?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#networkUrlRef
   */
  readonly networkUrlRef?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#networkUrlSelector
   */
  readonly networkUrlSelector?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * Reference to a ForwardingRule in compute to populate project.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#projectRef
   */
  readonly projectRef?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef;

  /**
   * Selector for a ForwardingRule in compute to populate project.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#projectSelector
   */
  readonly projectSelector?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#region
   */
  readonly region?: string;

  /**
   * Reference to a ForwardingRule in compute to populate region.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#regionRef
   */
  readonly regionRef?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef;

  /**
   * Selector for a ForwardingRule in compute to populate region.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#regionSelector
   */
  readonly regionSelector?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipAddressRef': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef(obj.ipAddressRef),
    'ipAddressSelector': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector(obj.ipAddressSelector),
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'networkUrlRef': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef(obj.networkUrlRef),
    'networkUrlSelector': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector(obj.networkUrlSelector),
    'port': obj.port,
    'project': obj.project,
    'projectRef': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef(obj.projectRef),
    'projectSelector': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector(obj.projectSelector),
    'region': obj.region,
    'regionRef': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef(obj.regionRef),
    'regionSelector': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector(obj.regionSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers
 */
export interface RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#region
   */
  readonly region?: string;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers(obj: RecordSetSpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#region
   */
  readonly region?: string;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ForwardingRule in compute to populate ipAddress.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ForwardingRule in compute to populate ipAddress.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ForwardingRule in compute to populate project.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ForwardingRule in compute to populate project.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ForwardingRule in compute to populate region.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ForwardingRule in compute to populate region.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#region
   */
  readonly region?: string;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ForwardingRule in compute to populate ipAddress.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef#policy
   */
  readonly policy?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ForwardingRule in compute to populate ipAddress.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector#policy
   */
  readonly policy?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef#policy
   */
  readonly policy?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector#policy
   */
  readonly policy?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ForwardingRule in compute to populate project.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef#policy
   */
  readonly policy?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ForwardingRule in compute to populate project.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector#policy
   */
  readonly policy?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ForwardingRule in compute to populate region.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef#policy
   */
  readonly policy?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ForwardingRule in compute to populate region.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector#policy
   */
  readonly policy?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy
 */
export interface RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy(obj: RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolution
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolve
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolution
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolve
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolution
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolve
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolution
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolve
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolution
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolve
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolution
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolve
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolution
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolve
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolution
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolve
 */
export enum RecordSetSpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RecordSet is the Schema for the RecordSets API. Manages a set of DNS records within Google Cloud DNS.
 *
 * @schema RecordSetV1Beta2
 */
export class RecordSetV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RecordSetV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dns.gcp.upbound.io/v1beta2',
    kind: 'RecordSet',
  }

  /**
   * Renders a Kubernetes manifest for "RecordSetV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RecordSetV1Beta2Props): any {
    return {
      ...RecordSetV1Beta2.GVK,
      ...toJson_RecordSetV1Beta2Props(props),
    };
  }

  /**
   * Defines a "RecordSetV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RecordSetV1Beta2Props) {
    super(scope, id, {
      ...RecordSetV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...RecordSetV1Beta2.GVK,
      ...toJson_RecordSetV1Beta2Props(resolved),
    };
  }
}

/**
 * RecordSet is the Schema for the RecordSets API. Manages a set of DNS records within Google Cloud DNS.
 *
 * @schema RecordSetV1Beta2
 */
export interface RecordSetV1Beta2Props {
  /**
   * @schema RecordSetV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RecordSetSpec defines the desired state of RecordSet
   *
   * @schema RecordSetV1Beta2#spec
   */
  readonly spec: RecordSetV1Beta2Spec;
}

/**
 * Converts an object of type 'RecordSetV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2Props(obj: RecordSetV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RecordSetV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RecordSetSpec defines the desired state of RecordSet
 *
 * @schema RecordSetV1Beta2Spec
 */
export interface RecordSetV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RecordSetV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: RecordSetV1Beta2SpecDeletionPolicy;

  /**
   * @schema RecordSetV1Beta2Spec#forProvider
   */
  readonly forProvider: RecordSetV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema RecordSetV1Beta2Spec#initProvider
   */
  readonly initProvider?: RecordSetV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RecordSetV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: RecordSetV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema RecordSetV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: RecordSetV1Beta2SpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema RecordSetV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RecordSetV1Beta2SpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'RecordSetV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2Spec(obj: RecordSetV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RecordSetV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_RecordSetV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RecordSetV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_RecordSetV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RecordSetV1Beta2SpecDeletionPolicy
 */
export enum RecordSetV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RecordSetV1Beta2SpecForProvider
 */
export interface RecordSetV1Beta2SpecForProvider {
  /**
   * The name of the zone in which this record set will
   * reside.
   *
   * @schema RecordSetV1Beta2SpecForProvider#managedZone
   */
  readonly managedZone?: string;

  /**
   * Reference to a ManagedZone in dns to populate managedZone.
   *
   * @schema RecordSetV1Beta2SpecForProvider#managedZoneRef
   */
  readonly managedZoneRef?: RecordSetV1Beta2SpecForProviderManagedZoneRef;

  /**
   * Selector for a ManagedZone in dns to populate managedZone.
   *
   * @schema RecordSetV1Beta2SpecForProvider#managedZoneSelector
   */
  readonly managedZoneSelector?: RecordSetV1Beta2SpecForProviderManagedZoneSelector;

  /**
   * The DNS name this record set will apply to.
   *
   * @schema RecordSetV1Beta2SpecForProvider#name
   */
  readonly name?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetV1Beta2SpecForProvider#project
   */
  readonly project?: string;

  /**
   * The configuration for steering traffic based on query.
   * Now you can specify either Weighted Round Robin(WRR) type or Geolocation(GEO) type.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecForProvider#routingPolicy
   */
  readonly routingPolicy?: RecordSetV1Beta2SpecForProviderRoutingPolicy;

  /**
   * The string data for the records in this record set
   * whose meaning depends on the DNS type. For TXT record, if the string data contains spaces, add surrounding \" if you don't want your string to get split on spaces.g. "first255characters\" \"morecharacters").
   *
   * @schema RecordSetV1Beta2SpecForProvider#rrdatas
   */
  readonly rrdatas?: string[];

  /**
   * The time-to-live of this record set (seconds).
   *
   * @schema RecordSetV1Beta2SpecForProvider#ttl
   */
  readonly ttl?: number;

  /**
   * The DNS record set type.
   *
   * @schema RecordSetV1Beta2SpecForProvider#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProvider(obj: RecordSetV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'managedZone': obj.managedZone,
    'managedZoneRef': toJson_RecordSetV1Beta2SpecForProviderManagedZoneRef(obj.managedZoneRef),
    'managedZoneSelector': toJson_RecordSetV1Beta2SpecForProviderManagedZoneSelector(obj.managedZoneSelector),
    'name': obj.name,
    'project': obj.project,
    'routingPolicy': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicy(obj.routingPolicy),
    'rrdatas': obj.rrdatas?.map(y => y),
    'ttl': obj.ttl,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema RecordSetV1Beta2SpecInitProvider
 */
export interface RecordSetV1Beta2SpecInitProvider {
  /**
   * The name of the zone in which this record set will
   * reside.
   *
   * @schema RecordSetV1Beta2SpecInitProvider#managedZone
   */
  readonly managedZone?: string;

  /**
   * Reference to a ManagedZone in dns to populate managedZone.
   *
   * @schema RecordSetV1Beta2SpecInitProvider#managedZoneRef
   */
  readonly managedZoneRef?: RecordSetV1Beta2SpecInitProviderManagedZoneRef;

  /**
   * Selector for a ManagedZone in dns to populate managedZone.
   *
   * @schema RecordSetV1Beta2SpecInitProvider#managedZoneSelector
   */
  readonly managedZoneSelector?: RecordSetV1Beta2SpecInitProviderManagedZoneSelector;

  /**
   * The DNS name this record set will apply to.
   *
   * @schema RecordSetV1Beta2SpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetV1Beta2SpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The configuration for steering traffic based on query.
   * Now you can specify either Weighted Round Robin(WRR) type or Geolocation(GEO) type.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecInitProvider#routingPolicy
   */
  readonly routingPolicy?: RecordSetV1Beta2SpecInitProviderRoutingPolicy;

  /**
   * The string data for the records in this record set
   * whose meaning depends on the DNS type. For TXT record, if the string data contains spaces, add surrounding \" if you don't want your string to get split on spaces.g. "first255characters\" \"morecharacters").
   *
   * @schema RecordSetV1Beta2SpecInitProvider#rrdatas
   */
  readonly rrdatas?: string[];

  /**
   * The time-to-live of this record set (seconds).
   *
   * @schema RecordSetV1Beta2SpecInitProvider#ttl
   */
  readonly ttl?: number;

  /**
   * The DNS record set type.
   *
   * @schema RecordSetV1Beta2SpecInitProvider#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProvider(obj: RecordSetV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'managedZone': obj.managedZone,
    'managedZoneRef': toJson_RecordSetV1Beta2SpecInitProviderManagedZoneRef(obj.managedZoneRef),
    'managedZoneSelector': toJson_RecordSetV1Beta2SpecInitProviderManagedZoneSelector(obj.managedZoneSelector),
    'name': obj.name,
    'project': obj.project,
    'routingPolicy': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicy(obj.routingPolicy),
    'rrdatas': obj.rrdatas?.map(y => y),
    'ttl': obj.ttl,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema RecordSetV1Beta2SpecManagementPolicies
 */
export enum RecordSetV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema RecordSetV1Beta2SpecProviderConfigRef
 */
export interface RecordSetV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: RecordSetV1Beta2SpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecProviderConfigRef(obj: RecordSetV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema RecordSetV1Beta2SpecWriteConnectionSecretToRef
 */
export interface RecordSetV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RecordSetV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RecordSetV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecWriteConnectionSecretToRef(obj: RecordSetV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ManagedZone in dns to populate managedZone.
 *
 * @schema RecordSetV1Beta2SpecForProviderManagedZoneRef
 */
export interface RecordSetV1Beta2SpecForProviderManagedZoneRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetV1Beta2SpecForProviderManagedZoneRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetV1Beta2SpecForProviderManagedZoneRef#policy
   */
  readonly policy?: RecordSetV1Beta2SpecForProviderManagedZoneRefPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderManagedZoneRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderManagedZoneRef(obj: RecordSetV1Beta2SpecForProviderManagedZoneRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetV1Beta2SpecForProviderManagedZoneRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ManagedZone in dns to populate managedZone.
 *
 * @schema RecordSetV1Beta2SpecForProviderManagedZoneSelector
 */
export interface RecordSetV1Beta2SpecForProviderManagedZoneSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetV1Beta2SpecForProviderManagedZoneSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetV1Beta2SpecForProviderManagedZoneSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetV1Beta2SpecForProviderManagedZoneSelector#policy
   */
  readonly policy?: RecordSetV1Beta2SpecForProviderManagedZoneSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderManagedZoneSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderManagedZoneSelector(obj: RecordSetV1Beta2SpecForProviderManagedZoneSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetV1Beta2SpecForProviderManagedZoneSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration for steering traffic based on query.
 * Now you can specify either Weighted Round Robin(WRR) type or Geolocation(GEO) type.
 * Structure is documented below.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicy
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicy {
  /**
   * Specifies whether to enable fencing for geo queries.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicy#enableGeoFencing
   */
  readonly enableGeoFencing?: boolean;

  /**
   * The configuration for Geolocation based routing policy.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicy#geo
   */
  readonly geo?: RecordSetV1Beta2SpecForProviderRoutingPolicyGeo[];

  /**
   * Specifies the health check (used with external endpoints).
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicy#healthCheck
   */
  readonly healthCheck?: string;

  /**
   * Reference to a HealthCheck in compute to populate healthCheck.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicy#healthCheckRef
   */
  readonly healthCheckRef?: RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRef;

  /**
   * Selector for a HealthCheck in compute to populate healthCheck.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicy#healthCheckSelector
   */
  readonly healthCheckSelector?: RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelector;

  /**
   * The configuration for a failover policy with global to regional failover. Queries are responded to with the global primary targets, but if none of the primary targets are healthy, then we fallback to a regional failover policy.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicy#primaryBackup
   */
  readonly primaryBackup?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackup;

  /**
   * The configuration for Weighted Round Robin based routing policy.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicy#wrr
   */
  readonly wrr?: RecordSetV1Beta2SpecForProviderRoutingPolicyWrr[];
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicy(obj: RecordSetV1Beta2SpecForProviderRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableGeoFencing': obj.enableGeoFencing,
    'geo': obj.geo?.map(y => toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyGeo(y)),
    'healthCheck': obj.healthCheck,
    'healthCheckRef': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRef(obj.healthCheckRef),
    'healthCheckSelector': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelector(obj.healthCheckSelector),
    'primaryBackup': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackup(obj.primaryBackup),
    'wrr': obj.wrr?.map(y => toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyWrr(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ManagedZone in dns to populate managedZone.
 *
 * @schema RecordSetV1Beta2SpecInitProviderManagedZoneRef
 */
export interface RecordSetV1Beta2SpecInitProviderManagedZoneRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetV1Beta2SpecInitProviderManagedZoneRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetV1Beta2SpecInitProviderManagedZoneRef#policy
   */
  readonly policy?: RecordSetV1Beta2SpecInitProviderManagedZoneRefPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderManagedZoneRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderManagedZoneRef(obj: RecordSetV1Beta2SpecInitProviderManagedZoneRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetV1Beta2SpecInitProviderManagedZoneRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ManagedZone in dns to populate managedZone.
 *
 * @schema RecordSetV1Beta2SpecInitProviderManagedZoneSelector
 */
export interface RecordSetV1Beta2SpecInitProviderManagedZoneSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetV1Beta2SpecInitProviderManagedZoneSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetV1Beta2SpecInitProviderManagedZoneSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetV1Beta2SpecInitProviderManagedZoneSelector#policy
   */
  readonly policy?: RecordSetV1Beta2SpecInitProviderManagedZoneSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderManagedZoneSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderManagedZoneSelector(obj: RecordSetV1Beta2SpecInitProviderManagedZoneSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetV1Beta2SpecInitProviderManagedZoneSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration for steering traffic based on query.
 * Now you can specify either Weighted Round Robin(WRR) type or Geolocation(GEO) type.
 * Structure is documented below.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicy
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicy {
  /**
   * Specifies whether to enable fencing for geo queries.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicy#enableGeoFencing
   */
  readonly enableGeoFencing?: boolean;

  /**
   * The configuration for Geolocation based routing policy.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicy#geo
   */
  readonly geo?: RecordSetV1Beta2SpecInitProviderRoutingPolicyGeo[];

  /**
   * Specifies the health check (used with external endpoints).
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicy#healthCheck
   */
  readonly healthCheck?: string;

  /**
   * Reference to a HealthCheck in compute to populate healthCheck.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicy#healthCheckRef
   */
  readonly healthCheckRef?: RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRef;

  /**
   * Selector for a HealthCheck in compute to populate healthCheck.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicy#healthCheckSelector
   */
  readonly healthCheckSelector?: RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelector;

  /**
   * The configuration for a failover policy with global to regional failover. Queries are responded to with the global primary targets, but if none of the primary targets are healthy, then we fallback to a regional failover policy.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicy#primaryBackup
   */
  readonly primaryBackup?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackup;

  /**
   * The configuration for Weighted Round Robin based routing policy.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicy#wrr
   */
  readonly wrr?: RecordSetV1Beta2SpecInitProviderRoutingPolicyWrr[];
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicy(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableGeoFencing': obj.enableGeoFencing,
    'geo': obj.geo?.map(y => toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyGeo(y)),
    'healthCheck': obj.healthCheck,
    'healthCheckRef': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRef(obj.healthCheckRef),
    'healthCheckSelector': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelector(obj.healthCheckSelector),
    'primaryBackup': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackup(obj.primaryBackup),
    'wrr': obj.wrr?.map(y => toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyWrr(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetV1Beta2SpecProviderConfigRefPolicy
 */
export interface RecordSetV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecProviderConfigRefPolicy(obj: RecordSetV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetV1Beta2SpecForProviderManagedZoneRefPolicy
 */
export interface RecordSetV1Beta2SpecForProviderManagedZoneRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecForProviderManagedZoneRefPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecForProviderManagedZoneRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecForProviderManagedZoneRefPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecForProviderManagedZoneRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderManagedZoneRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderManagedZoneRefPolicy(obj: RecordSetV1Beta2SpecForProviderManagedZoneRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetV1Beta2SpecForProviderManagedZoneSelectorPolicy
 */
export interface RecordSetV1Beta2SpecForProviderManagedZoneSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecForProviderManagedZoneSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecForProviderManagedZoneSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecForProviderManagedZoneSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecForProviderManagedZoneSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderManagedZoneSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderManagedZoneSelectorPolicy(obj: RecordSetV1Beta2SpecForProviderManagedZoneSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyGeo
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyGeo {
  /**
   * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyGeo#healthCheckedTargets
   */
  readonly healthCheckedTargets?: RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargets;

  /**
   * The location name defined in Google Cloud.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyGeo#location
   */
  readonly location?: string;

  /**
   * Same as rrdatas above.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyGeo#rrdatas
   */
  readonly rrdatas?: string[];
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyGeo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyGeo(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyGeo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckedTargets': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargets(obj.healthCheckedTargets),
    'location': obj.location,
    'rrdatas': obj.rrdatas?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a HealthCheck in compute to populate healthCheck.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRef
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRef#policy
   */
  readonly policy?: RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRefPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRef(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a HealthCheck in compute to populate healthCheck.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelector
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelector#policy
   */
  readonly policy?: RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelector(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration for a failover policy with global to regional failover. Queries are responded to with the global primary targets, but if none of the primary targets are healthy, then we fallback to a regional failover policy.
 * Structure is documented below.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackup
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackup {
  /**
   * The backup geo targets, which provide a regional failover policy for the otherwise global primary targets.
   * Structure is document above.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackup#backupGeo
   */
  readonly backupGeo?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeo[];

  /**
   * Specifies whether to enable fencing for backup geo queries.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackup#enableGeoFencingForBackups
   */
  readonly enableGeoFencingForBackups?: boolean;

  /**
   * The list of global primary targets to be health checked.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackup#primary
   */
  readonly primary?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimary;

  /**
   * Specifies the percentage of traffic to send to the backup targets even when the primary targets are healthy.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackup#trickleRatio
   */
  readonly trickleRatio?: number;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackup(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupGeo': obj.backupGeo?.map(y => toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeo(y)),
    'enableGeoFencingForBackups': obj.enableGeoFencingForBackups,
    'primary': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimary(obj.primary),
    'trickleRatio': obj.trickleRatio,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyWrr
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyWrr {
  /**
   * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyWrr#healthCheckedTargets
   */
  readonly healthCheckedTargets?: RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargets;

  /**
   * Same as rrdatas above.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyWrr#rrdatas
   */
  readonly rrdatas?: string[];

  /**
   * The ratio of traffic routed to the target.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyWrr#weight
   */
  readonly weight?: number;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyWrr' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyWrr(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyWrr | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckedTargets': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargets(obj.healthCheckedTargets),
    'rrdatas': obj.rrdatas?.map(y => y),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetV1Beta2SpecInitProviderManagedZoneRefPolicy
 */
export interface RecordSetV1Beta2SpecInitProviderManagedZoneRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecInitProviderManagedZoneRefPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecInitProviderManagedZoneRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecInitProviderManagedZoneRefPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecInitProviderManagedZoneRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderManagedZoneRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderManagedZoneRefPolicy(obj: RecordSetV1Beta2SpecInitProviderManagedZoneRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetV1Beta2SpecInitProviderManagedZoneSelectorPolicy
 */
export interface RecordSetV1Beta2SpecInitProviderManagedZoneSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecInitProviderManagedZoneSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecInitProviderManagedZoneSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecInitProviderManagedZoneSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecInitProviderManagedZoneSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderManagedZoneSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderManagedZoneSelectorPolicy(obj: RecordSetV1Beta2SpecInitProviderManagedZoneSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyGeo
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyGeo {
  /**
   * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyGeo#healthCheckedTargets
   */
  readonly healthCheckedTargets?: RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargets;

  /**
   * The location name defined in Google Cloud.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyGeo#location
   */
  readonly location?: string;

  /**
   * Same as rrdatas above.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyGeo#rrdatas
   */
  readonly rrdatas?: string[];
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyGeo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyGeo(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyGeo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckedTargets': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargets(obj.healthCheckedTargets),
    'location': obj.location,
    'rrdatas': obj.rrdatas?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a HealthCheck in compute to populate healthCheck.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRef
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRef#policy
   */
  readonly policy?: RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRefPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRef(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a HealthCheck in compute to populate healthCheck.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelector
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelector#policy
   */
  readonly policy?: RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelector(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration for a failover policy with global to regional failover. Queries are responded to with the global primary targets, but if none of the primary targets are healthy, then we fallback to a regional failover policy.
 * Structure is documented below.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackup
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackup {
  /**
   * The backup geo targets, which provide a regional failover policy for the otherwise global primary targets.
   * Structure is document above.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackup#backupGeo
   */
  readonly backupGeo?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeo[];

  /**
   * Specifies whether to enable fencing for backup geo queries.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackup#enableGeoFencingForBackups
   */
  readonly enableGeoFencingForBackups?: boolean;

  /**
   * The list of global primary targets to be health checked.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackup#primary
   */
  readonly primary?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimary;

  /**
   * Specifies the percentage of traffic to send to the backup targets even when the primary targets are healthy.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackup#trickleRatio
   */
  readonly trickleRatio?: number;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackup(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupGeo': obj.backupGeo?.map(y => toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeo(y)),
    'enableGeoFencingForBackups': obj.enableGeoFencingForBackups,
    'primary': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimary(obj.primary),
    'trickleRatio': obj.trickleRatio,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyWrr
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyWrr {
  /**
   * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyWrr#healthCheckedTargets
   */
  readonly healthCheckedTargets?: RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargets;

  /**
   * Same as rrdatas above.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyWrr#rrdatas
   */
  readonly rrdatas?: string[];

  /**
   * The ratio of traffic routed to the target.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyWrr#weight
   */
  readonly weight?: number;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyWrr' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyWrr(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyWrr | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckedTargets': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargets(obj.healthCheckedTargets),
    'rrdatas': obj.rrdatas?.map(y => y),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum RecordSetV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum RecordSetV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecForProviderManagedZoneRefPolicyResolution
 */
export enum RecordSetV1Beta2SpecForProviderManagedZoneRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecForProviderManagedZoneRefPolicyResolve
 */
export enum RecordSetV1Beta2SpecForProviderManagedZoneRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecForProviderManagedZoneSelectorPolicyResolution
 */
export enum RecordSetV1Beta2SpecForProviderManagedZoneSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecForProviderManagedZoneSelectorPolicyResolve
 */
export enum RecordSetV1Beta2SpecForProviderManagedZoneSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
 * Structure is documented below.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargets
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargets {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargets#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargets#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargets(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRefPolicy
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRefPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRefPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRefPolicy(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelectorPolicy
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelectorPolicy(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeo
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeo {
  /**
   * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeo#healthCheckedTargets
   */
  readonly healthCheckedTargets?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets;

  /**
   * The location name defined in Google Cloud.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeo#location
   */
  readonly location?: string;

  /**
   * Same as rrdatas above.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeo#rrdatas
   */
  readonly rrdatas?: string[];
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeo(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckedTargets': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets(obj.healthCheckedTargets),
    'location': obj.location,
    'rrdatas': obj.rrdatas?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The list of global primary targets to be health checked.
 * Structure is documented below.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimary
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimary {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimary#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimary#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimary' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimary(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
 * Structure is documented below.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargets
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargets {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargets#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargets#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargets(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecInitProviderManagedZoneRefPolicyResolution
 */
export enum RecordSetV1Beta2SpecInitProviderManagedZoneRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecInitProviderManagedZoneRefPolicyResolve
 */
export enum RecordSetV1Beta2SpecInitProviderManagedZoneRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecInitProviderManagedZoneSelectorPolicyResolution
 */
export enum RecordSetV1Beta2SpecInitProviderManagedZoneSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecInitProviderManagedZoneSelectorPolicyResolve
 */
export enum RecordSetV1Beta2SpecInitProviderManagedZoneSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
 * Structure is documented below.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargets
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargets {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargets#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargets#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargets(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRefPolicy
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRefPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRefPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRefPolicy(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelectorPolicy
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelectorPolicy(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeo
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeo {
  /**
   * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeo#healthCheckedTargets
   */
  readonly healthCheckedTargets?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets;

  /**
   * The location name defined in Google Cloud.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeo#location
   */
  readonly location?: string;

  /**
   * Same as rrdatas above.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeo#rrdatas
   */
  readonly rrdatas?: string[];
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeo(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckedTargets': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets(obj.healthCheckedTargets),
    'location': obj.location,
    'rrdatas': obj.rrdatas?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The list of global primary targets to be health checked.
 * Structure is documented below.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimary
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimary {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimary#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimary#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimary' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimary(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
 * Structure is documented below.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargets
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargets {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargets#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargets#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargets(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#region
   */
  readonly region?: string;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRefPolicyResolution
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRefPolicyResolve
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelectorPolicyResolution
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelectorPolicyResolve
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyHealthCheckSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
 * Structure is documented below.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * Reference to a ForwardingRule in compute to populate ipAddress.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipAddressRef
   */
  readonly ipAddressRef?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef;

  /**
   * Selector for a ForwardingRule in compute to populate ipAddress.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipAddressSelector
   */
  readonly ipAddressSelector?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#networkUrlRef
   */
  readonly networkUrlRef?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#networkUrlSelector
   */
  readonly networkUrlSelector?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * Reference to a ForwardingRule in compute to populate project.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#projectRef
   */
  readonly projectRef?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef;

  /**
   * Selector for a ForwardingRule in compute to populate project.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#projectSelector
   */
  readonly projectSelector?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#region
   */
  readonly region?: string;

  /**
   * Reference to a ForwardingRule in compute to populate region.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#regionRef
   */
  readonly regionRef?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef;

  /**
   * Selector for a ForwardingRule in compute to populate region.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#regionSelector
   */
  readonly regionSelector?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipAddressRef': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef(obj.ipAddressRef),
    'ipAddressSelector': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector(obj.ipAddressSelector),
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'networkUrlRef': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef(obj.networkUrlRef),
    'networkUrlSelector': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector(obj.networkUrlSelector),
    'port': obj.port,
    'project': obj.project,
    'projectRef': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef(obj.projectRef),
    'projectSelector': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector(obj.projectSelector),
    'region': obj.region,
    'regionRef': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef(obj.regionRef),
    'regionSelector': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector(obj.regionSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#region
   */
  readonly region?: string;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#region
   */
  readonly region?: string;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRefPolicyResolution
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRefPolicyResolve
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelectorPolicyResolution
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelectorPolicyResolve
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyHealthCheckSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set.
 * Structure is documented below.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets {
  /**
   * The list of external endpoint addresses to health check.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets#externalEndpoints
   */
  readonly externalEndpoints?: string[];

  /**
   * The list of internal load balancers to health check.
   * Structure is documented below.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets#internalLoadBalancers
   */
  readonly internalLoadBalancers?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers[];
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalEndpoints': obj.externalEndpoints?.map(y => y),
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * Reference to a ForwardingRule in compute to populate ipAddress.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipAddressRef
   */
  readonly ipAddressRef?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef;

  /**
   * Selector for a ForwardingRule in compute to populate ipAddress.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipAddressSelector
   */
  readonly ipAddressSelector?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#networkUrlRef
   */
  readonly networkUrlRef?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#networkUrlSelector
   */
  readonly networkUrlSelector?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * Reference to a ForwardingRule in compute to populate project.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#projectRef
   */
  readonly projectRef?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef;

  /**
   * Selector for a ForwardingRule in compute to populate project.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#projectSelector
   */
  readonly projectSelector?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#region
   */
  readonly region?: string;

  /**
   * Reference to a ForwardingRule in compute to populate region.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#regionRef
   */
  readonly regionRef?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef;

  /**
   * Selector for a ForwardingRule in compute to populate region.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#regionSelector
   */
  readonly regionSelector?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipAddressRef': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef(obj.ipAddressRef),
    'ipAddressSelector': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector(obj.ipAddressSelector),
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'networkUrlRef': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef(obj.networkUrlRef),
    'networkUrlSelector': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector(obj.networkUrlSelector),
    'port': obj.port,
    'project': obj.project,
    'projectRef': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef(obj.projectRef),
    'projectSelector': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector(obj.projectSelector),
    'region': obj.region,
    'regionRef': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef(obj.regionRef),
    'regionSelector': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector(obj.regionSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#region
   */
  readonly region?: string;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#region
   */
  readonly region?: string;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ForwardingRule in compute to populate ipAddress.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef#policy
   */
  readonly policy?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ForwardingRule in compute to populate ipAddress.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector#policy
   */
  readonly policy?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef#policy
   */
  readonly policy?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector#policy
   */
  readonly policy?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ForwardingRule in compute to populate project.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef#policy
   */
  readonly policy?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ForwardingRule in compute to populate project.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector#policy
   */
  readonly policy?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ForwardingRule in compute to populate region.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef#policy
   */
  readonly policy?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ForwardingRule in compute to populate region.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector#policy
   */
  readonly policy?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#port
   */
  readonly port?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#region
   */
  readonly region?: string;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ForwardingRule in compute to populate ipAddress.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef#policy
   */
  readonly policy?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ForwardingRule in compute to populate ipAddress.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector#policy
   */
  readonly policy?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef#policy
   */
  readonly policy?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector#policy
   */
  readonly policy?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ForwardingRule in compute to populate project.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef#policy
   */
  readonly policy?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ForwardingRule in compute to populate project.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector#policy
   */
  readonly policy?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ForwardingRule in compute to populate region.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef#policy
   */
  readonly policy?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ForwardingRule in compute to populate region.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector#policy
   */
  readonly policy?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy
 */
export interface RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy(obj: RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy
 */
export interface RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolve;
}

/**
 * Converts an object of type 'RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy(obj: RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolution
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolve
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolution
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolve
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolution
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolve
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolution
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolve
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolution
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolve
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolution
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolve
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolution
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolve
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolution
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolve
 */
export enum RecordSetV1Beta2SpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolution
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolve
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolution
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolve
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolution
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolve
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolution
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolve
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolution
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolve
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolution
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolve
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolution
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolve
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolution
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolve
 */
export enum RecordSetV1Beta2SpecInitProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

