// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Address is the Schema for the Addresss API. Represents an Address resource.
 *
 * @schema Address
 */
export class Address extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Address"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.gcp.upbound.io/v1beta1',
    kind: 'Address',
  }

  /**
   * Renders a Kubernetes manifest for "Address".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AddressProps): any {
    return {
      ...Address.GVK,
      ...toJson_AddressProps(props),
    };
  }

  /**
   * Defines a "Address" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AddressProps) {
    super(scope, id, {
      ...Address.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Address.GVK,
      ...toJson_AddressProps(resolved),
    };
  }
}

/**
 * Address is the Schema for the Addresss API. Represents an Address resource.
 *
 * @schema Address
 */
export interface AddressProps {
  /**
   * @schema Address#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AddressSpec defines the desired state of Address
   *
   * @schema Address#spec
   */
  readonly spec: AddressSpec;
}

/**
 * Converts an object of type 'AddressProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressProps(obj: AddressProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AddressSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AddressSpec defines the desired state of Address
 *
 * @schema AddressSpec
 */
export interface AddressSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AddressSpec#deletionPolicy
   */
  readonly deletionPolicy?: AddressSpecDeletionPolicy;

  /**
   * @schema AddressSpec#forProvider
   */
  readonly forProvider: AddressSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema AddressSpec#initProvider
   */
  readonly initProvider?: AddressSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AddressSpec#managementPolicies
   */
  readonly managementPolicies?: AddressSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema AddressSpec#providerConfigRef
   */
  readonly providerConfigRef?: AddressSpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema AddressSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AddressSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'AddressSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpec(obj: AddressSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AddressSpecForProvider(obj.forProvider),
    'initProvider': toJson_AddressSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AddressSpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_AddressSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AddressSpecDeletionPolicy
 */
export enum AddressSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AddressSpecForProvider
 */
export interface AddressSpecForProvider {
  /**
   * The static external IP address represented by this resource.
   * The IP address must be inside the specified subnetwork,
   * if any. Set by the API if undefined.
   *
   * @schema AddressSpecForProvider#address
   */
  readonly address?: string;

  /**
   * The type of address to reserve.
   * Note: if you set this argument's value as INTERNAL you need to leave the network_tier argument unset in that resource block.
   * Default value is EXTERNAL.
   * Possible values are: INTERNAL, EXTERNAL.
   *
   * @schema AddressSpecForProvider#addressType
   */
  readonly addressType?: string;

  /**
   * An optional description of this resource.
   *
   * @schema AddressSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The IP Version that will be used by this address. The default value is IPV4.
   * Possible values are: IPV4, IPV6.
   *
   * @schema AddressSpecForProvider#ipVersion
   */
  readonly ipVersion?: string;

  /**
   * The endpoint type of this address, which should be VM or NETLB. This is
   * used for deciding which type of endpoint this address can be used after
   * the external IPv6 address reservation.
   * Possible values are: VM, NETLB.
   *
   * @schema AddressSpecForProvider#ipv6EndpointType
   */
  readonly ipv6EndpointType?: string;

  /**
   * Labels to apply to this address.  A list of key->value pairs.
   *
   * @schema AddressSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The URL of the network in which to reserve the address. This field
   * can only be used with INTERNAL type with the VPC_PEERING and
   * IPSEC_INTERCONNECT purposes.
   *
   * @schema AddressSpecForProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema AddressSpecForProvider#networkRef
   */
  readonly networkRef?: AddressSpecForProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema AddressSpecForProvider#networkSelector
   */
  readonly networkSelector?: AddressSpecForProviderNetworkSelector;

  /**
   * The networking tier used for configuring this address. If this field is not
   * specified, it is assumed to be PREMIUM.
   * This argument should not be used when configuring Internal addresses, because network tier cannot be set for internal traffic; it's always Premium.
   * Possible values are: PREMIUM, STANDARD.
   *
   * @schema AddressSpecForProvider#networkTier
   */
  readonly networkTier?: string;

  /**
   * The prefix length if the resource represents an IP range.
   *
   * @schema AddressSpecForProvider#prefixLength
   */
  readonly prefixLength?: number;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema AddressSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The purpose of this resource, which can be one of the following values.
   *
   * @schema AddressSpecForProvider#purpose
   */
  readonly purpose?: string;

  /**
   * The Region in which the created address should reside.
   * If it is not provided, the provider region is used.
   *
   * @schema AddressSpecForProvider#region
   */
  readonly region: string;

  /**
   * The URL of the subnetwork in which to reserve the address. If an IP
   * address is specified, it must be within the subnetwork's IP range.
   * This field can only be used with INTERNAL type with
   * GCE_ENDPOINT/DNS_RESOLVER purposes.
   *
   * @schema AddressSpecForProvider#subnetwork
   */
  readonly subnetwork?: string;

  /**
   * Reference to a Subnetwork in compute to populate subnetwork.
   *
   * @schema AddressSpecForProvider#subnetworkRef
   */
  readonly subnetworkRef?: AddressSpecForProviderSubnetworkRef;

  /**
   * Selector for a Subnetwork in compute to populate subnetwork.
   *
   * @schema AddressSpecForProvider#subnetworkSelector
   */
  readonly subnetworkSelector?: AddressSpecForProviderSubnetworkSelector;
}

/**
 * Converts an object of type 'AddressSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecForProvider(obj: AddressSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'addressType': obj.addressType,
    'description': obj.description,
    'ipVersion': obj.ipVersion,
    'ipv6EndpointType': obj.ipv6EndpointType,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'network': obj.network,
    'networkRef': toJson_AddressSpecForProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_AddressSpecForProviderNetworkSelector(obj.networkSelector),
    'networkTier': obj.networkTier,
    'prefixLength': obj.prefixLength,
    'project': obj.project,
    'purpose': obj.purpose,
    'region': obj.region,
    'subnetwork': obj.subnetwork,
    'subnetworkRef': toJson_AddressSpecForProviderSubnetworkRef(obj.subnetworkRef),
    'subnetworkSelector': toJson_AddressSpecForProviderSubnetworkSelector(obj.subnetworkSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema AddressSpecInitProvider
 */
export interface AddressSpecInitProvider {
  /**
   * The static external IP address represented by this resource.
   * The IP address must be inside the specified subnetwork,
   * if any. Set by the API if undefined.
   *
   * @schema AddressSpecInitProvider#address
   */
  readonly address?: string;

  /**
   * The type of address to reserve.
   * Note: if you set this argument's value as INTERNAL you need to leave the network_tier argument unset in that resource block.
   * Default value is EXTERNAL.
   * Possible values are: INTERNAL, EXTERNAL.
   *
   * @schema AddressSpecInitProvider#addressType
   */
  readonly addressType?: string;

  /**
   * An optional description of this resource.
   *
   * @schema AddressSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The IP Version that will be used by this address. The default value is IPV4.
   * Possible values are: IPV4, IPV6.
   *
   * @schema AddressSpecInitProvider#ipVersion
   */
  readonly ipVersion?: string;

  /**
   * The endpoint type of this address, which should be VM or NETLB. This is
   * used for deciding which type of endpoint this address can be used after
   * the external IPv6 address reservation.
   * Possible values are: VM, NETLB.
   *
   * @schema AddressSpecInitProvider#ipv6EndpointType
   */
  readonly ipv6EndpointType?: string;

  /**
   * Labels to apply to this address.  A list of key->value pairs.
   *
   * @schema AddressSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The URL of the network in which to reserve the address. This field
   * can only be used with INTERNAL type with the VPC_PEERING and
   * IPSEC_INTERCONNECT purposes.
   *
   * @schema AddressSpecInitProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema AddressSpecInitProvider#networkRef
   */
  readonly networkRef?: AddressSpecInitProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema AddressSpecInitProvider#networkSelector
   */
  readonly networkSelector?: AddressSpecInitProviderNetworkSelector;

  /**
   * The networking tier used for configuring this address. If this field is not
   * specified, it is assumed to be PREMIUM.
   * This argument should not be used when configuring Internal addresses, because network tier cannot be set for internal traffic; it's always Premium.
   * Possible values are: PREMIUM, STANDARD.
   *
   * @schema AddressSpecInitProvider#networkTier
   */
  readonly networkTier?: string;

  /**
   * The prefix length if the resource represents an IP range.
   *
   * @schema AddressSpecInitProvider#prefixLength
   */
  readonly prefixLength?: number;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema AddressSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The purpose of this resource, which can be one of the following values.
   *
   * @schema AddressSpecInitProvider#purpose
   */
  readonly purpose?: string;

  /**
   * The URL of the subnetwork in which to reserve the address. If an IP
   * address is specified, it must be within the subnetwork's IP range.
   * This field can only be used with INTERNAL type with
   * GCE_ENDPOINT/DNS_RESOLVER purposes.
   *
   * @schema AddressSpecInitProvider#subnetwork
   */
  readonly subnetwork?: string;

  /**
   * Reference to a Subnetwork in compute to populate subnetwork.
   *
   * @schema AddressSpecInitProvider#subnetworkRef
   */
  readonly subnetworkRef?: AddressSpecInitProviderSubnetworkRef;

  /**
   * Selector for a Subnetwork in compute to populate subnetwork.
   *
   * @schema AddressSpecInitProvider#subnetworkSelector
   */
  readonly subnetworkSelector?: AddressSpecInitProviderSubnetworkSelector;
}

/**
 * Converts an object of type 'AddressSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecInitProvider(obj: AddressSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'addressType': obj.addressType,
    'description': obj.description,
    'ipVersion': obj.ipVersion,
    'ipv6EndpointType': obj.ipv6EndpointType,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'network': obj.network,
    'networkRef': toJson_AddressSpecInitProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_AddressSpecInitProviderNetworkSelector(obj.networkSelector),
    'networkTier': obj.networkTier,
    'prefixLength': obj.prefixLength,
    'project': obj.project,
    'purpose': obj.purpose,
    'subnetwork': obj.subnetwork,
    'subnetworkRef': toJson_AddressSpecInitProviderSubnetworkRef(obj.subnetworkRef),
    'subnetworkSelector': toJson_AddressSpecInitProviderSubnetworkSelector(obj.subnetworkSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema AddressSpecManagementPolicies
 */
export enum AddressSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema AddressSpecProviderConfigRef
 */
export interface AddressSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AddressSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AddressSpecProviderConfigRef#policy
   */
  readonly policy?: AddressSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'AddressSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecProviderConfigRef(obj: AddressSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AddressSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema AddressSpecWriteConnectionSecretToRef
 */
export interface AddressSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AddressSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AddressSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'AddressSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecWriteConnectionSecretToRef(obj: AddressSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema AddressSpecForProviderNetworkRef
 */
export interface AddressSpecForProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema AddressSpecForProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AddressSpecForProviderNetworkRef#policy
   */
  readonly policy?: AddressSpecForProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'AddressSpecForProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecForProviderNetworkRef(obj: AddressSpecForProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AddressSpecForProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema AddressSpecForProviderNetworkSelector
 */
export interface AddressSpecForProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema AddressSpecForProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AddressSpecForProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AddressSpecForProviderNetworkSelector#policy
   */
  readonly policy?: AddressSpecForProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'AddressSpecForProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecForProviderNetworkSelector(obj: AddressSpecForProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AddressSpecForProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Subnetwork in compute to populate subnetwork.
 *
 * @schema AddressSpecForProviderSubnetworkRef
 */
export interface AddressSpecForProviderSubnetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema AddressSpecForProviderSubnetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AddressSpecForProviderSubnetworkRef#policy
   */
  readonly policy?: AddressSpecForProviderSubnetworkRefPolicy;
}

/**
 * Converts an object of type 'AddressSpecForProviderSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecForProviderSubnetworkRef(obj: AddressSpecForProviderSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AddressSpecForProviderSubnetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Subnetwork in compute to populate subnetwork.
 *
 * @schema AddressSpecForProviderSubnetworkSelector
 */
export interface AddressSpecForProviderSubnetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema AddressSpecForProviderSubnetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AddressSpecForProviderSubnetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AddressSpecForProviderSubnetworkSelector#policy
   */
  readonly policy?: AddressSpecForProviderSubnetworkSelectorPolicy;
}

/**
 * Converts an object of type 'AddressSpecForProviderSubnetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecForProviderSubnetworkSelector(obj: AddressSpecForProviderSubnetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AddressSpecForProviderSubnetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema AddressSpecInitProviderNetworkRef
 */
export interface AddressSpecInitProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema AddressSpecInitProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AddressSpecInitProviderNetworkRef#policy
   */
  readonly policy?: AddressSpecInitProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'AddressSpecInitProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecInitProviderNetworkRef(obj: AddressSpecInitProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AddressSpecInitProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema AddressSpecInitProviderNetworkSelector
 */
export interface AddressSpecInitProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema AddressSpecInitProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AddressSpecInitProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AddressSpecInitProviderNetworkSelector#policy
   */
  readonly policy?: AddressSpecInitProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'AddressSpecInitProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecInitProviderNetworkSelector(obj: AddressSpecInitProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AddressSpecInitProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Subnetwork in compute to populate subnetwork.
 *
 * @schema AddressSpecInitProviderSubnetworkRef
 */
export interface AddressSpecInitProviderSubnetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema AddressSpecInitProviderSubnetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AddressSpecInitProviderSubnetworkRef#policy
   */
  readonly policy?: AddressSpecInitProviderSubnetworkRefPolicy;
}

/**
 * Converts an object of type 'AddressSpecInitProviderSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecInitProviderSubnetworkRef(obj: AddressSpecInitProviderSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AddressSpecInitProviderSubnetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Subnetwork in compute to populate subnetwork.
 *
 * @schema AddressSpecInitProviderSubnetworkSelector
 */
export interface AddressSpecInitProviderSubnetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema AddressSpecInitProviderSubnetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AddressSpecInitProviderSubnetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AddressSpecInitProviderSubnetworkSelector#policy
   */
  readonly policy?: AddressSpecInitProviderSubnetworkSelectorPolicy;
}

/**
 * Converts an object of type 'AddressSpecInitProviderSubnetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecInitProviderSubnetworkSelector(obj: AddressSpecInitProviderSubnetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AddressSpecInitProviderSubnetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema AddressSpecProviderConfigRefPolicy
 */
export interface AddressSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema AddressSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AddressSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema AddressSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AddressSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'AddressSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecProviderConfigRefPolicy(obj: AddressSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema AddressSpecForProviderNetworkRefPolicy
 */
export interface AddressSpecForProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema AddressSpecForProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: AddressSpecForProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema AddressSpecForProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: AddressSpecForProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'AddressSpecForProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecForProviderNetworkRefPolicy(obj: AddressSpecForProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema AddressSpecForProviderNetworkSelectorPolicy
 */
export interface AddressSpecForProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema AddressSpecForProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: AddressSpecForProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema AddressSpecForProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: AddressSpecForProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'AddressSpecForProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecForProviderNetworkSelectorPolicy(obj: AddressSpecForProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema AddressSpecForProviderSubnetworkRefPolicy
 */
export interface AddressSpecForProviderSubnetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema AddressSpecForProviderSubnetworkRefPolicy#resolution
   */
  readonly resolution?: AddressSpecForProviderSubnetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema AddressSpecForProviderSubnetworkRefPolicy#resolve
   */
  readonly resolve?: AddressSpecForProviderSubnetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'AddressSpecForProviderSubnetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecForProviderSubnetworkRefPolicy(obj: AddressSpecForProviderSubnetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema AddressSpecForProviderSubnetworkSelectorPolicy
 */
export interface AddressSpecForProviderSubnetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema AddressSpecForProviderSubnetworkSelectorPolicy#resolution
   */
  readonly resolution?: AddressSpecForProviderSubnetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema AddressSpecForProviderSubnetworkSelectorPolicy#resolve
   */
  readonly resolve?: AddressSpecForProviderSubnetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'AddressSpecForProviderSubnetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecForProviderSubnetworkSelectorPolicy(obj: AddressSpecForProviderSubnetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema AddressSpecInitProviderNetworkRefPolicy
 */
export interface AddressSpecInitProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema AddressSpecInitProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: AddressSpecInitProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema AddressSpecInitProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: AddressSpecInitProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'AddressSpecInitProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecInitProviderNetworkRefPolicy(obj: AddressSpecInitProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema AddressSpecInitProviderNetworkSelectorPolicy
 */
export interface AddressSpecInitProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema AddressSpecInitProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: AddressSpecInitProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema AddressSpecInitProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: AddressSpecInitProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'AddressSpecInitProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecInitProviderNetworkSelectorPolicy(obj: AddressSpecInitProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema AddressSpecInitProviderSubnetworkRefPolicy
 */
export interface AddressSpecInitProviderSubnetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema AddressSpecInitProviderSubnetworkRefPolicy#resolution
   */
  readonly resolution?: AddressSpecInitProviderSubnetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema AddressSpecInitProviderSubnetworkRefPolicy#resolve
   */
  readonly resolve?: AddressSpecInitProviderSubnetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'AddressSpecInitProviderSubnetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecInitProviderSubnetworkRefPolicy(obj: AddressSpecInitProviderSubnetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema AddressSpecInitProviderSubnetworkSelectorPolicy
 */
export interface AddressSpecInitProviderSubnetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema AddressSpecInitProviderSubnetworkSelectorPolicy#resolution
   */
  readonly resolution?: AddressSpecInitProviderSubnetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema AddressSpecInitProviderSubnetworkSelectorPolicy#resolve
   */
  readonly resolve?: AddressSpecInitProviderSubnetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'AddressSpecInitProviderSubnetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AddressSpecInitProviderSubnetworkSelectorPolicy(obj: AddressSpecInitProviderSubnetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema AddressSpecProviderConfigRefPolicyResolution
 */
export enum AddressSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema AddressSpecProviderConfigRefPolicyResolve
 */
export enum AddressSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema AddressSpecForProviderNetworkRefPolicyResolution
 */
export enum AddressSpecForProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema AddressSpecForProviderNetworkRefPolicyResolve
 */
export enum AddressSpecForProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema AddressSpecForProviderNetworkSelectorPolicyResolution
 */
export enum AddressSpecForProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema AddressSpecForProviderNetworkSelectorPolicyResolve
 */
export enum AddressSpecForProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema AddressSpecForProviderSubnetworkRefPolicyResolution
 */
export enum AddressSpecForProviderSubnetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema AddressSpecForProviderSubnetworkRefPolicyResolve
 */
export enum AddressSpecForProviderSubnetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema AddressSpecForProviderSubnetworkSelectorPolicyResolution
 */
export enum AddressSpecForProviderSubnetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema AddressSpecForProviderSubnetworkSelectorPolicyResolve
 */
export enum AddressSpecForProviderSubnetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema AddressSpecInitProviderNetworkRefPolicyResolution
 */
export enum AddressSpecInitProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema AddressSpecInitProviderNetworkRefPolicyResolve
 */
export enum AddressSpecInitProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema AddressSpecInitProviderNetworkSelectorPolicyResolution
 */
export enum AddressSpecInitProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema AddressSpecInitProviderNetworkSelectorPolicyResolve
 */
export enum AddressSpecInitProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema AddressSpecInitProviderSubnetworkRefPolicyResolution
 */
export enum AddressSpecInitProviderSubnetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema AddressSpecInitProviderSubnetworkRefPolicyResolve
 */
export enum AddressSpecInitProviderSubnetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema AddressSpecInitProviderSubnetworkSelectorPolicyResolution
 */
export enum AddressSpecInitProviderSubnetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema AddressSpecInitProviderSubnetworkSelectorPolicyResolve
 */
export enum AddressSpecInitProviderSubnetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Firewall is the Schema for the Firewalls API. Each network has its own firewall controlling access to and from the instances.
 *
 * @schema Firewall
 */
export class Firewall extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Firewall"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.gcp.upbound.io/v1beta1',
    kind: 'Firewall',
  }

  /**
   * Renders a Kubernetes manifest for "Firewall".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FirewallProps): any {
    return {
      ...Firewall.GVK,
      ...toJson_FirewallProps(props),
    };
  }

  /**
   * Defines a "Firewall" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FirewallProps) {
    super(scope, id, {
      ...Firewall.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Firewall.GVK,
      ...toJson_FirewallProps(resolved),
    };
  }
}

/**
 * Firewall is the Schema for the Firewalls API. Each network has its own firewall controlling access to and from the instances.
 *
 * @schema Firewall
 */
export interface FirewallProps {
  /**
   * @schema Firewall#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FirewallSpec defines the desired state of Firewall
   *
   * @schema Firewall#spec
   */
  readonly spec: FirewallSpec;
}

/**
 * Converts an object of type 'FirewallProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallProps(obj: FirewallProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FirewallSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FirewallSpec defines the desired state of Firewall
 *
 * @schema FirewallSpec
 */
export interface FirewallSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FirewallSpec#deletionPolicy
   */
  readonly deletionPolicy?: FirewallSpecDeletionPolicy;

  /**
   * @schema FirewallSpec#forProvider
   */
  readonly forProvider: FirewallSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema FirewallSpec#initProvider
   */
  readonly initProvider?: FirewallSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FirewallSpec#managementPolicies
   */
  readonly managementPolicies?: FirewallSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema FirewallSpec#providerConfigRef
   */
  readonly providerConfigRef?: FirewallSpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema FirewallSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FirewallSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'FirewallSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpec(obj: FirewallSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FirewallSpecForProvider(obj.forProvider),
    'initProvider': toJson_FirewallSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FirewallSpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_FirewallSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FirewallSpecDeletionPolicy
 */
export enum FirewallSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FirewallSpecForProvider
 */
export interface FirewallSpecForProvider {
  /**
   * The list of ALLOW rules specified by this firewall. Each rule
   * specifies a protocol and port-range tuple that describes a permitted
   * connection.
   * Structure is documented below.
   *
   * @schema FirewallSpecForProvider#allow
   */
  readonly allow?: FirewallSpecForProviderAllow[];

  /**
   * The list of DENY rules specified by this firewall. Each rule specifies
   * a protocol and port-range tuple that describes a denied connection.
   * Structure is documented below.
   *
   * @schema FirewallSpecForProvider#deny
   */
  readonly deny?: FirewallSpecForProviderDeny[];

  /**
   * An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema FirewallSpecForProvider#description
   */
  readonly description?: string;

  /**
   * If destination ranges are specified, the firewall will apply only to
   * traffic that has destination IP address in these ranges. These ranges
   * must be expressed in CIDR format. IPv4 or IPv6 ranges are supported.
   *
   * @schema FirewallSpecForProvider#destinationRanges
   */
  readonly destinationRanges?: string[];

  /**
   * Direction of traffic to which this firewall applies; default is
   * INGRESS. Note: For INGRESS traffic, one of source_ranges,
   * source_tags or source_service_accounts is required.
   * Possible values are: INGRESS, EGRESS.
   *
   * @schema FirewallSpecForProvider#direction
   */
  readonly direction?: string;

  /**
   * Denotes whether the firewall rule is disabled, i.e not applied to the
   * network it is associated with. When set to true, the firewall rule is
   * not enforced and the network behaves as if it did not exist. If this
   * is unspecified, the firewall rule will be enabled.
   *
   * @schema FirewallSpecForProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * This field denotes whether to enable logging for a particular firewall rule.
   * If logging is enabled, logs will be exported to Stackdriver. Deprecated in favor of log_config
   *
   * @schema FirewallSpecForProvider#enableLogging
   */
  readonly enableLogging?: boolean;

  /**
   * This field denotes the logging options for a particular firewall rule.
   * If defined, logging is enabled, and logs will be exported to Cloud Logging.
   * Structure is documented below.
   *
   * @schema FirewallSpecForProvider#logConfig
   */
  readonly logConfig?: FirewallSpecForProviderLogConfig[];

  /**
   * The name or self_link of the network to attach this firewall to.
   *
   * @schema FirewallSpecForProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema FirewallSpecForProvider#networkRef
   */
  readonly networkRef?: FirewallSpecForProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema FirewallSpecForProvider#networkSelector
   */
  readonly networkSelector?: FirewallSpecForProviderNetworkSelector;

  /**
   * Additional params passed with the request, but not persisted as part of resource payload
   * Structure is documented below.
   *
   * @schema FirewallSpecForProvider#params
   */
  readonly params?: FirewallSpecForProviderParams[];

  /**
   * Priority for this rule. This is an integer between 0 and 65535, both
   * inclusive. When not specified, the value assumed is 1000. Relative
   * priorities determine precedence of conflicting rules. Lower value of
   * priority implies higher precedence (eg, a rule with priority 0 has
   * higher precedence than a rule with priority 1). DENY rules take
   * precedence over ALLOW rules having equal priority.
   *
   * @schema FirewallSpecForProvider#priority
   */
  readonly priority?: number;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema FirewallSpecForProvider#project
   */
  readonly project?: string;

  /**
   * If source ranges are specified, the firewall will apply only to
   * traffic that has source IP address in these ranges. These ranges must
   * be expressed in CIDR format. One or both of sourceRanges and
   * sourceTags may be set. If both properties are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP that belongs to a tag listed in the sourceTags property. The
   * connection does not need to match both properties for the firewall to
   * apply. IPv4 or IPv6 ranges are supported. For INGRESS traffic, one of
   * source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallSpecForProvider#sourceRanges
   */
  readonly sourceRanges?: string[];

  /**
   * If source service accounts are specified, the firewall will apply only
   * to traffic originating from an instance with a service account in this
   * list. Source service accounts cannot be used to control traffic to an
   * instance's external IP address because service accounts are associated
   * with an instance, not an IP address. sourceRanges can be set at the
   * same time as sourceServiceAccounts. If both are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP belongs to an instance with service account listed in
   * sourceServiceAccount. The connection does not need to match both
   * properties for the firewall to apply. sourceServiceAccounts cannot be
   * used at the same time as sourceTags or targetTags. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallSpecForProvider#sourceServiceAccounts
   */
  readonly sourceServiceAccounts?: string[];

  /**
   * If source tags are specified, the firewall will apply only to traffic
   * with source IP that belongs to a tag listed in source tags. Source
   * tags cannot be used to control traffic to an instance's external IP
   * address. Because tags are associated with an instance, not an IP
   * address. One or both of sourceRanges and sourceTags may be set. If
   * both properties are set, the firewall will apply to traffic that has
   * source IP address within sourceRanges OR the source IP that belongs to
   * a tag listed in the sourceTags property. The connection does not need
   * to match both properties for the firewall to apply. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallSpecForProvider#sourceTags
   */
  readonly sourceTags?: string[];

  /**
   * A list of service accounts indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * targetServiceAccounts cannot be used at the same time as targetTags or
   * sourceTags. If neither targetServiceAccounts nor targetTags are
   * specified, the firewall rule applies to all instances on the specified
   * network.
   *
   * @schema FirewallSpecForProvider#targetServiceAccounts
   */
  readonly targetServiceAccounts?: string[];

  /**
   * A list of instance tags indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * If no targetTags are specified, the firewall rule applies to all
   * instances on the specified network.
   *
   * @schema FirewallSpecForProvider#targetTags
   */
  readonly targetTags?: string[];
}

/**
 * Converts an object of type 'FirewallSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProvider(obj: FirewallSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allow': obj.allow?.map(y => toJson_FirewallSpecForProviderAllow(y)),
    'deny': obj.deny?.map(y => toJson_FirewallSpecForProviderDeny(y)),
    'description': obj.description,
    'destinationRanges': obj.destinationRanges?.map(y => y),
    'direction': obj.direction,
    'disabled': obj.disabled,
    'enableLogging': obj.enableLogging,
    'logConfig': obj.logConfig?.map(y => toJson_FirewallSpecForProviderLogConfig(y)),
    'network': obj.network,
    'networkRef': toJson_FirewallSpecForProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_FirewallSpecForProviderNetworkSelector(obj.networkSelector),
    'params': obj.params?.map(y => toJson_FirewallSpecForProviderParams(y)),
    'priority': obj.priority,
    'project': obj.project,
    'sourceRanges': obj.sourceRanges?.map(y => y),
    'sourceServiceAccounts': obj.sourceServiceAccounts?.map(y => y),
    'sourceTags': obj.sourceTags?.map(y => y),
    'targetServiceAccounts': obj.targetServiceAccounts?.map(y => y),
    'targetTags': obj.targetTags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema FirewallSpecInitProvider
 */
export interface FirewallSpecInitProvider {
  /**
   * The list of ALLOW rules specified by this firewall. Each rule
   * specifies a protocol and port-range tuple that describes a permitted
   * connection.
   * Structure is documented below.
   *
   * @schema FirewallSpecInitProvider#allow
   */
  readonly allow?: FirewallSpecInitProviderAllow[];

  /**
   * The list of DENY rules specified by this firewall. Each rule specifies
   * a protocol and port-range tuple that describes a denied connection.
   * Structure is documented below.
   *
   * @schema FirewallSpecInitProvider#deny
   */
  readonly deny?: FirewallSpecInitProviderDeny[];

  /**
   * An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema FirewallSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * If destination ranges are specified, the firewall will apply only to
   * traffic that has destination IP address in these ranges. These ranges
   * must be expressed in CIDR format. IPv4 or IPv6 ranges are supported.
   *
   * @schema FirewallSpecInitProvider#destinationRanges
   */
  readonly destinationRanges?: string[];

  /**
   * Direction of traffic to which this firewall applies; default is
   * INGRESS. Note: For INGRESS traffic, one of source_ranges,
   * source_tags or source_service_accounts is required.
   * Possible values are: INGRESS, EGRESS.
   *
   * @schema FirewallSpecInitProvider#direction
   */
  readonly direction?: string;

  /**
   * Denotes whether the firewall rule is disabled, i.e not applied to the
   * network it is associated with. When set to true, the firewall rule is
   * not enforced and the network behaves as if it did not exist. If this
   * is unspecified, the firewall rule will be enabled.
   *
   * @schema FirewallSpecInitProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * This field denotes whether to enable logging for a particular firewall rule.
   * If logging is enabled, logs will be exported to Stackdriver. Deprecated in favor of log_config
   *
   * @schema FirewallSpecInitProvider#enableLogging
   */
  readonly enableLogging?: boolean;

  /**
   * This field denotes the logging options for a particular firewall rule.
   * If defined, logging is enabled, and logs will be exported to Cloud Logging.
   * Structure is documented below.
   *
   * @schema FirewallSpecInitProvider#logConfig
   */
  readonly logConfig?: FirewallSpecInitProviderLogConfig[];

  /**
   * The name or self_link of the network to attach this firewall to.
   *
   * @schema FirewallSpecInitProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema FirewallSpecInitProvider#networkRef
   */
  readonly networkRef?: FirewallSpecInitProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema FirewallSpecInitProvider#networkSelector
   */
  readonly networkSelector?: FirewallSpecInitProviderNetworkSelector;

  /**
   * Additional params passed with the request, but not persisted as part of resource payload
   * Structure is documented below.
   *
   * @schema FirewallSpecInitProvider#params
   */
  readonly params?: FirewallSpecInitProviderParams[];

  /**
   * Priority for this rule. This is an integer between 0 and 65535, both
   * inclusive. When not specified, the value assumed is 1000. Relative
   * priorities determine precedence of conflicting rules. Lower value of
   * priority implies higher precedence (eg, a rule with priority 0 has
   * higher precedence than a rule with priority 1). DENY rules take
   * precedence over ALLOW rules having equal priority.
   *
   * @schema FirewallSpecInitProvider#priority
   */
  readonly priority?: number;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema FirewallSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * If source ranges are specified, the firewall will apply only to
   * traffic that has source IP address in these ranges. These ranges must
   * be expressed in CIDR format. One or both of sourceRanges and
   * sourceTags may be set. If both properties are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP that belongs to a tag listed in the sourceTags property. The
   * connection does not need to match both properties for the firewall to
   * apply. IPv4 or IPv6 ranges are supported. For INGRESS traffic, one of
   * source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallSpecInitProvider#sourceRanges
   */
  readonly sourceRanges?: string[];

  /**
   * If source service accounts are specified, the firewall will apply only
   * to traffic originating from an instance with a service account in this
   * list. Source service accounts cannot be used to control traffic to an
   * instance's external IP address because service accounts are associated
   * with an instance, not an IP address. sourceRanges can be set at the
   * same time as sourceServiceAccounts. If both are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP belongs to an instance with service account listed in
   * sourceServiceAccount. The connection does not need to match both
   * properties for the firewall to apply. sourceServiceAccounts cannot be
   * used at the same time as sourceTags or targetTags. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallSpecInitProvider#sourceServiceAccounts
   */
  readonly sourceServiceAccounts?: string[];

  /**
   * If source tags are specified, the firewall will apply only to traffic
   * with source IP that belongs to a tag listed in source tags. Source
   * tags cannot be used to control traffic to an instance's external IP
   * address. Because tags are associated with an instance, not an IP
   * address. One or both of sourceRanges and sourceTags may be set. If
   * both properties are set, the firewall will apply to traffic that has
   * source IP address within sourceRanges OR the source IP that belongs to
   * a tag listed in the sourceTags property. The connection does not need
   * to match both properties for the firewall to apply. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallSpecInitProvider#sourceTags
   */
  readonly sourceTags?: string[];

  /**
   * A list of service accounts indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * targetServiceAccounts cannot be used at the same time as targetTags or
   * sourceTags. If neither targetServiceAccounts nor targetTags are
   * specified, the firewall rule applies to all instances on the specified
   * network.
   *
   * @schema FirewallSpecInitProvider#targetServiceAccounts
   */
  readonly targetServiceAccounts?: string[];

  /**
   * A list of instance tags indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * If no targetTags are specified, the firewall rule applies to all
   * instances on the specified network.
   *
   * @schema FirewallSpecInitProvider#targetTags
   */
  readonly targetTags?: string[];
}

/**
 * Converts an object of type 'FirewallSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProvider(obj: FirewallSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allow': obj.allow?.map(y => toJson_FirewallSpecInitProviderAllow(y)),
    'deny': obj.deny?.map(y => toJson_FirewallSpecInitProviderDeny(y)),
    'description': obj.description,
    'destinationRanges': obj.destinationRanges?.map(y => y),
    'direction': obj.direction,
    'disabled': obj.disabled,
    'enableLogging': obj.enableLogging,
    'logConfig': obj.logConfig?.map(y => toJson_FirewallSpecInitProviderLogConfig(y)),
    'network': obj.network,
    'networkRef': toJson_FirewallSpecInitProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_FirewallSpecInitProviderNetworkSelector(obj.networkSelector),
    'params': obj.params?.map(y => toJson_FirewallSpecInitProviderParams(y)),
    'priority': obj.priority,
    'project': obj.project,
    'sourceRanges': obj.sourceRanges?.map(y => y),
    'sourceServiceAccounts': obj.sourceServiceAccounts?.map(y => y),
    'sourceTags': obj.sourceTags?.map(y => y),
    'targetServiceAccounts': obj.targetServiceAccounts?.map(y => y),
    'targetTags': obj.targetTags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema FirewallSpecManagementPolicies
 */
export enum FirewallSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema FirewallSpecProviderConfigRef
 */
export interface FirewallSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecProviderConfigRef#policy
   */
  readonly policy?: FirewallSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'FirewallSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecProviderConfigRef(obj: FirewallSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema FirewallSpecWriteConnectionSecretToRef
 */
export interface FirewallSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FirewallSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FirewallSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'FirewallSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecWriteConnectionSecretToRef(obj: FirewallSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallSpecForProviderAllow
 */
export interface FirewallSpecForProviderAllow {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: ["22"], ["80","443"], and
   * ["12345-12349"].
   *
   * @schema FirewallSpecForProviderAllow#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallSpecForProviderAllow#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallSpecForProviderAllow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProviderAllow(obj: FirewallSpecForProviderAllow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallSpecForProviderDeny
 */
export interface FirewallSpecForProviderDeny {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: ["22"], ["80","443"], and
   * ["12345-12349"].
   *
   * @schema FirewallSpecForProviderDeny#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallSpecForProviderDeny#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallSpecForProviderDeny' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProviderDeny(obj: FirewallSpecForProviderDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallSpecForProviderLogConfig
 */
export interface FirewallSpecForProviderLogConfig {
  /**
   * This field denotes whether to include or exclude metadata for firewall logs.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA.
   *
   * @schema FirewallSpecForProviderLogConfig#metadata
   */
  readonly metadata?: string;
}

/**
 * Converts an object of type 'FirewallSpecForProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProviderLogConfig(obj: FirewallSpecForProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema FirewallSpecForProviderNetworkRef
 */
export interface FirewallSpecForProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecForProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecForProviderNetworkRef#policy
   */
  readonly policy?: FirewallSpecForProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'FirewallSpecForProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProviderNetworkRef(obj: FirewallSpecForProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecForProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema FirewallSpecForProviderNetworkSelector
 */
export interface FirewallSpecForProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema FirewallSpecForProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallSpecForProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallSpecForProviderNetworkSelector#policy
   */
  readonly policy?: FirewallSpecForProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'FirewallSpecForProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProviderNetworkSelector(obj: FirewallSpecForProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallSpecForProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallSpecForProviderParams
 */
export interface FirewallSpecForProviderParams {
  /**
   * Resource manager tags to be bound to the firewall. Tag keys and values have the
   * same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
   * and values are in the format tagValues/456. The field is ignored when empty.
   * The field is immutable and causes resource replacement when mutated. This field is only
   * set at create time and modifying this field after creation will trigger recreation.
   * To apply tags to an existing resource, see the google_tags_tag_binding resource.
   *
   * @schema FirewallSpecForProviderParams#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };
}

/**
 * Converts an object of type 'FirewallSpecForProviderParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProviderParams(obj: FirewallSpecForProviderParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallSpecInitProviderAllow
 */
export interface FirewallSpecInitProviderAllow {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: ["22"], ["80","443"], and
   * ["12345-12349"].
   *
   * @schema FirewallSpecInitProviderAllow#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallSpecInitProviderAllow#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallSpecInitProviderAllow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProviderAllow(obj: FirewallSpecInitProviderAllow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallSpecInitProviderDeny
 */
export interface FirewallSpecInitProviderDeny {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: ["22"], ["80","443"], and
   * ["12345-12349"].
   *
   * @schema FirewallSpecInitProviderDeny#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallSpecInitProviderDeny#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallSpecInitProviderDeny' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProviderDeny(obj: FirewallSpecInitProviderDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallSpecInitProviderLogConfig
 */
export interface FirewallSpecInitProviderLogConfig {
  /**
   * This field denotes whether to include or exclude metadata for firewall logs.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA.
   *
   * @schema FirewallSpecInitProviderLogConfig#metadata
   */
  readonly metadata?: string;
}

/**
 * Converts an object of type 'FirewallSpecInitProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProviderLogConfig(obj: FirewallSpecInitProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema FirewallSpecInitProviderNetworkRef
 */
export interface FirewallSpecInitProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecInitProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecInitProviderNetworkRef#policy
   */
  readonly policy?: FirewallSpecInitProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'FirewallSpecInitProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProviderNetworkRef(obj: FirewallSpecInitProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecInitProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema FirewallSpecInitProviderNetworkSelector
 */
export interface FirewallSpecInitProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema FirewallSpecInitProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallSpecInitProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallSpecInitProviderNetworkSelector#policy
   */
  readonly policy?: FirewallSpecInitProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'FirewallSpecInitProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProviderNetworkSelector(obj: FirewallSpecInitProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallSpecInitProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallSpecInitProviderParams
 */
export interface FirewallSpecInitProviderParams {
  /**
   * Resource manager tags to be bound to the firewall. Tag keys and values have the
   * same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
   * and values are in the format tagValues/456. The field is ignored when empty.
   * The field is immutable and causes resource replacement when mutated. This field is only
   * set at create time and modifying this field after creation will trigger recreation.
   * To apply tags to an existing resource, see the google_tags_tag_binding resource.
   *
   * @schema FirewallSpecInitProviderParams#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };
}

/**
 * Converts an object of type 'FirewallSpecInitProviderParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProviderParams(obj: FirewallSpecInitProviderParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecProviderConfigRefPolicy
 */
export interface FirewallSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'FirewallSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecProviderConfigRefPolicy(obj: FirewallSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecForProviderNetworkRefPolicy
 */
export interface FirewallSpecForProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallSpecForProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'FirewallSpecForProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProviderNetworkRefPolicy(obj: FirewallSpecForProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallSpecForProviderNetworkSelectorPolicy
 */
export interface FirewallSpecForProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallSpecForProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'FirewallSpecForProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProviderNetworkSelectorPolicy(obj: FirewallSpecForProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecInitProviderNetworkRefPolicy
 */
export interface FirewallSpecInitProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecInitProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecInitProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallSpecInitProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecInitProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'FirewallSpecInitProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProviderNetworkRefPolicy(obj: FirewallSpecInitProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallSpecInitProviderNetworkSelectorPolicy
 */
export interface FirewallSpecInitProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecInitProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: FirewallSpecInitProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallSpecInitProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: FirewallSpecInitProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'FirewallSpecInitProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProviderNetworkSelectorPolicy(obj: FirewallSpecInitProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecProviderConfigRefPolicyResolution
 */
export enum FirewallSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallSpecProviderConfigRefPolicyResolve
 */
export enum FirewallSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderNetworkRefPolicyResolution
 */
export enum FirewallSpecForProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallSpecForProviderNetworkRefPolicyResolve
 */
export enum FirewallSpecForProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderNetworkSelectorPolicyResolution
 */
export enum FirewallSpecForProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallSpecForProviderNetworkSelectorPolicyResolve
 */
export enum FirewallSpecForProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecInitProviderNetworkRefPolicyResolution
 */
export enum FirewallSpecInitProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallSpecInitProviderNetworkRefPolicyResolve
 */
export enum FirewallSpecInitProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecInitProviderNetworkSelectorPolicyResolution
 */
export enum FirewallSpecInitProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallSpecInitProviderNetworkSelectorPolicyResolve
 */
export enum FirewallSpecInitProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Firewall is the Schema for the Firewalls API. Each network has its own firewall controlling access to and from the instances.
 *
 * @schema FirewallV1Beta2
 */
export class FirewallV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FirewallV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.gcp.upbound.io/v1beta2',
    kind: 'Firewall',
  }

  /**
   * Renders a Kubernetes manifest for "FirewallV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FirewallV1Beta2Props): any {
    return {
      ...FirewallV1Beta2.GVK,
      ...toJson_FirewallV1Beta2Props(props),
    };
  }

  /**
   * Defines a "FirewallV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FirewallV1Beta2Props) {
    super(scope, id, {
      ...FirewallV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...FirewallV1Beta2.GVK,
      ...toJson_FirewallV1Beta2Props(resolved),
    };
  }
}

/**
 * Firewall is the Schema for the Firewalls API. Each network has its own firewall controlling access to and from the instances.
 *
 * @schema FirewallV1Beta2
 */
export interface FirewallV1Beta2Props {
  /**
   * @schema FirewallV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FirewallSpec defines the desired state of Firewall
   *
   * @schema FirewallV1Beta2#spec
   */
  readonly spec: FirewallV1Beta2Spec;
}

/**
 * Converts an object of type 'FirewallV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2Props(obj: FirewallV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FirewallV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FirewallSpec defines the desired state of Firewall
 *
 * @schema FirewallV1Beta2Spec
 */
export interface FirewallV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FirewallV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: FirewallV1Beta2SpecDeletionPolicy;

  /**
   * @schema FirewallV1Beta2Spec#forProvider
   */
  readonly forProvider: FirewallV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema FirewallV1Beta2Spec#initProvider
   */
  readonly initProvider?: FirewallV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FirewallV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: FirewallV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema FirewallV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: FirewallV1Beta2SpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema FirewallV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FirewallV1Beta2SpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'FirewallV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2Spec(obj: FirewallV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FirewallV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_FirewallV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FirewallV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_FirewallV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FirewallV1Beta2SpecDeletionPolicy
 */
export enum FirewallV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FirewallV1Beta2SpecForProvider
 */
export interface FirewallV1Beta2SpecForProvider {
  /**
   * The list of ALLOW rules specified by this firewall. Each rule
   * specifies a protocol and port-range tuple that describes a permitted
   * connection.
   * Structure is documented below.
   *
   * @schema FirewallV1Beta2SpecForProvider#allow
   */
  readonly allow?: FirewallV1Beta2SpecForProviderAllow[];

  /**
   * The list of DENY rules specified by this firewall. Each rule specifies
   * a protocol and port-range tuple that describes a denied connection.
   * Structure is documented below.
   *
   * @schema FirewallV1Beta2SpecForProvider#deny
   */
  readonly deny?: FirewallV1Beta2SpecForProviderDeny[];

  /**
   * An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema FirewallV1Beta2SpecForProvider#description
   */
  readonly description?: string;

  /**
   * If destination ranges are specified, the firewall will apply only to
   * traffic that has destination IP address in these ranges. These ranges
   * must be expressed in CIDR format. IPv4 or IPv6 ranges are supported.
   *
   * @schema FirewallV1Beta2SpecForProvider#destinationRanges
   */
  readonly destinationRanges?: string[];

  /**
   * Direction of traffic to which this firewall applies; default is
   * INGRESS. Note: For INGRESS traffic, one of source_ranges,
   * source_tags or source_service_accounts is required.
   * Possible values are: INGRESS, EGRESS.
   *
   * @schema FirewallV1Beta2SpecForProvider#direction
   */
  readonly direction?: string;

  /**
   * Denotes whether the firewall rule is disabled, i.e not applied to the
   * network it is associated with. When set to true, the firewall rule is
   * not enforced and the network behaves as if it did not exist. If this
   * is unspecified, the firewall rule will be enabled.
   *
   * @schema FirewallV1Beta2SpecForProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * This field denotes whether to enable logging for a particular firewall rule.
   * If logging is enabled, logs will be exported to Stackdriver. Deprecated in favor of log_config
   *
   * @schema FirewallV1Beta2SpecForProvider#enableLogging
   */
  readonly enableLogging?: boolean;

  /**
   * This field denotes the logging options for a particular firewall rule.
   * If defined, logging is enabled, and logs will be exported to Cloud Logging.
   * Structure is documented below.
   *
   * @schema FirewallV1Beta2SpecForProvider#logConfig
   */
  readonly logConfig?: FirewallV1Beta2SpecForProviderLogConfig;

  /**
   * The name or self_link of the network to attach this firewall to.
   *
   * @schema FirewallV1Beta2SpecForProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema FirewallV1Beta2SpecForProvider#networkRef
   */
  readonly networkRef?: FirewallV1Beta2SpecForProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema FirewallV1Beta2SpecForProvider#networkSelector
   */
  readonly networkSelector?: FirewallV1Beta2SpecForProviderNetworkSelector;

  /**
   * Additional params passed with the request, but not persisted as part of resource payload
   * Structure is documented below.
   *
   * @schema FirewallV1Beta2SpecForProvider#params
   */
  readonly params?: FirewallV1Beta2SpecForProviderParams;

  /**
   * Priority for this rule. This is an integer between 0 and 65535, both
   * inclusive. When not specified, the value assumed is 1000. Relative
   * priorities determine precedence of conflicting rules. Lower value of
   * priority implies higher precedence (eg, a rule with priority 0 has
   * higher precedence than a rule with priority 1). DENY rules take
   * precedence over ALLOW rules having equal priority.
   *
   * @schema FirewallV1Beta2SpecForProvider#priority
   */
  readonly priority?: number;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema FirewallV1Beta2SpecForProvider#project
   */
  readonly project?: string;

  /**
   * If source ranges are specified, the firewall will apply only to
   * traffic that has source IP address in these ranges. These ranges must
   * be expressed in CIDR format. One or both of sourceRanges and
   * sourceTags may be set. If both properties are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP that belongs to a tag listed in the sourceTags property. The
   * connection does not need to match both properties for the firewall to
   * apply. IPv4 or IPv6 ranges are supported. For INGRESS traffic, one of
   * source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallV1Beta2SpecForProvider#sourceRanges
   */
  readonly sourceRanges?: string[];

  /**
   * If source service accounts are specified, the firewall will apply only
   * to traffic originating from an instance with a service account in this
   * list. Source service accounts cannot be used to control traffic to an
   * instance's external IP address because service accounts are associated
   * with an instance, not an IP address. sourceRanges can be set at the
   * same time as sourceServiceAccounts. If both are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP belongs to an instance with service account listed in
   * sourceServiceAccount. The connection does not need to match both
   * properties for the firewall to apply. sourceServiceAccounts cannot be
   * used at the same time as sourceTags or targetTags. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallV1Beta2SpecForProvider#sourceServiceAccounts
   */
  readonly sourceServiceAccounts?: string[];

  /**
   * If source tags are specified, the firewall will apply only to traffic
   * with source IP that belongs to a tag listed in source tags. Source
   * tags cannot be used to control traffic to an instance's external IP
   * address. Because tags are associated with an instance, not an IP
   * address. One or both of sourceRanges and sourceTags may be set. If
   * both properties are set, the firewall will apply to traffic that has
   * source IP address within sourceRanges OR the source IP that belongs to
   * a tag listed in the sourceTags property. The connection does not need
   * to match both properties for the firewall to apply. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallV1Beta2SpecForProvider#sourceTags
   */
  readonly sourceTags?: string[];

  /**
   * A list of service accounts indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * targetServiceAccounts cannot be used at the same time as targetTags or
   * sourceTags. If neither targetServiceAccounts nor targetTags are
   * specified, the firewall rule applies to all instances on the specified
   * network.
   *
   * @schema FirewallV1Beta2SpecForProvider#targetServiceAccounts
   */
  readonly targetServiceAccounts?: string[];

  /**
   * A list of instance tags indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * If no targetTags are specified, the firewall rule applies to all
   * instances on the specified network.
   *
   * @schema FirewallV1Beta2SpecForProvider#targetTags
   */
  readonly targetTags?: string[];
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProvider(obj: FirewallV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allow': obj.allow?.map(y => toJson_FirewallV1Beta2SpecForProviderAllow(y)),
    'deny': obj.deny?.map(y => toJson_FirewallV1Beta2SpecForProviderDeny(y)),
    'description': obj.description,
    'destinationRanges': obj.destinationRanges?.map(y => y),
    'direction': obj.direction,
    'disabled': obj.disabled,
    'enableLogging': obj.enableLogging,
    'logConfig': toJson_FirewallV1Beta2SpecForProviderLogConfig(obj.logConfig),
    'network': obj.network,
    'networkRef': toJson_FirewallV1Beta2SpecForProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_FirewallV1Beta2SpecForProviderNetworkSelector(obj.networkSelector),
    'params': toJson_FirewallV1Beta2SpecForProviderParams(obj.params),
    'priority': obj.priority,
    'project': obj.project,
    'sourceRanges': obj.sourceRanges?.map(y => y),
    'sourceServiceAccounts': obj.sourceServiceAccounts?.map(y => y),
    'sourceTags': obj.sourceTags?.map(y => y),
    'targetServiceAccounts': obj.targetServiceAccounts?.map(y => y),
    'targetTags': obj.targetTags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema FirewallV1Beta2SpecInitProvider
 */
export interface FirewallV1Beta2SpecInitProvider {
  /**
   * The list of ALLOW rules specified by this firewall. Each rule
   * specifies a protocol and port-range tuple that describes a permitted
   * connection.
   * Structure is documented below.
   *
   * @schema FirewallV1Beta2SpecInitProvider#allow
   */
  readonly allow?: FirewallV1Beta2SpecInitProviderAllow[];

  /**
   * The list of DENY rules specified by this firewall. Each rule specifies
   * a protocol and port-range tuple that describes a denied connection.
   * Structure is documented below.
   *
   * @schema FirewallV1Beta2SpecInitProvider#deny
   */
  readonly deny?: FirewallV1Beta2SpecInitProviderDeny[];

  /**
   * An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema FirewallV1Beta2SpecInitProvider#description
   */
  readonly description?: string;

  /**
   * If destination ranges are specified, the firewall will apply only to
   * traffic that has destination IP address in these ranges. These ranges
   * must be expressed in CIDR format. IPv4 or IPv6 ranges are supported.
   *
   * @schema FirewallV1Beta2SpecInitProvider#destinationRanges
   */
  readonly destinationRanges?: string[];

  /**
   * Direction of traffic to which this firewall applies; default is
   * INGRESS. Note: For INGRESS traffic, one of source_ranges,
   * source_tags or source_service_accounts is required.
   * Possible values are: INGRESS, EGRESS.
   *
   * @schema FirewallV1Beta2SpecInitProvider#direction
   */
  readonly direction?: string;

  /**
   * Denotes whether the firewall rule is disabled, i.e not applied to the
   * network it is associated with. When set to true, the firewall rule is
   * not enforced and the network behaves as if it did not exist. If this
   * is unspecified, the firewall rule will be enabled.
   *
   * @schema FirewallV1Beta2SpecInitProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * This field denotes whether to enable logging for a particular firewall rule.
   * If logging is enabled, logs will be exported to Stackdriver. Deprecated in favor of log_config
   *
   * @schema FirewallV1Beta2SpecInitProvider#enableLogging
   */
  readonly enableLogging?: boolean;

  /**
   * This field denotes the logging options for a particular firewall rule.
   * If defined, logging is enabled, and logs will be exported to Cloud Logging.
   * Structure is documented below.
   *
   * @schema FirewallV1Beta2SpecInitProvider#logConfig
   */
  readonly logConfig?: FirewallV1Beta2SpecInitProviderLogConfig;

  /**
   * The name or self_link of the network to attach this firewall to.
   *
   * @schema FirewallV1Beta2SpecInitProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema FirewallV1Beta2SpecInitProvider#networkRef
   */
  readonly networkRef?: FirewallV1Beta2SpecInitProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema FirewallV1Beta2SpecInitProvider#networkSelector
   */
  readonly networkSelector?: FirewallV1Beta2SpecInitProviderNetworkSelector;

  /**
   * Additional params passed with the request, but not persisted as part of resource payload
   * Structure is documented below.
   *
   * @schema FirewallV1Beta2SpecInitProvider#params
   */
  readonly params?: FirewallV1Beta2SpecInitProviderParams;

  /**
   * Priority for this rule. This is an integer between 0 and 65535, both
   * inclusive. When not specified, the value assumed is 1000. Relative
   * priorities determine precedence of conflicting rules. Lower value of
   * priority implies higher precedence (eg, a rule with priority 0 has
   * higher precedence than a rule with priority 1). DENY rules take
   * precedence over ALLOW rules having equal priority.
   *
   * @schema FirewallV1Beta2SpecInitProvider#priority
   */
  readonly priority?: number;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema FirewallV1Beta2SpecInitProvider#project
   */
  readonly project?: string;

  /**
   * If source ranges are specified, the firewall will apply only to
   * traffic that has source IP address in these ranges. These ranges must
   * be expressed in CIDR format. One or both of sourceRanges and
   * sourceTags may be set. If both properties are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP that belongs to a tag listed in the sourceTags property. The
   * connection does not need to match both properties for the firewall to
   * apply. IPv4 or IPv6 ranges are supported. For INGRESS traffic, one of
   * source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallV1Beta2SpecInitProvider#sourceRanges
   */
  readonly sourceRanges?: string[];

  /**
   * If source service accounts are specified, the firewall will apply only
   * to traffic originating from an instance with a service account in this
   * list. Source service accounts cannot be used to control traffic to an
   * instance's external IP address because service accounts are associated
   * with an instance, not an IP address. sourceRanges can be set at the
   * same time as sourceServiceAccounts. If both are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP belongs to an instance with service account listed in
   * sourceServiceAccount. The connection does not need to match both
   * properties for the firewall to apply. sourceServiceAccounts cannot be
   * used at the same time as sourceTags or targetTags. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallV1Beta2SpecInitProvider#sourceServiceAccounts
   */
  readonly sourceServiceAccounts?: string[];

  /**
   * If source tags are specified, the firewall will apply only to traffic
   * with source IP that belongs to a tag listed in source tags. Source
   * tags cannot be used to control traffic to an instance's external IP
   * address. Because tags are associated with an instance, not an IP
   * address. One or both of sourceRanges and sourceTags may be set. If
   * both properties are set, the firewall will apply to traffic that has
   * source IP address within sourceRanges OR the source IP that belongs to
   * a tag listed in the sourceTags property. The connection does not need
   * to match both properties for the firewall to apply. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallV1Beta2SpecInitProvider#sourceTags
   */
  readonly sourceTags?: string[];

  /**
   * A list of service accounts indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * targetServiceAccounts cannot be used at the same time as targetTags or
   * sourceTags. If neither targetServiceAccounts nor targetTags are
   * specified, the firewall rule applies to all instances on the specified
   * network.
   *
   * @schema FirewallV1Beta2SpecInitProvider#targetServiceAccounts
   */
  readonly targetServiceAccounts?: string[];

  /**
   * A list of instance tags indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * If no targetTags are specified, the firewall rule applies to all
   * instances on the specified network.
   *
   * @schema FirewallV1Beta2SpecInitProvider#targetTags
   */
  readonly targetTags?: string[];
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProvider(obj: FirewallV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allow': obj.allow?.map(y => toJson_FirewallV1Beta2SpecInitProviderAllow(y)),
    'deny': obj.deny?.map(y => toJson_FirewallV1Beta2SpecInitProviderDeny(y)),
    'description': obj.description,
    'destinationRanges': obj.destinationRanges?.map(y => y),
    'direction': obj.direction,
    'disabled': obj.disabled,
    'enableLogging': obj.enableLogging,
    'logConfig': toJson_FirewallV1Beta2SpecInitProviderLogConfig(obj.logConfig),
    'network': obj.network,
    'networkRef': toJson_FirewallV1Beta2SpecInitProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_FirewallV1Beta2SpecInitProviderNetworkSelector(obj.networkSelector),
    'params': toJson_FirewallV1Beta2SpecInitProviderParams(obj.params),
    'priority': obj.priority,
    'project': obj.project,
    'sourceRanges': obj.sourceRanges?.map(y => y),
    'sourceServiceAccounts': obj.sourceServiceAccounts?.map(y => y),
    'sourceTags': obj.sourceTags?.map(y => y),
    'targetServiceAccounts': obj.targetServiceAccounts?.map(y => y),
    'targetTags': obj.targetTags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema FirewallV1Beta2SpecManagementPolicies
 */
export enum FirewallV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema FirewallV1Beta2SpecProviderConfigRef
 */
export interface FirewallV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: FirewallV1Beta2SpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecProviderConfigRef(obj: FirewallV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema FirewallV1Beta2SpecWriteConnectionSecretToRef
 */
export interface FirewallV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FirewallV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FirewallV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecWriteConnectionSecretToRef(obj: FirewallV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallV1Beta2SpecForProviderAllow
 */
export interface FirewallV1Beta2SpecForProviderAllow {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: [22], [80, 443], and
   * ["12345-12349"].
   *
   * @schema FirewallV1Beta2SpecForProviderAllow#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallV1Beta2SpecForProviderAllow#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProviderAllow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProviderAllow(obj: FirewallV1Beta2SpecForProviderAllow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallV1Beta2SpecForProviderDeny
 */
export interface FirewallV1Beta2SpecForProviderDeny {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: [22], [80, 443], and
   * ["12345-12349"].
   *
   * @schema FirewallV1Beta2SpecForProviderDeny#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallV1Beta2SpecForProviderDeny#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProviderDeny' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProviderDeny(obj: FirewallV1Beta2SpecForProviderDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * This field denotes the logging options for a particular firewall rule.
 * If defined, logging is enabled, and logs will be exported to Cloud Logging.
 * Structure is documented below.
 *
 * @schema FirewallV1Beta2SpecForProviderLogConfig
 */
export interface FirewallV1Beta2SpecForProviderLogConfig {
  /**
   * This field denotes whether to include or exclude metadata for firewall logs.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA.
   *
   * @schema FirewallV1Beta2SpecForProviderLogConfig#metadata
   */
  readonly metadata?: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProviderLogConfig(obj: FirewallV1Beta2SpecForProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkRef
 */
export interface FirewallV1Beta2SpecForProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkRef#policy
   */
  readonly policy?: FirewallV1Beta2SpecForProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProviderNetworkRef(obj: FirewallV1Beta2SpecForProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallV1Beta2SpecForProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkSelector
 */
export interface FirewallV1Beta2SpecForProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkSelector#policy
   */
  readonly policy?: FirewallV1Beta2SpecForProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProviderNetworkSelector(obj: FirewallV1Beta2SpecForProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallV1Beta2SpecForProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Additional params passed with the request, but not persisted as part of resource payload
 * Structure is documented below.
 *
 * @schema FirewallV1Beta2SpecForProviderParams
 */
export interface FirewallV1Beta2SpecForProviderParams {
  /**
   * Resource manager tags to be bound to the firewall. Tag keys and values have the
   * same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
   * and values are in the format tagValues/456. The field is ignored when empty.
   * The field is immutable and causes resource replacement when mutated. This field is only
   * set at create time and modifying this field after creation will trigger recreation.
   * To apply tags to an existing resource, see the google_tags_tag_binding resource.
   *
   * @schema FirewallV1Beta2SpecForProviderParams#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProviderParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProviderParams(obj: FirewallV1Beta2SpecForProviderParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallV1Beta2SpecInitProviderAllow
 */
export interface FirewallV1Beta2SpecInitProviderAllow {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: [22], [80, 443], and
   * ["12345-12349"].
   *
   * @schema FirewallV1Beta2SpecInitProviderAllow#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallV1Beta2SpecInitProviderAllow#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProviderAllow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProviderAllow(obj: FirewallV1Beta2SpecInitProviderAllow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallV1Beta2SpecInitProviderDeny
 */
export interface FirewallV1Beta2SpecInitProviderDeny {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: [22], [80, 443], and
   * ["12345-12349"].
   *
   * @schema FirewallV1Beta2SpecInitProviderDeny#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallV1Beta2SpecInitProviderDeny#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProviderDeny' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProviderDeny(obj: FirewallV1Beta2SpecInitProviderDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * This field denotes the logging options for a particular firewall rule.
 * If defined, logging is enabled, and logs will be exported to Cloud Logging.
 * Structure is documented below.
 *
 * @schema FirewallV1Beta2SpecInitProviderLogConfig
 */
export interface FirewallV1Beta2SpecInitProviderLogConfig {
  /**
   * This field denotes whether to include or exclude metadata for firewall logs.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA.
   *
   * @schema FirewallV1Beta2SpecInitProviderLogConfig#metadata
   */
  readonly metadata?: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProviderLogConfig(obj: FirewallV1Beta2SpecInitProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkRef
 */
export interface FirewallV1Beta2SpecInitProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkRef#policy
   */
  readonly policy?: FirewallV1Beta2SpecInitProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProviderNetworkRef(obj: FirewallV1Beta2SpecInitProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallV1Beta2SpecInitProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkSelector
 */
export interface FirewallV1Beta2SpecInitProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkSelector#policy
   */
  readonly policy?: FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProviderNetworkSelector(obj: FirewallV1Beta2SpecInitProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Additional params passed with the request, but not persisted as part of resource payload
 * Structure is documented below.
 *
 * @schema FirewallV1Beta2SpecInitProviderParams
 */
export interface FirewallV1Beta2SpecInitProviderParams {
  /**
   * Resource manager tags to be bound to the firewall. Tag keys and values have the
   * same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
   * and values are in the format tagValues/456. The field is ignored when empty.
   * The field is immutable and causes resource replacement when mutated. This field is only
   * set at create time and modifying this field after creation will trigger recreation.
   * To apply tags to an existing resource, see the google_tags_tag_binding resource.
   *
   * @schema FirewallV1Beta2SpecInitProviderParams#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProviderParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProviderParams(obj: FirewallV1Beta2SpecInitProviderParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallV1Beta2SpecProviderConfigRefPolicy
 */
export interface FirewallV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallV1Beta2SpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecProviderConfigRefPolicy(obj: FirewallV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkRefPolicy
 */
export interface FirewallV1Beta2SpecForProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: FirewallV1Beta2SpecForProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: FirewallV1Beta2SpecForProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProviderNetworkRefPolicy(obj: FirewallV1Beta2SpecForProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkSelectorPolicy
 */
export interface FirewallV1Beta2SpecForProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: FirewallV1Beta2SpecForProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: FirewallV1Beta2SpecForProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProviderNetworkSelectorPolicy(obj: FirewallV1Beta2SpecForProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkRefPolicy
 */
export interface FirewallV1Beta2SpecInitProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: FirewallV1Beta2SpecInitProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: FirewallV1Beta2SpecInitProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProviderNetworkRefPolicy(obj: FirewallV1Beta2SpecInitProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy
 */
export interface FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: FirewallV1Beta2SpecInitProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: FirewallV1Beta2SpecInitProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy(obj: FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum FirewallV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum FirewallV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkRefPolicyResolution
 */
export enum FirewallV1Beta2SpecForProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkRefPolicyResolve
 */
export enum FirewallV1Beta2SpecForProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkSelectorPolicyResolution
 */
export enum FirewallV1Beta2SpecForProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkSelectorPolicyResolve
 */
export enum FirewallV1Beta2SpecForProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkRefPolicyResolution
 */
export enum FirewallV1Beta2SpecInitProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkRefPolicyResolve
 */
export enum FirewallV1Beta2SpecInitProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkSelectorPolicyResolution
 */
export enum FirewallV1Beta2SpecInitProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkSelectorPolicyResolve
 */
export enum FirewallV1Beta2SpecInitProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Network is the Schema for the Networks API. Manages a VPC network or legacy network resource on GCP.
 *
 * @schema Network
 */
export class Network extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Network"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.gcp.upbound.io/v1beta1',
    kind: 'Network',
  }

  /**
   * Renders a Kubernetes manifest for "Network".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NetworkProps): any {
    return {
      ...Network.GVK,
      ...toJson_NetworkProps(props),
    };
  }

  /**
   * Defines a "Network" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NetworkProps) {
    super(scope, id, {
      ...Network.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Network.GVK,
      ...toJson_NetworkProps(resolved),
    };
  }
}

/**
 * Network is the Schema for the Networks API. Manages a VPC network or legacy network resource on GCP.
 *
 * @schema Network
 */
export interface NetworkProps {
  /**
   * @schema Network#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NetworkSpec defines the desired state of Network
   *
   * @schema Network#spec
   */
  readonly spec: NetworkSpec;
}

/**
 * Converts an object of type 'NetworkProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NetworkProps(obj: NetworkProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NetworkSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NetworkSpec defines the desired state of Network
 *
 * @schema NetworkSpec
 */
export interface NetworkSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NetworkSpec#deletionPolicy
   */
  readonly deletionPolicy?: NetworkSpecDeletionPolicy;

  /**
   * @schema NetworkSpec#forProvider
   */
  readonly forProvider: NetworkSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema NetworkSpec#initProvider
   */
  readonly initProvider?: NetworkSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema NetworkSpec#managementPolicies
   */
  readonly managementPolicies?: NetworkSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema NetworkSpec#providerConfigRef
   */
  readonly providerConfigRef?: NetworkSpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema NetworkSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NetworkSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'NetworkSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NetworkSpec(obj: NetworkSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NetworkSpecForProvider(obj.forProvider),
    'initProvider': toJson_NetworkSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_NetworkSpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_NetworkSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NetworkSpecDeletionPolicy
 */
export enum NetworkSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NetworkSpecForProvider
 */
export interface NetworkSpecForProvider {
  /**
   * When set to true, the network is created in "auto subnet mode" and
   * it will create a subnet for each region automatically across the
   * 10.128.0.0/9 address range.
   * When set to false, the network is created in "custom subnet mode" so
   * the user can explicitly connect subnetwork resources.
   *
   * @schema NetworkSpecForProvider#autoCreateSubnetworks
   */
  readonly autoCreateSubnetworks?: boolean;

  /**
   * Enables/disables the comparison of MED across routes with different Neighbor ASNs.
   * This value can only be set if the --bgp-best-path-selection-mode is STANDARD
   *
   * @schema NetworkSpecForProvider#bgpAlwaysCompareMed
   */
  readonly bgpAlwaysCompareMed?: boolean;

  /**
   * The BGP best selection algorithm to be employed. MODE can be LEGACY or STANDARD.
   * Possible values are: LEGACY, STANDARD.
   *
   * @schema NetworkSpecForProvider#bgpBestPathSelectionMode
   */
  readonly bgpBestPathSelectionMode?: string;

  /**
   * Choice of the behavior of inter-regional cost and MED in the BPS algorithm.
   * Possible values are: DEFAULT, ADD_COST_TO_MED.
   *
   * @schema NetworkSpecForProvider#bgpInterRegionCost
   */
  readonly bgpInterRegionCost?: string;

  /**
   * If set to true, default routes (0.0.0.0/0) will be deleted
   * immediately after network creation. Defaults to false.
   *
   * @default false.
   * @schema NetworkSpecForProvider#deleteDefaultRoutesOnCreate
   */
  readonly deleteDefaultRoutesOnCreate?: boolean;

  /**
   * An optional description of this resource. The resource must be
   * recreated to modify this field.
   *
   * @schema NetworkSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Enable ULA internal ipv6 on this network. Enabling this feature will assign
   * a /48 from google defined ULA prefix fd20::/20.
   *
   * @schema NetworkSpecForProvider#enableUlaInternalIpv6
   */
  readonly enableUlaInternalIpv6?: boolean;

  /**
   * When enabling ula internal ipv6, caller optionally can specify the /48 range
   * they want from the google defined ULA prefix fd20::/20. The input must be a
   * valid /48 ULA IPv6 address and must be within the fd20::/20. Operation will
   * fail if the speficied /48 is already in used by another resource.
   * If the field is not speficied, then a /48 range will be randomly allocated from fd20::/20 and returned via this field.
   *
   * @schema NetworkSpecForProvider#internalIpv6Range
   */
  readonly internalIpv6Range?: string;

  /**
   * Maximum Transmission Unit in bytes. The default value is 1460 bytes.
   * The minimum value for this field is 1300 and the maximum value is 8896 bytes (jumbo frames).
   * Note that packets larger than 1500 bytes (standard Ethernet) can be subject to TCP-MSS clamping or dropped
   * with an ICMP Fragmentation-Needed message if the packets are routed to the Internet or other VPCs
   * with varying MTUs.
   *
   * @schema NetworkSpecForProvider#mtu
   */
  readonly mtu?: number;

  /**
   * Set the order that Firewall Rules and Firewall Policies are evaluated.
   * Default value is AFTER_CLASSIC_FIREWALL.
   * Possible values are: BEFORE_CLASSIC_FIREWALL, AFTER_CLASSIC_FIREWALL.
   *
   * @schema NetworkSpecForProvider#networkFirewallPolicyEnforcementOrder
   */
  readonly networkFirewallPolicyEnforcementOrder?: string;

  /**
   * A full or partial URL of the network profile to apply to this network.
   * This field can be set only at resource creation time. For example, the
   * following are valid URLs:
   *
   * @schema NetworkSpecForProvider#networkProfile
   */
  readonly networkProfile?: string;

  /**
   * Additional params passed with the request, but not persisted as part of resource payload
   * Structure is documented below.
   *
   * @schema NetworkSpecForProvider#params
   */
  readonly params?: NetworkSpecForProviderParams;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema NetworkSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The network-wide routing mode to use. If set to REGIONAL, this
   * network's cloud routers will only advertise routes with subnetworks
   * of this network in the same region as the router. If set to GLOBAL,
   * this network's cloud routers will advertise routes with all
   * subnetworks of this network, across regions.
   * Possible values are: REGIONAL, GLOBAL.
   *
   * @schema NetworkSpecForProvider#routingMode
   */
  readonly routingMode?: string;
}

/**
 * Converts an object of type 'NetworkSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NetworkSpecForProvider(obj: NetworkSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoCreateSubnetworks': obj.autoCreateSubnetworks,
    'bgpAlwaysCompareMed': obj.bgpAlwaysCompareMed,
    'bgpBestPathSelectionMode': obj.bgpBestPathSelectionMode,
    'bgpInterRegionCost': obj.bgpInterRegionCost,
    'deleteDefaultRoutesOnCreate': obj.deleteDefaultRoutesOnCreate,
    'description': obj.description,
    'enableUlaInternalIpv6': obj.enableUlaInternalIpv6,
    'internalIpv6Range': obj.internalIpv6Range,
    'mtu': obj.mtu,
    'networkFirewallPolicyEnforcementOrder': obj.networkFirewallPolicyEnforcementOrder,
    'networkProfile': obj.networkProfile,
    'params': toJson_NetworkSpecForProviderParams(obj.params),
    'project': obj.project,
    'routingMode': obj.routingMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema NetworkSpecInitProvider
 */
export interface NetworkSpecInitProvider {
  /**
   * When set to true, the network is created in "auto subnet mode" and
   * it will create a subnet for each region automatically across the
   * 10.128.0.0/9 address range.
   * When set to false, the network is created in "custom subnet mode" so
   * the user can explicitly connect subnetwork resources.
   *
   * @schema NetworkSpecInitProvider#autoCreateSubnetworks
   */
  readonly autoCreateSubnetworks?: boolean;

  /**
   * Enables/disables the comparison of MED across routes with different Neighbor ASNs.
   * This value can only be set if the --bgp-best-path-selection-mode is STANDARD
   *
   * @schema NetworkSpecInitProvider#bgpAlwaysCompareMed
   */
  readonly bgpAlwaysCompareMed?: boolean;

  /**
   * The BGP best selection algorithm to be employed. MODE can be LEGACY or STANDARD.
   * Possible values are: LEGACY, STANDARD.
   *
   * @schema NetworkSpecInitProvider#bgpBestPathSelectionMode
   */
  readonly bgpBestPathSelectionMode?: string;

  /**
   * Choice of the behavior of inter-regional cost and MED in the BPS algorithm.
   * Possible values are: DEFAULT, ADD_COST_TO_MED.
   *
   * @schema NetworkSpecInitProvider#bgpInterRegionCost
   */
  readonly bgpInterRegionCost?: string;

  /**
   * If set to true, default routes (0.0.0.0/0) will be deleted
   * immediately after network creation. Defaults to false.
   *
   * @default false.
   * @schema NetworkSpecInitProvider#deleteDefaultRoutesOnCreate
   */
  readonly deleteDefaultRoutesOnCreate?: boolean;

  /**
   * An optional description of this resource. The resource must be
   * recreated to modify this field.
   *
   * @schema NetworkSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Enable ULA internal ipv6 on this network. Enabling this feature will assign
   * a /48 from google defined ULA prefix fd20::/20.
   *
   * @schema NetworkSpecInitProvider#enableUlaInternalIpv6
   */
  readonly enableUlaInternalIpv6?: boolean;

  /**
   * When enabling ula internal ipv6, caller optionally can specify the /48 range
   * they want from the google defined ULA prefix fd20::/20. The input must be a
   * valid /48 ULA IPv6 address and must be within the fd20::/20. Operation will
   * fail if the speficied /48 is already in used by another resource.
   * If the field is not speficied, then a /48 range will be randomly allocated from fd20::/20 and returned via this field.
   *
   * @schema NetworkSpecInitProvider#internalIpv6Range
   */
  readonly internalIpv6Range?: string;

  /**
   * Maximum Transmission Unit in bytes. The default value is 1460 bytes.
   * The minimum value for this field is 1300 and the maximum value is 8896 bytes (jumbo frames).
   * Note that packets larger than 1500 bytes (standard Ethernet) can be subject to TCP-MSS clamping or dropped
   * with an ICMP Fragmentation-Needed message if the packets are routed to the Internet or other VPCs
   * with varying MTUs.
   *
   * @schema NetworkSpecInitProvider#mtu
   */
  readonly mtu?: number;

  /**
   * Set the order that Firewall Rules and Firewall Policies are evaluated.
   * Default value is AFTER_CLASSIC_FIREWALL.
   * Possible values are: BEFORE_CLASSIC_FIREWALL, AFTER_CLASSIC_FIREWALL.
   *
   * @schema NetworkSpecInitProvider#networkFirewallPolicyEnforcementOrder
   */
  readonly networkFirewallPolicyEnforcementOrder?: string;

  /**
   * A full or partial URL of the network profile to apply to this network.
   * This field can be set only at resource creation time. For example, the
   * following are valid URLs:
   *
   * @schema NetworkSpecInitProvider#networkProfile
   */
  readonly networkProfile?: string;

  /**
   * Additional params passed with the request, but not persisted as part of resource payload
   * Structure is documented below.
   *
   * @schema NetworkSpecInitProvider#params
   */
  readonly params?: NetworkSpecInitProviderParams;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema NetworkSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The network-wide routing mode to use. If set to REGIONAL, this
   * network's cloud routers will only advertise routes with subnetworks
   * of this network in the same region as the router. If set to GLOBAL,
   * this network's cloud routers will advertise routes with all
   * subnetworks of this network, across regions.
   * Possible values are: REGIONAL, GLOBAL.
   *
   * @schema NetworkSpecInitProvider#routingMode
   */
  readonly routingMode?: string;
}

/**
 * Converts an object of type 'NetworkSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NetworkSpecInitProvider(obj: NetworkSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoCreateSubnetworks': obj.autoCreateSubnetworks,
    'bgpAlwaysCompareMed': obj.bgpAlwaysCompareMed,
    'bgpBestPathSelectionMode': obj.bgpBestPathSelectionMode,
    'bgpInterRegionCost': obj.bgpInterRegionCost,
    'deleteDefaultRoutesOnCreate': obj.deleteDefaultRoutesOnCreate,
    'description': obj.description,
    'enableUlaInternalIpv6': obj.enableUlaInternalIpv6,
    'internalIpv6Range': obj.internalIpv6Range,
    'mtu': obj.mtu,
    'networkFirewallPolicyEnforcementOrder': obj.networkFirewallPolicyEnforcementOrder,
    'networkProfile': obj.networkProfile,
    'params': toJson_NetworkSpecInitProviderParams(obj.params),
    'project': obj.project,
    'routingMode': obj.routingMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema NetworkSpecManagementPolicies
 */
export enum NetworkSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema NetworkSpecProviderConfigRef
 */
export interface NetworkSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NetworkSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NetworkSpecProviderConfigRef#policy
   */
  readonly policy?: NetworkSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'NetworkSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NetworkSpecProviderConfigRef(obj: NetworkSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NetworkSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema NetworkSpecWriteConnectionSecretToRef
 */
export interface NetworkSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NetworkSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NetworkSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'NetworkSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NetworkSpecWriteConnectionSecretToRef(obj: NetworkSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Additional params passed with the request, but not persisted as part of resource payload
 * Structure is documented below.
 *
 * @schema NetworkSpecForProviderParams
 */
export interface NetworkSpecForProviderParams {
  /**
   * Resource manager tags to be bound to the network. Tag keys and values have the
   * same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
   * and values are in the format tagValues/456.
   *
   * @schema NetworkSpecForProviderParams#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };
}

/**
 * Converts an object of type 'NetworkSpecForProviderParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NetworkSpecForProviderParams(obj: NetworkSpecForProviderParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Additional params passed with the request, but not persisted as part of resource payload
 * Structure is documented below.
 *
 * @schema NetworkSpecInitProviderParams
 */
export interface NetworkSpecInitProviderParams {
  /**
   * Resource manager tags to be bound to the network. Tag keys and values have the
   * same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
   * and values are in the format tagValues/456.
   *
   * @schema NetworkSpecInitProviderParams#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };
}

/**
 * Converts an object of type 'NetworkSpecInitProviderParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NetworkSpecInitProviderParams(obj: NetworkSpecInitProviderParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema NetworkSpecProviderConfigRefPolicy
 */
export interface NetworkSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema NetworkSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NetworkSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema NetworkSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NetworkSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'NetworkSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NetworkSpecProviderConfigRefPolicy(obj: NetworkSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema NetworkSpecProviderConfigRefPolicyResolution
 */
export enum NetworkSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema NetworkSpecProviderConfigRefPolicyResolve
 */
export enum NetworkSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Subnetwork is the Schema for the Subnetworks API. A VPC network is a virtual version of the traditional physical networks that exist within and between physical data centers.
 *
 * @schema Subnetwork
 */
export class Subnetwork extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Subnetwork"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.gcp.upbound.io/v1beta1',
    kind: 'Subnetwork',
  }

  /**
   * Renders a Kubernetes manifest for "Subnetwork".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SubnetworkProps): any {
    return {
      ...Subnetwork.GVK,
      ...toJson_SubnetworkProps(props),
    };
  }

  /**
   * Defines a "Subnetwork" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SubnetworkProps) {
    super(scope, id, {
      ...Subnetwork.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Subnetwork.GVK,
      ...toJson_SubnetworkProps(resolved),
    };
  }
}

/**
 * Subnetwork is the Schema for the Subnetworks API. A VPC network is a virtual version of the traditional physical networks that exist within and between physical data centers.
 *
 * @schema Subnetwork
 */
export interface SubnetworkProps {
  /**
   * @schema Subnetwork#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SubnetworkSpec defines the desired state of Subnetwork
   *
   * @schema Subnetwork#spec
   */
  readonly spec: SubnetworkSpec;
}

/**
 * Converts an object of type 'SubnetworkProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkProps(obj: SubnetworkProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SubnetworkSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SubnetworkSpec defines the desired state of Subnetwork
 *
 * @schema SubnetworkSpec
 */
export interface SubnetworkSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SubnetworkSpec#deletionPolicy
   */
  readonly deletionPolicy?: SubnetworkSpecDeletionPolicy;

  /**
   * @schema SubnetworkSpec#forProvider
   */
  readonly forProvider: SubnetworkSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema SubnetworkSpec#initProvider
   */
  readonly initProvider?: SubnetworkSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SubnetworkSpec#managementPolicies
   */
  readonly managementPolicies?: SubnetworkSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema SubnetworkSpec#providerConfigRef
   */
  readonly providerConfigRef?: SubnetworkSpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema SubnetworkSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SubnetworkSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'SubnetworkSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpec(obj: SubnetworkSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SubnetworkSpecForProvider(obj.forProvider),
    'initProvider': toJson_SubnetworkSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SubnetworkSpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_SubnetworkSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SubnetworkSpecDeletionPolicy
 */
export enum SubnetworkSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SubnetworkSpecForProvider
 */
export interface SubnetworkSpecForProvider {
  /**
   * An optional description of this resource. Provide this property when
   * you create the resource. This field can be set only at resource
   * creation time.
   *
   * @schema SubnetworkSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether to enable flow logging for this subnetwork. If this field is not explicitly set,
   * it will not appear in get listings. If not set the default behavior is determined by the
   * org policy, if there is no org policy specified, then it will default to disabled.
   * This field isn't supported if the subnet purpose field is set to REGIONAL_MANAGED_PROXY.
   *
   * @schema SubnetworkSpecForProvider#enableFlowLogs
   */
  readonly enableFlowLogs?: boolean;

  /**
   * The range of external IPv6 addresses that are owned by this subnetwork.
   *
   * @schema SubnetworkSpecForProvider#externalIpv6Prefix
   */
  readonly externalIpv6Prefix?: string;

  /**
   * The range of internal addresses that are owned by this subnetwork.
   * Provide this property when you create the subnetwork. For example,
   * 10.0.0.0/8 or 192.168.0.0/16. Ranges must be unique and
   * non-overlapping within a network. Only IPv4 is supported.
   *
   * @schema SubnetworkSpecForProvider#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * Resource reference of a PublicDelegatedPrefix. The PDP must be a sub-PDP
   * in EXTERNAL_IPV6_SUBNETWORK_CREATION mode.
   * Use one of the following formats to specify a sub-PDP when creating an
   * IPv6 NetLB forwarding rule using BYOIP:
   * Full resource URL, as in:
   *
   * @schema SubnetworkSpecForProvider#ipCollection
   */
  readonly ipCollection?: string;

  /**
   * The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation
   * or the first time the subnet is updated into IPV4_IPV6 dual stack. If the ipv6_type is EXTERNAL then this subnet
   * cannot enable direct path.
   * Possible values are: EXTERNAL, INTERNAL.
   *
   * @schema SubnetworkSpecForProvider#ipv6AccessType
   */
  readonly ipv6AccessType?: string;

  /**
   * This field denotes the VPC flow logging options for this subnetwork. If
   * logging is enabled, logs are exported to Cloud Logging. Flow logging
   * isn't supported if the subnet purpose field is set to subnetwork is
   * REGIONAL_MANAGED_PROXY or GLOBAL_MANAGED_PROXY.
   * Structure is documented below.
   *
   * @schema SubnetworkSpecForProvider#logConfig
   */
  readonly logConfig?: SubnetworkSpecForProviderLogConfig[];

  /**
   * The network this subnet belongs to.
   * Only networks that are in the distributed mode can have subnetworks.
   *
   * @schema SubnetworkSpecForProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema SubnetworkSpecForProvider#networkRef
   */
  readonly networkRef?: SubnetworkSpecForProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema SubnetworkSpecForProvider#networkSelector
   */
  readonly networkSelector?: SubnetworkSpecForProviderNetworkSelector;

  /**
   * Additional params passed with the request, but not persisted as part of resource payload
   * Structure is documented below.
   *
   * @schema SubnetworkSpecForProvider#params
   */
  readonly params?: SubnetworkSpecForProviderParams[];

  /**
   * When enabled, VMs in this subnetwork without external IP addresses can
   * access Google APIs and services by using Private Google Access.
   *
   * @schema SubnetworkSpecForProvider#privateIpGoogleAccess
   */
  readonly privateIpGoogleAccess?: boolean;

  /**
   * The private IPv6 google access type for the VMs in this subnet.
   *
   * @schema SubnetworkSpecForProvider#privateIpv6GoogleAccess
   */
  readonly privateIpv6GoogleAccess?: string;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema SubnetworkSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The purpose of the resource. This field can be either PRIVATE_RFC_1918, REGIONAL_MANAGED_PROXY, GLOBAL_MANAGED_PROXY, PRIVATE_SERVICE_CONNECT or PRIVATE_NAT(Beta).
   * A subnet with purpose set to REGIONAL_MANAGED_PROXY is a user-created subnetwork that is reserved for regional Envoy-based load balancers.
   * A subnetwork in a given region with purpose set to GLOBAL_MANAGED_PROXY is a proxy-only subnet and is shared between all the cross-regional Envoy-based load balancers.
   * A subnetwork with purpose set to PRIVATE_SERVICE_CONNECT reserves the subnet for hosting a Private Service Connect published service.
   * A subnetwork with purpose set to PRIVATE_NAT is used as source range for Private NAT gateways.
   * Note that REGIONAL_MANAGED_PROXY is the preferred setting for all regional Envoy load balancers.
   * If unspecified, the purpose defaults to PRIVATE_RFC_1918.
   *
   * @schema SubnetworkSpecForProvider#purpose
   */
  readonly purpose?: string;

  /**
   * The GCP region for this subnetwork.
   *
   * @schema SubnetworkSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ID of the reserved internal range. Must be prefixed with networkconnectivity.googleapis.com
   * E.g. networkconnectivity.googleapis.com/projects/{project}/locations/global/internalRanges/{rangeId}
   *
   * @schema SubnetworkSpecForProvider#reservedInternalRange
   */
  readonly reservedInternalRange?: string;

  /**
   * The role of subnetwork.
   * Currently, this field is only used when purpose is REGIONAL_MANAGED_PROXY.
   * The value can be set to ACTIVE or BACKUP.
   * An ACTIVE subnetwork is one that is currently being used for Envoy-based load balancers in a region.
   * A BACKUP subnetwork is one that is ready to be promoted to ACTIVE or is currently draining.
   * Possible values are: ACTIVE, BACKUP.
   *
   * @schema SubnetworkSpecForProvider#role
   */
  readonly role?: string;

  /**
   * An array of configurations for secondary IP ranges for VM instances
   * contained in this subnetwork. The primary IP of such VM must belong
   * to the primary ipCidrRange of the subnetwork. The alias IPs may belong
   * to either primary or secondary ranges.
   * Note: This field uses attr-as-block mode to avoid
   * breaking users during the 0.12 upgrade. To explicitly send a list
   * of zero objects you must use the following syntax:
   * example=[]
   * For more details about this behavior, see this section.
   * Structure is documented below.
   *
   * @schema SubnetworkSpecForProvider#secondaryIpRange
   */
  readonly secondaryIpRange?: SubnetworkSpecForProviderSecondaryIpRange[];

  /**
   * Controls the removal behavior of secondary_ip_range.
   * When false, removing secondary_ip_range from config will not produce a diff as
   * the provider will default to the API's value.
   * When true, the provider will treat removing secondary_ip_range as sending an
   * empty list of secondary IP ranges to the API.
   * Defaults to false.
   *
   * @default false.
   * @schema SubnetworkSpecForProvider#sendSecondaryIpRangeIfEmpty
   */
  readonly sendSecondaryIpRangeIfEmpty?: boolean;

  /**
   * The stack type for this subnet to identify whether the IPv6 feature is enabled or not.
   * If not specified IPV4_ONLY will be used.
   * Possible values are: IPV4_ONLY, IPV4_IPV6.
   *
   * @schema SubnetworkSpecForProvider#stackType
   */
  readonly stackType?: string;
}

/**
 * Converts an object of type 'SubnetworkSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecForProvider(obj: SubnetworkSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'enableFlowLogs': obj.enableFlowLogs,
    'externalIpv6Prefix': obj.externalIpv6Prefix,
    'ipCidrRange': obj.ipCidrRange,
    'ipCollection': obj.ipCollection,
    'ipv6AccessType': obj.ipv6AccessType,
    'logConfig': obj.logConfig?.map(y => toJson_SubnetworkSpecForProviderLogConfig(y)),
    'network': obj.network,
    'networkRef': toJson_SubnetworkSpecForProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_SubnetworkSpecForProviderNetworkSelector(obj.networkSelector),
    'params': obj.params?.map(y => toJson_SubnetworkSpecForProviderParams(y)),
    'privateIpGoogleAccess': obj.privateIpGoogleAccess,
    'privateIpv6GoogleAccess': obj.privateIpv6GoogleAccess,
    'project': obj.project,
    'purpose': obj.purpose,
    'region': obj.region,
    'reservedInternalRange': obj.reservedInternalRange,
    'role': obj.role,
    'secondaryIpRange': obj.secondaryIpRange?.map(y => toJson_SubnetworkSpecForProviderSecondaryIpRange(y)),
    'sendSecondaryIpRangeIfEmpty': obj.sendSecondaryIpRangeIfEmpty,
    'stackType': obj.stackType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema SubnetworkSpecInitProvider
 */
export interface SubnetworkSpecInitProvider {
  /**
   * An optional description of this resource. Provide this property when
   * you create the resource. This field can be set only at resource
   * creation time.
   *
   * @schema SubnetworkSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Whether to enable flow logging for this subnetwork. If this field is not explicitly set,
   * it will not appear in get listings. If not set the default behavior is determined by the
   * org policy, if there is no org policy specified, then it will default to disabled.
   * This field isn't supported if the subnet purpose field is set to REGIONAL_MANAGED_PROXY.
   *
   * @schema SubnetworkSpecInitProvider#enableFlowLogs
   */
  readonly enableFlowLogs?: boolean;

  /**
   * The range of external IPv6 addresses that are owned by this subnetwork.
   *
   * @schema SubnetworkSpecInitProvider#externalIpv6Prefix
   */
  readonly externalIpv6Prefix?: string;

  /**
   * The range of internal addresses that are owned by this subnetwork.
   * Provide this property when you create the subnetwork. For example,
   * 10.0.0.0/8 or 192.168.0.0/16. Ranges must be unique and
   * non-overlapping within a network. Only IPv4 is supported.
   *
   * @schema SubnetworkSpecInitProvider#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * Resource reference of a PublicDelegatedPrefix. The PDP must be a sub-PDP
   * in EXTERNAL_IPV6_SUBNETWORK_CREATION mode.
   * Use one of the following formats to specify a sub-PDP when creating an
   * IPv6 NetLB forwarding rule using BYOIP:
   * Full resource URL, as in:
   *
   * @schema SubnetworkSpecInitProvider#ipCollection
   */
  readonly ipCollection?: string;

  /**
   * The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation
   * or the first time the subnet is updated into IPV4_IPV6 dual stack. If the ipv6_type is EXTERNAL then this subnet
   * cannot enable direct path.
   * Possible values are: EXTERNAL, INTERNAL.
   *
   * @schema SubnetworkSpecInitProvider#ipv6AccessType
   */
  readonly ipv6AccessType?: string;

  /**
   * This field denotes the VPC flow logging options for this subnetwork. If
   * logging is enabled, logs are exported to Cloud Logging. Flow logging
   * isn't supported if the subnet purpose field is set to subnetwork is
   * REGIONAL_MANAGED_PROXY or GLOBAL_MANAGED_PROXY.
   * Structure is documented below.
   *
   * @schema SubnetworkSpecInitProvider#logConfig
   */
  readonly logConfig?: SubnetworkSpecInitProviderLogConfig[];

  /**
   * The network this subnet belongs to.
   * Only networks that are in the distributed mode can have subnetworks.
   *
   * @schema SubnetworkSpecInitProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema SubnetworkSpecInitProvider#networkRef
   */
  readonly networkRef?: SubnetworkSpecInitProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema SubnetworkSpecInitProvider#networkSelector
   */
  readonly networkSelector?: SubnetworkSpecInitProviderNetworkSelector;

  /**
   * Additional params passed with the request, but not persisted as part of resource payload
   * Structure is documented below.
   *
   * @schema SubnetworkSpecInitProvider#params
   */
  readonly params?: SubnetworkSpecInitProviderParams[];

  /**
   * When enabled, VMs in this subnetwork without external IP addresses can
   * access Google APIs and services by using Private Google Access.
   *
   * @schema SubnetworkSpecInitProvider#privateIpGoogleAccess
   */
  readonly privateIpGoogleAccess?: boolean;

  /**
   * The private IPv6 google access type for the VMs in this subnet.
   *
   * @schema SubnetworkSpecInitProvider#privateIpv6GoogleAccess
   */
  readonly privateIpv6GoogleAccess?: string;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema SubnetworkSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The purpose of the resource. This field can be either PRIVATE_RFC_1918, REGIONAL_MANAGED_PROXY, GLOBAL_MANAGED_PROXY, PRIVATE_SERVICE_CONNECT or PRIVATE_NAT(Beta).
   * A subnet with purpose set to REGIONAL_MANAGED_PROXY is a user-created subnetwork that is reserved for regional Envoy-based load balancers.
   * A subnetwork in a given region with purpose set to GLOBAL_MANAGED_PROXY is a proxy-only subnet and is shared between all the cross-regional Envoy-based load balancers.
   * A subnetwork with purpose set to PRIVATE_SERVICE_CONNECT reserves the subnet for hosting a Private Service Connect published service.
   * A subnetwork with purpose set to PRIVATE_NAT is used as source range for Private NAT gateways.
   * Note that REGIONAL_MANAGED_PROXY is the preferred setting for all regional Envoy load balancers.
   * If unspecified, the purpose defaults to PRIVATE_RFC_1918.
   *
   * @schema SubnetworkSpecInitProvider#purpose
   */
  readonly purpose?: string;

  /**
   * The ID of the reserved internal range. Must be prefixed with networkconnectivity.googleapis.com
   * E.g. networkconnectivity.googleapis.com/projects/{project}/locations/global/internalRanges/{rangeId}
   *
   * @schema SubnetworkSpecInitProvider#reservedInternalRange
   */
  readonly reservedInternalRange?: string;

  /**
   * The role of subnetwork.
   * Currently, this field is only used when purpose is REGIONAL_MANAGED_PROXY.
   * The value can be set to ACTIVE or BACKUP.
   * An ACTIVE subnetwork is one that is currently being used for Envoy-based load balancers in a region.
   * A BACKUP subnetwork is one that is ready to be promoted to ACTIVE or is currently draining.
   * Possible values are: ACTIVE, BACKUP.
   *
   * @schema SubnetworkSpecInitProvider#role
   */
  readonly role?: string;

  /**
   * An array of configurations for secondary IP ranges for VM instances
   * contained in this subnetwork. The primary IP of such VM must belong
   * to the primary ipCidrRange of the subnetwork. The alias IPs may belong
   * to either primary or secondary ranges.
   * Note: This field uses attr-as-block mode to avoid
   * breaking users during the 0.12 upgrade. To explicitly send a list
   * of zero objects you must use the following syntax:
   * example=[]
   * For more details about this behavior, see this section.
   * Structure is documented below.
   *
   * @schema SubnetworkSpecInitProvider#secondaryIpRange
   */
  readonly secondaryIpRange?: SubnetworkSpecInitProviderSecondaryIpRange[];

  /**
   * Controls the removal behavior of secondary_ip_range.
   * When false, removing secondary_ip_range from config will not produce a diff as
   * the provider will default to the API's value.
   * When true, the provider will treat removing secondary_ip_range as sending an
   * empty list of secondary IP ranges to the API.
   * Defaults to false.
   *
   * @default false.
   * @schema SubnetworkSpecInitProvider#sendSecondaryIpRangeIfEmpty
   */
  readonly sendSecondaryIpRangeIfEmpty?: boolean;

  /**
   * The stack type for this subnet to identify whether the IPv6 feature is enabled or not.
   * If not specified IPV4_ONLY will be used.
   * Possible values are: IPV4_ONLY, IPV4_IPV6.
   *
   * @schema SubnetworkSpecInitProvider#stackType
   */
  readonly stackType?: string;
}

/**
 * Converts an object of type 'SubnetworkSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecInitProvider(obj: SubnetworkSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'enableFlowLogs': obj.enableFlowLogs,
    'externalIpv6Prefix': obj.externalIpv6Prefix,
    'ipCidrRange': obj.ipCidrRange,
    'ipCollection': obj.ipCollection,
    'ipv6AccessType': obj.ipv6AccessType,
    'logConfig': obj.logConfig?.map(y => toJson_SubnetworkSpecInitProviderLogConfig(y)),
    'network': obj.network,
    'networkRef': toJson_SubnetworkSpecInitProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_SubnetworkSpecInitProviderNetworkSelector(obj.networkSelector),
    'params': obj.params?.map(y => toJson_SubnetworkSpecInitProviderParams(y)),
    'privateIpGoogleAccess': obj.privateIpGoogleAccess,
    'privateIpv6GoogleAccess': obj.privateIpv6GoogleAccess,
    'project': obj.project,
    'purpose': obj.purpose,
    'reservedInternalRange': obj.reservedInternalRange,
    'role': obj.role,
    'secondaryIpRange': obj.secondaryIpRange?.map(y => toJson_SubnetworkSpecInitProviderSecondaryIpRange(y)),
    'sendSecondaryIpRangeIfEmpty': obj.sendSecondaryIpRangeIfEmpty,
    'stackType': obj.stackType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema SubnetworkSpecManagementPolicies
 */
export enum SubnetworkSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema SubnetworkSpecProviderConfigRef
 */
export interface SubnetworkSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetworkSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetworkSpecProviderConfigRef#policy
   */
  readonly policy?: SubnetworkSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'SubnetworkSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecProviderConfigRef(obj: SubnetworkSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetworkSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema SubnetworkSpecWriteConnectionSecretToRef
 */
export interface SubnetworkSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SubnetworkSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SubnetworkSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'SubnetworkSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecWriteConnectionSecretToRef(obj: SubnetworkSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubnetworkSpecForProviderLogConfig
 */
export interface SubnetworkSpecForProviderLogConfig {
  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Toggles the aggregation interval for collecting flow logs. Increasing the
   * interval time will reduce the amount of generated flow logs for long
   * lasting connections. Default is an interval of 5 seconds per connection.
   * Default value is INTERVAL_5_SEC.
   * Possible values are: INTERVAL_5_SEC, INTERVAL_30_SEC, INTERVAL_1_MIN, INTERVAL_5_MIN, INTERVAL_10_MIN, INTERVAL_15_MIN.
   *
   * @default an interval of 5 seconds per connection.
   * @schema SubnetworkSpecForProviderLogConfig#aggregationInterval
   */
  readonly aggregationInterval?: string;

  /**
   * Export filter used to define which VPC flow logs should be logged, as as CEL expression. See
   * https://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.
   * The default value is 'true', which evaluates to include everything.
   *
   * @schema SubnetworkSpecForProviderLogConfig#filterExpr
   */
  readonly filterExpr?: string;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * The value of the field must be in [0, 1]. Set the sampling rate of VPC
   * flow logs within the subnetwork where 1.0 means all collected logs are
   * reported and 0.0 means no logs are reported. Default is 0.5 which means
   * half of all collected logs are reported.
   *
   * @default 0.5 which means
   * @schema SubnetworkSpecForProviderLogConfig#flowSampling
   */
  readonly flowSampling?: number;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Configures whether metadata fields should be added to the reported VPC
   * flow logs.
   * Default value is INCLUDE_ALL_METADATA.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA, CUSTOM_METADATA.
   *
   * @schema SubnetworkSpecForProviderLogConfig#metadata
   */
  readonly metadata?: string;

  /**
   * List of metadata fields that should be added to reported logs.
   * Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" is set to CUSTOM_METADATA.
   *
   * @schema SubnetworkSpecForProviderLogConfig#metadataFields
   */
  readonly metadataFields?: string[];
}

/**
 * Converts an object of type 'SubnetworkSpecForProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecForProviderLogConfig(obj: SubnetworkSpecForProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationInterval': obj.aggregationInterval,
    'filterExpr': obj.filterExpr,
    'flowSampling': obj.flowSampling,
    'metadata': obj.metadata,
    'metadataFields': obj.metadataFields?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema SubnetworkSpecForProviderNetworkRef
 */
export interface SubnetworkSpecForProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetworkSpecForProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetworkSpecForProviderNetworkRef#policy
   */
  readonly policy?: SubnetworkSpecForProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'SubnetworkSpecForProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecForProviderNetworkRef(obj: SubnetworkSpecForProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetworkSpecForProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema SubnetworkSpecForProviderNetworkSelector
 */
export interface SubnetworkSpecForProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema SubnetworkSpecForProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubnetworkSpecForProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubnetworkSpecForProviderNetworkSelector#policy
   */
  readonly policy?: SubnetworkSpecForProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'SubnetworkSpecForProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecForProviderNetworkSelector(obj: SubnetworkSpecForProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubnetworkSpecForProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubnetworkSpecForProviderParams
 */
export interface SubnetworkSpecForProviderParams {
  /**
   * Resource manager tags to be bound to the subnetwork. Tag keys and values have the
   * same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
   * and values are in the format tagValues/456. The field is ignored when empty.
   * The field is immutable and causes resource replacement when mutated. This field is only
   * set at create time and modifying this field after creation will trigger recreation.
   * To apply tags to an existing resource, see the google_tags_tag_binding resource.
   *
   * @schema SubnetworkSpecForProviderParams#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };
}

/**
 * Converts an object of type 'SubnetworkSpecForProviderParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecForProviderParams(obj: SubnetworkSpecForProviderParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubnetworkSpecForProviderSecondaryIpRange
 */
export interface SubnetworkSpecForProviderSecondaryIpRange {
  /**
   * The range of IP addresses belonging to this subnetwork secondary
   * range. Provide this property when you create the subnetwork.
   * Ranges must be unique and non-overlapping with all primary and
   * secondary IP ranges within a network. Only IPv4 is supported.
   * Field is optional when reserved_internal_range is defined, otherwise required.
   *
   * @schema SubnetworkSpecForProviderSecondaryIpRange#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * The name associated with this subnetwork secondary range, used
   * when adding an alias IP range to a VM instance. The name must
   * be 1-63 characters long, and comply with RFC1035. The name
   * must be unique within the subnetwork.
   *
   * @schema SubnetworkSpecForProviderSecondaryIpRange#rangeName
   */
  readonly rangeName?: string;

  /**
   * The ID of the reserved internal range. Must be prefixed with networkconnectivity.googleapis.com
   * E.g. networkconnectivity.googleapis.com/projects/{project}/locations/global/internalRanges/{rangeId}
   *
   * @schema SubnetworkSpecForProviderSecondaryIpRange#reservedInternalRange
   */
  readonly reservedInternalRange?: string;
}

/**
 * Converts an object of type 'SubnetworkSpecForProviderSecondaryIpRange' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecForProviderSecondaryIpRange(obj: SubnetworkSpecForProviderSecondaryIpRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipCidrRange': obj.ipCidrRange,
    'rangeName': obj.rangeName,
    'reservedInternalRange': obj.reservedInternalRange,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubnetworkSpecInitProviderLogConfig
 */
export interface SubnetworkSpecInitProviderLogConfig {
  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Toggles the aggregation interval for collecting flow logs. Increasing the
   * interval time will reduce the amount of generated flow logs for long
   * lasting connections. Default is an interval of 5 seconds per connection.
   * Default value is INTERVAL_5_SEC.
   * Possible values are: INTERVAL_5_SEC, INTERVAL_30_SEC, INTERVAL_1_MIN, INTERVAL_5_MIN, INTERVAL_10_MIN, INTERVAL_15_MIN.
   *
   * @default an interval of 5 seconds per connection.
   * @schema SubnetworkSpecInitProviderLogConfig#aggregationInterval
   */
  readonly aggregationInterval?: string;

  /**
   * Export filter used to define which VPC flow logs should be logged, as as CEL expression. See
   * https://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.
   * The default value is 'true', which evaluates to include everything.
   *
   * @schema SubnetworkSpecInitProviderLogConfig#filterExpr
   */
  readonly filterExpr?: string;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * The value of the field must be in [0, 1]. Set the sampling rate of VPC
   * flow logs within the subnetwork where 1.0 means all collected logs are
   * reported and 0.0 means no logs are reported. Default is 0.5 which means
   * half of all collected logs are reported.
   *
   * @default 0.5 which means
   * @schema SubnetworkSpecInitProviderLogConfig#flowSampling
   */
  readonly flowSampling?: number;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Configures whether metadata fields should be added to the reported VPC
   * flow logs.
   * Default value is INCLUDE_ALL_METADATA.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA, CUSTOM_METADATA.
   *
   * @schema SubnetworkSpecInitProviderLogConfig#metadata
   */
  readonly metadata?: string;

  /**
   * List of metadata fields that should be added to reported logs.
   * Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" is set to CUSTOM_METADATA.
   *
   * @schema SubnetworkSpecInitProviderLogConfig#metadataFields
   */
  readonly metadataFields?: string[];
}

/**
 * Converts an object of type 'SubnetworkSpecInitProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecInitProviderLogConfig(obj: SubnetworkSpecInitProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationInterval': obj.aggregationInterval,
    'filterExpr': obj.filterExpr,
    'flowSampling': obj.flowSampling,
    'metadata': obj.metadata,
    'metadataFields': obj.metadataFields?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema SubnetworkSpecInitProviderNetworkRef
 */
export interface SubnetworkSpecInitProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetworkSpecInitProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetworkSpecInitProviderNetworkRef#policy
   */
  readonly policy?: SubnetworkSpecInitProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'SubnetworkSpecInitProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecInitProviderNetworkRef(obj: SubnetworkSpecInitProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetworkSpecInitProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema SubnetworkSpecInitProviderNetworkSelector
 */
export interface SubnetworkSpecInitProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema SubnetworkSpecInitProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubnetworkSpecInitProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubnetworkSpecInitProviderNetworkSelector#policy
   */
  readonly policy?: SubnetworkSpecInitProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'SubnetworkSpecInitProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecInitProviderNetworkSelector(obj: SubnetworkSpecInitProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubnetworkSpecInitProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubnetworkSpecInitProviderParams
 */
export interface SubnetworkSpecInitProviderParams {
  /**
   * Resource manager tags to be bound to the subnetwork. Tag keys and values have the
   * same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
   * and values are in the format tagValues/456. The field is ignored when empty.
   * The field is immutable and causes resource replacement when mutated. This field is only
   * set at create time and modifying this field after creation will trigger recreation.
   * To apply tags to an existing resource, see the google_tags_tag_binding resource.
   *
   * @schema SubnetworkSpecInitProviderParams#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };
}

/**
 * Converts an object of type 'SubnetworkSpecInitProviderParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecInitProviderParams(obj: SubnetworkSpecInitProviderParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubnetworkSpecInitProviderSecondaryIpRange
 */
export interface SubnetworkSpecInitProviderSecondaryIpRange {
  /**
   * The range of IP addresses belonging to this subnetwork secondary
   * range. Provide this property when you create the subnetwork.
   * Ranges must be unique and non-overlapping with all primary and
   * secondary IP ranges within a network. Only IPv4 is supported.
   * Field is optional when reserved_internal_range is defined, otherwise required.
   *
   * @schema SubnetworkSpecInitProviderSecondaryIpRange#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * The name associated with this subnetwork secondary range, used
   * when adding an alias IP range to a VM instance. The name must
   * be 1-63 characters long, and comply with RFC1035. The name
   * must be unique within the subnetwork.
   *
   * @schema SubnetworkSpecInitProviderSecondaryIpRange#rangeName
   */
  readonly rangeName?: string;

  /**
   * The ID of the reserved internal range. Must be prefixed with networkconnectivity.googleapis.com
   * E.g. networkconnectivity.googleapis.com/projects/{project}/locations/global/internalRanges/{rangeId}
   *
   * @schema SubnetworkSpecInitProviderSecondaryIpRange#reservedInternalRange
   */
  readonly reservedInternalRange?: string;
}

/**
 * Converts an object of type 'SubnetworkSpecInitProviderSecondaryIpRange' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecInitProviderSecondaryIpRange(obj: SubnetworkSpecInitProviderSecondaryIpRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipCidrRange': obj.ipCidrRange,
    'rangeName': obj.rangeName,
    'reservedInternalRange': obj.reservedInternalRange,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetworkSpecProviderConfigRefPolicy
 */
export interface SubnetworkSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetworkSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetworkSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecProviderConfigRefPolicy(obj: SubnetworkSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetworkSpecForProviderNetworkRefPolicy
 */
export interface SubnetworkSpecForProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkSpecForProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: SubnetworkSpecForProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkSpecForProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: SubnetworkSpecForProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkSpecForProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecForProviderNetworkRefPolicy(obj: SubnetworkSpecForProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema SubnetworkSpecForProviderNetworkSelectorPolicy
 */
export interface SubnetworkSpecForProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkSpecForProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: SubnetworkSpecForProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkSpecForProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: SubnetworkSpecForProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkSpecForProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecForProviderNetworkSelectorPolicy(obj: SubnetworkSpecForProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetworkSpecInitProviderNetworkRefPolicy
 */
export interface SubnetworkSpecInitProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkSpecInitProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: SubnetworkSpecInitProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkSpecInitProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: SubnetworkSpecInitProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkSpecInitProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecInitProviderNetworkRefPolicy(obj: SubnetworkSpecInitProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema SubnetworkSpecInitProviderNetworkSelectorPolicy
 */
export interface SubnetworkSpecInitProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkSpecInitProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: SubnetworkSpecInitProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkSpecInitProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: SubnetworkSpecInitProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkSpecInitProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecInitProviderNetworkSelectorPolicy(obj: SubnetworkSpecInitProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkSpecProviderConfigRefPolicyResolution
 */
export enum SubnetworkSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkSpecProviderConfigRefPolicyResolve
 */
export enum SubnetworkSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkSpecForProviderNetworkRefPolicyResolution
 */
export enum SubnetworkSpecForProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkSpecForProviderNetworkRefPolicyResolve
 */
export enum SubnetworkSpecForProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkSpecForProviderNetworkSelectorPolicyResolution
 */
export enum SubnetworkSpecForProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkSpecForProviderNetworkSelectorPolicyResolve
 */
export enum SubnetworkSpecForProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkSpecInitProviderNetworkRefPolicyResolution
 */
export enum SubnetworkSpecInitProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkSpecInitProviderNetworkRefPolicyResolve
 */
export enum SubnetworkSpecInitProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkSpecInitProviderNetworkSelectorPolicyResolution
 */
export enum SubnetworkSpecInitProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkSpecInitProviderNetworkSelectorPolicyResolve
 */
export enum SubnetworkSpecInitProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Subnetwork is the Schema for the Subnetworks API. A VPC network is a virtual version of the traditional physical networks that exist within and between physical data centers.
 *
 * @schema SubnetworkV1Beta2
 */
export class SubnetworkV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SubnetworkV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.gcp.upbound.io/v1beta2',
    kind: 'Subnetwork',
  }

  /**
   * Renders a Kubernetes manifest for "SubnetworkV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SubnetworkV1Beta2Props): any {
    return {
      ...SubnetworkV1Beta2.GVK,
      ...toJson_SubnetworkV1Beta2Props(props),
    };
  }

  /**
   * Defines a "SubnetworkV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SubnetworkV1Beta2Props) {
    super(scope, id, {
      ...SubnetworkV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...SubnetworkV1Beta2.GVK,
      ...toJson_SubnetworkV1Beta2Props(resolved),
    };
  }
}

/**
 * Subnetwork is the Schema for the Subnetworks API. A VPC network is a virtual version of the traditional physical networks that exist within and between physical data centers.
 *
 * @schema SubnetworkV1Beta2
 */
export interface SubnetworkV1Beta2Props {
  /**
   * @schema SubnetworkV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SubnetworkSpec defines the desired state of Subnetwork
   *
   * @schema SubnetworkV1Beta2#spec
   */
  readonly spec: SubnetworkV1Beta2Spec;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2Props(obj: SubnetworkV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SubnetworkV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SubnetworkSpec defines the desired state of Subnetwork
 *
 * @schema SubnetworkV1Beta2Spec
 */
export interface SubnetworkV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SubnetworkV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: SubnetworkV1Beta2SpecDeletionPolicy;

  /**
   * @schema SubnetworkV1Beta2Spec#forProvider
   */
  readonly forProvider: SubnetworkV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema SubnetworkV1Beta2Spec#initProvider
   */
  readonly initProvider?: SubnetworkV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SubnetworkV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: SubnetworkV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema SubnetworkV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: SubnetworkV1Beta2SpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema SubnetworkV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SubnetworkV1Beta2SpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2Spec(obj: SubnetworkV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SubnetworkV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_SubnetworkV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SubnetworkV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_SubnetworkV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SubnetworkV1Beta2SpecDeletionPolicy
 */
export enum SubnetworkV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SubnetworkV1Beta2SpecForProvider
 */
export interface SubnetworkV1Beta2SpecForProvider {
  /**
   * An optional description of this resource. Provide this property when
   * you create the resource. This field can be set only at resource
   * creation time.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether to enable flow logging for this subnetwork. If this field is not explicitly set,
   * it will not appear in get listings. If not set the default behavior is determined by the
   * org policy, if there is no org policy specified, then it will default to disabled.
   * This field isn't supported if the subnet purpose field is set to REGIONAL_MANAGED_PROXY.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#enableFlowLogs
   */
  readonly enableFlowLogs?: boolean;

  /**
   * The range of external IPv6 addresses that are owned by this subnetwork.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#externalIpv6Prefix
   */
  readonly externalIpv6Prefix?: string;

  /**
   * The range of internal addresses that are owned by this subnetwork.
   * Provide this property when you create the subnetwork. For example,
   * 10.0.0.0/8 or 192.168.0.0/16. Ranges must be unique and
   * non-overlapping within a network. Only IPv4 is supported.
   * Field is optional when reserved_internal_range is defined, otherwise required.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * Resource reference of a PublicDelegatedPrefix. The PDP must be a sub-PDP
   * in EXTERNAL_IPV6_SUBNETWORK_CREATION mode.
   * Use one of the following formats to specify a sub-PDP when creating an
   * IPv6 NetLB forwarding rule using BYOIP:
   * Full resource URL, as in:
   *
   * @schema SubnetworkV1Beta2SpecForProvider#ipCollection
   */
  readonly ipCollection?: string;

  /**
   * The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation
   * or the first time the subnet is updated into IPV4_IPV6 dual stack. If the ipv6_type is EXTERNAL then this subnet
   * cannot enable direct path.
   * Possible values are: EXTERNAL, INTERNAL.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#ipv6AccessType
   */
  readonly ipv6AccessType?: string;

  /**
   * This field denotes the VPC flow logging options for this subnetwork. If
   * logging is enabled, logs are exported to Cloud Logging. Flow logging
   * isn't supported if the subnet purpose field is set to subnetwork is
   * REGIONAL_MANAGED_PROXY or GLOBAL_MANAGED_PROXY.
   * Structure is documented below.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#logConfig
   */
  readonly logConfig?: SubnetworkV1Beta2SpecForProviderLogConfig;

  /**
   * The network this subnet belongs to.
   * Only networks that are in the distributed mode can have subnetworks.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#networkRef
   */
  readonly networkRef?: SubnetworkV1Beta2SpecForProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#networkSelector
   */
  readonly networkSelector?: SubnetworkV1Beta2SpecForProviderNetworkSelector;

  /**
   * Additional params passed with the request, but not persisted as part of resource payload
   * Structure is documented below.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#params
   */
  readonly params?: SubnetworkV1Beta2SpecForProviderParams;

  /**
   * When enabled, VMs in this subnetwork without external IP addresses can
   * access Google APIs and services by using Private Google Access.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#privateIpGoogleAccess
   */
  readonly privateIpGoogleAccess?: boolean;

  /**
   * The private IPv6 google access type for the VMs in this subnet.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#privateIpv6GoogleAccess
   */
  readonly privateIpv6GoogleAccess?: string;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#project
   */
  readonly project?: string;

  /**
   * The purpose of the resource. This field can be either PRIVATE, REGIONAL_MANAGED_PROXY, GLOBAL_MANAGED_PROXY, PRIVATE_SERVICE_CONNECT, PEER_MIGRATION or PRIVATE_NAT(Beta).
   * A subnet with purpose set to REGIONAL_MANAGED_PROXY is a user-created subnetwork that is reserved for regional Envoy-based load balancers.
   * A subnetwork in a given region with purpose set to GLOBAL_MANAGED_PROXY is a proxy-only subnet and is shared between all the cross-regional Envoy-based load balancers.
   * A subnetwork with purpose set to PRIVATE_SERVICE_CONNECT reserves the subnet for hosting a Private Service Connect published service.
   * A subnetwork with purpose set to PEER_MIGRATION is a user created subnetwork that is reserved for migrating resources from one peered network to another.
   * A subnetwork with purpose set to PRIVATE_NAT is used as source range for Private NAT gateways.
   * Note that REGIONAL_MANAGED_PROXY is the preferred setting for all regional Envoy load balancers.
   * If unspecified, the purpose defaults to PRIVATE.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#purpose
   */
  readonly purpose?: string;

  /**
   * The GCP region for this subnetwork.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#region
   */
  readonly region: string;

  /**
   * The ID of the reserved internal range. Must be prefixed with networkconnectivity.googleapis.com
   * E.g. networkconnectivity.googleapis.com/projects/{project}/locations/global/internalRanges/{rangeId}
   *
   * @schema SubnetworkV1Beta2SpecForProvider#reservedInternalRange
   */
  readonly reservedInternalRange?: string;

  /**
   * The role of subnetwork.
   * Currently, this field is only used when purpose is REGIONAL_MANAGED_PROXY.
   * The value can be set to ACTIVE or BACKUP.
   * An ACTIVE subnetwork is one that is currently being used for Envoy-based load balancers in a region.
   * A BACKUP subnetwork is one that is ready to be promoted to ACTIVE or is currently draining.
   * Possible values are: ACTIVE, BACKUP.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#role
   */
  readonly role?: string;

  /**
   * An array of configurations for secondary IP ranges for VM instances
   * contained in this subnetwork. The primary IP of such VM must belong
   * to the primary ipCidrRange of the subnetwork. The alias IPs may belong
   * to either primary or secondary ranges.
   * Note: This field uses attr-as-block mode to avoid
   * breaking users during the 0.12 upgrade. To explicitly send a list of zero objects,
   * set send_secondary_ip_range_if_empty = true
   * Structure is documented below.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#secondaryIpRange
   */
  readonly secondaryIpRange?: SubnetworkV1Beta2SpecForProviderSecondaryIpRange[];

  /**
   * Controls the removal behavior of secondary_ip_range.
   * When false, removing secondary_ip_range from config will not produce a diff as
   * the provider will default to the API's value.
   * When true, the provider will treat removing secondary_ip_range as sending an
   * empty list of secondary IP ranges to the API.
   * Defaults to false.
   *
   * @default false.
   * @schema SubnetworkV1Beta2SpecForProvider#sendSecondaryIpRangeIfEmpty
   */
  readonly sendSecondaryIpRangeIfEmpty?: boolean;

  /**
   * The stack type for this subnet to identify whether the IPv6 feature is enabled or not.
   * If not specified IPV4_ONLY will be used.
   * Possible values are: IPV4_ONLY, IPV4_IPV6, IPV6_ONLY.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#stackType
   */
  readonly stackType?: string;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecForProvider(obj: SubnetworkV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'enableFlowLogs': obj.enableFlowLogs,
    'externalIpv6Prefix': obj.externalIpv6Prefix,
    'ipCidrRange': obj.ipCidrRange,
    'ipCollection': obj.ipCollection,
    'ipv6AccessType': obj.ipv6AccessType,
    'logConfig': toJson_SubnetworkV1Beta2SpecForProviderLogConfig(obj.logConfig),
    'network': obj.network,
    'networkRef': toJson_SubnetworkV1Beta2SpecForProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_SubnetworkV1Beta2SpecForProviderNetworkSelector(obj.networkSelector),
    'params': toJson_SubnetworkV1Beta2SpecForProviderParams(obj.params),
    'privateIpGoogleAccess': obj.privateIpGoogleAccess,
    'privateIpv6GoogleAccess': obj.privateIpv6GoogleAccess,
    'project': obj.project,
    'purpose': obj.purpose,
    'region': obj.region,
    'reservedInternalRange': obj.reservedInternalRange,
    'role': obj.role,
    'secondaryIpRange': obj.secondaryIpRange?.map(y => toJson_SubnetworkV1Beta2SpecForProviderSecondaryIpRange(y)),
    'sendSecondaryIpRangeIfEmpty': obj.sendSecondaryIpRangeIfEmpty,
    'stackType': obj.stackType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema SubnetworkV1Beta2SpecInitProvider
 */
export interface SubnetworkV1Beta2SpecInitProvider {
  /**
   * An optional description of this resource. Provide this property when
   * you create the resource. This field can be set only at resource
   * creation time.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Whether to enable flow logging for this subnetwork. If this field is not explicitly set,
   * it will not appear in get listings. If not set the default behavior is determined by the
   * org policy, if there is no org policy specified, then it will default to disabled.
   * This field isn't supported if the subnet purpose field is set to REGIONAL_MANAGED_PROXY.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#enableFlowLogs
   */
  readonly enableFlowLogs?: boolean;

  /**
   * The range of external IPv6 addresses that are owned by this subnetwork.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#externalIpv6Prefix
   */
  readonly externalIpv6Prefix?: string;

  /**
   * The range of internal addresses that are owned by this subnetwork.
   * Provide this property when you create the subnetwork. For example,
   * 10.0.0.0/8 or 192.168.0.0/16. Ranges must be unique and
   * non-overlapping within a network. Only IPv4 is supported.
   * Field is optional when reserved_internal_range is defined, otherwise required.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * Resource reference of a PublicDelegatedPrefix. The PDP must be a sub-PDP
   * in EXTERNAL_IPV6_SUBNETWORK_CREATION mode.
   * Use one of the following formats to specify a sub-PDP when creating an
   * IPv6 NetLB forwarding rule using BYOIP:
   * Full resource URL, as in:
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#ipCollection
   */
  readonly ipCollection?: string;

  /**
   * The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation
   * or the first time the subnet is updated into IPV4_IPV6 dual stack. If the ipv6_type is EXTERNAL then this subnet
   * cannot enable direct path.
   * Possible values are: EXTERNAL, INTERNAL.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#ipv6AccessType
   */
  readonly ipv6AccessType?: string;

  /**
   * This field denotes the VPC flow logging options for this subnetwork. If
   * logging is enabled, logs are exported to Cloud Logging. Flow logging
   * isn't supported if the subnet purpose field is set to subnetwork is
   * REGIONAL_MANAGED_PROXY or GLOBAL_MANAGED_PROXY.
   * Structure is documented below.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#logConfig
   */
  readonly logConfig?: SubnetworkV1Beta2SpecInitProviderLogConfig;

  /**
   * The network this subnet belongs to.
   * Only networks that are in the distributed mode can have subnetworks.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#networkRef
   */
  readonly networkRef?: SubnetworkV1Beta2SpecInitProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#networkSelector
   */
  readonly networkSelector?: SubnetworkV1Beta2SpecInitProviderNetworkSelector;

  /**
   * Additional params passed with the request, but not persisted as part of resource payload
   * Structure is documented below.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#params
   */
  readonly params?: SubnetworkV1Beta2SpecInitProviderParams;

  /**
   * When enabled, VMs in this subnetwork without external IP addresses can
   * access Google APIs and services by using Private Google Access.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#privateIpGoogleAccess
   */
  readonly privateIpGoogleAccess?: boolean;

  /**
   * The private IPv6 google access type for the VMs in this subnet.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#privateIpv6GoogleAccess
   */
  readonly privateIpv6GoogleAccess?: string;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The purpose of the resource. This field can be either PRIVATE, REGIONAL_MANAGED_PROXY, GLOBAL_MANAGED_PROXY, PRIVATE_SERVICE_CONNECT, PEER_MIGRATION or PRIVATE_NAT(Beta).
   * A subnet with purpose set to REGIONAL_MANAGED_PROXY is a user-created subnetwork that is reserved for regional Envoy-based load balancers.
   * A subnetwork in a given region with purpose set to GLOBAL_MANAGED_PROXY is a proxy-only subnet and is shared between all the cross-regional Envoy-based load balancers.
   * A subnetwork with purpose set to PRIVATE_SERVICE_CONNECT reserves the subnet for hosting a Private Service Connect published service.
   * A subnetwork with purpose set to PEER_MIGRATION is a user created subnetwork that is reserved for migrating resources from one peered network to another.
   * A subnetwork with purpose set to PRIVATE_NAT is used as source range for Private NAT gateways.
   * Note that REGIONAL_MANAGED_PROXY is the preferred setting for all regional Envoy load balancers.
   * If unspecified, the purpose defaults to PRIVATE.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#purpose
   */
  readonly purpose?: string;

  /**
   * The ID of the reserved internal range. Must be prefixed with networkconnectivity.googleapis.com
   * E.g. networkconnectivity.googleapis.com/projects/{project}/locations/global/internalRanges/{rangeId}
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#reservedInternalRange
   */
  readonly reservedInternalRange?: string;

  /**
   * The role of subnetwork.
   * Currently, this field is only used when purpose is REGIONAL_MANAGED_PROXY.
   * The value can be set to ACTIVE or BACKUP.
   * An ACTIVE subnetwork is one that is currently being used for Envoy-based load balancers in a region.
   * A BACKUP subnetwork is one that is ready to be promoted to ACTIVE or is currently draining.
   * Possible values are: ACTIVE, BACKUP.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#role
   */
  readonly role?: string;

  /**
   * An array of configurations for secondary IP ranges for VM instances
   * contained in this subnetwork. The primary IP of such VM must belong
   * to the primary ipCidrRange of the subnetwork. The alias IPs may belong
   * to either primary or secondary ranges.
   * Note: This field uses attr-as-block mode to avoid
   * breaking users during the 0.12 upgrade. To explicitly send a list of zero objects,
   * set send_secondary_ip_range_if_empty = true
   * Structure is documented below.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#secondaryIpRange
   */
  readonly secondaryIpRange?: SubnetworkV1Beta2SpecInitProviderSecondaryIpRange[];

  /**
   * Controls the removal behavior of secondary_ip_range.
   * When false, removing secondary_ip_range from config will not produce a diff as
   * the provider will default to the API's value.
   * When true, the provider will treat removing secondary_ip_range as sending an
   * empty list of secondary IP ranges to the API.
   * Defaults to false.
   *
   * @default false.
   * @schema SubnetworkV1Beta2SpecInitProvider#sendSecondaryIpRangeIfEmpty
   */
  readonly sendSecondaryIpRangeIfEmpty?: boolean;

  /**
   * The stack type for this subnet to identify whether the IPv6 feature is enabled or not.
   * If not specified IPV4_ONLY will be used.
   * Possible values are: IPV4_ONLY, IPV4_IPV6, IPV6_ONLY.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#stackType
   */
  readonly stackType?: string;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecInitProvider(obj: SubnetworkV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'enableFlowLogs': obj.enableFlowLogs,
    'externalIpv6Prefix': obj.externalIpv6Prefix,
    'ipCidrRange': obj.ipCidrRange,
    'ipCollection': obj.ipCollection,
    'ipv6AccessType': obj.ipv6AccessType,
    'logConfig': toJson_SubnetworkV1Beta2SpecInitProviderLogConfig(obj.logConfig),
    'network': obj.network,
    'networkRef': toJson_SubnetworkV1Beta2SpecInitProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_SubnetworkV1Beta2SpecInitProviderNetworkSelector(obj.networkSelector),
    'params': toJson_SubnetworkV1Beta2SpecInitProviderParams(obj.params),
    'privateIpGoogleAccess': obj.privateIpGoogleAccess,
    'privateIpv6GoogleAccess': obj.privateIpv6GoogleAccess,
    'project': obj.project,
    'purpose': obj.purpose,
    'reservedInternalRange': obj.reservedInternalRange,
    'role': obj.role,
    'secondaryIpRange': obj.secondaryIpRange?.map(y => toJson_SubnetworkV1Beta2SpecInitProviderSecondaryIpRange(y)),
    'sendSecondaryIpRangeIfEmpty': obj.sendSecondaryIpRangeIfEmpty,
    'stackType': obj.stackType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema SubnetworkV1Beta2SpecManagementPolicies
 */
export enum SubnetworkV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema SubnetworkV1Beta2SpecProviderConfigRef
 */
export interface SubnetworkV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetworkV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetworkV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: SubnetworkV1Beta2SpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecProviderConfigRef(obj: SubnetworkV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetworkV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema SubnetworkV1Beta2SpecWriteConnectionSecretToRef
 */
export interface SubnetworkV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SubnetworkV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SubnetworkV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecWriteConnectionSecretToRef(obj: SubnetworkV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * This field denotes the VPC flow logging options for this subnetwork. If
 * logging is enabled, logs are exported to Cloud Logging. Flow logging
 * isn't supported if the subnet purpose field is set to subnetwork is
 * REGIONAL_MANAGED_PROXY or GLOBAL_MANAGED_PROXY.
 * Structure is documented below.
 *
 * @schema SubnetworkV1Beta2SpecForProviderLogConfig
 */
export interface SubnetworkV1Beta2SpecForProviderLogConfig {
  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Toggles the aggregation interval for collecting flow logs. Increasing the
   * interval time will reduce the amount of generated flow logs for long
   * lasting connections. Default is an interval of 5 seconds per connection.
   * Default value is INTERVAL_5_SEC.
   * Possible values are: INTERVAL_5_SEC, INTERVAL_30_SEC, INTERVAL_1_MIN, INTERVAL_5_MIN, INTERVAL_10_MIN, INTERVAL_15_MIN.
   *
   * @default an interval of 5 seconds per connection.
   * @schema SubnetworkV1Beta2SpecForProviderLogConfig#aggregationInterval
   */
  readonly aggregationInterval?: string;

  /**
   * Export filter used to define which VPC flow logs should be logged, as as CEL expression. See
   * https://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.
   * The default value is 'true', which evaluates to include everything.
   *
   * @schema SubnetworkV1Beta2SpecForProviderLogConfig#filterExpr
   */
  readonly filterExpr?: string;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * The value of the field must be in [0, 1]. Set the sampling rate of VPC
   * flow logs within the subnetwork where 1.0 means all collected logs are
   * reported and 0.0 means no logs are reported. Default is 0.5 which means
   * half of all collected logs are reported.
   *
   * @default 0.5 which means
   * @schema SubnetworkV1Beta2SpecForProviderLogConfig#flowSampling
   */
  readonly flowSampling?: number;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Configures whether metadata fields should be added to the reported VPC
   * flow logs.
   * Default value is INCLUDE_ALL_METADATA.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA, CUSTOM_METADATA.
   *
   * @schema SubnetworkV1Beta2SpecForProviderLogConfig#metadata
   */
  readonly metadata?: string;

  /**
   * List of metadata fields that should be added to reported logs.
   * Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" is set to CUSTOM_METADATA.
   *
   * @schema SubnetworkV1Beta2SpecForProviderLogConfig#metadataFields
   */
  readonly metadataFields?: string[];
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecForProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecForProviderLogConfig(obj: SubnetworkV1Beta2SpecForProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationInterval': obj.aggregationInterval,
    'filterExpr': obj.filterExpr,
    'flowSampling': obj.flowSampling,
    'metadata': obj.metadata,
    'metadataFields': obj.metadataFields?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkRef
 */
export interface SubnetworkV1Beta2SpecForProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkRef#policy
   */
  readonly policy?: SubnetworkV1Beta2SpecForProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecForProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecForProviderNetworkRef(obj: SubnetworkV1Beta2SpecForProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetworkV1Beta2SpecForProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkSelector
 */
export interface SubnetworkV1Beta2SpecForProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkSelector#policy
   */
  readonly policy?: SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecForProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecForProviderNetworkSelector(obj: SubnetworkV1Beta2SpecForProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Additional params passed with the request, but not persisted as part of resource payload
 * Structure is documented below.
 *
 * @schema SubnetworkV1Beta2SpecForProviderParams
 */
export interface SubnetworkV1Beta2SpecForProviderParams {
  /**
   * Resource manager tags to be bound to the subnetwork. Tag keys and values have the
   * same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
   * and values are in the format tagValues/456. The field is ignored when empty.
   * The field is immutable and causes resource replacement when mutated. This field is only
   * set at create time and modifying this field after creation will trigger recreation.
   * To apply tags to an existing resource, see the google_tags_tag_binding resource.
   *
   * @schema SubnetworkV1Beta2SpecForProviderParams#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecForProviderParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecForProviderParams(obj: SubnetworkV1Beta2SpecForProviderParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubnetworkV1Beta2SpecForProviderSecondaryIpRange
 */
export interface SubnetworkV1Beta2SpecForProviderSecondaryIpRange {
  /**
   * The range of IP addresses belonging to this subnetwork secondary
   * range. Provide this property when you create the subnetwork.
   * Ranges must be unique and non-overlapping with all primary and
   * secondary IP ranges within a network. Only IPv4 is supported.
   * Field is optional when reserved_internal_range is defined, otherwise required.
   *
   * @schema SubnetworkV1Beta2SpecForProviderSecondaryIpRange#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * The name associated with this subnetwork secondary range, used
   * when adding an alias IP range to a VM instance. The name must
   * be 1-63 characters long, and comply with RFC1035. The name
   * must be unique within the subnetwork.
   *
   * @schema SubnetworkV1Beta2SpecForProviderSecondaryIpRange#rangeName
   */
  readonly rangeName?: string;

  /**
   * The ID of the reserved internal range. Must be prefixed with networkconnectivity.googleapis.com
   * E.g. networkconnectivity.googleapis.com/projects/{project}/locations/global/internalRanges/{rangeId}
   *
   * @schema SubnetworkV1Beta2SpecForProviderSecondaryIpRange#reservedInternalRange
   */
  readonly reservedInternalRange?: string;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecForProviderSecondaryIpRange' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecForProviderSecondaryIpRange(obj: SubnetworkV1Beta2SpecForProviderSecondaryIpRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipCidrRange': obj.ipCidrRange,
    'rangeName': obj.rangeName,
    'reservedInternalRange': obj.reservedInternalRange,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * This field denotes the VPC flow logging options for this subnetwork. If
 * logging is enabled, logs are exported to Cloud Logging. Flow logging
 * isn't supported if the subnet purpose field is set to subnetwork is
 * REGIONAL_MANAGED_PROXY or GLOBAL_MANAGED_PROXY.
 * Structure is documented below.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderLogConfig
 */
export interface SubnetworkV1Beta2SpecInitProviderLogConfig {
  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Toggles the aggregation interval for collecting flow logs. Increasing the
   * interval time will reduce the amount of generated flow logs for long
   * lasting connections. Default is an interval of 5 seconds per connection.
   * Default value is INTERVAL_5_SEC.
   * Possible values are: INTERVAL_5_SEC, INTERVAL_30_SEC, INTERVAL_1_MIN, INTERVAL_5_MIN, INTERVAL_10_MIN, INTERVAL_15_MIN.
   *
   * @default an interval of 5 seconds per connection.
   * @schema SubnetworkV1Beta2SpecInitProviderLogConfig#aggregationInterval
   */
  readonly aggregationInterval?: string;

  /**
   * Export filter used to define which VPC flow logs should be logged, as as CEL expression. See
   * https://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.
   * The default value is 'true', which evaluates to include everything.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderLogConfig#filterExpr
   */
  readonly filterExpr?: string;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * The value of the field must be in [0, 1]. Set the sampling rate of VPC
   * flow logs within the subnetwork where 1.0 means all collected logs are
   * reported and 0.0 means no logs are reported. Default is 0.5 which means
   * half of all collected logs are reported.
   *
   * @default 0.5 which means
   * @schema SubnetworkV1Beta2SpecInitProviderLogConfig#flowSampling
   */
  readonly flowSampling?: number;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Configures whether metadata fields should be added to the reported VPC
   * flow logs.
   * Default value is INCLUDE_ALL_METADATA.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA, CUSTOM_METADATA.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderLogConfig#metadata
   */
  readonly metadata?: string;

  /**
   * List of metadata fields that should be added to reported logs.
   * Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" is set to CUSTOM_METADATA.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderLogConfig#metadataFields
   */
  readonly metadataFields?: string[];
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecInitProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecInitProviderLogConfig(obj: SubnetworkV1Beta2SpecInitProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationInterval': obj.aggregationInterval,
    'filterExpr': obj.filterExpr,
    'flowSampling': obj.flowSampling,
    'metadata': obj.metadata,
    'metadataFields': obj.metadataFields?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkRef
 */
export interface SubnetworkV1Beta2SpecInitProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkRef#policy
   */
  readonly policy?: SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecInitProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecInitProviderNetworkRef(obj: SubnetworkV1Beta2SpecInitProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelector
 */
export interface SubnetworkV1Beta2SpecInitProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelector#policy
   */
  readonly policy?: SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecInitProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecInitProviderNetworkSelector(obj: SubnetworkV1Beta2SpecInitProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Additional params passed with the request, but not persisted as part of resource payload
 * Structure is documented below.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderParams
 */
export interface SubnetworkV1Beta2SpecInitProviderParams {
  /**
   * Resource manager tags to be bound to the subnetwork. Tag keys and values have the
   * same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
   * and values are in the format tagValues/456. The field is ignored when empty.
   * The field is immutable and causes resource replacement when mutated. This field is only
   * set at create time and modifying this field after creation will trigger recreation.
   * To apply tags to an existing resource, see the google_tags_tag_binding resource.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderParams#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecInitProviderParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecInitProviderParams(obj: SubnetworkV1Beta2SpecInitProviderParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubnetworkV1Beta2SpecInitProviderSecondaryIpRange
 */
export interface SubnetworkV1Beta2SpecInitProviderSecondaryIpRange {
  /**
   * The range of IP addresses belonging to this subnetwork secondary
   * range. Provide this property when you create the subnetwork.
   * Ranges must be unique and non-overlapping with all primary and
   * secondary IP ranges within a network. Only IPv4 is supported.
   * Field is optional when reserved_internal_range is defined, otherwise required.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderSecondaryIpRange#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * The name associated with this subnetwork secondary range, used
   * when adding an alias IP range to a VM instance. The name must
   * be 1-63 characters long, and comply with RFC1035. The name
   * must be unique within the subnetwork.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderSecondaryIpRange#rangeName
   */
  readonly rangeName?: string;

  /**
   * The ID of the reserved internal range. Must be prefixed with networkconnectivity.googleapis.com
   * E.g. networkconnectivity.googleapis.com/projects/{project}/locations/global/internalRanges/{rangeId}
   *
   * @schema SubnetworkV1Beta2SpecInitProviderSecondaryIpRange#reservedInternalRange
   */
  readonly reservedInternalRange?: string;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecInitProviderSecondaryIpRange' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecInitProviderSecondaryIpRange(obj: SubnetworkV1Beta2SpecInitProviderSecondaryIpRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipCidrRange': obj.ipCidrRange,
    'rangeName': obj.rangeName,
    'reservedInternalRange': obj.reservedInternalRange,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetworkV1Beta2SpecProviderConfigRefPolicy
 */
export interface SubnetworkV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetworkV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetworkV1Beta2SpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecProviderConfigRefPolicy(obj: SubnetworkV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkRefPolicy
 */
export interface SubnetworkV1Beta2SpecForProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: SubnetworkV1Beta2SpecForProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: SubnetworkV1Beta2SpecForProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecForProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecForProviderNetworkRefPolicy(obj: SubnetworkV1Beta2SpecForProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy
 */
export interface SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy(obj: SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy
 */
export interface SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: SubnetworkV1Beta2SpecInitProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: SubnetworkV1Beta2SpecInitProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy(obj: SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy
 */
export interface SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy(obj: SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum SubnetworkV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum SubnetworkV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkRefPolicyResolution
 */
export enum SubnetworkV1Beta2SpecForProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkRefPolicyResolve
 */
export enum SubnetworkV1Beta2SpecForProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicyResolution
 */
export enum SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicyResolve
 */
export enum SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkRefPolicyResolution
 */
export enum SubnetworkV1Beta2SpecInitProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkRefPolicyResolve
 */
export enum SubnetworkV1Beta2SpecInitProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicyResolution
 */
export enum SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicyResolve
 */
export enum SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

