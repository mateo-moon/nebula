// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Cluster is the Schema for the k0smotronclusters API
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k0smotron.io/v1beta1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps = {}): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps = {}) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * Cluster is the Schema for the k0smotronclusters API
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of K0smotronCluster
   *
   * @schema Cluster#spec
   */
  readonly spec?: ClusterSpec;
}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterSpec defines the desired state of K0smotronCluster
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * CertificateRefs defines the certificate references.
   *
   * @schema ClusterSpec#certificateRefs
   */
  readonly certificateRefs?: ClusterSpecCertificateRefs[];

  /**
   * ControlPlaneFlags allows to configure additional flags for k0s
   * control plane and to override existing ones. The default flags are
   * kept unless they are overriden explicitly. Flags with arguments must
   * be specified as a single string, e.g. --some-flag=argument
   *
   * @schema ClusterSpec#controllerPlaneFlags
   */
  readonly controllerPlaneFlags?: string[];

  /**
   * Etcd defines the etcd configuration.
   *
   * @schema ClusterSpec#etcd
   */
  readonly etcd?: ClusterSpecEtcd;

  /**
   * ExternalAddress defines k0s external address. See https://docs.k0sproject.io/stable/configuration/#specapi
   * Will be detected automatically for service type LoadBalancer.
   *
   * @schema ClusterSpec#externalAddress
   */
  readonly externalAddress?: string;

  /**
   * Image defines the k0s image to be deployed. If empty k0smotron
   * will pick it automatically. Must not include the image tag.
   *
   * @schema ClusterSpec#image
   */
  readonly image?: string;

  /**
   * k0sConfig defines the k0s configuration. Note, that some fields will be overwritten by k0smotron.
   * If empty, will be used default configuration. @see https://docs.k0sproject.io/stable/configuration/
   *
   * @schema ClusterSpec#k0sConfig
   */
  readonly k0SConfig?: any;

  /**
   * KineDataSourceSecretName defines the name of kine datasource URL secret.
   *
   * @schema ClusterSpec#kineDataSourceSecretName
   */
  readonly kineDataSourceSecretName?: string;

  /**
   * KineDataSourceURL defines the kine datasource URL.
   *
   * @schema ClusterSpec#kineDataSourceURL
   */
  readonly kineDataSourceUrl?: string;

  /**
   * KubeconfigRef is the reference to the kubeconfig of the hosting cluster.
   * This kubeconfig will be used to deploy the k0s control plane.
   *
   * @schema ClusterSpec#kubeconfigRef
   */
  readonly kubeconfigRef?: ClusterSpecKubeconfigRef;

  /**
   * Manifests allows to specify list of volumes with manifests to be
   * deployed in the cluster. The volumes will be mounted
   * in /var/lib/k0s/manifests/<manifests.name>, for this reason each
   * manifest is a stack. K0smotron allows any kind of volume, but the
   * recommendation is to use secrets and configmaps.
   * For more information check:
   * https://docs.k0sproject.io/stable/manifests/ and
   * https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema ClusterSpec#manifests
   */
  readonly manifests?: ClusterSpecManifests[];

  /**
   * Monitoring defines the monitoring configuration.
   *
   * @schema ClusterSpec#monitoring
   */
  readonly monitoring?: ClusterSpecMonitoring;

  /**
   * Mounts allows to specify list of volumes with any files to be
   * mounted in the controlplane pod. K0smotron allows any kind of volume, but the
   * recommendation is to use secrets and configmaps.
   * For more information check:
   * https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema ClusterSpec#mounts
   */
  readonly mounts?: ClusterSpecMounts[];

  /**
   * Persistence defines the persistence configuration. If empty k0smotron
   * will use emptyDir as a volume. See https://docs.k0smotron.io/stable/configuration/#persistence
   *
   * @schema ClusterSpec#persistence
   */
  readonly persistence?: ClusterSpecPersistence;

  /**
   * Replicas is the desired number of replicas of the k0s control planes.
   * If unspecified, defaults to 1. If the value is above 1, k0smotron requires kine datasource URL to be set.
   * Recommended value is 3.
   *
   * @schema ClusterSpec#replicas
   */
  readonly replicas?: number;

  /**
   * Resources describes the compute resource requirements for the control plane pods.
   *
   * @schema ClusterSpec#resources
   */
  readonly resources?: ClusterSpecResources;

  /**
   * Service defines the service configuration.
   *
   * @schema ClusterSpec#service
   */
  readonly service?: ClusterSpecService;

  /**
   * ServiceAccount defines the service account to be used by both k0s and etcd StatefulSets.
   *
   * @schema ClusterSpec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * TopologySpreadConstraints will be passed directly to BOTH etcd and k0s pods.
   * See https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/ for more information.
   *
   * @schema ClusterSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: ClusterSpecTopologySpreadConstraints[];

  /**
   * Version defines the k0s version to be deployed. If empty k0smotron
   * will pick it automatically.
   *
   * @schema ClusterSpec#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateRefs': obj.certificateRefs?.map(y => toJson_ClusterSpecCertificateRefs(y)),
    'controllerPlaneFlags': obj.controllerPlaneFlags?.map(y => y),
    'etcd': toJson_ClusterSpecEtcd(obj.etcd),
    'externalAddress': obj.externalAddress,
    'image': obj.image,
    'k0sConfig': obj.k0SConfig,
    'kineDataSourceSecretName': obj.kineDataSourceSecretName,
    'kineDataSourceURL': obj.kineDataSourceUrl,
    'kubeconfigRef': toJson_ClusterSpecKubeconfigRef(obj.kubeconfigRef),
    'manifests': obj.manifests?.map(y => toJson_ClusterSpecManifests(y)),
    'monitoring': toJson_ClusterSpecMonitoring(obj.monitoring),
    'mounts': obj.mounts?.map(y => toJson_ClusterSpecMounts(y)),
    'persistence': toJson_ClusterSpecPersistence(obj.persistence),
    'replicas': obj.replicas,
    'resources': toJson_ClusterSpecResources(obj.resources),
    'service': toJson_ClusterSpecService(obj.service),
    'serviceAccount': obj.serviceAccount,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_ClusterSpecTopologySpreadConstraints(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecCertificateRefs
 */
export interface ClusterSpecCertificateRefs {
  /**
   * @schema ClusterSpecCertificateRefs#name
   */
  readonly name?: string;

  /**
   * @schema ClusterSpecCertificateRefs#type
   */
  readonly type: ClusterSpecCertificateRefsType;
}

/**
 * Converts an object of type 'ClusterSpecCertificateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecCertificateRefs(obj: ClusterSpecCertificateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Etcd defines the etcd configuration.
 *
 * @schema ClusterSpecEtcd
 */
export interface ClusterSpecEtcd {
  /**
   * Args defines the etcd arguments.
   *
   * @schema ClusterSpecEtcd#args
   */
  readonly args?: string[];

  /**
   * AutoDeletePVCs defines whether the PVC should be deleted when the etcd cluster is deleted.
   *
   * @schema ClusterSpecEtcd#autoDeletePVCs
   */
  readonly autoDeletePvCs?: boolean;

  /**
   * DefragJob defines the etcd defragmentation job configuration.
   *
   * @schema ClusterSpecEtcd#defragJob
   */
  readonly defragJob?: ClusterSpecEtcdDefragJob;

  /**
   * Image defines the etcd image to be deployed.
   *
   * @schema ClusterSpecEtcd#image
   */
  readonly image: string;

  /**
   * Persistence defines the persistence configuration.
   *
   * @schema ClusterSpecEtcd#persistence
   */
  readonly persistence?: ClusterSpecEtcdPersistence;

  /**
   * Resources defines the compute resource requirements for the etcd container.
   *
   * @schema ClusterSpecEtcd#resources
   */
  readonly resources?: ClusterSpecEtcdResources;
}

/**
 * Converts an object of type 'ClusterSpecEtcd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEtcd(obj: ClusterSpecEtcd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'autoDeletePVCs': obj.autoDeletePvCs,
    'defragJob': toJson_ClusterSpecEtcdDefragJob(obj.defragJob),
    'image': obj.image,
    'persistence': toJson_ClusterSpecEtcdPersistence(obj.persistence),
    'resources': toJson_ClusterSpecEtcdResources(obj.resources),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KubeconfigRef is the reference to the kubeconfig of the hosting cluster.
 * This kubeconfig will be used to deploy the k0s control plane.
 *
 * @schema ClusterSpecKubeconfigRef
 */
export interface ClusterSpecKubeconfigRef {
  /**
   * Key is the key in the secret containing the kubeconfig of the hosting cluster.
   *
   * @schema ClusterSpecKubeconfigRef#key
   */
  readonly key?: string;

  /**
   * Name is the name of the secret containing the kubeconfig of the hosting cluster.
   *
   * @schema ClusterSpecKubeconfigRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the secret containing the kubeconfig of the hosting cluster.
   *
   * @schema ClusterSpecKubeconfigRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSpecKubeconfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecKubeconfigRef(obj: ClusterSpecKubeconfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema ClusterSpecManifests
 */
export interface ClusterSpecManifests {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ClusterSpecManifests#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: ClusterSpecManifestsAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema ClusterSpecManifests#azureDisk
   */
  readonly azureDisk?: ClusterSpecManifestsAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema ClusterSpecManifests#azureFile
   */
  readonly azureFile?: ClusterSpecManifestsAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema ClusterSpecManifests#cephfs
   */
  readonly cephfs?: ClusterSpecManifestsCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ClusterSpecManifests#cinder
   */
  readonly cinder?: ClusterSpecManifestsCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema ClusterSpecManifests#configMap
   */
  readonly configMap?: ClusterSpecManifestsConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema ClusterSpecManifests#csi
   */
  readonly csi?: ClusterSpecManifestsCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema ClusterSpecManifests#downwardAPI
   */
  readonly downwardApi?: ClusterSpecManifestsDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ClusterSpecManifests#emptyDir
   */
  readonly emptyDir?: ClusterSpecManifestsEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema ClusterSpecManifests#ephemeral
   */
  readonly ephemeral?: ClusterSpecManifestsEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema ClusterSpecManifests#fc
   */
  readonly fc?: ClusterSpecManifestsFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   *
   * @schema ClusterSpecManifests#flexVolume
   */
  readonly flexVolume?: ClusterSpecManifestsFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema ClusterSpecManifests#flocker
   */
  readonly flocker?: ClusterSpecManifestsFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ClusterSpecManifests#gcePersistentDisk
   */
  readonly gcePersistentDisk?: ClusterSpecManifestsGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema ClusterSpecManifests#gitRepo
   */
  readonly gitRepo?: ClusterSpecManifestsGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema ClusterSpecManifests#glusterfs
   */
  readonly glusterfs?: ClusterSpecManifestsGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * ---
   * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
   * mount host directories as read/write.
   *
   * @schema ClusterSpecManifests#hostPath
   */
  readonly hostPath?: ClusterSpecManifestsHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema ClusterSpecManifests#iscsi
   */
  readonly iscsi?: ClusterSpecManifestsIscsi;

  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterSpecManifests#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ClusterSpecManifests#nfs
   */
  readonly nfs?: ClusterSpecManifestsNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ClusterSpecManifests#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: ClusterSpecManifestsPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema ClusterSpecManifests#photonPersistentDisk
   */
  readonly photonPersistentDisk?: ClusterSpecManifestsPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema ClusterSpecManifests#portworxVolume
   */
  readonly portworxVolume?: ClusterSpecManifestsPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema ClusterSpecManifests#projected
   */
  readonly projected?: ClusterSpecManifestsProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema ClusterSpecManifests#quobyte
   */
  readonly quobyte?: ClusterSpecManifestsQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema ClusterSpecManifests#rbd
   */
  readonly rbd?: ClusterSpecManifestsRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema ClusterSpecManifests#scaleIO
   */
  readonly scaleIo?: ClusterSpecManifestsScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema ClusterSpecManifests#secret
   */
  readonly secret?: ClusterSpecManifestsSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema ClusterSpecManifests#storageos
   */
  readonly storageos?: ClusterSpecManifestsStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema ClusterSpecManifests#vsphereVolume
   */
  readonly vsphereVolume?: ClusterSpecManifestsVsphereVolume;
}

/**
 * Converts an object of type 'ClusterSpecManifests' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifests(obj: ClusterSpecManifests | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_ClusterSpecManifestsAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_ClusterSpecManifestsAzureDisk(obj.azureDisk),
    'azureFile': toJson_ClusterSpecManifestsAzureFile(obj.azureFile),
    'cephfs': toJson_ClusterSpecManifestsCephfs(obj.cephfs),
    'cinder': toJson_ClusterSpecManifestsCinder(obj.cinder),
    'configMap': toJson_ClusterSpecManifestsConfigMap(obj.configMap),
    'csi': toJson_ClusterSpecManifestsCsi(obj.csi),
    'downwardAPI': toJson_ClusterSpecManifestsDownwardApi(obj.downwardApi),
    'emptyDir': toJson_ClusterSpecManifestsEmptyDir(obj.emptyDir),
    'ephemeral': toJson_ClusterSpecManifestsEphemeral(obj.ephemeral),
    'fc': toJson_ClusterSpecManifestsFc(obj.fc),
    'flexVolume': toJson_ClusterSpecManifestsFlexVolume(obj.flexVolume),
    'flocker': toJson_ClusterSpecManifestsFlocker(obj.flocker),
    'gcePersistentDisk': toJson_ClusterSpecManifestsGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_ClusterSpecManifestsGitRepo(obj.gitRepo),
    'glusterfs': toJson_ClusterSpecManifestsGlusterfs(obj.glusterfs),
    'hostPath': toJson_ClusterSpecManifestsHostPath(obj.hostPath),
    'iscsi': toJson_ClusterSpecManifestsIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_ClusterSpecManifestsNfs(obj.nfs),
    'persistentVolumeClaim': toJson_ClusterSpecManifestsPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_ClusterSpecManifestsPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_ClusterSpecManifestsPortworxVolume(obj.portworxVolume),
    'projected': toJson_ClusterSpecManifestsProjected(obj.projected),
    'quobyte': toJson_ClusterSpecManifestsQuobyte(obj.quobyte),
    'rbd': toJson_ClusterSpecManifestsRbd(obj.rbd),
    'scaleIO': toJson_ClusterSpecManifestsScaleIo(obj.scaleIo),
    'secret': toJson_ClusterSpecManifestsSecret(obj.secret),
    'storageos': toJson_ClusterSpecManifestsStorageos(obj.storageos),
    'vsphereVolume': toJson_ClusterSpecManifestsVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Monitoring defines the monitoring configuration.
 *
 * @schema ClusterSpecMonitoring
 */
export interface ClusterSpecMonitoring {
  /**
   * Enabled enables prometheus sidecar that scrapes metrics from the child cluster system components and expose
   * them as usual kubernetes pod metrics.
   *
   * @schema ClusterSpecMonitoring#enabled
   */
  readonly enabled: boolean;

  /**
   * PrometheusImage defines the image used for the prometheus sidecar.
   *
   * @schema ClusterSpecMonitoring#prometheusImage
   */
  readonly prometheusImage: string;

  /**
   * ProxyImage defines the image used for the nginx proxy sidecar.
   *
   * @schema ClusterSpecMonitoring#proxyImage
   */
  readonly proxyImage: string;
}

/**
 * Converts an object of type 'ClusterSpecMonitoring' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMonitoring(obj: ClusterSpecMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'prometheusImage': obj.prometheusImage,
    'proxyImage': obj.proxyImage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecMounts
 */
export interface ClusterSpecMounts {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ClusterSpecMounts#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: ClusterSpecMountsAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema ClusterSpecMounts#azureDisk
   */
  readonly azureDisk?: ClusterSpecMountsAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema ClusterSpecMounts#azureFile
   */
  readonly azureFile?: ClusterSpecMountsAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema ClusterSpecMounts#cephfs
   */
  readonly cephfs?: ClusterSpecMountsCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ClusterSpecMounts#cinder
   */
  readonly cinder?: ClusterSpecMountsCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema ClusterSpecMounts#configMap
   */
  readonly configMap?: ClusterSpecMountsConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema ClusterSpecMounts#csi
   */
  readonly csi?: ClusterSpecMountsCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema ClusterSpecMounts#downwardAPI
   */
  readonly downwardApi?: ClusterSpecMountsDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ClusterSpecMounts#emptyDir
   */
  readonly emptyDir?: ClusterSpecMountsEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema ClusterSpecMounts#ephemeral
   */
  readonly ephemeral?: ClusterSpecMountsEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema ClusterSpecMounts#fc
   */
  readonly fc?: ClusterSpecMountsFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   *
   * @schema ClusterSpecMounts#flexVolume
   */
  readonly flexVolume?: ClusterSpecMountsFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema ClusterSpecMounts#flocker
   */
  readonly flocker?: ClusterSpecMountsFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ClusterSpecMounts#gcePersistentDisk
   */
  readonly gcePersistentDisk?: ClusterSpecMountsGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema ClusterSpecMounts#gitRepo
   */
  readonly gitRepo?: ClusterSpecMountsGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema ClusterSpecMounts#glusterfs
   */
  readonly glusterfs?: ClusterSpecMountsGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * ---
   * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
   * mount host directories as read/write.
   *
   * @schema ClusterSpecMounts#hostPath
   */
  readonly hostPath?: ClusterSpecMountsHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema ClusterSpecMounts#iscsi
   */
  readonly iscsi?: ClusterSpecMountsIscsi;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ClusterSpecMounts#nfs
   */
  readonly nfs?: ClusterSpecMountsNfs;

  /**
   * @schema ClusterSpecMounts#path
   */
  readonly path: string;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ClusterSpecMounts#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: ClusterSpecMountsPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema ClusterSpecMounts#photonPersistentDisk
   */
  readonly photonPersistentDisk?: ClusterSpecMountsPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema ClusterSpecMounts#portworxVolume
   */
  readonly portworxVolume?: ClusterSpecMountsPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema ClusterSpecMounts#projected
   */
  readonly projected?: ClusterSpecMountsProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema ClusterSpecMounts#quobyte
   */
  readonly quobyte?: ClusterSpecMountsQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema ClusterSpecMounts#rbd
   */
  readonly rbd?: ClusterSpecMountsRbd;

  /**
   * ReadOnly specifies whether the volume should be mounted as read-only. (default: false, except for ConfigMaps and Secrets)
   *
   * @schema ClusterSpecMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema ClusterSpecMounts#scaleIO
   */
  readonly scaleIo?: ClusterSpecMountsScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema ClusterSpecMounts#secret
   */
  readonly secret?: ClusterSpecMountsSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema ClusterSpecMounts#storageos
   */
  readonly storageos?: ClusterSpecMountsStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema ClusterSpecMounts#vsphereVolume
   */
  readonly vsphereVolume?: ClusterSpecMountsVsphereVolume;
}

/**
 * Converts an object of type 'ClusterSpecMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMounts(obj: ClusterSpecMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_ClusterSpecMountsAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_ClusterSpecMountsAzureDisk(obj.azureDisk),
    'azureFile': toJson_ClusterSpecMountsAzureFile(obj.azureFile),
    'cephfs': toJson_ClusterSpecMountsCephfs(obj.cephfs),
    'cinder': toJson_ClusterSpecMountsCinder(obj.cinder),
    'configMap': toJson_ClusterSpecMountsConfigMap(obj.configMap),
    'csi': toJson_ClusterSpecMountsCsi(obj.csi),
    'downwardAPI': toJson_ClusterSpecMountsDownwardApi(obj.downwardApi),
    'emptyDir': toJson_ClusterSpecMountsEmptyDir(obj.emptyDir),
    'ephemeral': toJson_ClusterSpecMountsEphemeral(obj.ephemeral),
    'fc': toJson_ClusterSpecMountsFc(obj.fc),
    'flexVolume': toJson_ClusterSpecMountsFlexVolume(obj.flexVolume),
    'flocker': toJson_ClusterSpecMountsFlocker(obj.flocker),
    'gcePersistentDisk': toJson_ClusterSpecMountsGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_ClusterSpecMountsGitRepo(obj.gitRepo),
    'glusterfs': toJson_ClusterSpecMountsGlusterfs(obj.glusterfs),
    'hostPath': toJson_ClusterSpecMountsHostPath(obj.hostPath),
    'iscsi': toJson_ClusterSpecMountsIscsi(obj.iscsi),
    'nfs': toJson_ClusterSpecMountsNfs(obj.nfs),
    'path': obj.path,
    'persistentVolumeClaim': toJson_ClusterSpecMountsPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_ClusterSpecMountsPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_ClusterSpecMountsPortworxVolume(obj.portworxVolume),
    'projected': toJson_ClusterSpecMountsProjected(obj.projected),
    'quobyte': toJson_ClusterSpecMountsQuobyte(obj.quobyte),
    'rbd': toJson_ClusterSpecMountsRbd(obj.rbd),
    'readOnly': obj.readOnly,
    'scaleIO': toJson_ClusterSpecMountsScaleIo(obj.scaleIo),
    'secret': toJson_ClusterSpecMountsSecret(obj.secret),
    'storageos': toJson_ClusterSpecMountsStorageos(obj.storageos),
    'vsphereVolume': toJson_ClusterSpecMountsVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Persistence defines the persistence configuration. If empty k0smotron
 * will use emptyDir as a volume. See https://docs.k0smotron.io/stable/configuration/#persistence
 *
 * @schema ClusterSpecPersistence
 */
export interface ClusterSpecPersistence {
  /**
   * AutoDeletePVCs defines whether the PVC should be deleted when the cluster is deleted.
   *
   * @schema ClusterSpecPersistence#autoDeletePVCs
   */
  readonly autoDeletePvCs?: boolean;

  /**
   * HostPath defines the host path configuration. Will be used as is in case of .spec.persistence.type is hostPath.
   *
   * @schema ClusterSpecPersistence#hostPath
   */
  readonly hostPath?: string;

  /**
   * PersistentVolumeClaim defines the PVC configuration. Will be used as is in case of .spec.persistence.type is pvc.
   *
   * @schema ClusterSpecPersistence#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: ClusterSpecPersistencePersistentVolumeClaim;

  /**
   * @schema ClusterSpecPersistence#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ClusterSpecPersistence' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPersistence(obj: ClusterSpecPersistence | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoDeletePVCs': obj.autoDeletePvCs,
    'hostPath': obj.hostPath,
    'persistentVolumeClaim': toJson_ClusterSpecPersistencePersistentVolumeClaim(obj.persistentVolumeClaim),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources describes the compute resource requirements for the control plane pods.
 *
 * @schema ClusterSpecResources
 */
export interface ClusterSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ClusterSpecResources#claims
   */
  readonly claims?: ClusterSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecResources#limits
   */
  readonly limits?: { [key: string]: ClusterSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecResources#requests
   */
  readonly requests?: { [key: string]: ClusterSpecResourcesRequests };
}

/**
 * Converts an object of type 'ClusterSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecResources(obj: ClusterSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_ClusterSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service defines the service configuration.
 *
 * @schema ClusterSpecService
 */
export interface ClusterSpecService {
  /**
   * Annotations defines extra annotations to be added to the service.
   *
   * @schema ClusterSpecService#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * APIPort defines the kubernetes API port. If empty k0smotron
   * will pick it automatically.
   *
   * @schema ClusterSpecService#apiPort
   */
  readonly apiPort?: number;

  /**
   * KonnectivityPort defines the konnectivity port. If empty k0smotron
   * will pick it automatically.
   *
   * @schema ClusterSpecService#konnectivityPort
   */
  readonly konnectivityPort?: number;

  /**
   * Labels defines extra labels to be added to the service.
   *
   * @schema ClusterSpecService#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * LoadBalancerClass defines the load balancer class to be used for the service. Used only when service type is LoadBalancer.
   *
   * @schema ClusterSpecService#loadBalancerClass
   */
  readonly loadBalancerClass?: string;

  /**
   * Service Type string describes ingress methods for a service
   *
   * @schema ClusterSpecService#type
   */
  readonly type: ClusterSpecServiceType;
}

/**
 * Converts an object of type 'ClusterSpecService' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecService(obj: ClusterSpecService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'apiPort': obj.apiPort,
    'konnectivityPort': obj.konnectivityPort,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'loadBalancerClass': obj.loadBalancerClass,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema ClusterSpecTopologySpreadConstraints
 */
export interface ClusterSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema ClusterSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: ClusterSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema ClusterSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema ClusterSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   * @schema ClusterSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema ClusterSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema ClusterSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema ClusterSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema ClusterSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'ClusterSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecTopologySpreadConstraints(obj: ClusterSpecTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecCertificateRefsType
 */
export enum ClusterSpecCertificateRefsType {
  /** ca */
  CA = "ca",
  /** sa */
  SA = "sa",
  /** proxy */
  PROXY = "proxy",
  /** etcd */
  ETCD = "etcd",
  /** apiserver-etcd-client */
  APISERVER_HYPHEN_ETCD_HYPHEN_CLIENT = "apiserver-etcd-client",
  /** etcd-peer */
  ETCD_HYPHEN_PEER = "etcd-peer",
  /** etcd-server */
  ETCD_HYPHEN_SERVER = "etcd-server",
}

/**
 * DefragJob defines the etcd defragmentation job configuration.
 *
 * @schema ClusterSpecEtcdDefragJob
 */
export interface ClusterSpecEtcdDefragJob {
  /**
   * Enabled enables the etcd defragmentation job.
   *
   * @schema ClusterSpecEtcdDefragJob#enabled
   */
  readonly enabled: boolean;

  /**
   * Image defines the etcd defragmentation job image.
   *
   * @schema ClusterSpecEtcdDefragJob#image
   */
  readonly image: string;

  /**
   * Rule defines the etcd defragmentation job defrag-rule.
   * For more information check: https://github.com/ahrtr/etcd-defrag/tree/main?tab=readme-ov-file#defragmentation-rule
   *
   * @schema ClusterSpecEtcdDefragJob#rule
   */
  readonly rule: string;

  /**
   * Schedule defines the etcd defragmentation job schedule.
   *
   * @schema ClusterSpecEtcdDefragJob#schedule
   */
  readonly schedule: string;
}

/**
 * Converts an object of type 'ClusterSpecEtcdDefragJob' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEtcdDefragJob(obj: ClusterSpecEtcdDefragJob | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'image': obj.image,
    'rule': obj.rule,
    'schedule': obj.schedule,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Persistence defines the persistence configuration.
 *
 * @schema ClusterSpecEtcdPersistence
 */
export interface ClusterSpecEtcdPersistence {
  /**
   * Size defines the size of the etcd volume. Default: 1Gi
   *
   * @schema ClusterSpecEtcdPersistence#size
   */
  readonly size?: ClusterSpecEtcdPersistenceSize;

  /**
   * StorageClass defines the storage class to be used for etcd persistence. If empty, will be used the default storage class.
   *
   * @schema ClusterSpecEtcdPersistence#storageClass
   */
  readonly storageClass?: string;
}

/**
 * Converts an object of type 'ClusterSpecEtcdPersistence' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEtcdPersistence(obj: ClusterSpecEtcdPersistence | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'size': obj.size?.value,
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources defines the compute resource requirements for the etcd container.
 *
 * @schema ClusterSpecEtcdResources
 */
export interface ClusterSpecEtcdResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ClusterSpecEtcdResources#claims
   */
  readonly claims?: ClusterSpecEtcdResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecEtcdResources#limits
   */
  readonly limits?: { [key: string]: ClusterSpecEtcdResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecEtcdResources#requests
   */
  readonly requests?: { [key: string]: ClusterSpecEtcdResourcesRequests };
}

/**
 * Converts an object of type 'ClusterSpecEtcdResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEtcdResources(obj: ClusterSpecEtcdResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_ClusterSpecEtcdResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema ClusterSpecManifestsAwsElasticBlockStore
 */
export interface ClusterSpecManifestsAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ClusterSpecManifestsAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema ClusterSpecManifestsAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ClusterSpecManifestsAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ClusterSpecManifestsAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsAwsElasticBlockStore(obj: ClusterSpecManifestsAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema ClusterSpecManifestsAzureDisk
 */
export interface ClusterSpecManifestsAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema ClusterSpecManifestsAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema ClusterSpecManifestsAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema ClusterSpecManifestsAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterSpecManifestsAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema ClusterSpecManifestsAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ClusterSpecManifestsAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecManifestsAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsAzureDisk(obj: ClusterSpecManifestsAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema ClusterSpecManifestsAzureFile
 */
export interface ClusterSpecManifestsAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ClusterSpecManifestsAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema ClusterSpecManifestsAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema ClusterSpecManifestsAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsAzureFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsAzureFile(obj: ClusterSpecManifestsAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema ClusterSpecManifestsCephfs
 */
export interface ClusterSpecManifestsCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ClusterSpecManifestsCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema ClusterSpecManifestsCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ClusterSpecManifestsCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ClusterSpecManifestsCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ClusterSpecManifestsCephfs#secretRef
   */
  readonly secretRef?: ClusterSpecManifestsCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ClusterSpecManifestsCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsCephfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsCephfs(obj: ClusterSpecManifestsCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_ClusterSpecManifestsCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema ClusterSpecManifestsCinder
 */
export interface ClusterSpecManifestsCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ClusterSpecManifestsCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ClusterSpecManifestsCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema ClusterSpecManifestsCinder#secretRef
   */
  readonly secretRef?: ClusterSpecManifestsCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ClusterSpecManifestsCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsCinder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsCinder(obj: ClusterSpecManifestsCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterSpecManifestsCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema ClusterSpecManifestsConfigMap
 */
export interface ClusterSpecManifestsConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema ClusterSpecManifestsConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterSpecManifestsConfigMap#items
   */
  readonly items?: ClusterSpecManifestsConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecManifestsConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema ClusterSpecManifestsConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecManifestsConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsConfigMap(obj: ClusterSpecManifestsConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ClusterSpecManifestsConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema ClusterSpecManifestsCsi
 */
export interface ClusterSpecManifestsCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema ClusterSpecManifestsCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema ClusterSpecManifestsCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema ClusterSpecManifestsCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: ClusterSpecManifestsCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema ClusterSpecManifestsCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema ClusterSpecManifestsCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecManifestsCsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsCsi(obj: ClusterSpecManifestsCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_ClusterSpecManifestsCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema ClusterSpecManifestsDownwardApi
 */
export interface ClusterSpecManifestsDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema ClusterSpecManifestsDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema ClusterSpecManifestsDownwardApi#items
   */
  readonly items?: ClusterSpecManifestsDownwardApiItems[];
}

/**
 * Converts an object of type 'ClusterSpecManifestsDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsDownwardApi(obj: ClusterSpecManifestsDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ClusterSpecManifestsDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema ClusterSpecManifestsEmptyDir
 */
export interface ClusterSpecManifestsEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ClusterSpecManifestsEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ClusterSpecManifestsEmptyDir#sizeLimit
   */
  readonly sizeLimit?: ClusterSpecManifestsEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'ClusterSpecManifestsEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsEmptyDir(obj: ClusterSpecManifestsEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema ClusterSpecManifestsEphemeral
 */
export interface ClusterSpecManifestsEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   *
   * Required, must not be nil.
   *
   * @schema ClusterSpecManifestsEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: ClusterSpecManifestsEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'ClusterSpecManifestsEphemeral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsEphemeral(obj: ClusterSpecManifestsEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema ClusterSpecManifestsFc
 */
export interface ClusterSpecManifestsFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ClusterSpecManifestsFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema ClusterSpecManifestsFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ClusterSpecManifestsFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema ClusterSpecManifestsFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema ClusterSpecManifestsFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'ClusterSpecManifestsFc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsFc(obj: ClusterSpecManifestsFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 *
 * @schema ClusterSpecManifestsFlexVolume
 */
export interface ClusterSpecManifestsFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema ClusterSpecManifestsFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema ClusterSpecManifestsFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema ClusterSpecManifestsFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ClusterSpecManifestsFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema ClusterSpecManifestsFlexVolume#secretRef
   */
  readonly secretRef?: ClusterSpecManifestsFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'ClusterSpecManifestsFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsFlexVolume(obj: ClusterSpecManifestsFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterSpecManifestsFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema ClusterSpecManifestsFlocker
 */
export interface ClusterSpecManifestsFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema ClusterSpecManifestsFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema ClusterSpecManifestsFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsFlocker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsFlocker(obj: ClusterSpecManifestsFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema ClusterSpecManifestsGcePersistentDisk
 */
export interface ClusterSpecManifestsGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ClusterSpecManifestsGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ClusterSpecManifestsGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ClusterSpecManifestsGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema ClusterSpecManifestsGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecManifestsGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsGcePersistentDisk(obj: ClusterSpecManifestsGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema ClusterSpecManifestsGitRepo
 */
export interface ClusterSpecManifestsGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema ClusterSpecManifestsGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema ClusterSpecManifestsGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema ClusterSpecManifestsGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsGitRepo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsGitRepo(obj: ClusterSpecManifestsGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema ClusterSpecManifestsGlusterfs
 */
export interface ClusterSpecManifestsGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema ClusterSpecManifestsGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema ClusterSpecManifestsGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema ClusterSpecManifestsGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecManifestsGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsGlusterfs(obj: ClusterSpecManifestsGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 * ---
 * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
 * mount host directories as read/write.
 *
 * @schema ClusterSpecManifestsHostPath
 */
export interface ClusterSpecManifestsHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema ClusterSpecManifestsHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema ClusterSpecManifestsHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsHostPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsHostPath(obj: ClusterSpecManifestsHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema ClusterSpecManifestsIscsi
 */
export interface ClusterSpecManifestsIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema ClusterSpecManifestsIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema ClusterSpecManifestsIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ClusterSpecManifestsIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema ClusterSpecManifestsIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema ClusterSpecManifestsIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema ClusterSpecManifestsIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema ClusterSpecManifestsIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema ClusterSpecManifestsIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecManifestsIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema ClusterSpecManifestsIscsi#secretRef
   */
  readonly secretRef?: ClusterSpecManifestsIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema ClusterSpecManifestsIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsIscsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsIscsi(obj: ClusterSpecManifestsIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterSpecManifestsIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema ClusterSpecManifestsNfs
 */
export interface ClusterSpecManifestsNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ClusterSpecManifestsNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema ClusterSpecManifestsNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ClusterSpecManifestsNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsNfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsNfs(obj: ClusterSpecManifestsNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema ClusterSpecManifestsPersistentVolumeClaim
 */
export interface ClusterSpecManifestsPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ClusterSpecManifestsPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema ClusterSpecManifestsPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecManifestsPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsPersistentVolumeClaim(obj: ClusterSpecManifestsPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema ClusterSpecManifestsPhotonPersistentDisk
 */
export interface ClusterSpecManifestsPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterSpecManifestsPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema ClusterSpecManifestsPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsPhotonPersistentDisk(obj: ClusterSpecManifestsPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema ClusterSpecManifestsPortworxVolume
 */
export interface ClusterSpecManifestsPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterSpecManifestsPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ClusterSpecManifestsPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema ClusterSpecManifestsPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsPortworxVolume(obj: ClusterSpecManifestsPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema ClusterSpecManifestsProjected
 */
export interface ClusterSpecManifestsProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecManifestsProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema ClusterSpecManifestsProjected#sources
   */
  readonly sources?: ClusterSpecManifestsProjectedSources[];
}

/**
 * Converts an object of type 'ClusterSpecManifestsProjected' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsProjected(obj: ClusterSpecManifestsProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_ClusterSpecManifestsProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema ClusterSpecManifestsQuobyte
 */
export interface ClusterSpecManifestsQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema ClusterSpecManifestsQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecManifestsQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema ClusterSpecManifestsQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema ClusterSpecManifestsQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema ClusterSpecManifestsQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema ClusterSpecManifestsQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsQuobyte' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsQuobyte(obj: ClusterSpecManifestsQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema ClusterSpecManifestsRbd
 */
export interface ClusterSpecManifestsRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ClusterSpecManifestsRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema ClusterSpecManifestsRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema ClusterSpecManifestsRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema ClusterSpecManifestsRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema ClusterSpecManifestsRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema ClusterSpecManifestsRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema ClusterSpecManifestsRbd#secretRef
   */
  readonly secretRef?: ClusterSpecManifestsRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema ClusterSpecManifestsRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsRbd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsRbd(obj: ClusterSpecManifestsRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterSpecManifestsRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema ClusterSpecManifestsScaleIo
 */
export interface ClusterSpecManifestsScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema ClusterSpecManifestsScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema ClusterSpecManifestsScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema ClusterSpecManifestsScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ClusterSpecManifestsScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema ClusterSpecManifestsScaleIo#secretRef
   */
  readonly secretRef: ClusterSpecManifestsScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema ClusterSpecManifestsScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema ClusterSpecManifestsScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema ClusterSpecManifestsScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema ClusterSpecManifestsScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema ClusterSpecManifestsScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsScaleIo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsScaleIo(obj: ClusterSpecManifestsScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterSpecManifestsScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema ClusterSpecManifestsSecret
 */
export interface ClusterSpecManifestsSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema ClusterSpecManifestsSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterSpecManifestsSecret#items
   */
  readonly items?: ClusterSpecManifestsSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema ClusterSpecManifestsSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema ClusterSpecManifestsSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsSecret(obj: ClusterSpecManifestsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ClusterSpecManifestsSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema ClusterSpecManifestsStorageos
 */
export interface ClusterSpecManifestsStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterSpecManifestsStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ClusterSpecManifestsStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema ClusterSpecManifestsStorageos#secretRef
   */
  readonly secretRef?: ClusterSpecManifestsStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema ClusterSpecManifestsStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema ClusterSpecManifestsStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsStorageos' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsStorageos(obj: ClusterSpecManifestsStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterSpecManifestsStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema ClusterSpecManifestsVsphereVolume
 */
export interface ClusterSpecManifestsVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterSpecManifestsVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema ClusterSpecManifestsVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema ClusterSpecManifestsVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema ClusterSpecManifestsVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsVsphereVolume(obj: ClusterSpecManifestsVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema ClusterSpecMountsAwsElasticBlockStore
 */
export interface ClusterSpecMountsAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ClusterSpecMountsAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema ClusterSpecMountsAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ClusterSpecMountsAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ClusterSpecMountsAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsAwsElasticBlockStore(obj: ClusterSpecMountsAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema ClusterSpecMountsAzureDisk
 */
export interface ClusterSpecMountsAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema ClusterSpecMountsAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema ClusterSpecMountsAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema ClusterSpecMountsAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterSpecMountsAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema ClusterSpecMountsAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ClusterSpecMountsAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecMountsAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsAzureDisk(obj: ClusterSpecMountsAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema ClusterSpecMountsAzureFile
 */
export interface ClusterSpecMountsAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ClusterSpecMountsAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema ClusterSpecMountsAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema ClusterSpecMountsAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsAzureFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsAzureFile(obj: ClusterSpecMountsAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema ClusterSpecMountsCephfs
 */
export interface ClusterSpecMountsCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ClusterSpecMountsCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema ClusterSpecMountsCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ClusterSpecMountsCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ClusterSpecMountsCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ClusterSpecMountsCephfs#secretRef
   */
  readonly secretRef?: ClusterSpecMountsCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ClusterSpecMountsCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsCephfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsCephfs(obj: ClusterSpecMountsCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_ClusterSpecMountsCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema ClusterSpecMountsCinder
 */
export interface ClusterSpecMountsCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ClusterSpecMountsCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ClusterSpecMountsCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema ClusterSpecMountsCinder#secretRef
   */
  readonly secretRef?: ClusterSpecMountsCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ClusterSpecMountsCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsCinder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsCinder(obj: ClusterSpecMountsCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterSpecMountsCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema ClusterSpecMountsConfigMap
 */
export interface ClusterSpecMountsConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema ClusterSpecMountsConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterSpecMountsConfigMap#items
   */
  readonly items?: ClusterSpecMountsConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecMountsConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema ClusterSpecMountsConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecMountsConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsConfigMap(obj: ClusterSpecMountsConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ClusterSpecMountsConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema ClusterSpecMountsCsi
 */
export interface ClusterSpecMountsCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema ClusterSpecMountsCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema ClusterSpecMountsCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema ClusterSpecMountsCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: ClusterSpecMountsCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema ClusterSpecMountsCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema ClusterSpecMountsCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecMountsCsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsCsi(obj: ClusterSpecMountsCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_ClusterSpecMountsCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema ClusterSpecMountsDownwardApi
 */
export interface ClusterSpecMountsDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema ClusterSpecMountsDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema ClusterSpecMountsDownwardApi#items
   */
  readonly items?: ClusterSpecMountsDownwardApiItems[];
}

/**
 * Converts an object of type 'ClusterSpecMountsDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsDownwardApi(obj: ClusterSpecMountsDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ClusterSpecMountsDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema ClusterSpecMountsEmptyDir
 */
export interface ClusterSpecMountsEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ClusterSpecMountsEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ClusterSpecMountsEmptyDir#sizeLimit
   */
  readonly sizeLimit?: ClusterSpecMountsEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'ClusterSpecMountsEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsEmptyDir(obj: ClusterSpecMountsEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema ClusterSpecMountsEphemeral
 */
export interface ClusterSpecMountsEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   *
   * Required, must not be nil.
   *
   * @schema ClusterSpecMountsEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: ClusterSpecMountsEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'ClusterSpecMountsEphemeral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsEphemeral(obj: ClusterSpecMountsEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_ClusterSpecMountsEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema ClusterSpecMountsFc
 */
export interface ClusterSpecMountsFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ClusterSpecMountsFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema ClusterSpecMountsFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ClusterSpecMountsFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema ClusterSpecMountsFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema ClusterSpecMountsFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'ClusterSpecMountsFc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsFc(obj: ClusterSpecMountsFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 *
 * @schema ClusterSpecMountsFlexVolume
 */
export interface ClusterSpecMountsFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema ClusterSpecMountsFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema ClusterSpecMountsFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema ClusterSpecMountsFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ClusterSpecMountsFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema ClusterSpecMountsFlexVolume#secretRef
   */
  readonly secretRef?: ClusterSpecMountsFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'ClusterSpecMountsFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsFlexVolume(obj: ClusterSpecMountsFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterSpecMountsFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema ClusterSpecMountsFlocker
 */
export interface ClusterSpecMountsFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema ClusterSpecMountsFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema ClusterSpecMountsFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsFlocker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsFlocker(obj: ClusterSpecMountsFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema ClusterSpecMountsGcePersistentDisk
 */
export interface ClusterSpecMountsGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ClusterSpecMountsGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ClusterSpecMountsGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ClusterSpecMountsGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema ClusterSpecMountsGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecMountsGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsGcePersistentDisk(obj: ClusterSpecMountsGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema ClusterSpecMountsGitRepo
 */
export interface ClusterSpecMountsGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema ClusterSpecMountsGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema ClusterSpecMountsGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema ClusterSpecMountsGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsGitRepo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsGitRepo(obj: ClusterSpecMountsGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema ClusterSpecMountsGlusterfs
 */
export interface ClusterSpecMountsGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema ClusterSpecMountsGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema ClusterSpecMountsGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema ClusterSpecMountsGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecMountsGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsGlusterfs(obj: ClusterSpecMountsGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 * ---
 * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
 * mount host directories as read/write.
 *
 * @schema ClusterSpecMountsHostPath
 */
export interface ClusterSpecMountsHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema ClusterSpecMountsHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema ClusterSpecMountsHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsHostPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsHostPath(obj: ClusterSpecMountsHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema ClusterSpecMountsIscsi
 */
export interface ClusterSpecMountsIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema ClusterSpecMountsIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema ClusterSpecMountsIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ClusterSpecMountsIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema ClusterSpecMountsIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema ClusterSpecMountsIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema ClusterSpecMountsIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema ClusterSpecMountsIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema ClusterSpecMountsIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecMountsIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema ClusterSpecMountsIscsi#secretRef
   */
  readonly secretRef?: ClusterSpecMountsIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema ClusterSpecMountsIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsIscsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsIscsi(obj: ClusterSpecMountsIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterSpecMountsIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema ClusterSpecMountsNfs
 */
export interface ClusterSpecMountsNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ClusterSpecMountsNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema ClusterSpecMountsNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ClusterSpecMountsNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsNfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsNfs(obj: ClusterSpecMountsNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema ClusterSpecMountsPersistentVolumeClaim
 */
export interface ClusterSpecMountsPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ClusterSpecMountsPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema ClusterSpecMountsPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecMountsPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsPersistentVolumeClaim(obj: ClusterSpecMountsPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema ClusterSpecMountsPhotonPersistentDisk
 */
export interface ClusterSpecMountsPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterSpecMountsPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema ClusterSpecMountsPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsPhotonPersistentDisk(obj: ClusterSpecMountsPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema ClusterSpecMountsPortworxVolume
 */
export interface ClusterSpecMountsPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterSpecMountsPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ClusterSpecMountsPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema ClusterSpecMountsPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsPortworxVolume(obj: ClusterSpecMountsPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema ClusterSpecMountsProjected
 */
export interface ClusterSpecMountsProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecMountsProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema ClusterSpecMountsProjected#sources
   */
  readonly sources?: ClusterSpecMountsProjectedSources[];
}

/**
 * Converts an object of type 'ClusterSpecMountsProjected' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsProjected(obj: ClusterSpecMountsProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_ClusterSpecMountsProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema ClusterSpecMountsQuobyte
 */
export interface ClusterSpecMountsQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema ClusterSpecMountsQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecMountsQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema ClusterSpecMountsQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema ClusterSpecMountsQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema ClusterSpecMountsQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema ClusterSpecMountsQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsQuobyte' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsQuobyte(obj: ClusterSpecMountsQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema ClusterSpecMountsRbd
 */
export interface ClusterSpecMountsRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ClusterSpecMountsRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema ClusterSpecMountsRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema ClusterSpecMountsRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema ClusterSpecMountsRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema ClusterSpecMountsRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema ClusterSpecMountsRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema ClusterSpecMountsRbd#secretRef
   */
  readonly secretRef?: ClusterSpecMountsRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema ClusterSpecMountsRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsRbd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsRbd(obj: ClusterSpecMountsRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterSpecMountsRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema ClusterSpecMountsScaleIo
 */
export interface ClusterSpecMountsScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema ClusterSpecMountsScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema ClusterSpecMountsScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema ClusterSpecMountsScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ClusterSpecMountsScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema ClusterSpecMountsScaleIo#secretRef
   */
  readonly secretRef: ClusterSpecMountsScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema ClusterSpecMountsScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema ClusterSpecMountsScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema ClusterSpecMountsScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema ClusterSpecMountsScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema ClusterSpecMountsScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsScaleIo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsScaleIo(obj: ClusterSpecMountsScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterSpecMountsScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema ClusterSpecMountsSecret
 */
export interface ClusterSpecMountsSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema ClusterSpecMountsSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterSpecMountsSecret#items
   */
  readonly items?: ClusterSpecMountsSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema ClusterSpecMountsSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema ClusterSpecMountsSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsSecret(obj: ClusterSpecMountsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ClusterSpecMountsSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema ClusterSpecMountsStorageos
 */
export interface ClusterSpecMountsStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterSpecMountsStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ClusterSpecMountsStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema ClusterSpecMountsStorageos#secretRef
   */
  readonly secretRef?: ClusterSpecMountsStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema ClusterSpecMountsStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema ClusterSpecMountsStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsStorageos' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsStorageos(obj: ClusterSpecMountsStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterSpecMountsStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema ClusterSpecMountsVsphereVolume
 */
export interface ClusterSpecMountsVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterSpecMountsVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema ClusterSpecMountsVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema ClusterSpecMountsVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema ClusterSpecMountsVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsVsphereVolume(obj: ClusterSpecMountsVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PersistentVolumeClaim defines the PVC configuration. Will be used as is in case of .spec.persistence.type is pvc.
 *
 * @schema ClusterSpecPersistencePersistentVolumeClaim
 */
export interface ClusterSpecPersistencePersistentVolumeClaim {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaim#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaim#kind
   */
  readonly kind?: string;

  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaim#metadata
   */
  readonly metadata?: ClusterSpecPersistencePersistentVolumeClaimMetadata;

  /**
   * spec defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaim#spec
   */
  readonly spec?: ClusterSpecPersistencePersistentVolumeClaimSpec;

  /**
   * status represents the current information/status of a persistent volume claim.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaim#status
   */
  readonly status?: ClusterSpecPersistencePersistentVolumeClaimStatus;
}

/**
 * Converts an object of type 'ClusterSpecPersistencePersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPersistencePersistentVolumeClaim(obj: ClusterSpecPersistencePersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': toJson_ClusterSpecPersistencePersistentVolumeClaimMetadata(obj.metadata),
    'spec': toJson_ClusterSpecPersistencePersistentVolumeClaimSpec(obj.spec),
    'status': toJson_ClusterSpecPersistencePersistentVolumeClaimStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ClusterSpecResourcesClaims
 */
export interface ClusterSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ClusterSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecResourcesClaims(obj: ClusterSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecResourcesLimits
 */
export class ClusterSpecResourcesLimits {
  public static fromNumber(value: number): ClusterSpecResourcesLimits {
    return new ClusterSpecResourcesLimits(value);
  }
  public static fromString(value: string): ClusterSpecResourcesLimits {
    return new ClusterSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecResourcesRequests
 */
export class ClusterSpecResourcesRequests {
  public static fromNumber(value: number): ClusterSpecResourcesRequests {
    return new ClusterSpecResourcesRequests(value);
  }
  public static fromString(value: string): ClusterSpecResourcesRequests {
    return new ClusterSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Service Type string describes ingress methods for a service
 *
 * @schema ClusterSpecServiceType
 */
export enum ClusterSpecServiceType {
  /** ClusterIP */
  CLUSTER_IP = "ClusterIP",
  /** NodePort */
  NODE_PORT = "NodePort",
  /** LoadBalancer */
  LOAD_BALANCER = "LoadBalancer",
}

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema ClusterSpecTopologySpreadConstraintsLabelSelector
 */
export interface ClusterSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecTopologySpreadConstraintsLabelSelector(obj: ClusterSpecTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Size defines the size of the etcd volume. Default: 1Gi
 *
 * @schema ClusterSpecEtcdPersistenceSize
 */
export class ClusterSpecEtcdPersistenceSize {
  public static fromNumber(value: number): ClusterSpecEtcdPersistenceSize {
    return new ClusterSpecEtcdPersistenceSize(value);
  }
  public static fromString(value: string): ClusterSpecEtcdPersistenceSize {
    return new ClusterSpecEtcdPersistenceSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ClusterSpecEtcdResourcesClaims
 */
export interface ClusterSpecEtcdResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ClusterSpecEtcdResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecEtcdResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEtcdResourcesClaims(obj: ClusterSpecEtcdResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecEtcdResourcesLimits
 */
export class ClusterSpecEtcdResourcesLimits {
  public static fromNumber(value: number): ClusterSpecEtcdResourcesLimits {
    return new ClusterSpecEtcdResourcesLimits(value);
  }
  public static fromString(value: string): ClusterSpecEtcdResourcesLimits {
    return new ClusterSpecEtcdResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecEtcdResourcesRequests
 */
export class ClusterSpecEtcdResourcesRequests {
  public static fromNumber(value: number): ClusterSpecEtcdResourcesRequests {
    return new ClusterSpecEtcdResourcesRequests(value);
  }
  public static fromString(value: string): ClusterSpecEtcdResourcesRequests {
    return new ClusterSpecEtcdResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema ClusterSpecManifestsCephfsSecretRef
 */
export interface ClusterSpecManifestsCephfsSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecManifestsCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsCephfsSecretRef(obj: ClusterSpecManifestsCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema ClusterSpecManifestsCinderSecretRef
 */
export interface ClusterSpecManifestsCinderSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecManifestsCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsCinderSecretRef(obj: ClusterSpecManifestsCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterSpecManifestsConfigMapItems
 */
export interface ClusterSpecManifestsConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterSpecManifestsConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecManifestsConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterSpecManifestsConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsConfigMapItems(obj: ClusterSpecManifestsConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema ClusterSpecManifestsCsiNodePublishSecretRef
 */
export interface ClusterSpecManifestsCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecManifestsCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsCsiNodePublishSecretRef(obj: ClusterSpecManifestsCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema ClusterSpecManifestsDownwardApiItems
 */
export interface ClusterSpecManifestsDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema ClusterSpecManifestsDownwardApiItems#fieldRef
   */
  readonly fieldRef?: ClusterSpecManifestsDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecManifestsDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema ClusterSpecManifestsDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema ClusterSpecManifestsDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: ClusterSpecManifestsDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'ClusterSpecManifestsDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsDownwardApiItems(obj: ClusterSpecManifestsDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_ClusterSpecManifestsDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_ClusterSpecManifestsDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema ClusterSpecManifestsEmptyDirSizeLimit
 */
export class ClusterSpecManifestsEmptyDirSizeLimit {
  public static fromNumber(value: number): ClusterSpecManifestsEmptyDirSizeLimit {
    return new ClusterSpecManifestsEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): ClusterSpecManifestsEmptyDirSizeLimit {
    return new ClusterSpecManifestsEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 *
 * Required, must not be nil.
 *
 * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplate
 */
export interface ClusterSpecManifestsEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: ClusterSpecManifestsEphemeralVolumeClaimTemplateMetadata;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'ClusterSpecManifestsEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplate(obj: ClusterSpecManifestsEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema ClusterSpecManifestsFlexVolumeSecretRef
 */
export interface ClusterSpecManifestsFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecManifestsFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsFlexVolumeSecretRef(obj: ClusterSpecManifestsFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema ClusterSpecManifestsIscsiSecretRef
 */
export interface ClusterSpecManifestsIscsiSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecManifestsIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsIscsiSecretRef(obj: ClusterSpecManifestsIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema ClusterSpecManifestsProjectedSources
 */
export interface ClusterSpecManifestsProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema ClusterSpecManifestsProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: ClusterSpecManifestsProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema ClusterSpecManifestsProjectedSources#configMap
   */
  readonly configMap?: ClusterSpecManifestsProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema ClusterSpecManifestsProjectedSources#downwardAPI
   */
  readonly downwardApi?: ClusterSpecManifestsProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema ClusterSpecManifestsProjectedSources#secret
   */
  readonly secret?: ClusterSpecManifestsProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema ClusterSpecManifestsProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: ClusterSpecManifestsProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'ClusterSpecManifestsProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsProjectedSources(obj: ClusterSpecManifestsProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterTrustBundle': toJson_ClusterSpecManifestsProjectedSourcesClusterTrustBundle(obj.clusterTrustBundle),
    'configMap': toJson_ClusterSpecManifestsProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_ClusterSpecManifestsProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_ClusterSpecManifestsProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_ClusterSpecManifestsProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema ClusterSpecManifestsRbdSecretRef
 */
export interface ClusterSpecManifestsRbdSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecManifestsRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsRbdSecretRef(obj: ClusterSpecManifestsRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema ClusterSpecManifestsScaleIoSecretRef
 */
export interface ClusterSpecManifestsScaleIoSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecManifestsScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsScaleIoSecretRef(obj: ClusterSpecManifestsScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterSpecManifestsSecretItems
 */
export interface ClusterSpecManifestsSecretItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterSpecManifestsSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecManifestsSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterSpecManifestsSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsSecretItems(obj: ClusterSpecManifestsSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema ClusterSpecManifestsStorageosSecretRef
 */
export interface ClusterSpecManifestsStorageosSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecManifestsStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsStorageosSecretRef(obj: ClusterSpecManifestsStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema ClusterSpecMountsCephfsSecretRef
 */
export interface ClusterSpecMountsCephfsSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecMountsCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsCephfsSecretRef(obj: ClusterSpecMountsCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema ClusterSpecMountsCinderSecretRef
 */
export interface ClusterSpecMountsCinderSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecMountsCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsCinderSecretRef(obj: ClusterSpecMountsCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterSpecMountsConfigMapItems
 */
export interface ClusterSpecMountsConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterSpecMountsConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecMountsConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterSpecMountsConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsConfigMapItems(obj: ClusterSpecMountsConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema ClusterSpecMountsCsiNodePublishSecretRef
 */
export interface ClusterSpecMountsCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecMountsCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsCsiNodePublishSecretRef(obj: ClusterSpecMountsCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema ClusterSpecMountsDownwardApiItems
 */
export interface ClusterSpecMountsDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema ClusterSpecMountsDownwardApiItems#fieldRef
   */
  readonly fieldRef?: ClusterSpecMountsDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecMountsDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema ClusterSpecMountsDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema ClusterSpecMountsDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: ClusterSpecMountsDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'ClusterSpecMountsDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsDownwardApiItems(obj: ClusterSpecMountsDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_ClusterSpecMountsDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_ClusterSpecMountsDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema ClusterSpecMountsEmptyDirSizeLimit
 */
export class ClusterSpecMountsEmptyDirSizeLimit {
  public static fromNumber(value: number): ClusterSpecMountsEmptyDirSizeLimit {
    return new ClusterSpecMountsEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): ClusterSpecMountsEmptyDirSizeLimit {
    return new ClusterSpecMountsEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 *
 * Required, must not be nil.
 *
 * @schema ClusterSpecMountsEphemeralVolumeClaimTemplate
 */
export interface ClusterSpecMountsEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: ClusterSpecMountsEphemeralVolumeClaimTemplateMetadata;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: ClusterSpecMountsEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'ClusterSpecMountsEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsEphemeralVolumeClaimTemplate(obj: ClusterSpecMountsEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_ClusterSpecMountsEphemeralVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_ClusterSpecMountsEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema ClusterSpecMountsFlexVolumeSecretRef
 */
export interface ClusterSpecMountsFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecMountsFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsFlexVolumeSecretRef(obj: ClusterSpecMountsFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema ClusterSpecMountsIscsiSecretRef
 */
export interface ClusterSpecMountsIscsiSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecMountsIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsIscsiSecretRef(obj: ClusterSpecMountsIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema ClusterSpecMountsProjectedSources
 */
export interface ClusterSpecMountsProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema ClusterSpecMountsProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: ClusterSpecMountsProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema ClusterSpecMountsProjectedSources#configMap
   */
  readonly configMap?: ClusterSpecMountsProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema ClusterSpecMountsProjectedSources#downwardAPI
   */
  readonly downwardApi?: ClusterSpecMountsProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema ClusterSpecMountsProjectedSources#secret
   */
  readonly secret?: ClusterSpecMountsProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema ClusterSpecMountsProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: ClusterSpecMountsProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'ClusterSpecMountsProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsProjectedSources(obj: ClusterSpecMountsProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterTrustBundle': toJson_ClusterSpecMountsProjectedSourcesClusterTrustBundle(obj.clusterTrustBundle),
    'configMap': toJson_ClusterSpecMountsProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_ClusterSpecMountsProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_ClusterSpecMountsProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_ClusterSpecMountsProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema ClusterSpecMountsRbdSecretRef
 */
export interface ClusterSpecMountsRbdSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecMountsRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsRbdSecretRef(obj: ClusterSpecMountsRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema ClusterSpecMountsScaleIoSecretRef
 */
export interface ClusterSpecMountsScaleIoSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecMountsScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsScaleIoSecretRef(obj: ClusterSpecMountsScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterSpecMountsSecretItems
 */
export interface ClusterSpecMountsSecretItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterSpecMountsSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecMountsSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterSpecMountsSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsSecretItems(obj: ClusterSpecMountsSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema ClusterSpecMountsStorageosSecretRef
 */
export interface ClusterSpecMountsStorageosSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecMountsStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsStorageosSecretRef(obj: ClusterSpecMountsStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Standard object's metadata.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
 *
 * @schema ClusterSpecPersistencePersistentVolumeClaimMetadata
 */
export interface ClusterSpecPersistencePersistentVolumeClaimMetadata {
  /**
   * @schema ClusterSpecPersistencePersistentVolumeClaimMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ClusterSpecPersistencePersistentVolumeClaimMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema ClusterSpecPersistencePersistentVolumeClaimMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema ClusterSpecPersistencePersistentVolumeClaimMetadata#name
   */
  readonly name?: string;

  /**
   * @schema ClusterSpecPersistencePersistentVolumeClaimMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSpecPersistencePersistentVolumeClaimMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPersistencePersistentVolumeClaimMetadata(obj: ClusterSpecPersistencePersistentVolumeClaimMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * spec defines the desired characteristics of a volume requested by a pod author.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema ClusterSpecPersistencePersistentVolumeClaimSpec
 */
export interface ClusterSpecPersistencePersistentVolumeClaimSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpec#dataSource
   */
  readonly dataSource?: ClusterSpecPersistencePersistentVolumeClaimSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpec#dataSourceRef
   */
  readonly dataSourceRef?: ClusterSpecPersistencePersistentVolumeClaimSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpec#resources
   */
  readonly resources?: ClusterSpecPersistencePersistentVolumeClaimSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpec#selector
   */
  readonly selector?: ClusterSpecPersistencePersistentVolumeClaimSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'ClusterSpecPersistencePersistentVolumeClaimSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPersistencePersistentVolumeClaimSpec(obj: ClusterSpecPersistencePersistentVolumeClaimSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ClusterSpecPersistencePersistentVolumeClaimSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_ClusterSpecPersistencePersistentVolumeClaimSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ClusterSpecPersistencePersistentVolumeClaimSpecResources(obj.resources),
    'selector': toJson_ClusterSpecPersistencePersistentVolumeClaimSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * status represents the current information/status of a persistent volume claim.
 * Read-only.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema ClusterSpecPersistencePersistentVolumeClaimStatus
 */
export interface ClusterSpecPersistencePersistentVolumeClaimStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   *
   * ClaimResourceStatus can be in any of following states:
   * - ControllerResizeInProgress:
   * State set when resize controller starts resizing the volume in control-plane.
   * - ControllerResizeFailed:
   * State set when resize has failed in resize controller with a terminal error.
   * - NodeResizePending:
   * State set when resize controller has finished resizing the volume but further resizing of
   * volume is needed on the node.
   * - NodeResizeInProgress:
   * State set when kubelet starts resizing the volume.
   * - NodeResizeFailed:
   * State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
   * NodeResizeFailed.
   * For example: if expanding a PVC for more capacity - this field can be one of the following states:
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
   * When this field is not set, it means that no resize operation is in progress for the given PVC.
   *
   *
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   *
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation
   * is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   *
   *
   * A controller that receives PVC update with previously unknown resourceName
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: ClusterSpecPersistencePersistentVolumeClaimStatusAllocatedResources };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatus#capacity
   */
  readonly capacity?: { [key: string]: ClusterSpecPersistencePersistentVolumeClaimStatusCapacity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'Resizing'.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatus#conditions
   */
  readonly conditions?: ClusterSpecPersistencePersistentVolumeClaimStatusConditions[];

  /**
   * currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
   * When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
   * This is an alpha field and requires enabling VolumeAttributesClass feature.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatus#currentVolumeAttributesClassName
   */
  readonly currentVolumeAttributesClassName?: string;

  /**
   * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
   * When this is unset, there is no ModifyVolume operation being attempted.
   * This is an alpha field and requires enabling VolumeAttributesClass feature.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatus#modifyVolumeStatus
   */
  readonly modifyVolumeStatus?: ClusterSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus;

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatus#phase
   */
  readonly phase?: string;
}

/**
 * Converts an object of type 'ClusterSpecPersistencePersistentVolumeClaimStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPersistencePersistentVolumeClaimStatus(obj: ClusterSpecPersistencePersistentVolumeClaimStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResourceStatuses': ((obj.allocatedResourceStatuses) === undefined) ? undefined : (Object.entries(obj.allocatedResourceStatuses).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_ClusterSpecPersistencePersistentVolumeClaimStatusConditions(y)),
    'currentVolumeAttributesClassName': obj.currentVolumeAttributesClassName,
    'modifyVolumeStatus': toJson_ClusterSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus(obj.modifyVolumeStatus),
    'phase': obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema ClusterSpecManifestsDownwardApiItemsFieldRef
 */
export interface ClusterSpecManifestsDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ClusterSpecManifestsDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ClusterSpecManifestsDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsDownwardApiItemsFieldRef(obj: ClusterSpecManifestsDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema ClusterSpecManifestsDownwardApiItemsResourceFieldRef
 */
export interface ClusterSpecManifestsDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ClusterSpecManifestsDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ClusterSpecManifestsDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: ClusterSpecManifestsDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ClusterSpecManifestsDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsDownwardApiItemsResourceFieldRef(obj: ClusterSpecManifestsDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * May contain labels and annotations that will be copied into the PVC
 * when creating it. No other fields are allowed and will be rejected during
 * validation.
 *
 * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateMetadata
 */
export interface ClusterSpecManifestsEphemeralVolumeClaimTemplateMetadata {
  /**
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsEphemeralVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplateMetadata(obj: ClusterSpecManifestsEphemeralVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec
 */
export interface ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec(obj: ClusterSpecManifestsEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema ClusterSpecManifestsProjectedSourcesClusterTrustBundle
 */
export interface ClusterSpecManifestsProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema ClusterSpecManifestsProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema ClusterSpecManifestsProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema ClusterSpecManifestsProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema ClusterSpecManifestsProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema ClusterSpecManifestsProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsProjectedSourcesClusterTrustBundle(obj: ClusterSpecManifestsProjectedSourcesClusterTrustBundle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector(obj.labelSelector),
    'name': obj.name,
    'optional': obj.optional,
    'path': obj.path,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema ClusterSpecManifestsProjectedSourcesConfigMap
 */
export interface ClusterSpecManifestsProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterSpecManifestsProjectedSourcesConfigMap#items
   */
  readonly items?: ClusterSpecManifestsProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecManifestsProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema ClusterSpecManifestsProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecManifestsProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsProjectedSourcesConfigMap(obj: ClusterSpecManifestsProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterSpecManifestsProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema ClusterSpecManifestsProjectedSourcesDownwardApi
 */
export interface ClusterSpecManifestsProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema ClusterSpecManifestsProjectedSourcesDownwardApi#items
   */
  readonly items?: ClusterSpecManifestsProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'ClusterSpecManifestsProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsProjectedSourcesDownwardApi(obj: ClusterSpecManifestsProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterSpecManifestsProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema ClusterSpecManifestsProjectedSourcesSecret
 */
export interface ClusterSpecManifestsProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterSpecManifestsProjectedSourcesSecret#items
   */
  readonly items?: ClusterSpecManifestsProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecManifestsProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecManifestsProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecManifestsProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsProjectedSourcesSecret(obj: ClusterSpecManifestsProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterSpecManifestsProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema ClusterSpecManifestsProjectedSourcesServiceAccountToken
 */
export interface ClusterSpecManifestsProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema ClusterSpecManifestsProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema ClusterSpecManifestsProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema ClusterSpecManifestsProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsProjectedSourcesServiceAccountToken(obj: ClusterSpecManifestsProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema ClusterSpecMountsDownwardApiItemsFieldRef
 */
export interface ClusterSpecMountsDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ClusterSpecMountsDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ClusterSpecMountsDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsDownwardApiItemsFieldRef(obj: ClusterSpecMountsDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema ClusterSpecMountsDownwardApiItemsResourceFieldRef
 */
export interface ClusterSpecMountsDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ClusterSpecMountsDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ClusterSpecMountsDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: ClusterSpecMountsDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ClusterSpecMountsDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsDownwardApiItemsResourceFieldRef(obj: ClusterSpecMountsDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * May contain labels and annotations that will be copied into the PVC
 * when creating it. No other fields are allowed and will be rejected during
 * validation.
 *
 * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateMetadata
 */
export interface ClusterSpecMountsEphemeralVolumeClaimTemplateMetadata {
  /**
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsEphemeralVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsEphemeralVolumeClaimTemplateMetadata(obj: ClusterSpecMountsEphemeralVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpec
 */
export interface ClusterSpecMountsEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsEphemeralVolumeClaimTemplateSpec(obj: ClusterSpecMountsEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema ClusterSpecMountsProjectedSourcesClusterTrustBundle
 */
export interface ClusterSpecMountsProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema ClusterSpecMountsProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema ClusterSpecMountsProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema ClusterSpecMountsProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema ClusterSpecMountsProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema ClusterSpecMountsProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsProjectedSourcesClusterTrustBundle(obj: ClusterSpecMountsProjectedSourcesClusterTrustBundle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelector(obj.labelSelector),
    'name': obj.name,
    'optional': obj.optional,
    'path': obj.path,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema ClusterSpecMountsProjectedSourcesConfigMap
 */
export interface ClusterSpecMountsProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterSpecMountsProjectedSourcesConfigMap#items
   */
  readonly items?: ClusterSpecMountsProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecMountsProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema ClusterSpecMountsProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecMountsProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsProjectedSourcesConfigMap(obj: ClusterSpecMountsProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterSpecMountsProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema ClusterSpecMountsProjectedSourcesDownwardApi
 */
export interface ClusterSpecMountsProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema ClusterSpecMountsProjectedSourcesDownwardApi#items
   */
  readonly items?: ClusterSpecMountsProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'ClusterSpecMountsProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsProjectedSourcesDownwardApi(obj: ClusterSpecMountsProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterSpecMountsProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema ClusterSpecMountsProjectedSourcesSecret
 */
export interface ClusterSpecMountsProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterSpecMountsProjectedSourcesSecret#items
   */
  readonly items?: ClusterSpecMountsProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema ClusterSpecMountsProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecMountsProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecMountsProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsProjectedSourcesSecret(obj: ClusterSpecMountsProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterSpecMountsProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema ClusterSpecMountsProjectedSourcesServiceAccountToken
 */
export interface ClusterSpecMountsProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema ClusterSpecMountsProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema ClusterSpecMountsProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema ClusterSpecMountsProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsProjectedSourcesServiceAccountToken(obj: ClusterSpecMountsProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ClusterSpecPersistencePersistentVolumeClaimSpecDataSource
 */
export interface ClusterSpecPersistencePersistentVolumeClaimSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecPersistencePersistentVolumeClaimSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPersistencePersistentVolumeClaimSpecDataSource(obj: ClusterSpecPersistencePersistentVolumeClaimSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ClusterSpecPersistencePersistentVolumeClaimSpecDataSourceRef
 */
export interface ClusterSpecPersistencePersistentVolumeClaimSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSpecPersistencePersistentVolumeClaimSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPersistencePersistentVolumeClaimSpecDataSourceRef(obj: ClusterSpecPersistencePersistentVolumeClaimSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ClusterSpecPersistencePersistentVolumeClaimSpecResources
 */
export interface ClusterSpecPersistencePersistentVolumeClaimSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpecResources#limits
   */
  readonly limits?: { [key: string]: ClusterSpecPersistencePersistentVolumeClaimSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpecResources#requests
   */
  readonly requests?: { [key: string]: ClusterSpecPersistencePersistentVolumeClaimSpecResourcesRequests };
}

/**
 * Converts an object of type 'ClusterSpecPersistencePersistentVolumeClaimSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPersistencePersistentVolumeClaimSpecResources(obj: ClusterSpecPersistencePersistentVolumeClaimSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ClusterSpecPersistencePersistentVolumeClaimSpecSelector
 */
export interface ClusterSpecPersistencePersistentVolumeClaimSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpecSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecPersistencePersistentVolumeClaimSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPersistencePersistentVolumeClaimSpecSelector(obj: ClusterSpecPersistencePersistentVolumeClaimSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecPersistencePersistentVolumeClaimStatusAllocatedResources
 */
export class ClusterSpecPersistencePersistentVolumeClaimStatusAllocatedResources {
  public static fromNumber(value: number): ClusterSpecPersistencePersistentVolumeClaimStatusAllocatedResources {
    return new ClusterSpecPersistencePersistentVolumeClaimStatusAllocatedResources(value);
  }
  public static fromString(value: string): ClusterSpecPersistencePersistentVolumeClaimStatusAllocatedResources {
    return new ClusterSpecPersistencePersistentVolumeClaimStatusAllocatedResources(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecPersistencePersistentVolumeClaimStatusCapacity
 */
export class ClusterSpecPersistencePersistentVolumeClaimStatusCapacity {
  public static fromNumber(value: number): ClusterSpecPersistencePersistentVolumeClaimStatusCapacity {
    return new ClusterSpecPersistencePersistentVolumeClaimStatusCapacity(value);
  }
  public static fromString(value: string): ClusterSpecPersistencePersistentVolumeClaimStatusCapacity {
    return new ClusterSpecPersistencePersistentVolumeClaimStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema ClusterSpecPersistencePersistentVolumeClaimStatusConditions
 */
export interface ClusterSpecPersistencePersistentVolumeClaimStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "Resizing" that means the underlying
   * persistent volume is being resized.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatusConditions#status
   */
  readonly status: string;

  /**
   * PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatusConditions#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ClusterSpecPersistencePersistentVolumeClaimStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPersistencePersistentVolumeClaimStatusConditions(obj: ClusterSpecPersistencePersistentVolumeClaimStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
 * When this is unset, there is no ModifyVolume operation being attempted.
 * This is an alpha field and requires enabling VolumeAttributesClass feature.
 *
 * @schema ClusterSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus
 */
export interface ClusterSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus {
  /**
   * status is the status of the ControllerModifyVolume operation. It can be in any of following states:
   * - Pending
   * Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
   * the specified VolumeAttributesClass not existing.
   * - InProgress
   * InProgress indicates that the volume is being modified.
   * - Infeasible
   * Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
   * resolve the error, a valid VolumeAttributesClass needs to be specified.
   * Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus#status
   */
  readonly status: string;

  /**
   * targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus#targetVolumeAttributesClassName
   */
  readonly targetVolumeAttributesClassName?: string;
}

/**
 * Converts an object of type 'ClusterSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus(obj: ClusterSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'targetVolumeAttributesClassName': obj.targetVolumeAttributesClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ClusterSpecManifestsDownwardApiItemsResourceFieldRefDivisor
 */
export class ClusterSpecManifestsDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): ClusterSpecManifestsDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterSpecManifestsDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ClusterSpecManifestsDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterSpecManifestsDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource(obj: ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResources
 */
export interface ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests };
}

/**
 * Converts an object of type 'ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResources(obj: ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelector
 */
export interface ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelector(obj: ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector(obj: ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterSpecManifestsProjectedSourcesConfigMapItems
 */
export interface ClusterSpecManifestsProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterSpecManifestsProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecManifestsProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterSpecManifestsProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsProjectedSourcesConfigMapItems(obj: ClusterSpecManifestsProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema ClusterSpecManifestsProjectedSourcesDownwardApiItems
 */
export interface ClusterSpecManifestsProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema ClusterSpecManifestsProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: ClusterSpecManifestsProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecManifestsProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema ClusterSpecManifestsProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema ClusterSpecManifestsProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'ClusterSpecManifestsProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsProjectedSourcesDownwardApiItems(obj: ClusterSpecManifestsProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_ClusterSpecManifestsProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterSpecManifestsProjectedSourcesSecretItems
 */
export interface ClusterSpecManifestsProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterSpecManifestsProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecManifestsProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterSpecManifestsProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsProjectedSourcesSecretItems(obj: ClusterSpecManifestsProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ClusterSpecMountsDownwardApiItemsResourceFieldRefDivisor
 */
export class ClusterSpecMountsDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): ClusterSpecMountsDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterSpecMountsDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ClusterSpecMountsDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterSpecMountsDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSource(obj: ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: ClusterSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResources
 */
export interface ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests };
}

/**
 * Converts an object of type 'ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResources(obj: ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelector
 */
export interface ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelector(obj: ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelector(obj: ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterSpecMountsProjectedSourcesConfigMapItems
 */
export interface ClusterSpecMountsProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterSpecMountsProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecMountsProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterSpecMountsProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsProjectedSourcesConfigMapItems(obj: ClusterSpecMountsProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema ClusterSpecMountsProjectedSourcesDownwardApiItems
 */
export interface ClusterSpecMountsProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema ClusterSpecMountsProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: ClusterSpecMountsProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecMountsProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema ClusterSpecMountsProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema ClusterSpecMountsProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'ClusterSpecMountsProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsProjectedSourcesDownwardApiItems(obj: ClusterSpecMountsProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_ClusterSpecMountsProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterSpecMountsProjectedSourcesSecretItems
 */
export interface ClusterSpecMountsProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterSpecMountsProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecMountsProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterSpecMountsProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsProjectedSourcesSecretItems(obj: ClusterSpecMountsProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecPersistencePersistentVolumeClaimSpecResourcesLimits
 */
export class ClusterSpecPersistencePersistentVolumeClaimSpecResourcesLimits {
  public static fromNumber(value: number): ClusterSpecPersistencePersistentVolumeClaimSpecResourcesLimits {
    return new ClusterSpecPersistencePersistentVolumeClaimSpecResourcesLimits(value);
  }
  public static fromString(value: string): ClusterSpecPersistencePersistentVolumeClaimSpecResourcesLimits {
    return new ClusterSpecPersistencePersistentVolumeClaimSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecPersistencePersistentVolumeClaimSpecResourcesRequests
 */
export class ClusterSpecPersistencePersistentVolumeClaimSpecResourcesRequests {
  public static fromNumber(value: number): ClusterSpecPersistencePersistentVolumeClaimSpecResourcesRequests {
    return new ClusterSpecPersistencePersistentVolumeClaimSpecResourcesRequests(value);
  }
  public static fromString(value: string): ClusterSpecPersistencePersistentVolumeClaimSpecResourcesRequests {
    return new ClusterSpecPersistencePersistentVolumeClaimSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions
 */
export interface ClusterSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions(obj: ClusterSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: ClusterSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(obj: ClusterSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema ClusterSpecManifestsProjectedSourcesDownwardApiItemsFieldRef
 */
export interface ClusterSpecManifestsProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ClusterSpecManifestsProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ClusterSpecManifestsProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsProjectedSourcesDownwardApiItemsFieldRef(obj: ClusterSpecManifestsProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef(obj: ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ClusterSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: ClusterSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(obj: ClusterSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema ClusterSpecMountsProjectedSourcesDownwardApiItemsFieldRef
 */
export interface ClusterSpecMountsProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ClusterSpecMountsProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ClusterSpecMountsProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsProjectedSourcesDownwardApiItemsFieldRef(obj: ClusterSpecMountsProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef(obj: ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * JoinTokenRequest is the Schema for the join token request API
 *
 * @schema JoinTokenRequest
 */
export class JoinTokenRequest extends ApiObject {
  /**
   * Returns the apiVersion and kind for "JoinTokenRequest"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k0smotron.io/v1beta1',
    kind: 'JoinTokenRequest',
  }

  /**
   * Renders a Kubernetes manifest for "JoinTokenRequest".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: JoinTokenRequestProps = {}): any {
    return {
      ...JoinTokenRequest.GVK,
      ...toJson_JoinTokenRequestProps(props),
    };
  }

  /**
   * Defines a "JoinTokenRequest" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: JoinTokenRequestProps = {}) {
    super(scope, id, {
      ...JoinTokenRequest.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...JoinTokenRequest.GVK,
      ...toJson_JoinTokenRequestProps(resolved),
    };
  }
}

/**
 * JoinTokenRequest is the Schema for the join token request API
 *
 * @schema JoinTokenRequest
 */
export interface JoinTokenRequestProps {
  /**
   * @schema JoinTokenRequest#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * JoinTokenRequestSpec defines the desired state of K0smotronJoinTokenRequest
   *
   * @schema JoinTokenRequest#spec
   */
  readonly spec?: JoinTokenRequestSpec;
}

/**
 * Converts an object of type 'JoinTokenRequestProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_JoinTokenRequestProps(obj: JoinTokenRequestProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_JoinTokenRequestSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * JoinTokenRequestSpec defines the desired state of K0smotronJoinTokenRequest
 *
 * @schema JoinTokenRequestSpec
 */
export interface JoinTokenRequestSpec {
  /**
   * ClusterRef is the reference to the cluster for which the join token is requested.
   *
   * @schema JoinTokenRequestSpec#clusterRef
   */
  readonly clusterRef: JoinTokenRequestSpecClusterRef;

  /**
   * Expiration time of the token. Format 1.5h, 2h45m or 300ms.
   *
   * @schema JoinTokenRequestSpec#expiry
   */
  readonly expiry?: string;

  /**
   * Role of the node for which the token is requested (worker or controller).
   *
   * @schema JoinTokenRequestSpec#role
   */
  readonly role?: JoinTokenRequestSpecRole;
}

/**
 * Converts an object of type 'JoinTokenRequestSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_JoinTokenRequestSpec(obj: JoinTokenRequestSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRef': toJson_JoinTokenRequestSpecClusterRef(obj.clusterRef),
    'expiry': obj.expiry,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterRef is the reference to the cluster for which the join token is requested.
 *
 * @schema JoinTokenRequestSpecClusterRef
 */
export interface JoinTokenRequestSpecClusterRef {
  /**
   * Name of the cluster.
   *
   * @schema JoinTokenRequestSpecClusterRef#name
   */
  readonly name: string;

  /**
   * Namespace of the cluster.
   *
   * @schema JoinTokenRequestSpecClusterRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'JoinTokenRequestSpecClusterRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_JoinTokenRequestSpecClusterRef(obj: JoinTokenRequestSpecClusterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Role of the node for which the token is requested (worker or controller).
 *
 * @schema JoinTokenRequestSpecRole
 */
export enum JoinTokenRequestSpecRole {
  /** worker */
  WORKER = "worker",
  /** controller */
  CONTROLLER = "controller",
}

