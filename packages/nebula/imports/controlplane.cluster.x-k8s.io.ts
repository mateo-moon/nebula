// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema K0sControlPlane
 */
export class K0sControlPlane extends ApiObject {
  /**
   * Returns the apiVersion and kind for "K0sControlPlane"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'controlplane.cluster.x-k8s.io/v1beta1',
    kind: 'K0sControlPlane',
  }

  /**
   * Renders a Kubernetes manifest for "K0sControlPlane".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: K0sControlPlaneProps = {}): any {
    return {
      ...K0sControlPlane.GVK,
      ...toJson_K0sControlPlaneProps(props),
    };
  }

  /**
   * Defines a "K0sControlPlane" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: K0sControlPlaneProps = {}) {
    super(scope, id, {
      ...K0sControlPlane.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...K0sControlPlane.GVK,
      ...toJson_K0sControlPlaneProps(resolved),
    };
  }
}

/**
 * @schema K0sControlPlane
 */
export interface K0sControlPlaneProps {
  /**
   * @schema K0sControlPlane#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema K0sControlPlane#spec
   */
  readonly spec?: K0SControlPlaneSpec;
}

/**
 * Converts an object of type 'K0sControlPlaneProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0sControlPlaneProps(obj: K0sControlPlaneProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_K0SControlPlaneSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SControlPlaneSpec
 */
export interface K0SControlPlaneSpec {
  /**
   * @schema K0SControlPlaneSpec#k0sConfigSpec
   */
  readonly k0SConfigSpec: K0SControlPlaneSpecK0SConfigSpec;

  /**
   * @schema K0SControlPlaneSpec#machineTemplate
   */
  readonly machineTemplate: K0SControlPlaneSpecMachineTemplate;

  /**
   * @schema K0SControlPlaneSpec#replicas
   */
  readonly replicas?: number;

  /**
   * UpdateStrategy defines the strategy to use when updating the control plane.
   *
   * @schema K0SControlPlaneSpec#updateStrategy
   */
  readonly updateStrategy?: K0SControlPlaneSpecUpdateStrategy;

  /**
   * Version defines the k0s version to be deployed. You can use a specific k0s version (e.g. v1.27.1+k0s.0) or
   * just the Kubernetes version (e.g. v1.27.1). If left empty, k0smotron will select one automatically.
   *
   * @schema K0SControlPlaneSpec#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'K0SControlPlaneSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneSpec(obj: K0SControlPlaneSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'k0sConfigSpec': toJson_K0SControlPlaneSpecK0SConfigSpec(obj.k0SConfigSpec),
    'machineTemplate': toJson_K0SControlPlaneSpecMachineTemplate(obj.machineTemplate),
    'replicas': obj.replicas,
    'updateStrategy': obj.updateStrategy,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SControlPlaneSpecK0SConfigSpec
 */
export interface K0SControlPlaneSpecK0SConfigSpec {
  /**
   * Args specifies extra arguments to be passed to k0s controller.
   * See: https://docs.k0sproject.io/stable/cli/k0s_controller/
   *
   * @schema K0SControlPlaneSpecK0SConfigSpec#args
   */
  readonly args?: string[];

  /**
   * CustomUserDataRef is a reference to a secret or a configmap that contains the custom user data.
   * Provided user-data will be merged with the one generated by k0smotron. Note that you may want to specify the merge type.
   * See: https://cloudinit.readthedocs.io/en/latest/reference/merging.html
   *
   * @schema K0SControlPlaneSpecK0SConfigSpec#customUserDataRef
   */
  readonly customUserDataRef?: K0SControlPlaneSpecK0SConfigSpecCustomUserDataRef;

  /**
   * DownloadURL specifies the URL from which to download the k0s binary.
   * If the version field is specified, it is ignored, and whatever version is downloaded from the URL is used.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpec#downloadURL
   */
  readonly downloadUrl?: string;

  /**
   * Files specifies extra files to be passed to user_data upon creation.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpec#files
   */
  readonly files?: K0SControlPlaneSpecK0SConfigSpecFiles[];

  /**
   * K0s defines the k0s configuration. Note, that some fields will be overwritten by k0smotron.
   * If empty, will be used default configuration. @see https://docs.k0sproject.io/stable/configuration/
   *
   * @schema K0SControlPlaneSpecK0SConfigSpec#k0s
   */
  readonly k0S?: any;

  /**
   * PostStartCommands specifies commands to be run after starting k0s worker.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpec#postStartCommands
   */
  readonly postStartCommands?: string[];

  /**
   * PreInstallK0s specifies whether k0s binary is pre-installed on the node.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpec#preInstalledK0s
   */
  readonly preInstalledK0S?: boolean;

  /**
   * PreStartCommands specifies commands to be run before starting k0s worker.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpec#preStartCommands
   */
  readonly preStartCommands?: string[];

  /**
   * Tunneling defines the tunneling configuration for the cluster.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpec#tunneling
   */
  readonly tunneling?: K0SControlPlaneSpecK0SConfigSpecTunneling;

  /**
   * UseSystemHostname specifies whether to use the system hostname for the kubernetes node name.
   * By default, k0smotron will use Machine name as a node name. If true, it will pick it from `hostname` command output.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpec#useSystemHostname
   */
  readonly useSystemHostname?: boolean;
}

/**
 * Converts an object of type 'K0SControlPlaneSpecK0SConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneSpecK0SConfigSpec(obj: K0SControlPlaneSpecK0SConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'customUserDataRef': toJson_K0SControlPlaneSpecK0SConfigSpecCustomUserDataRef(obj.customUserDataRef),
    'downloadURL': obj.downloadUrl,
    'files': obj.files?.map(y => toJson_K0SControlPlaneSpecK0SConfigSpecFiles(y)),
    'k0s': obj.k0S,
    'postStartCommands': obj.postStartCommands?.map(y => y),
    'preInstalledK0s': obj.preInstalledK0S,
    'preStartCommands': obj.preStartCommands?.map(y => y),
    'tunneling': toJson_K0SControlPlaneSpecK0SConfigSpecTunneling(obj.tunneling),
    'useSystemHostname': obj.useSystemHostname,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SControlPlaneSpecMachineTemplate
 */
export interface K0SControlPlaneSpecMachineTemplate {
  /**
   * InfrastructureRef is a required reference to a custom resource
   * offered by an infrastructure provider.
   *
   * @schema K0SControlPlaneSpecMachineTemplate#infrastructureRef
   */
  readonly infrastructureRef: K0SControlPlaneSpecMachineTemplateInfrastructureRef;

  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema K0SControlPlaneSpecMachineTemplate#metadata
   */
  readonly metadata?: K0SControlPlaneSpecMachineTemplateMetadata;

  /**
   * NodeDeletionTimeout defines how long the machine controller will attempt to delete the Node that the Machine
   * hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely.
   * If no value is provided, the default value for this property of the Machine resource will be used.
   *
   * @schema K0SControlPlaneSpecMachineTemplate#nodeDeletionTimeout
   */
  readonly nodeDeletionTimeout?: string;

  /**
   * NodeDrainTimeout is the total amount of time that the controller will spend on draining a controlplane node
   * The default value is 0, meaning that the node can be drained without any time limitations.
   * NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
   *
   * @schema K0SControlPlaneSpecMachineTemplate#nodeDrainTimeout
   */
  readonly nodeDrainTimeout?: string;

  /**
   * NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes
   * to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
   *
   * @schema K0SControlPlaneSpecMachineTemplate#nodeVolumeDetachTimeout
   */
  readonly nodeVolumeDetachTimeout?: string;
}

/**
 * Converts an object of type 'K0SControlPlaneSpecMachineTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneSpecMachineTemplate(obj: K0SControlPlaneSpecMachineTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infrastructureRef': toJson_K0SControlPlaneSpecMachineTemplateInfrastructureRef(obj.infrastructureRef),
    'metadata': toJson_K0SControlPlaneSpecMachineTemplateMetadata(obj.metadata),
    'nodeDeletionTimeout': obj.nodeDeletionTimeout,
    'nodeDrainTimeout': obj.nodeDrainTimeout,
    'nodeVolumeDetachTimeout': obj.nodeVolumeDetachTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UpdateStrategy defines the strategy to use when updating the control plane.
 *
 * @schema K0SControlPlaneSpecUpdateStrategy
 */
export enum K0SControlPlaneSpecUpdateStrategy {
  /** InPlace */
  IN_PLACE = "InPlace",
  /** Recreate */
  RECREATE = "Recreate",
}

/**
 * CustomUserDataRef is a reference to a secret or a configmap that contains the custom user data.
 * Provided user-data will be merged with the one generated by k0smotron. Note that you may want to specify the merge type.
 * See: https://cloudinit.readthedocs.io/en/latest/reference/merging.html
 *
 * @schema K0SControlPlaneSpecK0SConfigSpecCustomUserDataRef
 */
export interface K0SControlPlaneSpecK0SConfigSpecCustomUserDataRef {
  /**
   * ConfigMapRef is a reference to a configmap that contains the content.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecCustomUserDataRef#configMapRef
   */
  readonly configMapRef?: K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefConfigMapRef;

  /**
   * SecretRef is a reference to a secret that contains the content.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecCustomUserDataRef#secretRef
   */
  readonly secretRef?: K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefSecretRef;
}

/**
 * Converts an object of type 'K0SControlPlaneSpecK0SConfigSpecCustomUserDataRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneSpecK0SConfigSpecCustomUserDataRef(obj: K0SControlPlaneSpecK0SConfigSpecCustomUserDataRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefConfigMapRef(obj.configMapRef),
    'secretRef': toJson_K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * File defines a file to be passed to user_data upon creation.
 *
 * @schema K0SControlPlaneSpecK0SConfigSpecFiles
 */
export interface K0SControlPlaneSpecK0SConfigSpecFiles {
  /**
   * @schema K0SControlPlaneSpecK0SConfigSpecFiles#content
   */
  readonly content?: string;

  /**
   * ContentFrom specifies the source of the content.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecFiles#contentFrom
   */
  readonly contentFrom?: K0SControlPlaneSpecK0SConfigSpecFilesContentFrom;

  /**
   * @schema K0SControlPlaneSpecK0SConfigSpecFiles#path
   */
  readonly path?: string;

  /**
   * @schema K0SControlPlaneSpecK0SConfigSpecFiles#permissions
   */
  readonly permissions?: string;
}

/**
 * Converts an object of type 'K0SControlPlaneSpecK0SConfigSpecFiles' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneSpecK0SConfigSpecFiles(obj: K0SControlPlaneSpecK0SConfigSpecFiles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'contentFrom': toJson_K0SControlPlaneSpecK0SConfigSpecFilesContentFrom(obj.contentFrom),
    'path': obj.path,
    'permissions': obj.permissions,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Tunneling defines the tunneling configuration for the cluster.
 *
 * @schema K0SControlPlaneSpecK0SConfigSpecTunneling
 */
export interface K0SControlPlaneSpecK0SConfigSpecTunneling {
  /**
   * Enabled specifies whether tunneling is enabled.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecTunneling#enabled
   */
  readonly enabled?: boolean;

  /**
   * Mode describes tunneling mode.
   * If empty, k0smotron will use the default one.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecTunneling#mode
   */
  readonly mode?: K0SControlPlaneSpecK0SConfigSpecTunnelingMode;

  /**
   * Server address of the tunneling server.
   * If empty, k0smotron will try to detect worker node address for.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecTunneling#serverAddress
   */
  readonly serverAddress?: string;

  /**
   * NodePort to publish for server port of the tunneling server.
   * If empty, k0smotron will use the default one.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecTunneling#serverNodePort
   */
  readonly serverNodePort?: number;

  /**
   * NodePort to publish for tunneling port.
   * If empty, k0smotron will use the default one.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecTunneling#tunnelingNodePort
   */
  readonly tunnelingNodePort?: number;
}

/**
 * Converts an object of type 'K0SControlPlaneSpecK0SConfigSpecTunneling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneSpecK0SConfigSpecTunneling(obj: K0SControlPlaneSpecK0SConfigSpecTunneling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'mode': obj.mode,
    'serverAddress': obj.serverAddress,
    'serverNodePort': obj.serverNodePort,
    'tunnelingNodePort': obj.tunnelingNodePort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InfrastructureRef is a required reference to a custom resource
 * offered by an infrastructure provider.
 *
 * @schema K0SControlPlaneSpecMachineTemplateInfrastructureRef
 */
export interface K0SControlPlaneSpecMachineTemplateInfrastructureRef {
  /**
   * API version of the referent.
   *
   * @schema K0SControlPlaneSpecMachineTemplateInfrastructureRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * If referring to a piece of an object instead of an entire object, this string
   * should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
   * For example, if the object reference is to a container within a pod, this would take on a value like:
   * "spec.containers{name}" (where "name" refers to the name of the container that triggered
   * the event) or if no container name is specified "spec.containers[2]" (container with
   * index 2 in this pod). This syntax is chosen only to have some well-defined way of
   * referencing a part of an object.
   * TODO: this design is not final and this field is subject to change in the future.
   *
   * @schema K0SControlPlaneSpecMachineTemplateInfrastructureRef#fieldPath
   */
  readonly fieldPath?: string;

  /**
   * Kind of the referent.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema K0SControlPlaneSpecMachineTemplateInfrastructureRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema K0SControlPlaneSpecMachineTemplateInfrastructureRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema K0SControlPlaneSpecMachineTemplateInfrastructureRef#namespace
   */
  readonly namespace?: string;

  /**
   * Specific resourceVersion to which this reference is made, if any.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   *
   * @schema K0SControlPlaneSpecMachineTemplateInfrastructureRef#resourceVersion
   */
  readonly resourceVersion?: string;

  /**
   * UID of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
   *
   * @schema K0SControlPlaneSpecMachineTemplateInfrastructureRef#uid
   */
  readonly uid?: string;
}

/**
 * Converts an object of type 'K0SControlPlaneSpecMachineTemplateInfrastructureRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneSpecMachineTemplateInfrastructureRef(obj: K0SControlPlaneSpecMachineTemplateInfrastructureRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'resourceVersion': obj.resourceVersion,
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Standard object's metadata.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
 *
 * @schema K0SControlPlaneSpecMachineTemplateMetadata
 */
export interface K0SControlPlaneSpecMachineTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema K0SControlPlaneSpecMachineTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema K0SControlPlaneSpecMachineTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SControlPlaneSpecMachineTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneSpecMachineTemplateMetadata(obj: K0SControlPlaneSpecMachineTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMapRef is a reference to a configmap that contains the content.
 *
 * @schema K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefConfigMapRef
 */
export interface K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefConfigMapRef {
  /**
   * Key is the key in the source that contains the content
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefConfigMapRef#key
   */
  readonly key: string;

  /**
   * Name is the name of the source
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefConfigMapRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefConfigMapRef(obj: K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef is a reference to a secret that contains the content.
 *
 * @schema K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefSecretRef
 */
export interface K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefSecretRef {
  /**
   * Key is the key in the source that contains the content
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefSecretRef#key
   */
  readonly key: string;

  /**
   * Name is the name of the source
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefSecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefSecretRef(obj: K0SControlPlaneSpecK0SConfigSpecCustomUserDataRefSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContentFrom specifies the source of the content.
 *
 * @schema K0SControlPlaneSpecK0SConfigSpecFilesContentFrom
 */
export interface K0SControlPlaneSpecK0SConfigSpecFilesContentFrom {
  /**
   * ConfigMapRef is a reference to a configmap that contains the content.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecFilesContentFrom#configMapRef
   */
  readonly configMapRef?: K0SControlPlaneSpecK0SConfigSpecFilesContentFromConfigMapRef;

  /**
   * SecretRef is a reference to a secret that contains the content.
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecFilesContentFrom#secretRef
   */
  readonly secretRef?: K0SControlPlaneSpecK0SConfigSpecFilesContentFromSecretRef;
}

/**
 * Converts an object of type 'K0SControlPlaneSpecK0SConfigSpecFilesContentFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneSpecK0SConfigSpecFilesContentFrom(obj: K0SControlPlaneSpecK0SConfigSpecFilesContentFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_K0SControlPlaneSpecK0SConfigSpecFilesContentFromConfigMapRef(obj.configMapRef),
    'secretRef': toJson_K0SControlPlaneSpecK0SConfigSpecFilesContentFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Mode describes tunneling mode.
 * If empty, k0smotron will use the default one.
 *
 * @schema K0SControlPlaneSpecK0SConfigSpecTunnelingMode
 */
export enum K0SControlPlaneSpecK0SConfigSpecTunnelingMode {
  /** tunnel */
  TUNNEL = "tunnel",
  /** proxy */
  PROXY = "proxy",
}

/**
 * ConfigMapRef is a reference to a configmap that contains the content.
 *
 * @schema K0SControlPlaneSpecK0SConfigSpecFilesContentFromConfigMapRef
 */
export interface K0SControlPlaneSpecK0SConfigSpecFilesContentFromConfigMapRef {
  /**
   * Key is the key in the source that contains the content
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecFilesContentFromConfigMapRef#key
   */
  readonly key: string;

  /**
   * Name is the name of the source
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecFilesContentFromConfigMapRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SControlPlaneSpecK0SConfigSpecFilesContentFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneSpecK0SConfigSpecFilesContentFromConfigMapRef(obj: K0SControlPlaneSpecK0SConfigSpecFilesContentFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef is a reference to a secret that contains the content.
 *
 * @schema K0SControlPlaneSpecK0SConfigSpecFilesContentFromSecretRef
 */
export interface K0SControlPlaneSpecK0SConfigSpecFilesContentFromSecretRef {
  /**
   * Key is the key in the source that contains the content
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecFilesContentFromSecretRef#key
   */
  readonly key: string;

  /**
   * Name is the name of the source
   *
   * @schema K0SControlPlaneSpecK0SConfigSpecFilesContentFromSecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SControlPlaneSpecK0SConfigSpecFilesContentFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneSpecK0SConfigSpecFilesContentFromSecretRef(obj: K0SControlPlaneSpecK0SConfigSpecFilesContentFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema K0sControlPlaneTemplate
 */
export class K0sControlPlaneTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "K0sControlPlaneTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'controlplane.cluster.x-k8s.io/v1beta1',
    kind: 'K0sControlPlaneTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "K0sControlPlaneTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: K0sControlPlaneTemplateProps = {}): any {
    return {
      ...K0sControlPlaneTemplate.GVK,
      ...toJson_K0sControlPlaneTemplateProps(props),
    };
  }

  /**
   * Defines a "K0sControlPlaneTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: K0sControlPlaneTemplateProps = {}) {
    super(scope, id, {
      ...K0sControlPlaneTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...K0sControlPlaneTemplate.GVK,
      ...toJson_K0sControlPlaneTemplateProps(resolved),
    };
  }
}

/**
 * @schema K0sControlPlaneTemplate
 */
export interface K0sControlPlaneTemplateProps {
  /**
   * @schema K0sControlPlaneTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema K0sControlPlaneTemplate#spec
   */
  readonly spec?: K0SControlPlaneTemplateSpec;
}

/**
 * Converts an object of type 'K0sControlPlaneTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0sControlPlaneTemplateProps(obj: K0sControlPlaneTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_K0SControlPlaneTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SControlPlaneTemplateSpec
 */
export interface K0SControlPlaneTemplateSpec {
  /**
   * @schema K0SControlPlaneTemplateSpec#template
   */
  readonly template?: K0SControlPlaneTemplateSpecTemplate;
}

/**
 * Converts an object of type 'K0SControlPlaneTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneTemplateSpec(obj: K0SControlPlaneTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'template': toJson_K0SControlPlaneTemplateSpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SControlPlaneTemplateSpecTemplate
 */
export interface K0SControlPlaneTemplateSpecTemplate {
  /**
   * @schema K0SControlPlaneTemplateSpecTemplate#metadata
   */
  readonly metadata?: K0SControlPlaneTemplateSpecTemplateMetadata;

  /**
   * @schema K0SControlPlaneTemplateSpecTemplate#spec
   */
  readonly spec?: K0SControlPlaneTemplateSpecTemplateSpec;
}

/**
 * Converts an object of type 'K0SControlPlaneTemplateSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneTemplateSpecTemplate(obj: K0SControlPlaneTemplateSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_K0SControlPlaneTemplateSpecTemplateMetadata(obj.metadata),
    'spec': toJson_K0SControlPlaneTemplateSpecTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SControlPlaneTemplateSpecTemplateMetadata
 */
export interface K0SControlPlaneTemplateSpecTemplateMetadata {
  /**
   * @schema K0SControlPlaneTemplateSpecTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema K0SControlPlaneTemplateSpecTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema K0SControlPlaneTemplateSpecTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema K0SControlPlaneTemplateSpecTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema K0SControlPlaneTemplateSpecTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SControlPlaneTemplateSpecTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneTemplateSpecTemplateMetadata(obj: K0SControlPlaneTemplateSpecTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SControlPlaneTemplateSpecTemplateSpec
 */
export interface K0SControlPlaneTemplateSpecTemplateSpec {
  /**
   * @schema K0SControlPlaneTemplateSpecTemplateSpec#k0sConfigSpec
   */
  readonly k0SConfigSpec: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec;

  /**
   * K0sControlPlaneTemplateMachineTemplate defines the template for Machines
   * in a K0sControlPlaneMachineTemplate object.
   * NOTE: K0sControlPlaneTemplateMachineTemplate is similar to K0sControlPlaneMachineTemplate but
   * omits ObjectMeta and InfrastructureRef fields. These fields do not make sense on the K0sControlPlaneTemplate,
   * because they are calculated by the Cluster topology reconciler during reconciliation and thus cannot
   * be configured on the K0sControlPlaneTemplate.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpec#machineTemplate
   */
  readonly machineTemplate?: K0SControlPlaneTemplateSpecTemplateSpecMachineTemplate;

  /**
   * UpdateStrategy defines the strategy to use when updating the control plane.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpec#updateStrategy
   */
  readonly updateStrategy?: K0SControlPlaneTemplateSpecTemplateSpecUpdateStrategy;

  /**
   * @schema K0SControlPlaneTemplateSpecTemplateSpec#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'K0SControlPlaneTemplateSpecTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneTemplateSpecTemplateSpec(obj: K0SControlPlaneTemplateSpecTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'k0sConfigSpec': toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec(obj.k0SConfigSpec),
    'machineTemplate': toJson_K0SControlPlaneTemplateSpecTemplateSpecMachineTemplate(obj.machineTemplate),
    'updateStrategy': obj.updateStrategy,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec
 */
export interface K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec {
  /**
   * Args specifies extra arguments to be passed to k0s controller.
   * See: https://docs.k0sproject.io/stable/cli/k0s_controller/
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec#args
   */
  readonly args?: string[];

  /**
   * CustomUserDataRef is a reference to a secret or a configmap that contains the custom user data.
   * Provided user-data will be merged with the one generated by k0smotron. Note that you may want to specify the merge type.
   * See: https://cloudinit.readthedocs.io/en/latest/reference/merging.html
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec#customUserDataRef
   */
  readonly customUserDataRef?: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRef;

  /**
   * DownloadURL specifies the URL from which to download the k0s binary.
   * If the version field is specified, it is ignored, and whatever version is downloaded from the URL is used.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec#downloadURL
   */
  readonly downloadUrl?: string;

  /**
   * Files specifies extra files to be passed to user_data upon creation.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec#files
   */
  readonly files?: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFiles[];

  /**
   * K0s defines the k0s configuration. Note, that some fields will be overwritten by k0smotron.
   * If empty, will be used default configuration. @see https://docs.k0sproject.io/stable/configuration/
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec#k0s
   */
  readonly k0S?: any;

  /**
   * PostStartCommands specifies commands to be run after starting k0s worker.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec#postStartCommands
   */
  readonly postStartCommands?: string[];

  /**
   * PreInstallK0s specifies whether k0s binary is pre-installed on the node.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec#preInstalledK0s
   */
  readonly preInstalledK0S?: boolean;

  /**
   * PreStartCommands specifies commands to be run before starting k0s worker.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec#preStartCommands
   */
  readonly preStartCommands?: string[];

  /**
   * Tunneling defines the tunneling configuration for the cluster.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec#tunneling
   */
  readonly tunneling?: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecTunneling;

  /**
   * UseSystemHostname specifies whether to use the system hostname for the kubernetes node name.
   * By default, k0smotron will use Machine name as a node name. If true, it will pick it from `hostname` command output.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec#useSystemHostname
   */
  readonly useSystemHostname?: boolean;
}

/**
 * Converts an object of type 'K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec(obj: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'customUserDataRef': toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRef(obj.customUserDataRef),
    'downloadURL': obj.downloadUrl,
    'files': obj.files?.map(y => toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFiles(y)),
    'k0s': obj.k0S,
    'postStartCommands': obj.postStartCommands?.map(y => y),
    'preInstalledK0s': obj.preInstalledK0S,
    'preStartCommands': obj.preStartCommands?.map(y => y),
    'tunneling': toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecTunneling(obj.tunneling),
    'useSystemHostname': obj.useSystemHostname,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * K0sControlPlaneTemplateMachineTemplate defines the template for Machines
 * in a K0sControlPlaneMachineTemplate object.
 * NOTE: K0sControlPlaneTemplateMachineTemplate is similar to K0sControlPlaneMachineTemplate but
 * omits ObjectMeta and InfrastructureRef fields. These fields do not make sense on the K0sControlPlaneTemplate,
 * because they are calculated by the Cluster topology reconciler during reconciliation and thus cannot
 * be configured on the K0sControlPlaneTemplate.
 *
 * @schema K0SControlPlaneTemplateSpecTemplateSpecMachineTemplate
 */
export interface K0SControlPlaneTemplateSpecTemplateSpecMachineTemplate {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecMachineTemplate#metadata
   */
  readonly metadata?: K0SControlPlaneTemplateSpecTemplateSpecMachineTemplateMetadata;

  /**
   * NodeDeletionTimeout defines how long the machine controller will attempt to delete the Node that the Machine
   * hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely.
   * If no value is provided, the default value for this property of the Machine resource will be used.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecMachineTemplate#nodeDeletionTimeout
   */
  readonly nodeDeletionTimeout?: string;

  /**
   * NodeDrainTimeout is the total amount of time that the controller will spend on draining a controlplane node
   * The default value is 0, meaning that the node can be drained without any time limitations.
   * NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecMachineTemplate#nodeDrainTimeout
   */
  readonly nodeDrainTimeout?: string;

  /**
   * NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes
   * to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecMachineTemplate#nodeVolumeDetachTimeout
   */
  readonly nodeVolumeDetachTimeout?: string;
}

/**
 * Converts an object of type 'K0SControlPlaneTemplateSpecTemplateSpecMachineTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneTemplateSpecTemplateSpecMachineTemplate(obj: K0SControlPlaneTemplateSpecTemplateSpecMachineTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_K0SControlPlaneTemplateSpecTemplateSpecMachineTemplateMetadata(obj.metadata),
    'nodeDeletionTimeout': obj.nodeDeletionTimeout,
    'nodeDrainTimeout': obj.nodeDrainTimeout,
    'nodeVolumeDetachTimeout': obj.nodeVolumeDetachTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UpdateStrategy defines the strategy to use when updating the control plane.
 *
 * @schema K0SControlPlaneTemplateSpecTemplateSpecUpdateStrategy
 */
export enum K0SControlPlaneTemplateSpecTemplateSpecUpdateStrategy {
  /** InPlace */
  IN_PLACE = "InPlace",
  /** Recreate */
  RECREATE = "Recreate",
}

/**
 * CustomUserDataRef is a reference to a secret or a configmap that contains the custom user data.
 * Provided user-data will be merged with the one generated by k0smotron. Note that you may want to specify the merge type.
 * See: https://cloudinit.readthedocs.io/en/latest/reference/merging.html
 *
 * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRef
 */
export interface K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRef {
  /**
   * ConfigMapRef is a reference to a configmap that contains the content.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRef#configMapRef
   */
  readonly configMapRef?: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefConfigMapRef;

  /**
   * SecretRef is a reference to a secret that contains the content.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRef#secretRef
   */
  readonly secretRef?: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefSecretRef;
}

/**
 * Converts an object of type 'K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRef(obj: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefConfigMapRef(obj.configMapRef),
    'secretRef': toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * File defines a file to be passed to user_data upon creation.
 *
 * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFiles
 */
export interface K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFiles {
  /**
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFiles#content
   */
  readonly content?: string;

  /**
   * ContentFrom specifies the source of the content.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFiles#contentFrom
   */
  readonly contentFrom?: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFrom;

  /**
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFiles#path
   */
  readonly path?: string;

  /**
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFiles#permissions
   */
  readonly permissions?: string;
}

/**
 * Converts an object of type 'K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFiles' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFiles(obj: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFiles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'contentFrom': toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFrom(obj.contentFrom),
    'path': obj.path,
    'permissions': obj.permissions,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Tunneling defines the tunneling configuration for the cluster.
 *
 * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecTunneling
 */
export interface K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecTunneling {
  /**
   * Enabled specifies whether tunneling is enabled.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecTunneling#enabled
   */
  readonly enabled?: boolean;

  /**
   * Mode describes tunneling mode.
   * If empty, k0smotron will use the default one.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecTunneling#mode
   */
  readonly mode?: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecTunnelingMode;

  /**
   * Server address of the tunneling server.
   * If empty, k0smotron will try to detect worker node address for.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecTunneling#serverAddress
   */
  readonly serverAddress?: string;

  /**
   * NodePort to publish for server port of the tunneling server.
   * If empty, k0smotron will use the default one.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecTunneling#serverNodePort
   */
  readonly serverNodePort?: number;

  /**
   * NodePort to publish for tunneling port.
   * If empty, k0smotron will use the default one.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecTunneling#tunnelingNodePort
   */
  readonly tunnelingNodePort?: number;
}

/**
 * Converts an object of type 'K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecTunneling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecTunneling(obj: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecTunneling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'mode': obj.mode,
    'serverAddress': obj.serverAddress,
    'serverNodePort': obj.serverNodePort,
    'tunnelingNodePort': obj.tunnelingNodePort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Standard object's metadata.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
 *
 * @schema K0SControlPlaneTemplateSpecTemplateSpecMachineTemplateMetadata
 */
export interface K0SControlPlaneTemplateSpecTemplateSpecMachineTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecMachineTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecMachineTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SControlPlaneTemplateSpecTemplateSpecMachineTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneTemplateSpecTemplateSpecMachineTemplateMetadata(obj: K0SControlPlaneTemplateSpecTemplateSpecMachineTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMapRef is a reference to a configmap that contains the content.
 *
 * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefConfigMapRef
 */
export interface K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefConfigMapRef {
  /**
   * Key is the key in the source that contains the content
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefConfigMapRef#key
   */
  readonly key: string;

  /**
   * Name is the name of the source
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefConfigMapRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefConfigMapRef(obj: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef is a reference to a secret that contains the content.
 *
 * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefSecretRef
 */
export interface K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefSecretRef {
  /**
   * Key is the key in the source that contains the content
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefSecretRef#key
   */
  readonly key: string;

  /**
   * Name is the name of the source
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefSecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefSecretRef(obj: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecCustomUserDataRefSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContentFrom specifies the source of the content.
 *
 * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFrom
 */
export interface K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFrom {
  /**
   * ConfigMapRef is a reference to a configmap that contains the content.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFrom#configMapRef
   */
  readonly configMapRef?: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromConfigMapRef;

  /**
   * SecretRef is a reference to a secret that contains the content.
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFrom#secretRef
   */
  readonly secretRef?: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromSecretRef;
}

/**
 * Converts an object of type 'K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFrom(obj: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromConfigMapRef(obj.configMapRef),
    'secretRef': toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Mode describes tunneling mode.
 * If empty, k0smotron will use the default one.
 *
 * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecTunnelingMode
 */
export enum K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecTunnelingMode {
  /** tunnel */
  TUNNEL = "tunnel",
  /** proxy */
  PROXY = "proxy",
}

/**
 * ConfigMapRef is a reference to a configmap that contains the content.
 *
 * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromConfigMapRef
 */
export interface K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromConfigMapRef {
  /**
   * Key is the key in the source that contains the content
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromConfigMapRef#key
   */
  readonly key: string;

  /**
   * Name is the name of the source
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromConfigMapRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromConfigMapRef(obj: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef is a reference to a secret that contains the content.
 *
 * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromSecretRef
 */
export interface K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromSecretRef {
  /**
   * Key is the key in the source that contains the content
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromSecretRef#key
   */
  readonly key: string;

  /**
   * Name is the name of the source
   *
   * @schema K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromSecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromSecretRef(obj: K0SControlPlaneTemplateSpecTemplateSpecK0SConfigSpecFilesContentFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema K0smotronControlPlane
 */
export class K0smotronControlPlane extends ApiObject {
  /**
   * Returns the apiVersion and kind for "K0smotronControlPlane"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'controlplane.cluster.x-k8s.io/v1beta1',
    kind: 'K0smotronControlPlane',
  }

  /**
   * Renders a Kubernetes manifest for "K0smotronControlPlane".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: K0smotronControlPlaneProps = {}): any {
    return {
      ...K0smotronControlPlane.GVK,
      ...toJson_K0smotronControlPlaneProps(props),
    };
  }

  /**
   * Defines a "K0smotronControlPlane" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: K0smotronControlPlaneProps = {}) {
    super(scope, id, {
      ...K0smotronControlPlane.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...K0smotronControlPlane.GVK,
      ...toJson_K0smotronControlPlaneProps(resolved),
    };
  }
}

/**
 * @schema K0smotronControlPlane
 */
export interface K0smotronControlPlaneProps {
  /**
   * @schema K0smotronControlPlane#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of K0smotronCluster
   *
   * @schema K0smotronControlPlane#spec
   */
  readonly spec?: K0SmotronControlPlaneSpec;
}

/**
 * Converts an object of type 'K0smotronControlPlaneProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0smotronControlPlaneProps(obj: K0smotronControlPlaneProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_K0SmotronControlPlaneSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterSpec defines the desired state of K0smotronCluster
 *
 * @schema K0SmotronControlPlaneSpec
 */
export interface K0SmotronControlPlaneSpec {
  /**
   * CertificateRefs defines the certificate references.
   *
   * @schema K0SmotronControlPlaneSpec#certificateRefs
   */
  readonly certificateRefs?: K0SmotronControlPlaneSpecCertificateRefs[];

  /**
   * ControlPlaneFlags allows to configure additional flags for k0s
   * control plane and to override existing ones. The default flags are
   * kept unless they are overriden explicitly. Flags with arguments must
   * be specified as a single string, e.g. --some-flag=argument
   *
   * @schema K0SmotronControlPlaneSpec#controllerPlaneFlags
   */
  readonly controllerPlaneFlags?: string[];

  /**
   * Etcd defines the etcd configuration.
   *
   * @schema K0SmotronControlPlaneSpec#etcd
   */
  readonly etcd?: K0SmotronControlPlaneSpecEtcd;

  /**
   * ExternalAddress defines k0s external address. See https://docs.k0sproject.io/stable/configuration/#specapi
   * Will be detected automatically for service type LoadBalancer.
   *
   * @schema K0SmotronControlPlaneSpec#externalAddress
   */
  readonly externalAddress?: string;

  /**
   * Image defines the k0s image to be deployed. If empty k0smotron
   * will pick it automatically. Must not include the image tag.
   *
   * @schema K0SmotronControlPlaneSpec#image
   */
  readonly image?: string;

  /**
   * k0sConfig defines the k0s configuration. Note, that some fields will be overwritten by k0smotron.
   * If empty, will be used default configuration. @see https://docs.k0sproject.io/stable/configuration/
   *
   * @schema K0SmotronControlPlaneSpec#k0sConfig
   */
  readonly k0SConfig?: any;

  /**
   * KineDataSourceSecretName defines the name of kine datasource URL secret.
   *
   * @schema K0SmotronControlPlaneSpec#kineDataSourceSecretName
   */
  readonly kineDataSourceSecretName?: string;

  /**
   * KineDataSourceURL defines the kine datasource URL.
   *
   * @schema K0SmotronControlPlaneSpec#kineDataSourceURL
   */
  readonly kineDataSourceUrl?: string;

  /**
   * KubeconfigRef is the reference to the kubeconfig of the hosting cluster.
   * This kubeconfig will be used to deploy the k0s control plane.
   *
   * @schema K0SmotronControlPlaneSpec#kubeconfigRef
   */
  readonly kubeconfigRef?: K0SmotronControlPlaneSpecKubeconfigRef;

  /**
   * Manifests allows to specify list of volumes with manifests to be
   * deployed in the cluster. The volumes will be mounted
   * in /var/lib/k0s/manifests/<manifests.name>, for this reason each
   * manifest is a stack. K0smotron allows any kind of volume, but the
   * recommendation is to use secrets and configmaps.
   * For more information check:
   * https://docs.k0sproject.io/stable/manifests/ and
   * https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema K0SmotronControlPlaneSpec#manifests
   */
  readonly manifests?: K0SmotronControlPlaneSpecManifests[];

  /**
   * Monitoring defines the monitoring configuration.
   *
   * @schema K0SmotronControlPlaneSpec#monitoring
   */
  readonly monitoring?: K0SmotronControlPlaneSpecMonitoring;

  /**
   * Mounts allows to specify list of volumes with any files to be
   * mounted in the controlplane pod. K0smotron allows any kind of volume, but the
   * recommendation is to use secrets and configmaps.
   * For more information check:
   * https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema K0SmotronControlPlaneSpec#mounts
   */
  readonly mounts?: K0SmotronControlPlaneSpecMounts[];

  /**
   * Persistence defines the persistence configuration. If empty k0smotron
   * will use emptyDir as a volume. See https://docs.k0smotron.io/stable/configuration/#persistence
   *
   * @schema K0SmotronControlPlaneSpec#persistence
   */
  readonly persistence?: K0SmotronControlPlaneSpecPersistence;

  /**
   * Replicas is the desired number of replicas of the k0s control planes.
   * If unspecified, defaults to 1. If the value is above 1, k0smotron requires kine datasource URL to be set.
   * Recommended value is 3.
   *
   * @schema K0SmotronControlPlaneSpec#replicas
   */
  readonly replicas?: number;

  /**
   * Resources describes the compute resource requirements for the control plane pods.
   *
   * @schema K0SmotronControlPlaneSpec#resources
   */
  readonly resources?: K0SmotronControlPlaneSpecResources;

  /**
   * Service defines the service configuration.
   *
   * @schema K0SmotronControlPlaneSpec#service
   */
  readonly service?: K0SmotronControlPlaneSpecService;

  /**
   * ServiceAccount defines the service account to be used by both k0s and etcd StatefulSets.
   *
   * @schema K0SmotronControlPlaneSpec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * TopologySpreadConstraints will be passed directly to BOTH etcd and k0s pods.
   * See https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/ for more information.
   *
   * @schema K0SmotronControlPlaneSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: K0SmotronControlPlaneSpecTopologySpreadConstraints[];

  /**
   * Version defines the k0s version to be deployed. If empty k0smotron
   * will pick it automatically.
   *
   * @schema K0SmotronControlPlaneSpec#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpec(obj: K0SmotronControlPlaneSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateRefs': obj.certificateRefs?.map(y => toJson_K0SmotronControlPlaneSpecCertificateRefs(y)),
    'controllerPlaneFlags': obj.controllerPlaneFlags?.map(y => y),
    'etcd': toJson_K0SmotronControlPlaneSpecEtcd(obj.etcd),
    'externalAddress': obj.externalAddress,
    'image': obj.image,
    'k0sConfig': obj.k0SConfig,
    'kineDataSourceSecretName': obj.kineDataSourceSecretName,
    'kineDataSourceURL': obj.kineDataSourceUrl,
    'kubeconfigRef': toJson_K0SmotronControlPlaneSpecKubeconfigRef(obj.kubeconfigRef),
    'manifests': obj.manifests?.map(y => toJson_K0SmotronControlPlaneSpecManifests(y)),
    'monitoring': toJson_K0SmotronControlPlaneSpecMonitoring(obj.monitoring),
    'mounts': obj.mounts?.map(y => toJson_K0SmotronControlPlaneSpecMounts(y)),
    'persistence': toJson_K0SmotronControlPlaneSpecPersistence(obj.persistence),
    'replicas': obj.replicas,
    'resources': toJson_K0SmotronControlPlaneSpecResources(obj.resources),
    'service': toJson_K0SmotronControlPlaneSpecService(obj.service),
    'serviceAccount': obj.serviceAccount,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_K0SmotronControlPlaneSpecTopologySpreadConstraints(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneSpecCertificateRefs
 */
export interface K0SmotronControlPlaneSpecCertificateRefs {
  /**
   * @schema K0SmotronControlPlaneSpecCertificateRefs#name
   */
  readonly name?: string;

  /**
   * @schema K0SmotronControlPlaneSpecCertificateRefs#type
   */
  readonly type: K0SmotronControlPlaneSpecCertificateRefsType;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecCertificateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecCertificateRefs(obj: K0SmotronControlPlaneSpecCertificateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Etcd defines the etcd configuration.
 *
 * @schema K0SmotronControlPlaneSpecEtcd
 */
export interface K0SmotronControlPlaneSpecEtcd {
  /**
   * Args defines the etcd arguments.
   *
   * @schema K0SmotronControlPlaneSpecEtcd#args
   */
  readonly args?: string[];

  /**
   * AutoDeletePVCs defines whether the PVC should be deleted when the etcd cluster is deleted.
   *
   * @schema K0SmotronControlPlaneSpecEtcd#autoDeletePVCs
   */
  readonly autoDeletePvCs?: boolean;

  /**
   * DefragJob defines the etcd defragmentation job configuration.
   *
   * @schema K0SmotronControlPlaneSpecEtcd#defragJob
   */
  readonly defragJob?: K0SmotronControlPlaneSpecEtcdDefragJob;

  /**
   * Image defines the etcd image to be deployed.
   *
   * @schema K0SmotronControlPlaneSpecEtcd#image
   */
  readonly image: string;

  /**
   * Persistence defines the persistence configuration.
   *
   * @schema K0SmotronControlPlaneSpecEtcd#persistence
   */
  readonly persistence?: K0SmotronControlPlaneSpecEtcdPersistence;

  /**
   * Resources defines the compute resource requirements for the etcd container.
   *
   * @schema K0SmotronControlPlaneSpecEtcd#resources
   */
  readonly resources?: K0SmotronControlPlaneSpecEtcdResources;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecEtcd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecEtcd(obj: K0SmotronControlPlaneSpecEtcd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'autoDeletePVCs': obj.autoDeletePvCs,
    'defragJob': toJson_K0SmotronControlPlaneSpecEtcdDefragJob(obj.defragJob),
    'image': obj.image,
    'persistence': toJson_K0SmotronControlPlaneSpecEtcdPersistence(obj.persistence),
    'resources': toJson_K0SmotronControlPlaneSpecEtcdResources(obj.resources),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KubeconfigRef is the reference to the kubeconfig of the hosting cluster.
 * This kubeconfig will be used to deploy the k0s control plane.
 *
 * @schema K0SmotronControlPlaneSpecKubeconfigRef
 */
export interface K0SmotronControlPlaneSpecKubeconfigRef {
  /**
   * Key is the key in the secret containing the kubeconfig of the hosting cluster.
   *
   * @schema K0SmotronControlPlaneSpecKubeconfigRef#key
   */
  readonly key?: string;

  /**
   * Name is the name of the secret containing the kubeconfig of the hosting cluster.
   *
   * @schema K0SmotronControlPlaneSpecKubeconfigRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the secret containing the kubeconfig of the hosting cluster.
   *
   * @schema K0SmotronControlPlaneSpecKubeconfigRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecKubeconfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecKubeconfigRef(obj: K0SmotronControlPlaneSpecKubeconfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema K0SmotronControlPlaneSpecManifests
 */
export interface K0SmotronControlPlaneSpecManifests {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema K0SmotronControlPlaneSpecManifests#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: K0SmotronControlPlaneSpecManifestsAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema K0SmotronControlPlaneSpecManifests#azureDisk
   */
  readonly azureDisk?: K0SmotronControlPlaneSpecManifestsAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema K0SmotronControlPlaneSpecManifests#azureFile
   */
  readonly azureFile?: K0SmotronControlPlaneSpecManifestsAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema K0SmotronControlPlaneSpecManifests#cephfs
   */
  readonly cephfs?: K0SmotronControlPlaneSpecManifestsCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneSpecManifests#cinder
   */
  readonly cinder?: K0SmotronControlPlaneSpecManifestsCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema K0SmotronControlPlaneSpecManifests#configMap
   */
  readonly configMap?: K0SmotronControlPlaneSpecManifestsConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema K0SmotronControlPlaneSpecManifests#csi
   */
  readonly csi?: K0SmotronControlPlaneSpecManifestsCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema K0SmotronControlPlaneSpecManifests#downwardAPI
   */
  readonly downwardApi?: K0SmotronControlPlaneSpecManifestsDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema K0SmotronControlPlaneSpecManifests#emptyDir
   */
  readonly emptyDir?: K0SmotronControlPlaneSpecManifestsEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema K0SmotronControlPlaneSpecManifests#ephemeral
   */
  readonly ephemeral?: K0SmotronControlPlaneSpecManifestsEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema K0SmotronControlPlaneSpecManifests#fc
   */
  readonly fc?: K0SmotronControlPlaneSpecManifestsFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   *
   * @schema K0SmotronControlPlaneSpecManifests#flexVolume
   */
  readonly flexVolume?: K0SmotronControlPlaneSpecManifestsFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema K0SmotronControlPlaneSpecManifests#flocker
   */
  readonly flocker?: K0SmotronControlPlaneSpecManifestsFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema K0SmotronControlPlaneSpecManifests#gcePersistentDisk
   */
  readonly gcePersistentDisk?: K0SmotronControlPlaneSpecManifestsGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema K0SmotronControlPlaneSpecManifests#gitRepo
   */
  readonly gitRepo?: K0SmotronControlPlaneSpecManifestsGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema K0SmotronControlPlaneSpecManifests#glusterfs
   */
  readonly glusterfs?: K0SmotronControlPlaneSpecManifestsGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * ---
   * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
   * mount host directories as read/write.
   *
   * @schema K0SmotronControlPlaneSpecManifests#hostPath
   */
  readonly hostPath?: K0SmotronControlPlaneSpecManifestsHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema K0SmotronControlPlaneSpecManifests#iscsi
   */
  readonly iscsi?: K0SmotronControlPlaneSpecManifestsIscsi;

  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema K0SmotronControlPlaneSpecManifests#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema K0SmotronControlPlaneSpecManifests#nfs
   */
  readonly nfs?: K0SmotronControlPlaneSpecManifestsNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema K0SmotronControlPlaneSpecManifests#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: K0SmotronControlPlaneSpecManifestsPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema K0SmotronControlPlaneSpecManifests#photonPersistentDisk
   */
  readonly photonPersistentDisk?: K0SmotronControlPlaneSpecManifestsPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema K0SmotronControlPlaneSpecManifests#portworxVolume
   */
  readonly portworxVolume?: K0SmotronControlPlaneSpecManifestsPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema K0SmotronControlPlaneSpecManifests#projected
   */
  readonly projected?: K0SmotronControlPlaneSpecManifestsProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema K0SmotronControlPlaneSpecManifests#quobyte
   */
  readonly quobyte?: K0SmotronControlPlaneSpecManifestsQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema K0SmotronControlPlaneSpecManifests#rbd
   */
  readonly rbd?: K0SmotronControlPlaneSpecManifestsRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema K0SmotronControlPlaneSpecManifests#scaleIO
   */
  readonly scaleIo?: K0SmotronControlPlaneSpecManifestsScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema K0SmotronControlPlaneSpecManifests#secret
   */
  readonly secret?: K0SmotronControlPlaneSpecManifestsSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema K0SmotronControlPlaneSpecManifests#storageos
   */
  readonly storageos?: K0SmotronControlPlaneSpecManifestsStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema K0SmotronControlPlaneSpecManifests#vsphereVolume
   */
  readonly vsphereVolume?: K0SmotronControlPlaneSpecManifestsVsphereVolume;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifests' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifests(obj: K0SmotronControlPlaneSpecManifests | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_K0SmotronControlPlaneSpecManifestsAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_K0SmotronControlPlaneSpecManifestsAzureDisk(obj.azureDisk),
    'azureFile': toJson_K0SmotronControlPlaneSpecManifestsAzureFile(obj.azureFile),
    'cephfs': toJson_K0SmotronControlPlaneSpecManifestsCephfs(obj.cephfs),
    'cinder': toJson_K0SmotronControlPlaneSpecManifestsCinder(obj.cinder),
    'configMap': toJson_K0SmotronControlPlaneSpecManifestsConfigMap(obj.configMap),
    'csi': toJson_K0SmotronControlPlaneSpecManifestsCsi(obj.csi),
    'downwardAPI': toJson_K0SmotronControlPlaneSpecManifestsDownwardApi(obj.downwardApi),
    'emptyDir': toJson_K0SmotronControlPlaneSpecManifestsEmptyDir(obj.emptyDir),
    'ephemeral': toJson_K0SmotronControlPlaneSpecManifestsEphemeral(obj.ephemeral),
    'fc': toJson_K0SmotronControlPlaneSpecManifestsFc(obj.fc),
    'flexVolume': toJson_K0SmotronControlPlaneSpecManifestsFlexVolume(obj.flexVolume),
    'flocker': toJson_K0SmotronControlPlaneSpecManifestsFlocker(obj.flocker),
    'gcePersistentDisk': toJson_K0SmotronControlPlaneSpecManifestsGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_K0SmotronControlPlaneSpecManifestsGitRepo(obj.gitRepo),
    'glusterfs': toJson_K0SmotronControlPlaneSpecManifestsGlusterfs(obj.glusterfs),
    'hostPath': toJson_K0SmotronControlPlaneSpecManifestsHostPath(obj.hostPath),
    'iscsi': toJson_K0SmotronControlPlaneSpecManifestsIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_K0SmotronControlPlaneSpecManifestsNfs(obj.nfs),
    'persistentVolumeClaim': toJson_K0SmotronControlPlaneSpecManifestsPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_K0SmotronControlPlaneSpecManifestsPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_K0SmotronControlPlaneSpecManifestsPortworxVolume(obj.portworxVolume),
    'projected': toJson_K0SmotronControlPlaneSpecManifestsProjected(obj.projected),
    'quobyte': toJson_K0SmotronControlPlaneSpecManifestsQuobyte(obj.quobyte),
    'rbd': toJson_K0SmotronControlPlaneSpecManifestsRbd(obj.rbd),
    'scaleIO': toJson_K0SmotronControlPlaneSpecManifestsScaleIo(obj.scaleIo),
    'secret': toJson_K0SmotronControlPlaneSpecManifestsSecret(obj.secret),
    'storageos': toJson_K0SmotronControlPlaneSpecManifestsStorageos(obj.storageos),
    'vsphereVolume': toJson_K0SmotronControlPlaneSpecManifestsVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Monitoring defines the monitoring configuration.
 *
 * @schema K0SmotronControlPlaneSpecMonitoring
 */
export interface K0SmotronControlPlaneSpecMonitoring {
  /**
   * Enabled enables prometheus sidecar that scrapes metrics from the child cluster system components and expose
   * them as usual kubernetes pod metrics.
   *
   * @schema K0SmotronControlPlaneSpecMonitoring#enabled
   */
  readonly enabled: boolean;

  /**
   * PrometheusImage defines the image used for the prometheus sidecar.
   *
   * @schema K0SmotronControlPlaneSpecMonitoring#prometheusImage
   */
  readonly prometheusImage: string;

  /**
   * ProxyImage defines the image used for the nginx proxy sidecar.
   *
   * @schema K0SmotronControlPlaneSpecMonitoring#proxyImage
   */
  readonly proxyImage: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMonitoring' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMonitoring(obj: K0SmotronControlPlaneSpecMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'prometheusImage': obj.prometheusImage,
    'proxyImage': obj.proxyImage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneSpecMounts
 */
export interface K0SmotronControlPlaneSpecMounts {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema K0SmotronControlPlaneSpecMounts#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: K0SmotronControlPlaneSpecMountsAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema K0SmotronControlPlaneSpecMounts#azureDisk
   */
  readonly azureDisk?: K0SmotronControlPlaneSpecMountsAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema K0SmotronControlPlaneSpecMounts#azureFile
   */
  readonly azureFile?: K0SmotronControlPlaneSpecMountsAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema K0SmotronControlPlaneSpecMounts#cephfs
   */
  readonly cephfs?: K0SmotronControlPlaneSpecMountsCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneSpecMounts#cinder
   */
  readonly cinder?: K0SmotronControlPlaneSpecMountsCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema K0SmotronControlPlaneSpecMounts#configMap
   */
  readonly configMap?: K0SmotronControlPlaneSpecMountsConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema K0SmotronControlPlaneSpecMounts#csi
   */
  readonly csi?: K0SmotronControlPlaneSpecMountsCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema K0SmotronControlPlaneSpecMounts#downwardAPI
   */
  readonly downwardApi?: K0SmotronControlPlaneSpecMountsDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema K0SmotronControlPlaneSpecMounts#emptyDir
   */
  readonly emptyDir?: K0SmotronControlPlaneSpecMountsEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema K0SmotronControlPlaneSpecMounts#ephemeral
   */
  readonly ephemeral?: K0SmotronControlPlaneSpecMountsEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema K0SmotronControlPlaneSpecMounts#fc
   */
  readonly fc?: K0SmotronControlPlaneSpecMountsFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   *
   * @schema K0SmotronControlPlaneSpecMounts#flexVolume
   */
  readonly flexVolume?: K0SmotronControlPlaneSpecMountsFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema K0SmotronControlPlaneSpecMounts#flocker
   */
  readonly flocker?: K0SmotronControlPlaneSpecMountsFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema K0SmotronControlPlaneSpecMounts#gcePersistentDisk
   */
  readonly gcePersistentDisk?: K0SmotronControlPlaneSpecMountsGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema K0SmotronControlPlaneSpecMounts#gitRepo
   */
  readonly gitRepo?: K0SmotronControlPlaneSpecMountsGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema K0SmotronControlPlaneSpecMounts#glusterfs
   */
  readonly glusterfs?: K0SmotronControlPlaneSpecMountsGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * ---
   * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
   * mount host directories as read/write.
   *
   * @schema K0SmotronControlPlaneSpecMounts#hostPath
   */
  readonly hostPath?: K0SmotronControlPlaneSpecMountsHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema K0SmotronControlPlaneSpecMounts#iscsi
   */
  readonly iscsi?: K0SmotronControlPlaneSpecMountsIscsi;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema K0SmotronControlPlaneSpecMounts#nfs
   */
  readonly nfs?: K0SmotronControlPlaneSpecMountsNfs;

  /**
   * @schema K0SmotronControlPlaneSpecMounts#path
   */
  readonly path: string;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema K0SmotronControlPlaneSpecMounts#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: K0SmotronControlPlaneSpecMountsPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema K0SmotronControlPlaneSpecMounts#photonPersistentDisk
   */
  readonly photonPersistentDisk?: K0SmotronControlPlaneSpecMountsPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema K0SmotronControlPlaneSpecMounts#portworxVolume
   */
  readonly portworxVolume?: K0SmotronControlPlaneSpecMountsPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema K0SmotronControlPlaneSpecMounts#projected
   */
  readonly projected?: K0SmotronControlPlaneSpecMountsProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema K0SmotronControlPlaneSpecMounts#quobyte
   */
  readonly quobyte?: K0SmotronControlPlaneSpecMountsQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema K0SmotronControlPlaneSpecMounts#rbd
   */
  readonly rbd?: K0SmotronControlPlaneSpecMountsRbd;

  /**
   * ReadOnly specifies whether the volume should be mounted as read-only. (default: false, except for ConfigMaps and Secrets)
   *
   * @schema K0SmotronControlPlaneSpecMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema K0SmotronControlPlaneSpecMounts#scaleIO
   */
  readonly scaleIo?: K0SmotronControlPlaneSpecMountsScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema K0SmotronControlPlaneSpecMounts#secret
   */
  readonly secret?: K0SmotronControlPlaneSpecMountsSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema K0SmotronControlPlaneSpecMounts#storageos
   */
  readonly storageos?: K0SmotronControlPlaneSpecMountsStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema K0SmotronControlPlaneSpecMounts#vsphereVolume
   */
  readonly vsphereVolume?: K0SmotronControlPlaneSpecMountsVsphereVolume;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMounts(obj: K0SmotronControlPlaneSpecMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_K0SmotronControlPlaneSpecMountsAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_K0SmotronControlPlaneSpecMountsAzureDisk(obj.azureDisk),
    'azureFile': toJson_K0SmotronControlPlaneSpecMountsAzureFile(obj.azureFile),
    'cephfs': toJson_K0SmotronControlPlaneSpecMountsCephfs(obj.cephfs),
    'cinder': toJson_K0SmotronControlPlaneSpecMountsCinder(obj.cinder),
    'configMap': toJson_K0SmotronControlPlaneSpecMountsConfigMap(obj.configMap),
    'csi': toJson_K0SmotronControlPlaneSpecMountsCsi(obj.csi),
    'downwardAPI': toJson_K0SmotronControlPlaneSpecMountsDownwardApi(obj.downwardApi),
    'emptyDir': toJson_K0SmotronControlPlaneSpecMountsEmptyDir(obj.emptyDir),
    'ephemeral': toJson_K0SmotronControlPlaneSpecMountsEphemeral(obj.ephemeral),
    'fc': toJson_K0SmotronControlPlaneSpecMountsFc(obj.fc),
    'flexVolume': toJson_K0SmotronControlPlaneSpecMountsFlexVolume(obj.flexVolume),
    'flocker': toJson_K0SmotronControlPlaneSpecMountsFlocker(obj.flocker),
    'gcePersistentDisk': toJson_K0SmotronControlPlaneSpecMountsGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_K0SmotronControlPlaneSpecMountsGitRepo(obj.gitRepo),
    'glusterfs': toJson_K0SmotronControlPlaneSpecMountsGlusterfs(obj.glusterfs),
    'hostPath': toJson_K0SmotronControlPlaneSpecMountsHostPath(obj.hostPath),
    'iscsi': toJson_K0SmotronControlPlaneSpecMountsIscsi(obj.iscsi),
    'nfs': toJson_K0SmotronControlPlaneSpecMountsNfs(obj.nfs),
    'path': obj.path,
    'persistentVolumeClaim': toJson_K0SmotronControlPlaneSpecMountsPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_K0SmotronControlPlaneSpecMountsPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_K0SmotronControlPlaneSpecMountsPortworxVolume(obj.portworxVolume),
    'projected': toJson_K0SmotronControlPlaneSpecMountsProjected(obj.projected),
    'quobyte': toJson_K0SmotronControlPlaneSpecMountsQuobyte(obj.quobyte),
    'rbd': toJson_K0SmotronControlPlaneSpecMountsRbd(obj.rbd),
    'readOnly': obj.readOnly,
    'scaleIO': toJson_K0SmotronControlPlaneSpecMountsScaleIo(obj.scaleIo),
    'secret': toJson_K0SmotronControlPlaneSpecMountsSecret(obj.secret),
    'storageos': toJson_K0SmotronControlPlaneSpecMountsStorageos(obj.storageos),
    'vsphereVolume': toJson_K0SmotronControlPlaneSpecMountsVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Persistence defines the persistence configuration. If empty k0smotron
 * will use emptyDir as a volume. See https://docs.k0smotron.io/stable/configuration/#persistence
 *
 * @schema K0SmotronControlPlaneSpecPersistence
 */
export interface K0SmotronControlPlaneSpecPersistence {
  /**
   * AutoDeletePVCs defines whether the PVC should be deleted when the cluster is deleted.
   *
   * @schema K0SmotronControlPlaneSpecPersistence#autoDeletePVCs
   */
  readonly autoDeletePvCs?: boolean;

  /**
   * HostPath defines the host path configuration. Will be used as is in case of .spec.persistence.type is hostPath.
   *
   * @schema K0SmotronControlPlaneSpecPersistence#hostPath
   */
  readonly hostPath?: string;

  /**
   * PersistentVolumeClaim defines the PVC configuration. Will be used as is in case of .spec.persistence.type is pvc.
   *
   * @schema K0SmotronControlPlaneSpecPersistence#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaim;

  /**
   * @schema K0SmotronControlPlaneSpecPersistence#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecPersistence' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecPersistence(obj: K0SmotronControlPlaneSpecPersistence | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoDeletePVCs': obj.autoDeletePvCs,
    'hostPath': obj.hostPath,
    'persistentVolumeClaim': toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaim(obj.persistentVolumeClaim),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources describes the compute resource requirements for the control plane pods.
 *
 * @schema K0SmotronControlPlaneSpecResources
 */
export interface K0SmotronControlPlaneSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema K0SmotronControlPlaneSpecResources#claims
   */
  readonly claims?: K0SmotronControlPlaneSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneSpecResources#limits
   */
  readonly limits?: { [key: string]: K0SmotronControlPlaneSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneSpecResources#requests
   */
  readonly requests?: { [key: string]: K0SmotronControlPlaneSpecResourcesRequests };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecResources(obj: K0SmotronControlPlaneSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_K0SmotronControlPlaneSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service defines the service configuration.
 *
 * @schema K0SmotronControlPlaneSpecService
 */
export interface K0SmotronControlPlaneSpecService {
  /**
   * Annotations defines extra annotations to be added to the service.
   *
   * @schema K0SmotronControlPlaneSpecService#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * APIPort defines the kubernetes API port. If empty k0smotron
   * will pick it automatically.
   *
   * @schema K0SmotronControlPlaneSpecService#apiPort
   */
  readonly apiPort?: number;

  /**
   * KonnectivityPort defines the konnectivity port. If empty k0smotron
   * will pick it automatically.
   *
   * @schema K0SmotronControlPlaneSpecService#konnectivityPort
   */
  readonly konnectivityPort?: number;

  /**
   * Labels defines extra labels to be added to the service.
   *
   * @schema K0SmotronControlPlaneSpecService#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * LoadBalancerClass defines the load balancer class to be used for the service. Used only when service type is LoadBalancer.
   *
   * @schema K0SmotronControlPlaneSpecService#loadBalancerClass
   */
  readonly loadBalancerClass?: string;

  /**
   * Service Type string describes ingress methods for a service
   *
   * @schema K0SmotronControlPlaneSpecService#type
   */
  readonly type: K0SmotronControlPlaneSpecServiceType;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecService' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecService(obj: K0SmotronControlPlaneSpecService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'apiPort': obj.apiPort,
    'konnectivityPort': obj.konnectivityPort,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'loadBalancerClass': obj.loadBalancerClass,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema K0SmotronControlPlaneSpecTopologySpreadConstraints
 */
export interface K0SmotronControlPlaneSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema K0SmotronControlPlaneSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema K0SmotronControlPlaneSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema K0SmotronControlPlaneSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   * @schema K0SmotronControlPlaneSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema K0SmotronControlPlaneSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema K0SmotronControlPlaneSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema K0SmotronControlPlaneSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema K0SmotronControlPlaneSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecTopologySpreadConstraints(obj: K0SmotronControlPlaneSpecTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneSpecCertificateRefsType
 */
export enum K0SmotronControlPlaneSpecCertificateRefsType {
  /** ca */
  CA = "ca",
  /** sa */
  SA = "sa",
  /** proxy */
  PROXY = "proxy",
  /** etcd */
  ETCD = "etcd",
  /** apiserver-etcd-client */
  APISERVER_HYPHEN_ETCD_HYPHEN_CLIENT = "apiserver-etcd-client",
  /** etcd-peer */
  ETCD_HYPHEN_PEER = "etcd-peer",
  /** etcd-server */
  ETCD_HYPHEN_SERVER = "etcd-server",
}

/**
 * DefragJob defines the etcd defragmentation job configuration.
 *
 * @schema K0SmotronControlPlaneSpecEtcdDefragJob
 */
export interface K0SmotronControlPlaneSpecEtcdDefragJob {
  /**
   * Enabled enables the etcd defragmentation job.
   *
   * @schema K0SmotronControlPlaneSpecEtcdDefragJob#enabled
   */
  readonly enabled: boolean;

  /**
   * Image defines the etcd defragmentation job image.
   *
   * @schema K0SmotronControlPlaneSpecEtcdDefragJob#image
   */
  readonly image: string;

  /**
   * Rule defines the etcd defragmentation job defrag-rule.
   * For more information check: https://github.com/ahrtr/etcd-defrag/tree/main?tab=readme-ov-file#defragmentation-rule
   *
   * @schema K0SmotronControlPlaneSpecEtcdDefragJob#rule
   */
  readonly rule: string;

  /**
   * Schedule defines the etcd defragmentation job schedule.
   *
   * @schema K0SmotronControlPlaneSpecEtcdDefragJob#schedule
   */
  readonly schedule: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecEtcdDefragJob' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecEtcdDefragJob(obj: K0SmotronControlPlaneSpecEtcdDefragJob | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'image': obj.image,
    'rule': obj.rule,
    'schedule': obj.schedule,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Persistence defines the persistence configuration.
 *
 * @schema K0SmotronControlPlaneSpecEtcdPersistence
 */
export interface K0SmotronControlPlaneSpecEtcdPersistence {
  /**
   * Size defines the size of the etcd volume. Default: 1Gi
   *
   * @schema K0SmotronControlPlaneSpecEtcdPersistence#size
   */
  readonly size?: K0SmotronControlPlaneSpecEtcdPersistenceSize;

  /**
   * StorageClass defines the storage class to be used for etcd persistence. If empty, will be used the default storage class.
   *
   * @schema K0SmotronControlPlaneSpecEtcdPersistence#storageClass
   */
  readonly storageClass?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecEtcdPersistence' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecEtcdPersistence(obj: K0SmotronControlPlaneSpecEtcdPersistence | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'size': obj.size?.value,
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources defines the compute resource requirements for the etcd container.
 *
 * @schema K0SmotronControlPlaneSpecEtcdResources
 */
export interface K0SmotronControlPlaneSpecEtcdResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema K0SmotronControlPlaneSpecEtcdResources#claims
   */
  readonly claims?: K0SmotronControlPlaneSpecEtcdResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneSpecEtcdResources#limits
   */
  readonly limits?: { [key: string]: K0SmotronControlPlaneSpecEtcdResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneSpecEtcdResources#requests
   */
  readonly requests?: { [key: string]: K0SmotronControlPlaneSpecEtcdResourcesRequests };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecEtcdResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecEtcdResources(obj: K0SmotronControlPlaneSpecEtcdResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_K0SmotronControlPlaneSpecEtcdResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema K0SmotronControlPlaneSpecManifestsAwsElasticBlockStore
 */
export interface K0SmotronControlPlaneSpecManifestsAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneSpecManifestsAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema K0SmotronControlPlaneSpecManifestsAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema K0SmotronControlPlaneSpecManifestsAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema K0SmotronControlPlaneSpecManifestsAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsAwsElasticBlockStore(obj: K0SmotronControlPlaneSpecManifestsAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema K0SmotronControlPlaneSpecManifestsAzureDisk
 */
export interface K0SmotronControlPlaneSpecManifestsAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema K0SmotronControlPlaneSpecManifestsAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema K0SmotronControlPlaneSpecManifestsAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema K0SmotronControlPlaneSpecManifestsAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneSpecManifestsAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema K0SmotronControlPlaneSpecManifestsAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneSpecManifestsAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsAzureDisk(obj: K0SmotronControlPlaneSpecManifestsAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema K0SmotronControlPlaneSpecManifestsAzureFile
 */
export interface K0SmotronControlPlaneSpecManifestsAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneSpecManifestsAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema K0SmotronControlPlaneSpecManifestsAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema K0SmotronControlPlaneSpecManifestsAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsAzureFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsAzureFile(obj: K0SmotronControlPlaneSpecManifestsAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema K0SmotronControlPlaneSpecManifestsCephfs
 */
export interface K0SmotronControlPlaneSpecManifestsCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneSpecManifestsCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema K0SmotronControlPlaneSpecManifestsCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneSpecManifestsCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneSpecManifestsCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneSpecManifestsCephfs#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneSpecManifestsCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneSpecManifestsCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsCephfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsCephfs(obj: K0SmotronControlPlaneSpecManifestsCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_K0SmotronControlPlaneSpecManifestsCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema K0SmotronControlPlaneSpecManifestsCinder
 */
export interface K0SmotronControlPlaneSpecManifestsCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneSpecManifestsCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneSpecManifestsCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema K0SmotronControlPlaneSpecManifestsCinder#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneSpecManifestsCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneSpecManifestsCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsCinder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsCinder(obj: K0SmotronControlPlaneSpecManifestsCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneSpecManifestsCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema K0SmotronControlPlaneSpecManifestsConfigMap
 */
export interface K0SmotronControlPlaneSpecManifestsConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema K0SmotronControlPlaneSpecManifestsConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneSpecManifestsConfigMap#items
   */
  readonly items?: K0SmotronControlPlaneSpecManifestsConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecManifestsConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema K0SmotronControlPlaneSpecManifestsConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsConfigMap(obj: K0SmotronControlPlaneSpecManifestsConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneSpecManifestsConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema K0SmotronControlPlaneSpecManifestsCsi
 */
export interface K0SmotronControlPlaneSpecManifestsCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema K0SmotronControlPlaneSpecManifestsCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema K0SmotronControlPlaneSpecManifestsCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema K0SmotronControlPlaneSpecManifestsCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: K0SmotronControlPlaneSpecManifestsCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema K0SmotronControlPlaneSpecManifestsCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema K0SmotronControlPlaneSpecManifestsCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsCsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsCsi(obj: K0SmotronControlPlaneSpecManifestsCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_K0SmotronControlPlaneSpecManifestsCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema K0SmotronControlPlaneSpecManifestsDownwardApi
 */
export interface K0SmotronControlPlaneSpecManifestsDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema K0SmotronControlPlaneSpecManifestsDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema K0SmotronControlPlaneSpecManifestsDownwardApi#items
   */
  readonly items?: K0SmotronControlPlaneSpecManifestsDownwardApiItems[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsDownwardApi(obj: K0SmotronControlPlaneSpecManifestsDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneSpecManifestsDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema K0SmotronControlPlaneSpecManifestsEmptyDir
 */
export interface K0SmotronControlPlaneSpecManifestsEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema K0SmotronControlPlaneSpecManifestsEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema K0SmotronControlPlaneSpecManifestsEmptyDir#sizeLimit
   */
  readonly sizeLimit?: K0SmotronControlPlaneSpecManifestsEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsEmptyDir(obj: K0SmotronControlPlaneSpecManifestsEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema K0SmotronControlPlaneSpecManifestsEphemeral
 */
export interface K0SmotronControlPlaneSpecManifestsEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   *
   * Required, must not be nil.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsEphemeral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsEphemeral(obj: K0SmotronControlPlaneSpecManifestsEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema K0SmotronControlPlaneSpecManifestsFc
 */
export interface K0SmotronControlPlaneSpecManifestsFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneSpecManifestsFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema K0SmotronControlPlaneSpecManifestsFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneSpecManifestsFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema K0SmotronControlPlaneSpecManifestsFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema K0SmotronControlPlaneSpecManifestsFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsFc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsFc(obj: K0SmotronControlPlaneSpecManifestsFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 *
 * @schema K0SmotronControlPlaneSpecManifestsFlexVolume
 */
export interface K0SmotronControlPlaneSpecManifestsFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema K0SmotronControlPlaneSpecManifestsFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema K0SmotronControlPlaneSpecManifestsFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema K0SmotronControlPlaneSpecManifestsFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneSpecManifestsFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema K0SmotronControlPlaneSpecManifestsFlexVolume#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneSpecManifestsFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsFlexVolume(obj: K0SmotronControlPlaneSpecManifestsFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneSpecManifestsFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema K0SmotronControlPlaneSpecManifestsFlocker
 */
export interface K0SmotronControlPlaneSpecManifestsFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema K0SmotronControlPlaneSpecManifestsFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema K0SmotronControlPlaneSpecManifestsFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsFlocker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsFlocker(obj: K0SmotronControlPlaneSpecManifestsFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema K0SmotronControlPlaneSpecManifestsGcePersistentDisk
 */
export interface K0SmotronControlPlaneSpecManifestsGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneSpecManifestsGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema K0SmotronControlPlaneSpecManifestsGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema K0SmotronControlPlaneSpecManifestsGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema K0SmotronControlPlaneSpecManifestsGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsGcePersistentDisk(obj: K0SmotronControlPlaneSpecManifestsGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema K0SmotronControlPlaneSpecManifestsGitRepo
 */
export interface K0SmotronControlPlaneSpecManifestsGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema K0SmotronControlPlaneSpecManifestsGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema K0SmotronControlPlaneSpecManifestsGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema K0SmotronControlPlaneSpecManifestsGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsGitRepo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsGitRepo(obj: K0SmotronControlPlaneSpecManifestsGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema K0SmotronControlPlaneSpecManifestsGlusterfs
 */
export interface K0SmotronControlPlaneSpecManifestsGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema K0SmotronControlPlaneSpecManifestsGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema K0SmotronControlPlaneSpecManifestsGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema K0SmotronControlPlaneSpecManifestsGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsGlusterfs(obj: K0SmotronControlPlaneSpecManifestsGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 * ---
 * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
 * mount host directories as read/write.
 *
 * @schema K0SmotronControlPlaneSpecManifestsHostPath
 */
export interface K0SmotronControlPlaneSpecManifestsHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema K0SmotronControlPlaneSpecManifestsHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema K0SmotronControlPlaneSpecManifestsHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsHostPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsHostPath(obj: K0SmotronControlPlaneSpecManifestsHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema K0SmotronControlPlaneSpecManifestsIscsi
 */
export interface K0SmotronControlPlaneSpecManifestsIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema K0SmotronControlPlaneSpecManifestsIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema K0SmotronControlPlaneSpecManifestsIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneSpecManifestsIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema K0SmotronControlPlaneSpecManifestsIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema K0SmotronControlPlaneSpecManifestsIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema K0SmotronControlPlaneSpecManifestsIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema K0SmotronControlPlaneSpecManifestsIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema K0SmotronControlPlaneSpecManifestsIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema K0SmotronControlPlaneSpecManifestsIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema K0SmotronControlPlaneSpecManifestsIscsi#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneSpecManifestsIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema K0SmotronControlPlaneSpecManifestsIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsIscsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsIscsi(obj: K0SmotronControlPlaneSpecManifestsIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneSpecManifestsIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema K0SmotronControlPlaneSpecManifestsNfs
 */
export interface K0SmotronControlPlaneSpecManifestsNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema K0SmotronControlPlaneSpecManifestsNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema K0SmotronControlPlaneSpecManifestsNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema K0SmotronControlPlaneSpecManifestsNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsNfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsNfs(obj: K0SmotronControlPlaneSpecManifestsNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema K0SmotronControlPlaneSpecManifestsPersistentVolumeClaim
 */
export interface K0SmotronControlPlaneSpecManifestsPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema K0SmotronControlPlaneSpecManifestsPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema K0SmotronControlPlaneSpecManifestsPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsPersistentVolumeClaim(obj: K0SmotronControlPlaneSpecManifestsPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema K0SmotronControlPlaneSpecManifestsPhotonPersistentDisk
 */
export interface K0SmotronControlPlaneSpecManifestsPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneSpecManifestsPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema K0SmotronControlPlaneSpecManifestsPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsPhotonPersistentDisk(obj: K0SmotronControlPlaneSpecManifestsPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema K0SmotronControlPlaneSpecManifestsPortworxVolume
 */
export interface K0SmotronControlPlaneSpecManifestsPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneSpecManifestsPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneSpecManifestsPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema K0SmotronControlPlaneSpecManifestsPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsPortworxVolume(obj: K0SmotronControlPlaneSpecManifestsPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema K0SmotronControlPlaneSpecManifestsProjected
 */
export interface K0SmotronControlPlaneSpecManifestsProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjected#sources
   */
  readonly sources?: K0SmotronControlPlaneSpecManifestsProjectedSources[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsProjected' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsProjected(obj: K0SmotronControlPlaneSpecManifestsProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_K0SmotronControlPlaneSpecManifestsProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema K0SmotronControlPlaneSpecManifestsQuobyte
 */
export interface K0SmotronControlPlaneSpecManifestsQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema K0SmotronControlPlaneSpecManifestsQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema K0SmotronControlPlaneSpecManifestsQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema K0SmotronControlPlaneSpecManifestsQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema K0SmotronControlPlaneSpecManifestsQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema K0SmotronControlPlaneSpecManifestsQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema K0SmotronControlPlaneSpecManifestsQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsQuobyte' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsQuobyte(obj: K0SmotronControlPlaneSpecManifestsQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema K0SmotronControlPlaneSpecManifestsRbd
 */
export interface K0SmotronControlPlaneSpecManifestsRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneSpecManifestsRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneSpecManifestsRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema K0SmotronControlPlaneSpecManifestsRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneSpecManifestsRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema K0SmotronControlPlaneSpecManifestsRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema K0SmotronControlPlaneSpecManifestsRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema K0SmotronControlPlaneSpecManifestsRbd#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneSpecManifestsRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema K0SmotronControlPlaneSpecManifestsRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsRbd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsRbd(obj: K0SmotronControlPlaneSpecManifestsRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneSpecManifestsRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema K0SmotronControlPlaneSpecManifestsScaleIo
 */
export interface K0SmotronControlPlaneSpecManifestsScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema K0SmotronControlPlaneSpecManifestsScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema K0SmotronControlPlaneSpecManifestsScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema K0SmotronControlPlaneSpecManifestsScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneSpecManifestsScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema K0SmotronControlPlaneSpecManifestsScaleIo#secretRef
   */
  readonly secretRef: K0SmotronControlPlaneSpecManifestsScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema K0SmotronControlPlaneSpecManifestsScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema K0SmotronControlPlaneSpecManifestsScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema K0SmotronControlPlaneSpecManifestsScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema K0SmotronControlPlaneSpecManifestsScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema K0SmotronControlPlaneSpecManifestsScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsScaleIo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsScaleIo(obj: K0SmotronControlPlaneSpecManifestsScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneSpecManifestsScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema K0SmotronControlPlaneSpecManifestsSecret
 */
export interface K0SmotronControlPlaneSpecManifestsSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema K0SmotronControlPlaneSpecManifestsSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneSpecManifestsSecret#items
   */
  readonly items?: K0SmotronControlPlaneSpecManifestsSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema K0SmotronControlPlaneSpecManifestsSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema K0SmotronControlPlaneSpecManifestsSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsSecret(obj: K0SmotronControlPlaneSpecManifestsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneSpecManifestsSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema K0SmotronControlPlaneSpecManifestsStorageos
 */
export interface K0SmotronControlPlaneSpecManifestsStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneSpecManifestsStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneSpecManifestsStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema K0SmotronControlPlaneSpecManifestsStorageos#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneSpecManifestsStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema K0SmotronControlPlaneSpecManifestsStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema K0SmotronControlPlaneSpecManifestsStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsStorageos' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsStorageos(obj: K0SmotronControlPlaneSpecManifestsStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneSpecManifestsStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema K0SmotronControlPlaneSpecManifestsVsphereVolume
 */
export interface K0SmotronControlPlaneSpecManifestsVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneSpecManifestsVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema K0SmotronControlPlaneSpecManifestsVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema K0SmotronControlPlaneSpecManifestsVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema K0SmotronControlPlaneSpecManifestsVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsVsphereVolume(obj: K0SmotronControlPlaneSpecManifestsVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema K0SmotronControlPlaneSpecMountsAwsElasticBlockStore
 */
export interface K0SmotronControlPlaneSpecMountsAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneSpecMountsAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema K0SmotronControlPlaneSpecMountsAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema K0SmotronControlPlaneSpecMountsAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema K0SmotronControlPlaneSpecMountsAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsAwsElasticBlockStore(obj: K0SmotronControlPlaneSpecMountsAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema K0SmotronControlPlaneSpecMountsAzureDisk
 */
export interface K0SmotronControlPlaneSpecMountsAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema K0SmotronControlPlaneSpecMountsAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema K0SmotronControlPlaneSpecMountsAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema K0SmotronControlPlaneSpecMountsAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneSpecMountsAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema K0SmotronControlPlaneSpecMountsAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneSpecMountsAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsAzureDisk(obj: K0SmotronControlPlaneSpecMountsAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema K0SmotronControlPlaneSpecMountsAzureFile
 */
export interface K0SmotronControlPlaneSpecMountsAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneSpecMountsAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema K0SmotronControlPlaneSpecMountsAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema K0SmotronControlPlaneSpecMountsAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsAzureFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsAzureFile(obj: K0SmotronControlPlaneSpecMountsAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema K0SmotronControlPlaneSpecMountsCephfs
 */
export interface K0SmotronControlPlaneSpecMountsCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneSpecMountsCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema K0SmotronControlPlaneSpecMountsCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneSpecMountsCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneSpecMountsCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneSpecMountsCephfs#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneSpecMountsCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneSpecMountsCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsCephfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsCephfs(obj: K0SmotronControlPlaneSpecMountsCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_K0SmotronControlPlaneSpecMountsCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema K0SmotronControlPlaneSpecMountsCinder
 */
export interface K0SmotronControlPlaneSpecMountsCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneSpecMountsCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneSpecMountsCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema K0SmotronControlPlaneSpecMountsCinder#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneSpecMountsCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneSpecMountsCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsCinder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsCinder(obj: K0SmotronControlPlaneSpecMountsCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneSpecMountsCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema K0SmotronControlPlaneSpecMountsConfigMap
 */
export interface K0SmotronControlPlaneSpecMountsConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema K0SmotronControlPlaneSpecMountsConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneSpecMountsConfigMap#items
   */
  readonly items?: K0SmotronControlPlaneSpecMountsConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecMountsConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema K0SmotronControlPlaneSpecMountsConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsConfigMap(obj: K0SmotronControlPlaneSpecMountsConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneSpecMountsConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema K0SmotronControlPlaneSpecMountsCsi
 */
export interface K0SmotronControlPlaneSpecMountsCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema K0SmotronControlPlaneSpecMountsCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema K0SmotronControlPlaneSpecMountsCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema K0SmotronControlPlaneSpecMountsCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: K0SmotronControlPlaneSpecMountsCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema K0SmotronControlPlaneSpecMountsCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema K0SmotronControlPlaneSpecMountsCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsCsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsCsi(obj: K0SmotronControlPlaneSpecMountsCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_K0SmotronControlPlaneSpecMountsCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema K0SmotronControlPlaneSpecMountsDownwardApi
 */
export interface K0SmotronControlPlaneSpecMountsDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema K0SmotronControlPlaneSpecMountsDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema K0SmotronControlPlaneSpecMountsDownwardApi#items
   */
  readonly items?: K0SmotronControlPlaneSpecMountsDownwardApiItems[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsDownwardApi(obj: K0SmotronControlPlaneSpecMountsDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneSpecMountsDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema K0SmotronControlPlaneSpecMountsEmptyDir
 */
export interface K0SmotronControlPlaneSpecMountsEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema K0SmotronControlPlaneSpecMountsEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema K0SmotronControlPlaneSpecMountsEmptyDir#sizeLimit
   */
  readonly sizeLimit?: K0SmotronControlPlaneSpecMountsEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsEmptyDir(obj: K0SmotronControlPlaneSpecMountsEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema K0SmotronControlPlaneSpecMountsEphemeral
 */
export interface K0SmotronControlPlaneSpecMountsEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   *
   * Required, must not be nil.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsEphemeral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsEphemeral(obj: K0SmotronControlPlaneSpecMountsEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema K0SmotronControlPlaneSpecMountsFc
 */
export interface K0SmotronControlPlaneSpecMountsFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneSpecMountsFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema K0SmotronControlPlaneSpecMountsFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneSpecMountsFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema K0SmotronControlPlaneSpecMountsFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema K0SmotronControlPlaneSpecMountsFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsFc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsFc(obj: K0SmotronControlPlaneSpecMountsFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 *
 * @schema K0SmotronControlPlaneSpecMountsFlexVolume
 */
export interface K0SmotronControlPlaneSpecMountsFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema K0SmotronControlPlaneSpecMountsFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema K0SmotronControlPlaneSpecMountsFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema K0SmotronControlPlaneSpecMountsFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneSpecMountsFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema K0SmotronControlPlaneSpecMountsFlexVolume#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneSpecMountsFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsFlexVolume(obj: K0SmotronControlPlaneSpecMountsFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneSpecMountsFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema K0SmotronControlPlaneSpecMountsFlocker
 */
export interface K0SmotronControlPlaneSpecMountsFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema K0SmotronControlPlaneSpecMountsFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema K0SmotronControlPlaneSpecMountsFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsFlocker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsFlocker(obj: K0SmotronControlPlaneSpecMountsFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema K0SmotronControlPlaneSpecMountsGcePersistentDisk
 */
export interface K0SmotronControlPlaneSpecMountsGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneSpecMountsGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema K0SmotronControlPlaneSpecMountsGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema K0SmotronControlPlaneSpecMountsGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema K0SmotronControlPlaneSpecMountsGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsGcePersistentDisk(obj: K0SmotronControlPlaneSpecMountsGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema K0SmotronControlPlaneSpecMountsGitRepo
 */
export interface K0SmotronControlPlaneSpecMountsGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema K0SmotronControlPlaneSpecMountsGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema K0SmotronControlPlaneSpecMountsGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema K0SmotronControlPlaneSpecMountsGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsGitRepo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsGitRepo(obj: K0SmotronControlPlaneSpecMountsGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema K0SmotronControlPlaneSpecMountsGlusterfs
 */
export interface K0SmotronControlPlaneSpecMountsGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema K0SmotronControlPlaneSpecMountsGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema K0SmotronControlPlaneSpecMountsGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema K0SmotronControlPlaneSpecMountsGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsGlusterfs(obj: K0SmotronControlPlaneSpecMountsGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 * ---
 * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
 * mount host directories as read/write.
 *
 * @schema K0SmotronControlPlaneSpecMountsHostPath
 */
export interface K0SmotronControlPlaneSpecMountsHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema K0SmotronControlPlaneSpecMountsHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema K0SmotronControlPlaneSpecMountsHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsHostPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsHostPath(obj: K0SmotronControlPlaneSpecMountsHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema K0SmotronControlPlaneSpecMountsIscsi
 */
export interface K0SmotronControlPlaneSpecMountsIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema K0SmotronControlPlaneSpecMountsIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema K0SmotronControlPlaneSpecMountsIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneSpecMountsIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema K0SmotronControlPlaneSpecMountsIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema K0SmotronControlPlaneSpecMountsIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema K0SmotronControlPlaneSpecMountsIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema K0SmotronControlPlaneSpecMountsIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema K0SmotronControlPlaneSpecMountsIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema K0SmotronControlPlaneSpecMountsIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema K0SmotronControlPlaneSpecMountsIscsi#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneSpecMountsIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema K0SmotronControlPlaneSpecMountsIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsIscsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsIscsi(obj: K0SmotronControlPlaneSpecMountsIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneSpecMountsIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema K0SmotronControlPlaneSpecMountsNfs
 */
export interface K0SmotronControlPlaneSpecMountsNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema K0SmotronControlPlaneSpecMountsNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema K0SmotronControlPlaneSpecMountsNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema K0SmotronControlPlaneSpecMountsNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsNfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsNfs(obj: K0SmotronControlPlaneSpecMountsNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema K0SmotronControlPlaneSpecMountsPersistentVolumeClaim
 */
export interface K0SmotronControlPlaneSpecMountsPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema K0SmotronControlPlaneSpecMountsPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema K0SmotronControlPlaneSpecMountsPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsPersistentVolumeClaim(obj: K0SmotronControlPlaneSpecMountsPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema K0SmotronControlPlaneSpecMountsPhotonPersistentDisk
 */
export interface K0SmotronControlPlaneSpecMountsPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneSpecMountsPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema K0SmotronControlPlaneSpecMountsPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsPhotonPersistentDisk(obj: K0SmotronControlPlaneSpecMountsPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema K0SmotronControlPlaneSpecMountsPortworxVolume
 */
export interface K0SmotronControlPlaneSpecMountsPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneSpecMountsPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneSpecMountsPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema K0SmotronControlPlaneSpecMountsPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsPortworxVolume(obj: K0SmotronControlPlaneSpecMountsPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema K0SmotronControlPlaneSpecMountsProjected
 */
export interface K0SmotronControlPlaneSpecMountsProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema K0SmotronControlPlaneSpecMountsProjected#sources
   */
  readonly sources?: K0SmotronControlPlaneSpecMountsProjectedSources[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsProjected' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsProjected(obj: K0SmotronControlPlaneSpecMountsProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_K0SmotronControlPlaneSpecMountsProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema K0SmotronControlPlaneSpecMountsQuobyte
 */
export interface K0SmotronControlPlaneSpecMountsQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema K0SmotronControlPlaneSpecMountsQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema K0SmotronControlPlaneSpecMountsQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema K0SmotronControlPlaneSpecMountsQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema K0SmotronControlPlaneSpecMountsQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema K0SmotronControlPlaneSpecMountsQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema K0SmotronControlPlaneSpecMountsQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsQuobyte' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsQuobyte(obj: K0SmotronControlPlaneSpecMountsQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema K0SmotronControlPlaneSpecMountsRbd
 */
export interface K0SmotronControlPlaneSpecMountsRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneSpecMountsRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneSpecMountsRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema K0SmotronControlPlaneSpecMountsRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneSpecMountsRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema K0SmotronControlPlaneSpecMountsRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema K0SmotronControlPlaneSpecMountsRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema K0SmotronControlPlaneSpecMountsRbd#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneSpecMountsRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema K0SmotronControlPlaneSpecMountsRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsRbd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsRbd(obj: K0SmotronControlPlaneSpecMountsRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneSpecMountsRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema K0SmotronControlPlaneSpecMountsScaleIo
 */
export interface K0SmotronControlPlaneSpecMountsScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema K0SmotronControlPlaneSpecMountsScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema K0SmotronControlPlaneSpecMountsScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema K0SmotronControlPlaneSpecMountsScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneSpecMountsScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema K0SmotronControlPlaneSpecMountsScaleIo#secretRef
   */
  readonly secretRef: K0SmotronControlPlaneSpecMountsScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema K0SmotronControlPlaneSpecMountsScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema K0SmotronControlPlaneSpecMountsScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema K0SmotronControlPlaneSpecMountsScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema K0SmotronControlPlaneSpecMountsScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema K0SmotronControlPlaneSpecMountsScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsScaleIo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsScaleIo(obj: K0SmotronControlPlaneSpecMountsScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneSpecMountsScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema K0SmotronControlPlaneSpecMountsSecret
 */
export interface K0SmotronControlPlaneSpecMountsSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema K0SmotronControlPlaneSpecMountsSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneSpecMountsSecret#items
   */
  readonly items?: K0SmotronControlPlaneSpecMountsSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema K0SmotronControlPlaneSpecMountsSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema K0SmotronControlPlaneSpecMountsSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsSecret(obj: K0SmotronControlPlaneSpecMountsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneSpecMountsSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema K0SmotronControlPlaneSpecMountsStorageos
 */
export interface K0SmotronControlPlaneSpecMountsStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneSpecMountsStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneSpecMountsStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema K0SmotronControlPlaneSpecMountsStorageos#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneSpecMountsStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema K0SmotronControlPlaneSpecMountsStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema K0SmotronControlPlaneSpecMountsStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsStorageos' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsStorageos(obj: K0SmotronControlPlaneSpecMountsStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneSpecMountsStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema K0SmotronControlPlaneSpecMountsVsphereVolume
 */
export interface K0SmotronControlPlaneSpecMountsVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneSpecMountsVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema K0SmotronControlPlaneSpecMountsVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema K0SmotronControlPlaneSpecMountsVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema K0SmotronControlPlaneSpecMountsVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsVsphereVolume(obj: K0SmotronControlPlaneSpecMountsVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PersistentVolumeClaim defines the PVC configuration. Will be used as is in case of .spec.persistence.type is pvc.
 *
 * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaim
 */
export interface K0SmotronControlPlaneSpecPersistencePersistentVolumeClaim {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaim#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaim#kind
   */
  readonly kind?: string;

  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaim#metadata
   */
  readonly metadata?: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimMetadata;

  /**
   * spec defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaim#spec
   */
  readonly spec?: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec;

  /**
   * status represents the current information/status of a persistent volume claim.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaim#status
   */
  readonly status?: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatus;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecPersistencePersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaim(obj: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimMetadata(obj.metadata),
    'spec': toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec(obj.spec),
    'status': toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema K0SmotronControlPlaneSpecResourcesClaims
 */
export interface K0SmotronControlPlaneSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema K0SmotronControlPlaneSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecResourcesClaims(obj: K0SmotronControlPlaneSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneSpecResourcesLimits
 */
export class K0SmotronControlPlaneSpecResourcesLimits {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecResourcesLimits {
    return new K0SmotronControlPlaneSpecResourcesLimits(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecResourcesLimits {
    return new K0SmotronControlPlaneSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema K0SmotronControlPlaneSpecResourcesRequests
 */
export class K0SmotronControlPlaneSpecResourcesRequests {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecResourcesRequests {
    return new K0SmotronControlPlaneSpecResourcesRequests(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecResourcesRequests {
    return new K0SmotronControlPlaneSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Service Type string describes ingress methods for a service
 *
 * @schema K0SmotronControlPlaneSpecServiceType
 */
export enum K0SmotronControlPlaneSpecServiceType {
  /** ClusterIP */
  CLUSTER_IP = "ClusterIP",
  /** NodePort */
  NODE_PORT = "NodePort",
  /** LoadBalancer */
  LOAD_BALANCER = "LoadBalancer",
}

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelector
 */
export interface K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelector(obj: K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Size defines the size of the etcd volume. Default: 1Gi
 *
 * @schema K0SmotronControlPlaneSpecEtcdPersistenceSize
 */
export class K0SmotronControlPlaneSpecEtcdPersistenceSize {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecEtcdPersistenceSize {
    return new K0SmotronControlPlaneSpecEtcdPersistenceSize(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecEtcdPersistenceSize {
    return new K0SmotronControlPlaneSpecEtcdPersistenceSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema K0SmotronControlPlaneSpecEtcdResourcesClaims
 */
export interface K0SmotronControlPlaneSpecEtcdResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema K0SmotronControlPlaneSpecEtcdResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecEtcdResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecEtcdResourcesClaims(obj: K0SmotronControlPlaneSpecEtcdResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneSpecEtcdResourcesLimits
 */
export class K0SmotronControlPlaneSpecEtcdResourcesLimits {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecEtcdResourcesLimits {
    return new K0SmotronControlPlaneSpecEtcdResourcesLimits(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecEtcdResourcesLimits {
    return new K0SmotronControlPlaneSpecEtcdResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema K0SmotronControlPlaneSpecEtcdResourcesRequests
 */
export class K0SmotronControlPlaneSpecEtcdResourcesRequests {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecEtcdResourcesRequests {
    return new K0SmotronControlPlaneSpecEtcdResourcesRequests(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecEtcdResourcesRequests {
    return new K0SmotronControlPlaneSpecEtcdResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema K0SmotronControlPlaneSpecManifestsCephfsSecretRef
 */
export interface K0SmotronControlPlaneSpecManifestsCephfsSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecManifestsCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsCephfsSecretRef(obj: K0SmotronControlPlaneSpecManifestsCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema K0SmotronControlPlaneSpecManifestsCinderSecretRef
 */
export interface K0SmotronControlPlaneSpecManifestsCinderSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecManifestsCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsCinderSecretRef(obj: K0SmotronControlPlaneSpecManifestsCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneSpecManifestsConfigMapItems
 */
export interface K0SmotronControlPlaneSpecManifestsConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneSpecManifestsConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneSpecManifestsConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneSpecManifestsConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsConfigMapItems(obj: K0SmotronControlPlaneSpecManifestsConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema K0SmotronControlPlaneSpecManifestsCsiNodePublishSecretRef
 */
export interface K0SmotronControlPlaneSpecManifestsCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecManifestsCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsCsiNodePublishSecretRef(obj: K0SmotronControlPlaneSpecManifestsCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema K0SmotronControlPlaneSpecManifestsDownwardApiItems
 */
export interface K0SmotronControlPlaneSpecManifestsDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema K0SmotronControlPlaneSpecManifestsDownwardApiItems#fieldRef
   */
  readonly fieldRef?: K0SmotronControlPlaneSpecManifestsDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneSpecManifestsDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema K0SmotronControlPlaneSpecManifestsDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema K0SmotronControlPlaneSpecManifestsDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsDownwardApiItems(obj: K0SmotronControlPlaneSpecManifestsDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_K0SmotronControlPlaneSpecManifestsDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema K0SmotronControlPlaneSpecManifestsEmptyDirSizeLimit
 */
export class K0SmotronControlPlaneSpecManifestsEmptyDirSizeLimit {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecManifestsEmptyDirSizeLimit {
    return new K0SmotronControlPlaneSpecManifestsEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecManifestsEmptyDirSizeLimit {
    return new K0SmotronControlPlaneSpecManifestsEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 *
 * Required, must not be nil.
 *
 * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplate
 */
export interface K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateMetadata;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplate(obj: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema K0SmotronControlPlaneSpecManifestsFlexVolumeSecretRef
 */
export interface K0SmotronControlPlaneSpecManifestsFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecManifestsFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsFlexVolumeSecretRef(obj: K0SmotronControlPlaneSpecManifestsFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema K0SmotronControlPlaneSpecManifestsIscsiSecretRef
 */
export interface K0SmotronControlPlaneSpecManifestsIscsiSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecManifestsIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsIscsiSecretRef(obj: K0SmotronControlPlaneSpecManifestsIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema K0SmotronControlPlaneSpecManifestsProjectedSources
 */
export interface K0SmotronControlPlaneSpecManifestsProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSources#configMap
   */
  readonly configMap?: K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSources#downwardAPI
   */
  readonly downwardApi?: K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSources#secret
   */
  readonly secret?: K0SmotronControlPlaneSpecManifestsProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: K0SmotronControlPlaneSpecManifestsProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsProjectedSources(obj: K0SmotronControlPlaneSpecManifestsProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterTrustBundle': toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundle(obj.clusterTrustBundle),
    'configMap': toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema K0SmotronControlPlaneSpecManifestsRbdSecretRef
 */
export interface K0SmotronControlPlaneSpecManifestsRbdSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecManifestsRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsRbdSecretRef(obj: K0SmotronControlPlaneSpecManifestsRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema K0SmotronControlPlaneSpecManifestsScaleIoSecretRef
 */
export interface K0SmotronControlPlaneSpecManifestsScaleIoSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecManifestsScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsScaleIoSecretRef(obj: K0SmotronControlPlaneSpecManifestsScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneSpecManifestsSecretItems
 */
export interface K0SmotronControlPlaneSpecManifestsSecretItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneSpecManifestsSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneSpecManifestsSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneSpecManifestsSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsSecretItems(obj: K0SmotronControlPlaneSpecManifestsSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema K0SmotronControlPlaneSpecManifestsStorageosSecretRef
 */
export interface K0SmotronControlPlaneSpecManifestsStorageosSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecManifestsStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsStorageosSecretRef(obj: K0SmotronControlPlaneSpecManifestsStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema K0SmotronControlPlaneSpecMountsCephfsSecretRef
 */
export interface K0SmotronControlPlaneSpecMountsCephfsSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecMountsCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsCephfsSecretRef(obj: K0SmotronControlPlaneSpecMountsCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema K0SmotronControlPlaneSpecMountsCinderSecretRef
 */
export interface K0SmotronControlPlaneSpecMountsCinderSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecMountsCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsCinderSecretRef(obj: K0SmotronControlPlaneSpecMountsCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneSpecMountsConfigMapItems
 */
export interface K0SmotronControlPlaneSpecMountsConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneSpecMountsConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneSpecMountsConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneSpecMountsConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsConfigMapItems(obj: K0SmotronControlPlaneSpecMountsConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema K0SmotronControlPlaneSpecMountsCsiNodePublishSecretRef
 */
export interface K0SmotronControlPlaneSpecMountsCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecMountsCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsCsiNodePublishSecretRef(obj: K0SmotronControlPlaneSpecMountsCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema K0SmotronControlPlaneSpecMountsDownwardApiItems
 */
export interface K0SmotronControlPlaneSpecMountsDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema K0SmotronControlPlaneSpecMountsDownwardApiItems#fieldRef
   */
  readonly fieldRef?: K0SmotronControlPlaneSpecMountsDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneSpecMountsDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema K0SmotronControlPlaneSpecMountsDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema K0SmotronControlPlaneSpecMountsDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsDownwardApiItems(obj: K0SmotronControlPlaneSpecMountsDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_K0SmotronControlPlaneSpecMountsDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema K0SmotronControlPlaneSpecMountsEmptyDirSizeLimit
 */
export class K0SmotronControlPlaneSpecMountsEmptyDirSizeLimit {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecMountsEmptyDirSizeLimit {
    return new K0SmotronControlPlaneSpecMountsEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecMountsEmptyDirSizeLimit {
    return new K0SmotronControlPlaneSpecMountsEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 *
 * Required, must not be nil.
 *
 * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplate
 */
export interface K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateMetadata;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplate(obj: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema K0SmotronControlPlaneSpecMountsFlexVolumeSecretRef
 */
export interface K0SmotronControlPlaneSpecMountsFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecMountsFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsFlexVolumeSecretRef(obj: K0SmotronControlPlaneSpecMountsFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema K0SmotronControlPlaneSpecMountsIscsiSecretRef
 */
export interface K0SmotronControlPlaneSpecMountsIscsiSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecMountsIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsIscsiSecretRef(obj: K0SmotronControlPlaneSpecMountsIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema K0SmotronControlPlaneSpecMountsProjectedSources
 */
export interface K0SmotronControlPlaneSpecMountsProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSources#configMap
   */
  readonly configMap?: K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSources#downwardAPI
   */
  readonly downwardApi?: K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSources#secret
   */
  readonly secret?: K0SmotronControlPlaneSpecMountsProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: K0SmotronControlPlaneSpecMountsProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsProjectedSources(obj: K0SmotronControlPlaneSpecMountsProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterTrustBundle': toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundle(obj.clusterTrustBundle),
    'configMap': toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema K0SmotronControlPlaneSpecMountsRbdSecretRef
 */
export interface K0SmotronControlPlaneSpecMountsRbdSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecMountsRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsRbdSecretRef(obj: K0SmotronControlPlaneSpecMountsRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema K0SmotronControlPlaneSpecMountsScaleIoSecretRef
 */
export interface K0SmotronControlPlaneSpecMountsScaleIoSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecMountsScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsScaleIoSecretRef(obj: K0SmotronControlPlaneSpecMountsScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneSpecMountsSecretItems
 */
export interface K0SmotronControlPlaneSpecMountsSecretItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneSpecMountsSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneSpecMountsSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneSpecMountsSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsSecretItems(obj: K0SmotronControlPlaneSpecMountsSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema K0SmotronControlPlaneSpecMountsStorageosSecretRef
 */
export interface K0SmotronControlPlaneSpecMountsStorageosSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecMountsStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsStorageosSecretRef(obj: K0SmotronControlPlaneSpecMountsStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Standard object's metadata.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
 *
 * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimMetadata
 */
export interface K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimMetadata {
  /**
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimMetadata#name
   */
  readonly name?: string;

  /**
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimMetadata(obj: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * spec defines the desired characteristics of a volume requested by a pod author.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec
 */
export interface K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec#dataSource
   */
  readonly dataSource?: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec#dataSourceRef
   */
  readonly dataSourceRef?: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec#resources
   */
  readonly resources?: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec#selector
   */
  readonly selector?: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec(obj: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResources(obj.resources),
    'selector': toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * status represents the current information/status of a persistent volume claim.
 * Read-only.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatus
 */
export interface K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   *
   * ClaimResourceStatus can be in any of following states:
   * - ControllerResizeInProgress:
   * State set when resize controller starts resizing the volume in control-plane.
   * - ControllerResizeFailed:
   * State set when resize has failed in resize controller with a terminal error.
   * - NodeResizePending:
   * State set when resize controller has finished resizing the volume but further resizing of
   * volume is needed on the node.
   * - NodeResizeInProgress:
   * State set when kubelet starts resizing the volume.
   * - NodeResizeFailed:
   * State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
   * NodeResizeFailed.
   * For example: if expanding a PVC for more capacity - this field can be one of the following states:
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
   * When this field is not set, it means that no resize operation is in progress for the given PVC.
   *
   *
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   *
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation
   * is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   *
   *
   * A controller that receives PVC update with previously unknown resourceName
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusAllocatedResources };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatus#capacity
   */
  readonly capacity?: { [key: string]: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusCapacity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'Resizing'.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatus#conditions
   */
  readonly conditions?: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusConditions[];

  /**
   * currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
   * When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
   * This is an alpha field and requires enabling VolumeAttributesClass feature.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatus#currentVolumeAttributesClassName
   */
  readonly currentVolumeAttributesClassName?: string;

  /**
   * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
   * When this is unset, there is no ModifyVolume operation being attempted.
   * This is an alpha field and requires enabling VolumeAttributesClass feature.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatus#modifyVolumeStatus
   */
  readonly modifyVolumeStatus?: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus;

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatus#phase
   */
  readonly phase?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatus(obj: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResourceStatuses': ((obj.allocatedResourceStatuses) === undefined) ? undefined : (Object.entries(obj.allocatedResourceStatuses).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusConditions(y)),
    'currentVolumeAttributesClassName': obj.currentVolumeAttributesClassName,
    'modifyVolumeStatus': toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus(obj.modifyVolumeStatus),
    'phase': obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: K0SmotronControlPlaneSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema K0SmotronControlPlaneSpecManifestsDownwardApiItemsFieldRef
 */
export interface K0SmotronControlPlaneSpecManifestsDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema K0SmotronControlPlaneSpecManifestsDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema K0SmotronControlPlaneSpecManifestsDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsDownwardApiItemsFieldRef(obj: K0SmotronControlPlaneSpecManifestsDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRef
 */
export interface K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRef(obj: K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * May contain labels and annotations that will be copied into the PVC
 * when creating it. No other fields are allowed and will be rejected during
 * validation.
 *
 * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateMetadata
 */
export interface K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateMetadata {
  /**
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateMetadata(obj: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec
 */
export interface K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec(obj: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundle
 */
export interface K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundle(obj: K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector(obj.labelSelector),
    'name': obj.name,
    'optional': obj.optional,
    'path': obj.path,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMap
 */
export interface K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMap#items
   */
  readonly items?: K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMap(obj: K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApi
 */
export interface K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApi#items
   */
  readonly items?: K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApi(obj: K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesSecret
 */
export interface K0SmotronControlPlaneSpecManifestsProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesSecret#items
   */
  readonly items?: K0SmotronControlPlaneSpecManifestsProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesSecret(obj: K0SmotronControlPlaneSpecManifestsProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesServiceAccountToken
 */
export interface K0SmotronControlPlaneSpecManifestsProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesServiceAccountToken(obj: K0SmotronControlPlaneSpecManifestsProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema K0SmotronControlPlaneSpecMountsDownwardApiItemsFieldRef
 */
export interface K0SmotronControlPlaneSpecMountsDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema K0SmotronControlPlaneSpecMountsDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema K0SmotronControlPlaneSpecMountsDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsDownwardApiItemsFieldRef(obj: K0SmotronControlPlaneSpecMountsDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRef
 */
export interface K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRef(obj: K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * May contain labels and annotations that will be copied into the PVC
 * when creating it. No other fields are allowed and will be rejected during
 * validation.
 *
 * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateMetadata
 */
export interface K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateMetadata {
  /**
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateMetadata(obj: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec
 */
export interface K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec(obj: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundle
 */
export interface K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundle(obj: K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelector(obj.labelSelector),
    'name': obj.name,
    'optional': obj.optional,
    'path': obj.path,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMap
 */
export interface K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMap#items
   */
  readonly items?: K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMap(obj: K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApi
 */
export interface K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApi#items
   */
  readonly items?: K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApi(obj: K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesSecret
 */
export interface K0SmotronControlPlaneSpecMountsProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesSecret#items
   */
  readonly items?: K0SmotronControlPlaneSpecMountsProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesSecret(obj: K0SmotronControlPlaneSpecMountsProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesServiceAccountToken
 */
export interface K0SmotronControlPlaneSpecMountsProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesServiceAccountToken(obj: K0SmotronControlPlaneSpecMountsProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSource
 */
export interface K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSource(obj: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSourceRef
 */
export interface K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSourceRef(obj: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResources
 */
export interface K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResources#limits
   */
  readonly limits?: { [key: string]: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResources#requests
   */
  readonly requests?: { [key: string]: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResourcesRequests };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResources(obj: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelector
 */
export interface K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelector#matchExpressions
   */
  readonly matchExpressions?: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelector(obj: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusAllocatedResources
 */
export class K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusAllocatedResources {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusAllocatedResources {
    return new K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusAllocatedResources(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusAllocatedResources {
    return new K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusAllocatedResources(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusCapacity
 */
export class K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusCapacity {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusCapacity {
    return new K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusCapacity(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusCapacity {
    return new K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusConditions
 */
export interface K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "Resizing" that means the underlying
   * persistent volume is being resized.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusConditions#status
   */
  readonly status: string;

  /**
   * PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusConditions#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusConditions(obj: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
 * When this is unset, there is no ModifyVolume operation being attempted.
 * This is an alpha field and requires enabling VolumeAttributesClass feature.
 *
 * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus
 */
export interface K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus {
  /**
   * status is the status of the ControllerModifyVolume operation. It can be in any of following states:
   * - Pending
   * Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
   * the specified VolumeAttributesClass not existing.
   * - InProgress
   * InProgress indicates that the volume is being modified.
   * - Infeasible
   * Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
   * resolve the error, a valid VolumeAttributesClass needs to be specified.
   * Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus#status
   */
  readonly status: string;

  /**
   * targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus#targetVolumeAttributesClassName
   */
  readonly targetVolumeAttributesClassName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus(obj: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'targetVolumeAttributesClassName': obj.targetVolumeAttributesClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRefDivisor
 */
export class K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneSpecManifestsDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource(obj: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResources
 */
export interface K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResources(obj: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelector
 */
export interface K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelector(obj: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector(obj: K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMapItems
 */
export interface K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMapItems(obj: K0SmotronControlPlaneSpecManifestsProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItems
 */
export interface K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItems(obj: K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesSecretItems
 */
export interface K0SmotronControlPlaneSpecManifestsProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesSecretItems(obj: K0SmotronControlPlaneSpecManifestsProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRefDivisor
 */
export class K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneSpecMountsDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSource(obj: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResources
 */
export interface K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResources(obj: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelector
 */
export interface K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelector(obj: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelector(obj: K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMapItems
 */
export interface K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMapItems(obj: K0SmotronControlPlaneSpecMountsProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItems
 */
export interface K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItems(obj: K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesSecretItems
 */
export interface K0SmotronControlPlaneSpecMountsProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesSecretItems(obj: K0SmotronControlPlaneSpecMountsProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResourcesLimits
 */
export class K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResourcesLimits {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResourcesLimits {
    return new K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResourcesLimits(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResourcesLimits {
    return new K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResourcesRequests
 */
export class K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResourcesRequests {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResourcesRequests {
    return new K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResourcesRequests(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResourcesRequests {
    return new K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions
 */
export interface K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions(obj: K0SmotronControlPlaneSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: K0SmotronControlPlaneSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(obj: K0SmotronControlPlaneSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsFieldRef
 */
export interface K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsFieldRef(obj: K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef(obj: K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: K0SmotronControlPlaneSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(obj: K0SmotronControlPlaneSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsFieldRef
 */
export interface K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsFieldRef(obj: K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef(obj: K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 *
 *
 * @schema K0smotronControlPlaneTemplate
 */
export class K0smotronControlPlaneTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "K0smotronControlPlaneTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'controlplane.cluster.x-k8s.io/v1beta1',
    kind: 'K0smotronControlPlaneTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "K0smotronControlPlaneTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: K0smotronControlPlaneTemplateProps = {}): any {
    return {
      ...K0smotronControlPlaneTemplate.GVK,
      ...toJson_K0smotronControlPlaneTemplateProps(props),
    };
  }

  /**
   * Defines a "K0smotronControlPlaneTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: K0smotronControlPlaneTemplateProps = {}) {
    super(scope, id, {
      ...K0smotronControlPlaneTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...K0smotronControlPlaneTemplate.GVK,
      ...toJson_K0smotronControlPlaneTemplateProps(resolved),
    };
  }
}

/**
 * @schema K0smotronControlPlaneTemplate
 */
export interface K0smotronControlPlaneTemplateProps {
  /**
   * @schema K0smotronControlPlaneTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema K0smotronControlPlaneTemplate#spec
   */
  readonly spec?: K0SmotronControlPlaneTemplateSpec;
}

/**
 * Converts an object of type 'K0smotronControlPlaneTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0smotronControlPlaneTemplateProps(obj: K0smotronControlPlaneTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_K0SmotronControlPlaneTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneTemplateSpec
 */
export interface K0SmotronControlPlaneTemplateSpec {
  /**
   * @schema K0SmotronControlPlaneTemplateSpec#template
   */
  readonly template?: K0SmotronControlPlaneTemplateSpecTemplate;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpec(obj: K0SmotronControlPlaneTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'template': toJson_K0SmotronControlPlaneTemplateSpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplate
 */
export interface K0SmotronControlPlaneTemplateSpecTemplate {
  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplate#metadata
   */
  readonly metadata?: K0SmotronControlPlaneTemplateSpecTemplateMetadata;

  /**
   * ClusterSpec defines the desired state of K0smotronCluster
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplate#spec
   */
  readonly spec?: K0SmotronControlPlaneTemplateSpecTemplateSpec;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplate(obj: K0SmotronControlPlaneTemplateSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_K0SmotronControlPlaneTemplateSpecTemplateMetadata(obj.metadata),
    'spec': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateMetadata
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateMetadata {
  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateMetadata(obj: K0SmotronControlPlaneTemplateSpecTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterSpec defines the desired state of K0smotronCluster
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpec {
  /**
   * CertificateRefs defines the certificate references.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#certificateRefs
   */
  readonly certificateRefs?: K0SmotronControlPlaneTemplateSpecTemplateSpecCertificateRefs[];

  /**
   * ControlPlaneFlags allows to configure additional flags for k0s
   * control plane and to override existing ones. The default flags are
   * kept unless they are overriden explicitly. Flags with arguments must
   * be specified as a single string, e.g. --some-flag=argument
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#controllerPlaneFlags
   */
  readonly controllerPlaneFlags?: string[];

  /**
   * Etcd defines the etcd configuration.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#etcd
   */
  readonly etcd?: K0SmotronControlPlaneTemplateSpecTemplateSpecEtcd;

  /**
   * ExternalAddress defines k0s external address. See https://docs.k0sproject.io/stable/configuration/#specapi
   * Will be detected automatically for service type LoadBalancer.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#externalAddress
   */
  readonly externalAddress?: string;

  /**
   * Image defines the k0s image to be deployed. If empty k0smotron
   * will pick it automatically. Must not include the image tag.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#image
   */
  readonly image?: string;

  /**
   * k0sConfig defines the k0s configuration. Note, that some fields will be overwritten by k0smotron.
   * If empty, will be used default configuration. @see https://docs.k0sproject.io/stable/configuration/
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#k0sConfig
   */
  readonly k0SConfig?: any;

  /**
   * KineDataSourceSecretName defines the name of kine datasource URL secret.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#kineDataSourceSecretName
   */
  readonly kineDataSourceSecretName?: string;

  /**
   * KineDataSourceURL defines the kine datasource URL.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#kineDataSourceURL
   */
  readonly kineDataSourceUrl?: string;

  /**
   * KubeconfigRef is the reference to the kubeconfig of the hosting cluster.
   * This kubeconfig will be used to deploy the k0s control plane.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#kubeconfigRef
   */
  readonly kubeconfigRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecKubeconfigRef;

  /**
   * Manifests allows to specify list of volumes with manifests to be
   * deployed in the cluster. The volumes will be mounted
   * in /var/lib/k0s/manifests/<manifests.name>, for this reason each
   * manifest is a stack. K0smotron allows any kind of volume, but the
   * recommendation is to use secrets and configmaps.
   * For more information check:
   * https://docs.k0sproject.io/stable/manifests/ and
   * https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#manifests
   */
  readonly manifests?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifests[];

  /**
   * Monitoring defines the monitoring configuration.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#monitoring
   */
  readonly monitoring?: K0SmotronControlPlaneTemplateSpecTemplateSpecMonitoring;

  /**
   * Mounts allows to specify list of volumes with any files to be
   * mounted in the controlplane pod. K0smotron allows any kind of volume, but the
   * recommendation is to use secrets and configmaps.
   * For more information check:
   * https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#mounts
   */
  readonly mounts?: K0SmotronControlPlaneTemplateSpecTemplateSpecMounts[];

  /**
   * Persistence defines the persistence configuration. If empty k0smotron
   * will use emptyDir as a volume. See https://docs.k0smotron.io/stable/configuration/#persistence
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#persistence
   */
  readonly persistence?: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistence;

  /**
   * Replicas is the desired number of replicas of the k0s control planes.
   * If unspecified, defaults to 1. If the value is above 1, k0smotron requires kine datasource URL to be set.
   * Recommended value is 3.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#replicas
   */
  readonly replicas?: number;

  /**
   * Resources describes the compute resource requirements for the control plane pods.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#resources
   */
  readonly resources?: K0SmotronControlPlaneTemplateSpecTemplateSpecResources;

  /**
   * Service defines the service configuration.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#service
   */
  readonly service?: K0SmotronControlPlaneTemplateSpecTemplateSpecService;

  /**
   * ServiceAccount defines the service account to be used by both k0s and etcd StatefulSets.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * TopologySpreadConstraints will be passed directly to BOTH etcd and k0s pods.
   * See https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/ for more information.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraints[];

  /**
   * Version defines the k0s version to be deployed. If empty k0smotron
   * will pick it automatically.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpec#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpec(obj: K0SmotronControlPlaneTemplateSpecTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateRefs': obj.certificateRefs?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecCertificateRefs(y)),
    'controllerPlaneFlags': obj.controllerPlaneFlags?.map(y => y),
    'etcd': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecEtcd(obj.etcd),
    'externalAddress': obj.externalAddress,
    'image': obj.image,
    'k0sConfig': obj.k0SConfig,
    'kineDataSourceSecretName': obj.kineDataSourceSecretName,
    'kineDataSourceURL': obj.kineDataSourceUrl,
    'kubeconfigRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecKubeconfigRef(obj.kubeconfigRef),
    'manifests': obj.manifests?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifests(y)),
    'monitoring': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMonitoring(obj.monitoring),
    'mounts': obj.mounts?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMounts(y)),
    'persistence': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistence(obj.persistence),
    'replicas': obj.replicas,
    'resources': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecResources(obj.resources),
    'service': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecService(obj.service),
    'serviceAccount': obj.serviceAccount,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraints(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecCertificateRefs
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecCertificateRefs {
  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecCertificateRefs#name
   */
  readonly name?: string;

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecCertificateRefs#type
   */
  readonly type: K0SmotronControlPlaneTemplateSpecTemplateSpecCertificateRefsType;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecCertificateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecCertificateRefs(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecCertificateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Etcd defines the etcd configuration.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcd
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecEtcd {
  /**
   * Args defines the etcd arguments.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcd#args
   */
  readonly args?: string[];

  /**
   * AutoDeletePVCs defines whether the PVC should be deleted when the etcd cluster is deleted.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcd#autoDeletePVCs
   */
  readonly autoDeletePvCs?: boolean;

  /**
   * DefragJob defines the etcd defragmentation job configuration.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcd#defragJob
   */
  readonly defragJob?: K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdDefragJob;

  /**
   * Image defines the etcd image to be deployed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcd#image
   */
  readonly image: string;

  /**
   * Persistence defines the persistence configuration.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcd#persistence
   */
  readonly persistence?: K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistence;

  /**
   * Resources defines the compute resource requirements for the etcd container.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcd#resources
   */
  readonly resources?: K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResources;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecEtcd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecEtcd(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecEtcd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'autoDeletePVCs': obj.autoDeletePvCs,
    'defragJob': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdDefragJob(obj.defragJob),
    'image': obj.image,
    'persistence': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistence(obj.persistence),
    'resources': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResources(obj.resources),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KubeconfigRef is the reference to the kubeconfig of the hosting cluster.
 * This kubeconfig will be used to deploy the k0s control plane.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecKubeconfigRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecKubeconfigRef {
  /**
   * Key is the key in the secret containing the kubeconfig of the hosting cluster.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecKubeconfigRef#key
   */
  readonly key?: string;

  /**
   * Name is the name of the secret containing the kubeconfig of the hosting cluster.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecKubeconfigRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the secret containing the kubeconfig of the hosting cluster.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecKubeconfigRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecKubeconfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecKubeconfigRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecKubeconfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifests {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#azureDisk
   */
  readonly azureDisk?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#azureFile
   */
  readonly azureFile?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#cephfs
   */
  readonly cephfs?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#cinder
   */
  readonly cinder?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#configMap
   */
  readonly configMap?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#csi
   */
  readonly csi?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#downwardAPI
   */
  readonly downwardApi?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#emptyDir
   */
  readonly emptyDir?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#ephemeral
   */
  readonly ephemeral?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#fc
   */
  readonly fc?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#flexVolume
   */
  readonly flexVolume?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#flocker
   */
  readonly flocker?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#gcePersistentDisk
   */
  readonly gcePersistentDisk?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#gitRepo
   */
  readonly gitRepo?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#glusterfs
   */
  readonly glusterfs?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * ---
   * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
   * mount host directories as read/write.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#hostPath
   */
  readonly hostPath?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#iscsi
   */
  readonly iscsi?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi;

  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#nfs
   */
  readonly nfs?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#photonPersistentDisk
   */
  readonly photonPersistentDisk?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#portworxVolume
   */
  readonly portworxVolume?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#projected
   */
  readonly projected?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#quobyte
   */
  readonly quobyte?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#rbd
   */
  readonly rbd?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#scaleIO
   */
  readonly scaleIo?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#secret
   */
  readonly secret?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#storageos
   */
  readonly storageos?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifests#vsphereVolume
   */
  readonly vsphereVolume?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsVsphereVolume;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifests' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifests(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifests | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureDisk(obj.azureDisk),
    'azureFile': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureFile(obj.azureFile),
    'cephfs': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfs(obj.cephfs),
    'cinder': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinder(obj.cinder),
    'configMap': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMap(obj.configMap),
    'csi': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsi(obj.csi),
    'downwardAPI': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApi(obj.downwardApi),
    'emptyDir': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDir(obj.emptyDir),
    'ephemeral': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeral(obj.ephemeral),
    'fc': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFc(obj.fc),
    'flexVolume': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolume(obj.flexVolume),
    'flocker': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlocker(obj.flocker),
    'gcePersistentDisk': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGitRepo(obj.gitRepo),
    'glusterfs': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGlusterfs(obj.glusterfs),
    'hostPath': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsHostPath(obj.hostPath),
    'iscsi': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsNfs(obj.nfs),
    'persistentVolumeClaim': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPortworxVolume(obj.portworxVolume),
    'projected': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjected(obj.projected),
    'quobyte': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsQuobyte(obj.quobyte),
    'rbd': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbd(obj.rbd),
    'scaleIO': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo(obj.scaleIo),
    'secret': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecret(obj.secret),
    'storageos': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageos(obj.storageos),
    'vsphereVolume': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Monitoring defines the monitoring configuration.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMonitoring
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMonitoring {
  /**
   * Enabled enables prometheus sidecar that scrapes metrics from the child cluster system components and expose
   * them as usual kubernetes pod metrics.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMonitoring#enabled
   */
  readonly enabled: boolean;

  /**
   * PrometheusImage defines the image used for the prometheus sidecar.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMonitoring#prometheusImage
   */
  readonly prometheusImage: string;

  /**
   * ProxyImage defines the image used for the nginx proxy sidecar.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMonitoring#proxyImage
   */
  readonly proxyImage: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMonitoring' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMonitoring(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'prometheusImage': obj.prometheusImage,
    'proxyImage': obj.proxyImage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMounts {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#azureDisk
   */
  readonly azureDisk?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#azureFile
   */
  readonly azureFile?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#cephfs
   */
  readonly cephfs?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#cinder
   */
  readonly cinder?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#configMap
   */
  readonly configMap?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#csi
   */
  readonly csi?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#downwardAPI
   */
  readonly downwardApi?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#emptyDir
   */
  readonly emptyDir?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#ephemeral
   */
  readonly ephemeral?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#fc
   */
  readonly fc?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#flexVolume
   */
  readonly flexVolume?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#flocker
   */
  readonly flocker?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#gcePersistentDisk
   */
  readonly gcePersistentDisk?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#gitRepo
   */
  readonly gitRepo?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#glusterfs
   */
  readonly glusterfs?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * ---
   * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
   * mount host directories as read/write.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#hostPath
   */
  readonly hostPath?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#iscsi
   */
  readonly iscsi?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#nfs
   */
  readonly nfs?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsNfs;

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#path
   */
  readonly path: string;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#photonPersistentDisk
   */
  readonly photonPersistentDisk?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#portworxVolume
   */
  readonly portworxVolume?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#projected
   */
  readonly projected?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#quobyte
   */
  readonly quobyte?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#rbd
   */
  readonly rbd?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbd;

  /**
   * ReadOnly specifies whether the volume should be mounted as read-only. (default: false, except for ConfigMaps and Secrets)
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#scaleIO
   */
  readonly scaleIo?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#secret
   */
  readonly secret?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#storageos
   */
  readonly storageos?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMounts#vsphereVolume
   */
  readonly vsphereVolume?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsVsphereVolume;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMounts(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureDisk(obj.azureDisk),
    'azureFile': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureFile(obj.azureFile),
    'cephfs': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfs(obj.cephfs),
    'cinder': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinder(obj.cinder),
    'configMap': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMap(obj.configMap),
    'csi': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsi(obj.csi),
    'downwardAPI': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApi(obj.downwardApi),
    'emptyDir': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDir(obj.emptyDir),
    'ephemeral': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeral(obj.ephemeral),
    'fc': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFc(obj.fc),
    'flexVolume': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolume(obj.flexVolume),
    'flocker': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlocker(obj.flocker),
    'gcePersistentDisk': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGitRepo(obj.gitRepo),
    'glusterfs': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGlusterfs(obj.glusterfs),
    'hostPath': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsHostPath(obj.hostPath),
    'iscsi': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi(obj.iscsi),
    'nfs': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsNfs(obj.nfs),
    'path': obj.path,
    'persistentVolumeClaim': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPortworxVolume(obj.portworxVolume),
    'projected': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjected(obj.projected),
    'quobyte': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsQuobyte(obj.quobyte),
    'rbd': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbd(obj.rbd),
    'readOnly': obj.readOnly,
    'scaleIO': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo(obj.scaleIo),
    'secret': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecret(obj.secret),
    'storageos': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageos(obj.storageos),
    'vsphereVolume': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Persistence defines the persistence configuration. If empty k0smotron
 * will use emptyDir as a volume. See https://docs.k0smotron.io/stable/configuration/#persistence
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistence
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecPersistence {
  /**
   * AutoDeletePVCs defines whether the PVC should be deleted when the cluster is deleted.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistence#autoDeletePVCs
   */
  readonly autoDeletePvCs?: boolean;

  /**
   * HostPath defines the host path configuration. Will be used as is in case of .spec.persistence.type is hostPath.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistence#hostPath
   */
  readonly hostPath?: string;

  /**
   * PersistentVolumeClaim defines the PVC configuration. Will be used as is in case of .spec.persistence.type is pvc.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistence#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaim;

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistence#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecPersistence' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistence(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistence | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoDeletePVCs': obj.autoDeletePvCs,
    'hostPath': obj.hostPath,
    'persistentVolumeClaim': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaim(obj.persistentVolumeClaim),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources describes the compute resource requirements for the control plane pods.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecResources
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecResources#claims
   */
  readonly claims?: K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesRequests };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecResources(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service defines the service configuration.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecService
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecService {
  /**
   * Annotations defines extra annotations to be added to the service.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecService#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * APIPort defines the kubernetes API port. If empty k0smotron
   * will pick it automatically.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecService#apiPort
   */
  readonly apiPort?: number;

  /**
   * KonnectivityPort defines the konnectivity port. If empty k0smotron
   * will pick it automatically.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecService#konnectivityPort
   */
  readonly konnectivityPort?: number;

  /**
   * Labels defines extra labels to be added to the service.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecService#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * LoadBalancerClass defines the load balancer class to be used for the service. Used only when service type is LoadBalancer.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecService#loadBalancerClass
   */
  readonly loadBalancerClass?: string;

  /**
   * Service Type string describes ingress methods for a service
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecService#type
   */
  readonly type: K0SmotronControlPlaneTemplateSpecTemplateSpecServiceType;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecService' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecService(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'apiPort': obj.apiPort,
    'konnectivityPort': obj.konnectivityPort,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'loadBalancerClass': obj.loadBalancerClass,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraints
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraints(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecCertificateRefsType
 */
export enum K0SmotronControlPlaneTemplateSpecTemplateSpecCertificateRefsType {
  /** ca */
  CA = "ca",
  /** sa */
  SA = "sa",
  /** proxy */
  PROXY = "proxy",
  /** etcd */
  ETCD = "etcd",
  /** apiserver-etcd-client */
  APISERVER_HYPHEN_ETCD_HYPHEN_CLIENT = "apiserver-etcd-client",
  /** etcd-peer */
  ETCD_HYPHEN_PEER = "etcd-peer",
  /** etcd-server */
  ETCD_HYPHEN_SERVER = "etcd-server",
}

/**
 * DefragJob defines the etcd defragmentation job configuration.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdDefragJob
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdDefragJob {
  /**
   * Enabled enables the etcd defragmentation job.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdDefragJob#enabled
   */
  readonly enabled: boolean;

  /**
   * Image defines the etcd defragmentation job image.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdDefragJob#image
   */
  readonly image: string;

  /**
   * Rule defines the etcd defragmentation job defrag-rule.
   * For more information check: https://github.com/ahrtr/etcd-defrag/tree/main?tab=readme-ov-file#defragmentation-rule
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdDefragJob#rule
   */
  readonly rule: string;

  /**
   * Schedule defines the etcd defragmentation job schedule.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdDefragJob#schedule
   */
  readonly schedule: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdDefragJob' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdDefragJob(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdDefragJob | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'image': obj.image,
    'rule': obj.rule,
    'schedule': obj.schedule,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Persistence defines the persistence configuration.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistence
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistence {
  /**
   * Size defines the size of the etcd volume. Default: 1Gi
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistence#size
   */
  readonly size?: K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistenceSize;

  /**
   * StorageClass defines the storage class to be used for etcd persistence. If empty, will be used the default storage class.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistence#storageClass
   */
  readonly storageClass?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistence' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistence(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistence | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'size': obj.size?.value,
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources defines the compute resource requirements for the etcd container.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResources
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResources#claims
   */
  readonly claims?: K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResources#limits
   */
  readonly limits?: { [key: string]: K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResources#requests
   */
  readonly requests?: { [key: string]: K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesRequests };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResources(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAwsElasticBlockStore
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAwsElasticBlockStore(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureDisk
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureDisk(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureFile
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureFile(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfs
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfs#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfs(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinder
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinder#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinder(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMap
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMap#items
   */
  readonly items?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMap(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsi
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsi(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApi
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApi#items
   */
  readonly items?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItems[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApi(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDir
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDir#sizeLimit
   */
  readonly sizeLimit?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDir(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeral
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   *
   * Required, must not be nil.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeral(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFc
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFc(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolume
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolume#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolume(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlocker
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlocker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlocker(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGcePersistentDisk
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGcePersistentDisk(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGitRepo
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGitRepo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGitRepo(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGlusterfs
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGlusterfs(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 * ---
 * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
 * mount host directories as read/write.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsHostPath
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsHostPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsHostPath(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsNfs
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsNfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsNfs(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPersistentVolumeClaim
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPersistentVolumeClaim(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPhotonPersistentDisk
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPhotonPersistentDisk(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPortworxVolume
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPortworxVolume(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjected
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjected#sources
   */
  readonly sources?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSources[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjected' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjected(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsQuobyte
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsQuobyte' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsQuobyte(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbd
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbd#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbd(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo#secretRef
   */
  readonly secretRef: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecret
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecret#items
   */
  readonly items?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecret(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageos
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageos#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageos' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageos(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsVsphereVolume
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsVsphereVolume(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAwsElasticBlockStore
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAwsElasticBlockStore(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureDisk
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureDisk(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureFile
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureFile(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfs
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfs#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfs(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinder
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinder#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinder(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMap
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMap#items
   */
  readonly items?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMap(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsi
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsi(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApi
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApi#items
   */
  readonly items?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItems[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApi(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDir
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDir#sizeLimit
   */
  readonly sizeLimit?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDir(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeral
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   *
   * Required, must not be nil.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeral(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFc
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFc(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolume
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolume#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolume(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlocker
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlocker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlocker(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGcePersistentDisk
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGcePersistentDisk(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGitRepo
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGitRepo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGitRepo(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGlusterfs
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGlusterfs(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 * ---
 * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
 * mount host directories as read/write.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsHostPath
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsHostPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsHostPath(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsNfs
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsNfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsNfs(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPersistentVolumeClaim
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPersistentVolumeClaim(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPhotonPersistentDisk
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPhotonPersistentDisk(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPortworxVolume
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPortworxVolume(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjected
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjected#sources
   */
  readonly sources?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSources[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjected' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjected(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsQuobyte
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsQuobyte' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsQuobyte(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbd
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbd#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbd(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo#secretRef
   */
  readonly secretRef: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecret
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecret#items
   */
  readonly items?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecret(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageos
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageos#secretRef
   */
  readonly secretRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageos' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageos(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsVsphereVolume
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsVsphereVolume(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PersistentVolumeClaim defines the PVC configuration. Will be used as is in case of .spec.persistence.type is pvc.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaim
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaim {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaim#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaim#kind
   */
  readonly kind?: string;

  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaim#metadata
   */
  readonly metadata?: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimMetadata;

  /**
   * spec defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaim#spec
   */
  readonly spec?: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec;

  /**
   * status represents the current information/status of a persistent volume claim.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaim#status
   */
  readonly status?: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatus;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaim(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimMetadata(obj.metadata),
    'spec': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec(obj.spec),
    'status': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesClaims
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesClaims(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesLimits
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesLimits {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesLimits {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesLimits {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesRequests
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesRequests {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesRequests {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesRequests {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Service Type string describes ingress methods for a service
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecServiceType
 */
export enum K0SmotronControlPlaneTemplateSpecTemplateSpecServiceType {
  /** ClusterIP */
  CLUSTER_IP = "ClusterIP",
  /** NodePort */
  NODE_PORT = "NodePort",
  /** LoadBalancer */
  LOAD_BALANCER = "LoadBalancer",
}

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Size defines the size of the etcd volume. Default: 1Gi
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistenceSize
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistenceSize {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistenceSize {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistenceSize(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistenceSize {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdPersistenceSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesClaims
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesClaims(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesLimits
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesLimits {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesLimits {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesLimits(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesLimits {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesRequests
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesRequests {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesRequests {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesRequests(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesRequests {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecEtcdResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfsSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfsSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfsSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinderSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinderSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinderSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMapItems
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMapItems(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsiNodePublishSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsiNodePublishSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItems
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItems#fieldRef
   */
  readonly fieldRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItems(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDirSizeLimit
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDirSizeLimit {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDirSizeLimit {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDirSizeLimit {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 *
 * Required, must not be nil.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplate
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateMetadata;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplate(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolumeSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolumeSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsiSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsiSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsiSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSources
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSources#configMap
   */
  readonly configMap?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSources#downwardAPI
   */
  readonly downwardApi?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSources#secret
   */
  readonly secret?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSources(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterTrustBundle': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundle(obj.clusterTrustBundle),
    'configMap': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbdSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbdSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbdSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIoSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIoSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIoSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecretItems
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecretItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecretItems(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageosSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageosSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageosSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfsSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfsSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfsSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinderSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinderSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinderSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMapItems
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMapItems(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsiNodePublishSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsiNodePublishSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItems
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItems#fieldRef
   */
  readonly fieldRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItems(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDirSizeLimit
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDirSizeLimit {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDirSizeLimit {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDirSizeLimit {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 *
 * Required, must not be nil.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplate
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateMetadata;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplate(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolumeSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolumeSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsiSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsiSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsiSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSources
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSources#configMap
   */
  readonly configMap?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSources#downwardAPI
   */
  readonly downwardApi?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSources#secret
   */
  readonly secret?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSources(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterTrustBundle': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundle(obj.clusterTrustBundle),
    'configMap': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbdSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbdSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbdSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIoSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIoSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIoSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecretItems
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecretItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecretItems(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageosSecretRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageosSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageosSecretRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Standard object's metadata.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimMetadata
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimMetadata {
  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimMetadata#name
   */
  readonly name?: string;

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimMetadata(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * spec defines the desired characteristics of a volume requested by a pod author.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec#dataSource
   */
  readonly dataSource?: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec#dataSourceRef
   */
  readonly dataSourceRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec#resources
   */
  readonly resources?: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec#selector
   */
  readonly selector?: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResources(obj.resources),
    'selector': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * status represents the current information/status of a persistent volume claim.
 * Read-only.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatus
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   *
   * ClaimResourceStatus can be in any of following states:
   * - ControllerResizeInProgress:
   * State set when resize controller starts resizing the volume in control-plane.
   * - ControllerResizeFailed:
   * State set when resize has failed in resize controller with a terminal error.
   * - NodeResizePending:
   * State set when resize controller has finished resizing the volume but further resizing of
   * volume is needed on the node.
   * - NodeResizeInProgress:
   * State set when kubelet starts resizing the volume.
   * - NodeResizeFailed:
   * State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
   * NodeResizeFailed.
   * For example: if expanding a PVC for more capacity - this field can be one of the following states:
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
   * When this field is not set, it means that no resize operation is in progress for the given PVC.
   *
   *
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   *
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation
   * is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   *
   *
   * A controller that receives PVC update with previously unknown resourceName
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusAllocatedResources };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatus#capacity
   */
  readonly capacity?: { [key: string]: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusCapacity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'Resizing'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatus#conditions
   */
  readonly conditions?: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusConditions[];

  /**
   * currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
   * When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
   * This is an alpha field and requires enabling VolumeAttributesClass feature.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatus#currentVolumeAttributesClassName
   */
  readonly currentVolumeAttributesClassName?: string;

  /**
   * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
   * When this is unset, there is no ModifyVolume operation being attempted.
   * This is an alpha field and requires enabling VolumeAttributesClass feature.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatus#modifyVolumeStatus
   */
  readonly modifyVolumeStatus?: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus;

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatus#phase
   */
  readonly phase?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatus(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResourceStatuses': ((obj.allocatedResourceStatuses) === undefined) ? undefined : (Object.entries(obj.allocatedResourceStatuses).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusConditions(y)),
    'currentVolumeAttributesClassName': obj.currentVolumeAttributesClassName,
    'modifyVolumeStatus': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus(obj.modifyVolumeStatus),
    'phase': obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsFieldRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsFieldRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * May contain labels and annotations that will be copied into the PVC
 * when creating it. No other fields are allowed and will be rejected during
 * validation.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateMetadata
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateMetadata {
  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateMetadata(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundle
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundle(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector(obj.labelSelector),
    'name': obj.name,
    'optional': obj.optional,
    'path': obj.path,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMap
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMap#items
   */
  readonly items?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMap(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApi
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApi#items
   */
  readonly items?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApi(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecret
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecret#items
   */
  readonly items?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecret(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesServiceAccountToken
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesServiceAccountToken(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsFieldRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsFieldRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * May contain labels and annotations that will be copied into the PVC
 * when creating it. No other fields are allowed and will be rejected during
 * validation.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateMetadata
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateMetadata {
  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateMetadata(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundle
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundle(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelector(obj.labelSelector),
    'name': obj.name,
    'optional': obj.optional,
    'path': obj.path,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMap
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMap#items
   */
  readonly items?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMap(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApi
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApi#items
   */
  readonly items?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApi(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecret
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecret#items
   */
  readonly items?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Drop `kubebuilder:default` when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecret(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesServiceAccountToken
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesServiceAccountToken(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSource
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSource(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSourceRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSourceRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResources
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResources#limits
   */
  readonly limits?: { [key: string]: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResources#requests
   */
  readonly requests?: { [key: string]: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResourcesRequests };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResources(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelector
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelector#matchExpressions
   */
  readonly matchExpressions?: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelector(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusAllocatedResources
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusAllocatedResources {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusAllocatedResources {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusAllocatedResources(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusAllocatedResources {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusAllocatedResources(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusCapacity
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusCapacity {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusCapacity {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusCapacity(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusCapacity {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusConditions
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "Resizing" that means the underlying
   * persistent volume is being resized.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusConditions#status
   */
  readonly status: string;

  /**
   * PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusConditions#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusConditions(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
 * When this is unset, there is no ModifyVolume operation being attempted.
 * This is an alpha field and requires enabling VolumeAttributesClass feature.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus {
  /**
   * status is the status of the ControllerModifyVolume operation. It can be in any of following states:
   * - Pending
   * Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
   * the specified VolumeAttributesClass not existing.
   * - InProgress
   * InProgress indicates that the volume is being modified.
   * - Infeasible
   * Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
   * resolve the error, a valid VolumeAttributesClass needs to be specified.
   * Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus#status
   */
  readonly status: string;

  /**
   * targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus#targetVolumeAttributesClassName
   */
  readonly targetVolumeAttributesClassName?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimStatusModifyVolumeStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'targetVolumeAttributesClassName': obj.targetVolumeAttributesClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRefDivisor
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResources
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResources(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelector
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelector(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMapItems
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMapItems(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItems
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItems(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecretItems
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecretItems(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRefDivisor
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecMountsDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSource(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResources
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResources(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelector
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelector(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelector(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMapItems
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMapItems(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItems
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItems(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecretItems
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecretItems(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResourcesLimits
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResourcesLimits {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResourcesLimits {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResourcesLimits(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResourcesLimits {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResourcesRequests
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResourcesRequests {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResourcesRequests {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResourcesRequests(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResourcesRequests {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecPersistencePersistentVolumeClaimSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsFieldRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsFieldRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsFieldRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsFieldRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef(obj: K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecManifestsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new K0SmotronControlPlaneTemplateSpecTemplateSpecMountsProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

