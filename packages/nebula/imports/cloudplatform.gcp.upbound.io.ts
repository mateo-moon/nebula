// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ProjectIAMMember is the Schema for the ProjectIAMMembers API. <no value>
 *
 * @schema ProjectIAMMember
 */
export class ProjectIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProjectIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ProjectIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "ProjectIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectIamMemberProps): any {
    return {
      ...ProjectIamMember.GVK,
      ...toJson_ProjectIamMemberProps(props),
    };
  }

  /**
   * Defines a "ProjectIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectIamMemberProps) {
    super(scope, id, {
      ...ProjectIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProjectIamMember.GVK,
      ...toJson_ProjectIamMemberProps(resolved),
    };
  }
}

/**
 * ProjectIAMMember is the Schema for the ProjectIAMMembers API. <no value>
 *
 * @schema ProjectIAMMember
 */
export interface ProjectIamMemberProps {
  /**
   * @schema ProjectIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectIAMMemberSpec defines the desired state of ProjectIAMMember
   *
   * @schema ProjectIAMMember#spec
   */
  readonly spec: ProjectIamMemberSpec;
}

/**
 * Converts an object of type 'ProjectIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberProps(obj: ProjectIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProjectIAMMemberSpec defines the desired state of ProjectIAMMember
 *
 * @schema ProjectIamMemberSpec
 */
export interface ProjectIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectIamMemberSpecDeletionPolicy;

  /**
   * @schema ProjectIamMemberSpec#forProvider
   */
  readonly forProvider: ProjectIamMemberSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ProjectIamMemberSpec#initProvider
   */
  readonly initProvider?: ProjectIamMemberSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProjectIamMemberSpec#managementPolicies
   */
  readonly managementPolicies?: ProjectIamMemberSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ProjectIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectIamMemberSpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ProjectIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectIamMemberSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ProjectIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpec(obj: ProjectIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectIamMemberSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProjectIamMemberSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProjectIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_ProjectIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectIamMemberSpecDeletionPolicy
 */
export enum ProjectIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectIamMemberSpecForProvider
 */
export interface ProjectIamMemberSpecForProvider {
  /**
   * @schema ProjectIamMemberSpecForProvider#condition
   */
  readonly condition?: ProjectIamMemberSpecForProviderCondition[];

  /**
   * @schema ProjectIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema ProjectIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberSpecForProvider#projectRef
   */
  readonly projectRef?: ProjectIamMemberSpecForProviderProjectRef;

  /**
   * Selector for a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberSpecForProvider#projectSelector
   */
  readonly projectSelector?: ProjectIamMemberSpecForProviderProjectSelector;

  /**
   * @schema ProjectIamMemberSpecForProvider#role
   */
  readonly role?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecForProvider(obj: ProjectIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_ProjectIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'projectRef': toJson_ProjectIamMemberSpecForProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ProjectIamMemberSpecForProviderProjectSelector(obj.projectSelector),
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ProjectIamMemberSpecInitProvider
 */
export interface ProjectIamMemberSpecInitProvider {
  /**
   * @schema ProjectIamMemberSpecInitProvider#condition
   */
  readonly condition?: ProjectIamMemberSpecInitProviderCondition[];

  /**
   * @schema ProjectIamMemberSpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema ProjectIamMemberSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberSpecInitProvider#projectRef
   */
  readonly projectRef?: ProjectIamMemberSpecInitProviderProjectRef;

  /**
   * Selector for a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberSpecInitProvider#projectSelector
   */
  readonly projectSelector?: ProjectIamMemberSpecInitProviderProjectSelector;

  /**
   * @schema ProjectIamMemberSpecInitProvider#role
   */
  readonly role?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecInitProvider(obj: ProjectIamMemberSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_ProjectIamMemberSpecInitProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'projectRef': toJson_ProjectIamMemberSpecInitProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ProjectIamMemberSpecInitProviderProjectSelector(obj.projectSelector),
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ProjectIamMemberSpecManagementPolicies
 */
export enum ProjectIamMemberSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ProjectIamMemberSpecProviderConfigRef
 */
export interface ProjectIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectIamMemberSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecProviderConfigRef(obj: ProjectIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ProjectIamMemberSpecWriteConnectionSecretToRef
 */
export interface ProjectIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecWriteConnectionSecretToRef(obj: ProjectIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ProjectIamMemberSpecForProviderCondition
 */
export interface ProjectIamMemberSpecForProviderCondition {
  /**
   * @schema ProjectIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ProjectIamMemberSpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ProjectIamMemberSpecForProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecForProviderCondition(obj: ProjectIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberSpecForProviderProjectRef
 */
export interface ProjectIamMemberSpecForProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberSpecForProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberSpecForProviderProjectRef#policy
   */
  readonly policy?: ProjectIamMemberSpecForProviderProjectRefPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecForProviderProjectRef(obj: ProjectIamMemberSpecForProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberSpecForProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberSpecForProviderProjectSelector
 */
export interface ProjectIamMemberSpecForProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ProjectIamMemberSpecForProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectIamMemberSpecForProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectIamMemberSpecForProviderProjectSelector#policy
   */
  readonly policy?: ProjectIamMemberSpecForProviderProjectSelectorPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecForProviderProjectSelector(obj: ProjectIamMemberSpecForProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectIamMemberSpecForProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ProjectIamMemberSpecInitProviderCondition
 */
export interface ProjectIamMemberSpecInitProviderCondition {
  /**
   * @schema ProjectIamMemberSpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ProjectIamMemberSpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ProjectIamMemberSpecInitProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecInitProviderCondition(obj: ProjectIamMemberSpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectRef
 */
export interface ProjectIamMemberSpecInitProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectRef#policy
   */
  readonly policy?: ProjectIamMemberSpecInitProviderProjectRefPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecInitProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecInitProviderProjectRef(obj: ProjectIamMemberSpecInitProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberSpecInitProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectSelector
 */
export interface ProjectIamMemberSpecInitProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectSelector#policy
   */
  readonly policy?: ProjectIamMemberSpecInitProviderProjectSelectorPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecInitProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecInitProviderProjectSelector(obj: ProjectIamMemberSpecInitProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectIamMemberSpecInitProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberSpecProviderConfigRefPolicy
 */
export interface ProjectIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecProviderConfigRefPolicy(obj: ProjectIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberSpecForProviderProjectRefPolicy
 */
export interface ProjectIamMemberSpecForProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberSpecForProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberSpecForProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberSpecForProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberSpecForProviderProjectRefPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecForProviderProjectRefPolicy(obj: ProjectIamMemberSpecForProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectIamMemberSpecForProviderProjectSelectorPolicy
 */
export interface ProjectIamMemberSpecForProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberSpecForProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberSpecForProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberSpecForProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberSpecForProviderProjectSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecForProviderProjectSelectorPolicy(obj: ProjectIamMemberSpecForProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectRefPolicy
 */
export interface ProjectIamMemberSpecInitProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberSpecInitProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberSpecInitProviderProjectRefPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecInitProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecInitProviderProjectRefPolicy(obj: ProjectIamMemberSpecInitProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectSelectorPolicy
 */
export interface ProjectIamMemberSpecInitProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberSpecInitProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberSpecInitProviderProjectSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecInitProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecInitProviderProjectSelectorPolicy(obj: ProjectIamMemberSpecInitProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum ProjectIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum ProjectIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberSpecForProviderProjectRefPolicyResolution
 */
export enum ProjectIamMemberSpecForProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberSpecForProviderProjectRefPolicyResolve
 */
export enum ProjectIamMemberSpecForProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberSpecForProviderProjectSelectorPolicyResolution
 */
export enum ProjectIamMemberSpecForProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberSpecForProviderProjectSelectorPolicyResolve
 */
export enum ProjectIamMemberSpecForProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectRefPolicyResolution
 */
export enum ProjectIamMemberSpecInitProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectRefPolicyResolve
 */
export enum ProjectIamMemberSpecInitProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectSelectorPolicyResolution
 */
export enum ProjectIamMemberSpecInitProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectSelectorPolicyResolve
 */
export enum ProjectIamMemberSpecInitProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProjectIAMMember is the Schema for the ProjectIAMMembers API. <no value>
 *
 * @schema ProjectIAMMemberV1Beta2
 */
export class ProjectIamMemberV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProjectIAMMemberV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta2',
    kind: 'ProjectIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "ProjectIAMMemberV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectIamMemberV1Beta2Props): any {
    return {
      ...ProjectIamMemberV1Beta2.GVK,
      ...toJson_ProjectIamMemberV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ProjectIAMMemberV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectIamMemberV1Beta2Props) {
    super(scope, id, {
      ...ProjectIamMemberV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProjectIamMemberV1Beta2.GVK,
      ...toJson_ProjectIamMemberV1Beta2Props(resolved),
    };
  }
}

/**
 * ProjectIAMMember is the Schema for the ProjectIAMMembers API. <no value>
 *
 * @schema ProjectIAMMemberV1Beta2
 */
export interface ProjectIamMemberV1Beta2Props {
  /**
   * @schema ProjectIAMMemberV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectIAMMemberSpec defines the desired state of ProjectIAMMember
   *
   * @schema ProjectIAMMemberV1Beta2#spec
   */
  readonly spec: ProjectIamMemberV1Beta2Spec;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2Props(obj: ProjectIamMemberV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectIamMemberV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProjectIAMMemberSpec defines the desired state of ProjectIAMMember
 *
 * @schema ProjectIamMemberV1Beta2Spec
 */
export interface ProjectIamMemberV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectIamMemberV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectIamMemberV1Beta2SpecDeletionPolicy;

  /**
   * @schema ProjectIamMemberV1Beta2Spec#forProvider
   */
  readonly forProvider: ProjectIamMemberV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ProjectIamMemberV1Beta2Spec#initProvider
   */
  readonly initProvider?: ProjectIamMemberV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProjectIamMemberV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: ProjectIamMemberV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ProjectIamMemberV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectIamMemberV1Beta2SpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ProjectIamMemberV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2Spec(obj: ProjectIamMemberV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectIamMemberV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_ProjectIamMemberV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProjectIamMemberV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectIamMemberV1Beta2SpecDeletionPolicy
 */
export enum ProjectIamMemberV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectIamMemberV1Beta2SpecForProvider
 */
export interface ProjectIamMemberV1Beta2SpecForProvider {
  /**
   * @schema ProjectIamMemberV1Beta2SpecForProvider#condition
   */
  readonly condition?: ProjectIamMemberV1Beta2SpecForProviderCondition;

  /**
   * @schema ProjectIamMemberV1Beta2SpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema ProjectIamMemberV1Beta2SpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProvider#projectRef
   */
  readonly projectRef?: ProjectIamMemberV1Beta2SpecForProviderProjectRef;

  /**
   * Selector for a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProvider#projectSelector
   */
  readonly projectSelector?: ProjectIamMemberV1Beta2SpecForProviderProjectSelector;

  /**
   * @schema ProjectIamMemberV1Beta2SpecForProvider#role
   */
  readonly role?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecForProvider(obj: ProjectIamMemberV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': toJson_ProjectIamMemberV1Beta2SpecForProviderCondition(obj.condition),
    'member': obj.member,
    'project': obj.project,
    'projectRef': toJson_ProjectIamMemberV1Beta2SpecForProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ProjectIamMemberV1Beta2SpecForProviderProjectSelector(obj.projectSelector),
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProvider
 */
export interface ProjectIamMemberV1Beta2SpecInitProvider {
  /**
   * @schema ProjectIamMemberV1Beta2SpecInitProvider#condition
   */
  readonly condition?: ProjectIamMemberV1Beta2SpecInitProviderCondition;

  /**
   * @schema ProjectIamMemberV1Beta2SpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema ProjectIamMemberV1Beta2SpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProvider#projectRef
   */
  readonly projectRef?: ProjectIamMemberV1Beta2SpecInitProviderProjectRef;

  /**
   * Selector for a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProvider#projectSelector
   */
  readonly projectSelector?: ProjectIamMemberV1Beta2SpecInitProviderProjectSelector;

  /**
   * @schema ProjectIamMemberV1Beta2SpecInitProvider#role
   */
  readonly role?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecInitProvider(obj: ProjectIamMemberV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': toJson_ProjectIamMemberV1Beta2SpecInitProviderCondition(obj.condition),
    'member': obj.member,
    'project': obj.project,
    'projectRef': toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectSelector(obj.projectSelector),
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ProjectIamMemberV1Beta2SpecManagementPolicies
 */
export enum ProjectIamMemberV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ProjectIamMemberV1Beta2SpecProviderConfigRef
 */
export interface ProjectIamMemberV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecProviderConfigRef(obj: ProjectIamMemberV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef
 */
export interface ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef(obj: ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ProjectIamMemberV1Beta2SpecForProviderCondition
 */
export interface ProjectIamMemberV1Beta2SpecForProviderCondition {
  /**
   * @schema ProjectIamMemberV1Beta2SpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ProjectIamMemberV1Beta2SpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ProjectIamMemberV1Beta2SpecForProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecForProviderCondition(obj: ProjectIamMemberV1Beta2SpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRef
 */
export interface ProjectIamMemberV1Beta2SpecForProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRef#policy
   */
  readonly policy?: ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecForProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecForProviderProjectRef(obj: ProjectIamMemberV1Beta2SpecForProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelector
 */
export interface ProjectIamMemberV1Beta2SpecForProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelector#policy
   */
  readonly policy?: ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecForProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecForProviderProjectSelector(obj: ProjectIamMemberV1Beta2SpecForProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ProjectIamMemberV1Beta2SpecInitProviderCondition
 */
export interface ProjectIamMemberV1Beta2SpecInitProviderCondition {
  /**
   * @schema ProjectIamMemberV1Beta2SpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ProjectIamMemberV1Beta2SpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ProjectIamMemberV1Beta2SpecInitProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecInitProviderCondition(obj: ProjectIamMemberV1Beta2SpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRef
 */
export interface ProjectIamMemberV1Beta2SpecInitProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRef#policy
   */
  readonly policy?: ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecInitProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectRef(obj: ProjectIamMemberV1Beta2SpecInitProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelector
 */
export interface ProjectIamMemberV1Beta2SpecInitProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelector#policy
   */
  readonly policy?: ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecInitProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectSelector(obj: ProjectIamMemberV1Beta2SpecInitProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy
 */
export interface ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberV1Beta2SpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy(obj: ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy
 */
export interface ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy(obj: ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy
 */
export interface ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy(obj: ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy
 */
export interface ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy(obj: ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy
 */
export interface ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy(obj: ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum ProjectIamMemberV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum ProjectIamMemberV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicyResolution
 */
export enum ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicyResolve
 */
export enum ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicyResolution
 */
export enum ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicyResolve
 */
export enum ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicyResolution
 */
export enum ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicyResolve
 */
export enum ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicyResolution
 */
export enum ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicyResolve
 */
export enum ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServiceAccount is the Schema for the ServiceAccounts API. Allows management of a Google Cloud Platform service account.
 *
 * @schema ServiceAccount
 */
export class ServiceAccount extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceAccount"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ServiceAccount',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceAccount".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceAccountProps): any {
    return {
      ...ServiceAccount.GVK,
      ...toJson_ServiceAccountProps(props),
    };
  }

  /**
   * Defines a "ServiceAccount" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceAccountProps) {
    super(scope, id, {
      ...ServiceAccount.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceAccount.GVK,
      ...toJson_ServiceAccountProps(resolved),
    };
  }
}

/**
 * ServiceAccount is the Schema for the ServiceAccounts API. Allows management of a Google Cloud Platform service account.
 *
 * @schema ServiceAccount
 */
export interface ServiceAccountProps {
  /**
   * @schema ServiceAccount#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceAccountSpec defines the desired state of ServiceAccount
   *
   * @schema ServiceAccount#spec
   */
  readonly spec: ServiceAccountSpec;
}

/**
 * Converts an object of type 'ServiceAccountProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountProps(obj: ServiceAccountProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceAccountSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceAccountSpec defines the desired state of ServiceAccount
 *
 * @schema ServiceAccountSpec
 */
export interface ServiceAccountSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceAccountSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceAccountSpecDeletionPolicy;

  /**
   * @schema ServiceAccountSpec#forProvider
   */
  readonly forProvider: ServiceAccountSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ServiceAccountSpec#initProvider
   */
  readonly initProvider?: ServiceAccountSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServiceAccountSpec#managementPolicies
   */
  readonly managementPolicies?: ServiceAccountSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ServiceAccountSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceAccountSpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ServiceAccountSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceAccountSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ServiceAccountSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpec(obj: ServiceAccountSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceAccountSpecForProvider(obj.forProvider),
    'initProvider': toJson_ServiceAccountSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServiceAccountSpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_ServiceAccountSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceAccountSpecDeletionPolicy
 */
export enum ServiceAccountSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceAccountSpecForProvider
 */
export interface ServiceAccountSpecForProvider {
  /**
   * If set to true, skip service account creation if a service account with the same email already exists.
   *
   * @schema ServiceAccountSpecForProvider#createIgnoreAlreadyExists
   */
  readonly createIgnoreAlreadyExists?: boolean;

  /**
   * A text description of the service account.
   * Must be less than or equal to 256 UTF-8 bytes.
   *
   * @schema ServiceAccountSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether a service account is disabled or not. Defaults to false. This field has no effect during creation.
   * Must be set after creation to disable a service account.
   *
   * @default false. This field has no effect during creation.
   * @schema ServiceAccountSpecForProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * The display name for the service account.
   * Can be updated without creating a new resource.
   *
   * @schema ServiceAccountSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The ID of the project that the service account will be created in.
   * Defaults to the provider project configuration.
   *
   * @default the provider project configuration.
   * @schema ServiceAccountSpecForProvider#project
   */
  readonly project?: string;
}

/**
 * Converts an object of type 'ServiceAccountSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpecForProvider(obj: ServiceAccountSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createIgnoreAlreadyExists': obj.createIgnoreAlreadyExists,
    'description': obj.description,
    'disabled': obj.disabled,
    'displayName': obj.displayName,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ServiceAccountSpecInitProvider
 */
export interface ServiceAccountSpecInitProvider {
  /**
   * If set to true, skip service account creation if a service account with the same email already exists.
   *
   * @schema ServiceAccountSpecInitProvider#createIgnoreAlreadyExists
   */
  readonly createIgnoreAlreadyExists?: boolean;

  /**
   * A text description of the service account.
   * Must be less than or equal to 256 UTF-8 bytes.
   *
   * @schema ServiceAccountSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Whether a service account is disabled or not. Defaults to false. This field has no effect during creation.
   * Must be set after creation to disable a service account.
   *
   * @default false. This field has no effect during creation.
   * @schema ServiceAccountSpecInitProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * The display name for the service account.
   * Can be updated without creating a new resource.
   *
   * @schema ServiceAccountSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The ID of the project that the service account will be created in.
   * Defaults to the provider project configuration.
   *
   * @default the provider project configuration.
   * @schema ServiceAccountSpecInitProvider#project
   */
  readonly project?: string;
}

/**
 * Converts an object of type 'ServiceAccountSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpecInitProvider(obj: ServiceAccountSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createIgnoreAlreadyExists': obj.createIgnoreAlreadyExists,
    'description': obj.description,
    'disabled': obj.disabled,
    'displayName': obj.displayName,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ServiceAccountSpecManagementPolicies
 */
export enum ServiceAccountSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ServiceAccountSpecProviderConfigRef
 */
export interface ServiceAccountSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceAccountSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpecProviderConfigRef(obj: ServiceAccountSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ServiceAccountSpecWriteConnectionSecretToRef
 */
export interface ServiceAccountSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceAccountSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceAccountSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ServiceAccountSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpecWriteConnectionSecretToRef(obj: ServiceAccountSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountSpecProviderConfigRefPolicy
 */
export interface ServiceAccountSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpecProviderConfigRefPolicy(obj: ServiceAccountSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountSpecProviderConfigRefPolicyResolution
 */
export enum ServiceAccountSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountSpecProviderConfigRefPolicyResolve
 */
export enum ServiceAccountSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServiceAccountIAMMember is the Schema for the ServiceAccountIAMMembers API. <no value>
 *
 * @schema ServiceAccountIAMMember
 */
export class ServiceAccountIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceAccountIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ServiceAccountIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceAccountIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceAccountIamMemberProps): any {
    return {
      ...ServiceAccountIamMember.GVK,
      ...toJson_ServiceAccountIamMemberProps(props),
    };
  }

  /**
   * Defines a "ServiceAccountIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceAccountIamMemberProps) {
    super(scope, id, {
      ...ServiceAccountIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceAccountIamMember.GVK,
      ...toJson_ServiceAccountIamMemberProps(resolved),
    };
  }
}

/**
 * ServiceAccountIAMMember is the Schema for the ServiceAccountIAMMembers API. <no value>
 *
 * @schema ServiceAccountIAMMember
 */
export interface ServiceAccountIamMemberProps {
  /**
   * @schema ServiceAccountIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceAccountIAMMemberSpec defines the desired state of ServiceAccountIAMMember
   *
   * @schema ServiceAccountIAMMember#spec
   */
  readonly spec: ServiceAccountIamMemberSpec;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberProps(obj: ServiceAccountIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceAccountIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceAccountIAMMemberSpec defines the desired state of ServiceAccountIAMMember
 *
 * @schema ServiceAccountIamMemberSpec
 */
export interface ServiceAccountIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceAccountIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceAccountIamMemberSpecDeletionPolicy;

  /**
   * @schema ServiceAccountIamMemberSpec#forProvider
   */
  readonly forProvider: ServiceAccountIamMemberSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ServiceAccountIamMemberSpec#initProvider
   */
  readonly initProvider?: ServiceAccountIamMemberSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServiceAccountIamMemberSpec#managementPolicies
   */
  readonly managementPolicies?: ServiceAccountIamMemberSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ServiceAccountIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceAccountIamMemberSpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ServiceAccountIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceAccountIamMemberSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpec(obj: ServiceAccountIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceAccountIamMemberSpecForProvider(obj.forProvider),
    'initProvider': toJson_ServiceAccountIamMemberSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServiceAccountIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_ServiceAccountIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceAccountIamMemberSpecDeletionPolicy
 */
export enum ServiceAccountIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceAccountIamMemberSpecForProvider
 */
export interface ServiceAccountIamMemberSpecForProvider {
  /**
   * @schema ServiceAccountIamMemberSpecForProvider#condition
   */
  readonly condition?: ServiceAccountIamMemberSpecForProviderCondition[];

  /**
   * @schema ServiceAccountIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema ServiceAccountIamMemberSpecForProvider#role
   */
  readonly role?: string;

  /**
   * @schema ServiceAccountIamMemberSpecForProvider#serviceAccountId
   */
  readonly serviceAccountId?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberSpecForProvider#serviceAccountIdRef
   */
  readonly serviceAccountIdRef?: ServiceAccountIamMemberSpecForProviderServiceAccountIdRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberSpecForProvider#serviceAccountIdSelector
   */
  readonly serviceAccountIdSelector?: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecForProvider(obj: ServiceAccountIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_ServiceAccountIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'role': obj.role,
    'serviceAccountId': obj.serviceAccountId,
    'serviceAccountIdRef': toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdRef(obj.serviceAccountIdRef),
    'serviceAccountIdSelector': toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector(obj.serviceAccountIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ServiceAccountIamMemberSpecInitProvider
 */
export interface ServiceAccountIamMemberSpecInitProvider {
  /**
   * @schema ServiceAccountIamMemberSpecInitProvider#condition
   */
  readonly condition?: ServiceAccountIamMemberSpecInitProviderCondition[];

  /**
   * @schema ServiceAccountIamMemberSpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema ServiceAccountIamMemberSpecInitProvider#role
   */
  readonly role?: string;

  /**
   * @schema ServiceAccountIamMemberSpecInitProvider#serviceAccountId
   */
  readonly serviceAccountId?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberSpecInitProvider#serviceAccountIdRef
   */
  readonly serviceAccountIdRef?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberSpecInitProvider#serviceAccountIdSelector
   */
  readonly serviceAccountIdSelector?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecInitProvider(obj: ServiceAccountIamMemberSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_ServiceAccountIamMemberSpecInitProviderCondition(y)),
    'member': obj.member,
    'role': obj.role,
    'serviceAccountId': obj.serviceAccountId,
    'serviceAccountIdRef': toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef(obj.serviceAccountIdRef),
    'serviceAccountIdSelector': toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector(obj.serviceAccountIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ServiceAccountIamMemberSpecManagementPolicies
 */
export enum ServiceAccountIamMemberSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ServiceAccountIamMemberSpecProviderConfigRef
 */
export interface ServiceAccountIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceAccountIamMemberSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecProviderConfigRef(obj: ServiceAccountIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ServiceAccountIamMemberSpecWriteConnectionSecretToRef
 */
export interface ServiceAccountIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceAccountIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceAccountIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecWriteConnectionSecretToRef(obj: ServiceAccountIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ServiceAccountIamMemberSpecForProviderCondition
 */
export interface ServiceAccountIamMemberSpecForProviderCondition {
  /**
   * @schema ServiceAccountIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ServiceAccountIamMemberSpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ServiceAccountIamMemberSpecForProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecForProviderCondition(obj: ServiceAccountIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRef
 */
export interface ServiceAccountIamMemberSpecForProviderServiceAccountIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRef#policy
   */
  readonly policy?: ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProviderServiceAccountIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdRef(obj: ServiceAccountIamMemberSpecForProviderServiceAccountIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector
 */
export interface ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector#policy
   */
  readonly policy?: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector(obj: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ServiceAccountIamMemberSpecInitProviderCondition
 */
export interface ServiceAccountIamMemberSpecInitProviderCondition {
  /**
   * @schema ServiceAccountIamMemberSpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ServiceAccountIamMemberSpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ServiceAccountIamMemberSpecInitProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecInitProviderCondition(obj: ServiceAccountIamMemberSpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef
 */
export interface ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef#policy
   */
  readonly policy?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef(obj: ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector
 */
export interface ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector#policy
   */
  readonly policy?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector(obj: ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberSpecProviderConfigRefPolicy
 */
export interface ServiceAccountIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecProviderConfigRefPolicy(obj: ServiceAccountIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy
 */
export interface ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy(obj: ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy
 */
export interface ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy(obj: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy
 */
export interface ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy(obj: ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy
 */
export interface ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy(obj: ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum ServiceAccountIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum ServiceAccountIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolution
 */
export enum ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolve
 */
export enum ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolution
 */
export enum ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolve
 */
export enum ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicyResolution
 */
export enum ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicyResolve
 */
export enum ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicyResolution
 */
export enum ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicyResolve
 */
export enum ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServiceAccountIAMMember is the Schema for the ServiceAccountIAMMembers API. <no value>
 *
 * @schema ServiceAccountIAMMemberV1Beta2
 */
export class ServiceAccountIamMemberV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceAccountIAMMemberV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta2',
    kind: 'ServiceAccountIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceAccountIAMMemberV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceAccountIamMemberV1Beta2Props): any {
    return {
      ...ServiceAccountIamMemberV1Beta2.GVK,
      ...toJson_ServiceAccountIamMemberV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ServiceAccountIAMMemberV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceAccountIamMemberV1Beta2Props) {
    super(scope, id, {
      ...ServiceAccountIamMemberV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceAccountIamMemberV1Beta2.GVK,
      ...toJson_ServiceAccountIamMemberV1Beta2Props(resolved),
    };
  }
}

/**
 * ServiceAccountIAMMember is the Schema for the ServiceAccountIAMMembers API. <no value>
 *
 * @schema ServiceAccountIAMMemberV1Beta2
 */
export interface ServiceAccountIamMemberV1Beta2Props {
  /**
   * @schema ServiceAccountIAMMemberV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceAccountIAMMemberSpec defines the desired state of ServiceAccountIAMMember
   *
   * @schema ServiceAccountIAMMemberV1Beta2#spec
   */
  readonly spec: ServiceAccountIamMemberV1Beta2Spec;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2Props(obj: ServiceAccountIamMemberV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceAccountIamMemberV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceAccountIAMMemberSpec defines the desired state of ServiceAccountIAMMember
 *
 * @schema ServiceAccountIamMemberV1Beta2Spec
 */
export interface ServiceAccountIamMemberV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceAccountIamMemberV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceAccountIamMemberV1Beta2SpecDeletionPolicy;

  /**
   * @schema ServiceAccountIamMemberV1Beta2Spec#forProvider
   */
  readonly forProvider: ServiceAccountIamMemberV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ServiceAccountIamMemberV1Beta2Spec#initProvider
   */
  readonly initProvider?: ServiceAccountIamMemberV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServiceAccountIamMemberV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: ServiceAccountIamMemberV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ServiceAccountIamMemberV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceAccountIamMemberV1Beta2SpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ServiceAccountIamMemberV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2Spec(obj: ServiceAccountIamMemberV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceAccountIamMemberV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_ServiceAccountIamMemberV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServiceAccountIamMemberV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecDeletionPolicy
 */
export enum ServiceAccountIamMemberV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceAccountIamMemberV1Beta2SpecForProvider
 */
export interface ServiceAccountIamMemberV1Beta2SpecForProvider {
  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecForProvider#condition
   */
  readonly condition?: ServiceAccountIamMemberV1Beta2SpecForProviderCondition;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecForProvider#role
   */
  readonly role?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecForProvider#serviceAccountId
   */
  readonly serviceAccountId?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProvider#serviceAccountIdRef
   */
  readonly serviceAccountIdRef?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProvider#serviceAccountIdSelector
   */
  readonly serviceAccountIdSelector?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecForProvider(obj: ServiceAccountIamMemberV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': toJson_ServiceAccountIamMemberV1Beta2SpecForProviderCondition(obj.condition),
    'member': obj.member,
    'role': obj.role,
    'serviceAccountId': obj.serviceAccountId,
    'serviceAccountIdRef': toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef(obj.serviceAccountIdRef),
    'serviceAccountIdSelector': toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector(obj.serviceAccountIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProvider
 */
export interface ServiceAccountIamMemberV1Beta2SpecInitProvider {
  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProvider#condition
   */
  readonly condition?: ServiceAccountIamMemberV1Beta2SpecInitProviderCondition;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProvider#role
   */
  readonly role?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProvider#serviceAccountId
   */
  readonly serviceAccountId?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProvider#serviceAccountIdRef
   */
  readonly serviceAccountIdRef?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProvider#serviceAccountIdSelector
   */
  readonly serviceAccountIdSelector?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecInitProvider(obj: ServiceAccountIamMemberV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderCondition(obj.condition),
    'member': obj.member,
    'role': obj.role,
    'serviceAccountId': obj.serviceAccountId,
    'serviceAccountIdRef': toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef(obj.serviceAccountIdRef),
    'serviceAccountIdSelector': toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector(obj.serviceAccountIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecManagementPolicies
 */
export enum ServiceAccountIamMemberV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRef
 */
export interface ServiceAccountIamMemberV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecProviderConfigRef(obj: ServiceAccountIamMemberV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef
 */
export interface ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef(obj: ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderCondition
 */
export interface ServiceAccountIamMemberV1Beta2SpecForProviderCondition {
  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecForProviderCondition(obj: ServiceAccountIamMemberV1Beta2SpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef
 */
export interface ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef#policy
   */
  readonly policy?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef(obj: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector
 */
export interface ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector#policy
   */
  readonly policy?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector(obj: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderCondition
 */
export interface ServiceAccountIamMemberV1Beta2SpecInitProviderCondition {
  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderCondition(obj: ServiceAccountIamMemberV1Beta2SpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef
 */
export interface ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef#policy
   */
  readonly policy?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef(obj: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector
 */
export interface ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector#policy
   */
  readonly policy?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector(obj: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy
 */
export interface ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy(obj: ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy
 */
export interface ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy(obj: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy
 */
export interface ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy(obj: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy
 */
export interface ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy(obj: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy
 */
export interface ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy(obj: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicyResolution
 */
export enum ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicyResolve
 */
export enum ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicyResolution
 */
export enum ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicyResolve
 */
export enum ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicyResolution
 */
export enum ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicyResolve
 */
export enum ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicyResolution
 */
export enum ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicyResolve
 */
export enum ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServiceAccountKey is the Schema for the ServiceAccountKeys API. Allows management of a Google Cloud Platform service account Key
 *
 * @schema ServiceAccountKey
 */
export class ServiceAccountKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceAccountKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ServiceAccountKey',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceAccountKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceAccountKeyProps): any {
    return {
      ...ServiceAccountKey.GVK,
      ...toJson_ServiceAccountKeyProps(props),
    };
  }

  /**
   * Defines a "ServiceAccountKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceAccountKeyProps) {
    super(scope, id, {
      ...ServiceAccountKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceAccountKey.GVK,
      ...toJson_ServiceAccountKeyProps(resolved),
    };
  }
}

/**
 * ServiceAccountKey is the Schema for the ServiceAccountKeys API. Allows management of a Google Cloud Platform service account Key
 *
 * @schema ServiceAccountKey
 */
export interface ServiceAccountKeyProps {
  /**
   * @schema ServiceAccountKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceAccountKeySpec defines the desired state of ServiceAccountKey
   *
   * @schema ServiceAccountKey#spec
   */
  readonly spec: ServiceAccountKeySpec;
}

/**
 * Converts an object of type 'ServiceAccountKeyProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountKeyProps(obj: ServiceAccountKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceAccountKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceAccountKeySpec defines the desired state of ServiceAccountKey
 *
 * @schema ServiceAccountKeySpec
 */
export interface ServiceAccountKeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceAccountKeySpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceAccountKeySpecDeletionPolicy;

  /**
   * @schema ServiceAccountKeySpec#forProvider
   */
  readonly forProvider: ServiceAccountKeySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ServiceAccountKeySpec#initProvider
   */
  readonly initProvider?: ServiceAccountKeySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServiceAccountKeySpec#managementPolicies
   */
  readonly managementPolicies?: ServiceAccountKeySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ServiceAccountKeySpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceAccountKeySpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ServiceAccountKeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceAccountKeySpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ServiceAccountKeySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountKeySpec(obj: ServiceAccountKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceAccountKeySpecForProvider(obj.forProvider),
    'initProvider': toJson_ServiceAccountKeySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServiceAccountKeySpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_ServiceAccountKeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceAccountKeySpecDeletionPolicy
 */
export enum ServiceAccountKeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceAccountKeySpecForProvider
 */
export interface ServiceAccountKeySpecForProvider {
  /**
   * Arbitrary map of values that, when changed, will trigger a new key to be generated.
   *
   * @schema ServiceAccountKeySpecForProvider#keepers
   */
  readonly keepers?: { [key: string]: string };

  /**
   * The algorithm used to generate the key. KEY_ALG_RSA_2048 is the default algorithm.
   * Valid values are listed at
   * ServiceAccountPrivateKeyType
   * (only used on create)
   *
   * @schema ServiceAccountKeySpecForProvider#keyAlgorithm
   */
  readonly keyAlgorithm?: string;

  /**
   * The output format of the private key. TYPE_GOOGLE_CREDENTIALS_FILE is the default output format.
   *
   * @schema ServiceAccountKeySpecForProvider#privateKeyType
   */
  readonly privateKeyType?: string;

  /**
   * Public key data to create a service account key for given service account. The expected format for this field is a base64 encoded X509_PEM and it conflicts with public_key_type and private_key_type.
   *
   * @schema ServiceAccountKeySpecForProvider#publicKeyData
   */
  readonly publicKeyData?: string;

  /**
   * The output format of the public key requested. TYPE_X509_PEM_FILE is the default output format.
   *
   * @schema ServiceAccountKeySpecForProvider#publicKeyType
   */
  readonly publicKeyType?: string;

  /**
   * The Service account id of the Key. This can be a string in the format
   * {ACCOUNT} or projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}. If the {ACCOUNT}-only syntax is used, either
   * the full email address of the service account or its name can be specified as a value, in which case the project will
   * automatically be inferred from the account. Otherwise, if the projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}
   * syntax is used, the {ACCOUNT} specified can be the full email address of the service account or the service account's
   * unique id. Substituting - as a wildcard for the {PROJECT_ID} will infer the project from the account.
   *
   * @schema ServiceAccountKeySpecForProvider#serviceAccountId
   */
  readonly serviceAccountId?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountKeySpecForProvider#serviceAccountIdRef
   */
  readonly serviceAccountIdRef?: ServiceAccountKeySpecForProviderServiceAccountIdRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountKeySpecForProvider#serviceAccountIdSelector
   */
  readonly serviceAccountIdSelector?: ServiceAccountKeySpecForProviderServiceAccountIdSelector;
}

/**
 * Converts an object of type 'ServiceAccountKeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountKeySpecForProvider(obj: ServiceAccountKeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keepers': ((obj.keepers) === undefined) ? undefined : (Object.entries(obj.keepers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'keyAlgorithm': obj.keyAlgorithm,
    'privateKeyType': obj.privateKeyType,
    'publicKeyData': obj.publicKeyData,
    'publicKeyType': obj.publicKeyType,
    'serviceAccountId': obj.serviceAccountId,
    'serviceAccountIdRef': toJson_ServiceAccountKeySpecForProviderServiceAccountIdRef(obj.serviceAccountIdRef),
    'serviceAccountIdSelector': toJson_ServiceAccountKeySpecForProviderServiceAccountIdSelector(obj.serviceAccountIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ServiceAccountKeySpecInitProvider
 */
export interface ServiceAccountKeySpecInitProvider {
  /**
   * Arbitrary map of values that, when changed, will trigger a new key to be generated.
   *
   * @schema ServiceAccountKeySpecInitProvider#keepers
   */
  readonly keepers?: { [key: string]: string };

  /**
   * The algorithm used to generate the key. KEY_ALG_RSA_2048 is the default algorithm.
   * Valid values are listed at
   * ServiceAccountPrivateKeyType
   * (only used on create)
   *
   * @schema ServiceAccountKeySpecInitProvider#keyAlgorithm
   */
  readonly keyAlgorithm?: string;

  /**
   * The output format of the private key. TYPE_GOOGLE_CREDENTIALS_FILE is the default output format.
   *
   * @schema ServiceAccountKeySpecInitProvider#privateKeyType
   */
  readonly privateKeyType?: string;

  /**
   * Public key data to create a service account key for given service account. The expected format for this field is a base64 encoded X509_PEM and it conflicts with public_key_type and private_key_type.
   *
   * @schema ServiceAccountKeySpecInitProvider#publicKeyData
   */
  readonly publicKeyData?: string;

  /**
   * The output format of the public key requested. TYPE_X509_PEM_FILE is the default output format.
   *
   * @schema ServiceAccountKeySpecInitProvider#publicKeyType
   */
  readonly publicKeyType?: string;

  /**
   * The Service account id of the Key. This can be a string in the format
   * {ACCOUNT} or projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}. If the {ACCOUNT}-only syntax is used, either
   * the full email address of the service account or its name can be specified as a value, in which case the project will
   * automatically be inferred from the account. Otherwise, if the projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}
   * syntax is used, the {ACCOUNT} specified can be the full email address of the service account or the service account's
   * unique id. Substituting - as a wildcard for the {PROJECT_ID} will infer the project from the account.
   *
   * @schema ServiceAccountKeySpecInitProvider#serviceAccountId
   */
  readonly serviceAccountId?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountKeySpecInitProvider#serviceAccountIdRef
   */
  readonly serviceAccountIdRef?: ServiceAccountKeySpecInitProviderServiceAccountIdRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountKeySpecInitProvider#serviceAccountIdSelector
   */
  readonly serviceAccountIdSelector?: ServiceAccountKeySpecInitProviderServiceAccountIdSelector;
}

/**
 * Converts an object of type 'ServiceAccountKeySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountKeySpecInitProvider(obj: ServiceAccountKeySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keepers': ((obj.keepers) === undefined) ? undefined : (Object.entries(obj.keepers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'keyAlgorithm': obj.keyAlgorithm,
    'privateKeyType': obj.privateKeyType,
    'publicKeyData': obj.publicKeyData,
    'publicKeyType': obj.publicKeyType,
    'serviceAccountId': obj.serviceAccountId,
    'serviceAccountIdRef': toJson_ServiceAccountKeySpecInitProviderServiceAccountIdRef(obj.serviceAccountIdRef),
    'serviceAccountIdSelector': toJson_ServiceAccountKeySpecInitProviderServiceAccountIdSelector(obj.serviceAccountIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ServiceAccountKeySpecManagementPolicies
 */
export enum ServiceAccountKeySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ServiceAccountKeySpecProviderConfigRef
 */
export interface ServiceAccountKeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountKeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountKeySpecProviderConfigRef#policy
   */
  readonly policy?: ServiceAccountKeySpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountKeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountKeySpecProviderConfigRef(obj: ServiceAccountKeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountKeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ServiceAccountKeySpecWriteConnectionSecretToRef
 */
export interface ServiceAccountKeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceAccountKeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceAccountKeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ServiceAccountKeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountKeySpecWriteConnectionSecretToRef(obj: ServiceAccountKeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdRef
 */
export interface ServiceAccountKeySpecForProviderServiceAccountIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdRef#policy
   */
  readonly policy?: ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountKeySpecForProviderServiceAccountIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountKeySpecForProviderServiceAccountIdRef(obj: ServiceAccountKeySpecForProviderServiceAccountIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelector
 */
export interface ServiceAccountKeySpecForProviderServiceAccountIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelector#policy
   */
  readonly policy?: ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy;
}

/**
 * Converts an object of type 'ServiceAccountKeySpecForProviderServiceAccountIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountKeySpecForProviderServiceAccountIdSelector(obj: ServiceAccountKeySpecForProviderServiceAccountIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountKeySpecInitProviderServiceAccountIdRef
 */
export interface ServiceAccountKeySpecInitProviderServiceAccountIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountKeySpecInitProviderServiceAccountIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountKeySpecInitProviderServiceAccountIdRef#policy
   */
  readonly policy?: ServiceAccountKeySpecInitProviderServiceAccountIdRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountKeySpecInitProviderServiceAccountIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountKeySpecInitProviderServiceAccountIdRef(obj: ServiceAccountKeySpecInitProviderServiceAccountIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountKeySpecInitProviderServiceAccountIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountKeySpecInitProviderServiceAccountIdSelector
 */
export interface ServiceAccountKeySpecInitProviderServiceAccountIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ServiceAccountKeySpecInitProviderServiceAccountIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceAccountKeySpecInitProviderServiceAccountIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceAccountKeySpecInitProviderServiceAccountIdSelector#policy
   */
  readonly policy?: ServiceAccountKeySpecInitProviderServiceAccountIdSelectorPolicy;
}

/**
 * Converts an object of type 'ServiceAccountKeySpecInitProviderServiceAccountIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountKeySpecInitProviderServiceAccountIdSelector(obj: ServiceAccountKeySpecInitProviderServiceAccountIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceAccountKeySpecInitProviderServiceAccountIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountKeySpecProviderConfigRefPolicy
 */
export interface ServiceAccountKeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountKeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountKeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountKeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountKeySpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountKeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountKeySpecProviderConfigRefPolicy(obj: ServiceAccountKeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy
 */
export interface ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountKeySpecForProviderServiceAccountIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountKeySpecForProviderServiceAccountIdRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy(obj: ServiceAccountKeySpecForProviderServiceAccountIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy
 */
export interface ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy#resolution
   */
  readonly resolution?: ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy#resolve
   */
  readonly resolve?: ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy(obj: ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountKeySpecInitProviderServiceAccountIdRefPolicy
 */
export interface ServiceAccountKeySpecInitProviderServiceAccountIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountKeySpecInitProviderServiceAccountIdRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountKeySpecInitProviderServiceAccountIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountKeySpecInitProviderServiceAccountIdRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountKeySpecInitProviderServiceAccountIdRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountKeySpecInitProviderServiceAccountIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountKeySpecInitProviderServiceAccountIdRefPolicy(obj: ServiceAccountKeySpecInitProviderServiceAccountIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceAccountKeySpecInitProviderServiceAccountIdSelectorPolicy
 */
export interface ServiceAccountKeySpecInitProviderServiceAccountIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountKeySpecInitProviderServiceAccountIdSelectorPolicy#resolution
   */
  readonly resolution?: ServiceAccountKeySpecInitProviderServiceAccountIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountKeySpecInitProviderServiceAccountIdSelectorPolicy#resolve
   */
  readonly resolve?: ServiceAccountKeySpecInitProviderServiceAccountIdSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountKeySpecInitProviderServiceAccountIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountKeySpecInitProviderServiceAccountIdSelectorPolicy(obj: ServiceAccountKeySpecInitProviderServiceAccountIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountKeySpecProviderConfigRefPolicyResolution
 */
export enum ServiceAccountKeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountKeySpecProviderConfigRefPolicyResolve
 */
export enum ServiceAccountKeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdRefPolicyResolution
 */
export enum ServiceAccountKeySpecForProviderServiceAccountIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdRefPolicyResolve
 */
export enum ServiceAccountKeySpecForProviderServiceAccountIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicyResolution
 */
export enum ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicyResolve
 */
export enum ServiceAccountKeySpecForProviderServiceAccountIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountKeySpecInitProviderServiceAccountIdRefPolicyResolution
 */
export enum ServiceAccountKeySpecInitProviderServiceAccountIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountKeySpecInitProviderServiceAccountIdRefPolicyResolve
 */
export enum ServiceAccountKeySpecInitProviderServiceAccountIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountKeySpecInitProviderServiceAccountIdSelectorPolicyResolution
 */
export enum ServiceAccountKeySpecInitProviderServiceAccountIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountKeySpecInitProviderServiceAccountIdSelectorPolicyResolve
 */
export enum ServiceAccountKeySpecInitProviderServiceAccountIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

