// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A CompositeResourceDefinition defines the schema for a new custom Kubernetes
API.

Read the Crossplane documentation for
[more information about CustomResourceDefinitions](https://docs.crossplane.io/latest/concepts/composite-resource-definitions).
 *
 * @schema CompositeResourceDefinition
 */
export class CompositeResourceDefinition extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CompositeResourceDefinition"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apiextensions.crossplane.io/v1',
    kind: 'CompositeResourceDefinition',
  }

  /**
   * Renders a Kubernetes manifest for "CompositeResourceDefinition".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CompositeResourceDefinitionProps = {}): any {
    return {
      ...CompositeResourceDefinition.GVK,
      ...toJson_CompositeResourceDefinitionProps(props),
    };
  }

  /**
   * Defines a "CompositeResourceDefinition" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CompositeResourceDefinitionProps = {}) {
    super(scope, id, {
      ...CompositeResourceDefinition.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...CompositeResourceDefinition.GVK,
      ...toJson_CompositeResourceDefinitionProps(resolved),
    };
  }
}

/**
 * A CompositeResourceDefinition defines the schema for a new custom Kubernetes
 * API.
 *
 * Read the Crossplane documentation for
 * [more information about CustomResourceDefinitions](https://docs.crossplane.io/latest/concepts/composite-resource-definitions).
 *
 * @schema CompositeResourceDefinition
 */
export interface CompositeResourceDefinitionProps {
  /**
   * @schema CompositeResourceDefinition#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CompositeResourceDefinitionSpec specifies the desired state of the definition.
   *
   * @schema CompositeResourceDefinition#spec
   */
  readonly spec?: CompositeResourceDefinitionSpec;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionProps(obj: CompositeResourceDefinitionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CompositeResourceDefinitionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CompositeResourceDefinitionSpec specifies the desired state of the definition.
 *
 * @schema CompositeResourceDefinitionSpec
 */
export interface CompositeResourceDefinitionSpec {
  /**
   * ClaimNames specifies the names of an optional composite resource claim.
   * When claim names are specified Crossplane will create a namespaced
   * 'composite resource claim' CRD that corresponds to the defined composite
   * resource. This composite resource claim acts as a namespaced proxy for
   * the composite resource; creating, updating, or deleting the claim will
   * create, update, or delete a corresponding composite resource. You may add
   * claim names to an existing CompositeResourceDefinition, but they cannot
   * be changed or removed once they have been set.
   *
   * @schema CompositeResourceDefinitionSpec#claimNames
   */
  readonly claimNames?: CompositeResourceDefinitionSpecClaimNames;

  /**
   * ConnectionSecretKeys is the list of connection secret keys the
   * defined XR can publish. If the list is empty, all keys will be
   * published. If the list isn't empty, any connection secret keys that
   * don't appear in the list will be filtered out. Only LegacyCluster XRs
   * support connection secrets.
   *
   * @schema CompositeResourceDefinitionSpec#connectionSecretKeys
   */
  readonly connectionSecretKeys?: string[];

  /**
   * Conversion defines all conversion settings for the defined Composite resource.
   *
   * @schema CompositeResourceDefinitionSpec#conversion
   */
  readonly conversion?: CompositeResourceDefinitionSpecConversion;

  /**
   * DefaultCompositeDeletePolicy is the policy used when deleting the Composite
   * that is associated with the Claim if no policy has been specified.
   *
   * @schema CompositeResourceDefinitionSpec#defaultCompositeDeletePolicy
   */
  readonly defaultCompositeDeletePolicy?: CompositeResourceDefinitionSpecDefaultCompositeDeletePolicy;

  /**
   * DefaultCompositionRef refers to the Composition resource that will be used
   * in case no composition selector is given.
   *
   * @schema CompositeResourceDefinitionSpec#defaultCompositionRef
   */
  readonly defaultCompositionRef?: CompositeResourceDefinitionSpecDefaultCompositionRef;

  /**
   * DefaultCompositionUpdatePolicy is the policy used when updating composites after a new
   * Composition Revision has been created if no policy has been specified on the composite.
   *
   * @schema CompositeResourceDefinitionSpec#defaultCompositionUpdatePolicy
   */
  readonly defaultCompositionUpdatePolicy?: CompositeResourceDefinitionSpecDefaultCompositionUpdatePolicy;

  /**
   * EnforcedCompositionRef refers to the Composition resource that will be used
   * by all composite instances whose schema is defined by this definition.
   *
   * @schema CompositeResourceDefinitionSpec#enforcedCompositionRef
   */
  readonly enforcedCompositionRef?: CompositeResourceDefinitionSpecEnforcedCompositionRef;

  /**
   * Group specifies the API group of the defined composite resource.
   * Composite resources are served under `/apis/<group>/...`. Must match the
   * name of the XRD (in the form `<names.plural>.<group>`).
   *
   * @schema CompositeResourceDefinitionSpec#group
   */
  readonly group: string;

  /**
   * Metadata specifies the desired metadata for the defined composite resource and claim CRD's.
   *
   * @schema CompositeResourceDefinitionSpec#metadata
   */
  readonly metadata?: CompositeResourceDefinitionSpecMetadata;

  /**
   * Names specifies the resource and kind names of the defined composite
   * resource.
   *
   * @schema CompositeResourceDefinitionSpec#names
   */
  readonly names: CompositeResourceDefinitionSpecNames;

  /**
   * Scope of the defined composite resource. Namespaced composite resources
   * are scoped to a single namespace. Cluster scoped composite resource exist
   * outside the scope of any namespace. Neither can be claimed. Legacy
   * cluster scoped composite resources are cluster scoped resources that can
   * be claimed.
   *
   * @schema CompositeResourceDefinitionSpec#scope
   */
  readonly scope?: CompositeResourceDefinitionSpecScope;

  /**
   * Versions is the list of all API versions of the defined composite
   * resource. Version names are used to compute the order in which served
   * versions are listed in API discovery. If the version string is
   * "kube-like", it will sort above non "kube-like" version strings, which
   * are ordered lexicographically. "Kube-like" versions start with a "v",
   * then are followed by a number (the major version), then optionally the
   * string "alpha" or "beta" and another number (the minor version). These
   * are sorted first by GA > beta > alpha (where GA is a version with no
   * suffix such as beta or alpha), and then by comparing major version, then
   * minor version. An example sorted list of versions: v10, v2, v1, v11beta2,
   * v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.
   *
   * @schema CompositeResourceDefinitionSpec#versions
   */
  readonly versions: CompositeResourceDefinitionSpecVersions[];
}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionSpec(obj: CompositeResourceDefinitionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimNames': toJson_CompositeResourceDefinitionSpecClaimNames(obj.claimNames),
    'connectionSecretKeys': obj.connectionSecretKeys?.map(y => y),
    'conversion': toJson_CompositeResourceDefinitionSpecConversion(obj.conversion),
    'defaultCompositeDeletePolicy': obj.defaultCompositeDeletePolicy,
    'defaultCompositionRef': toJson_CompositeResourceDefinitionSpecDefaultCompositionRef(obj.defaultCompositionRef),
    'defaultCompositionUpdatePolicy': obj.defaultCompositionUpdatePolicy,
    'enforcedCompositionRef': toJson_CompositeResourceDefinitionSpecEnforcedCompositionRef(obj.enforcedCompositionRef),
    'group': obj.group,
    'metadata': toJson_CompositeResourceDefinitionSpecMetadata(obj.metadata),
    'names': toJson_CompositeResourceDefinitionSpecNames(obj.names),
    'scope': obj.scope,
    'versions': obj.versions?.map(y => toJson_CompositeResourceDefinitionSpecVersions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClaimNames specifies the names of an optional composite resource claim.
 * When claim names are specified Crossplane will create a namespaced
 * 'composite resource claim' CRD that corresponds to the defined composite
 * resource. This composite resource claim acts as a namespaced proxy for
 * the composite resource; creating, updating, or deleting the claim will
 * create, update, or delete a corresponding composite resource. You may add
 * claim names to an existing CompositeResourceDefinition, but they cannot
 * be changed or removed once they have been set.
 *
 * @schema CompositeResourceDefinitionSpecClaimNames
 */
export interface CompositeResourceDefinitionSpecClaimNames {
  /**
   * categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
   * This is published in API discovery documents, and used by clients to support invocations like
   * `kubectl get all`.
   *
   * @schema CompositeResourceDefinitionSpecClaimNames#categories
   */
  readonly categories?: string[];

  /**
   * kind is the serialized kind of the resource. It is normally CamelCase and singular.
   * Custom resource instances will use this value as the `kind` attribute in API calls.
   *
   * @schema CompositeResourceDefinitionSpecClaimNames#kind
   */
  readonly kind: string;

  /**
   * listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
   *
   * @default kind`List".
   * @schema CompositeResourceDefinitionSpecClaimNames#listKind
   */
  readonly listKind?: string;

  /**
   * plural is the plural name of the resource to serve.
   * The custom resources are served under `/apis/<group>/<version>/.../<plural>`.
   * Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`).
   * Must be all lowercase.
   *
   * @schema CompositeResourceDefinitionSpecClaimNames#plural
   */
  readonly plural: string;

  /**
   * shortNames are short names for the resource, exposed in API discovery documents,
   * and used by clients to support invocations like `kubectl get <shortname>`.
   * It must be all lowercase.
   *
   * @schema CompositeResourceDefinitionSpecClaimNames#shortNames
   */
  readonly shortNames?: string[];

  /**
   * singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`.
   *
   * @default lowercased `kind`.
   * @schema CompositeResourceDefinitionSpecClaimNames#singular
   */
  readonly singular?: string;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecClaimNames' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionSpecClaimNames(obj: CompositeResourceDefinitionSpecClaimNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'categories': obj.categories?.map(y => y),
    'kind': obj.kind,
    'listKind': obj.listKind,
    'plural': obj.plural,
    'shortNames': obj.shortNames?.map(y => y),
    'singular': obj.singular,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Conversion defines all conversion settings for the defined Composite resource.
 *
 * @schema CompositeResourceDefinitionSpecConversion
 */
export interface CompositeResourceDefinitionSpecConversion {
  /**
   * strategy specifies how custom resources are converted between versions. Allowed values are:
   * - `"None"`: The converter only change the apiVersion and would not touch any other field in the custom resource.
   * - `"Webhook"`: API Server will call to an external webhook to do the conversion. Additional information
   * is needed for this option. This requires spec.preserveUnknownFields to be false, and spec.conversion.webhook to be set.
   *
   * @schema CompositeResourceDefinitionSpecConversion#strategy
   */
  readonly strategy: string;

  /**
   * webhook describes how to call the conversion webhook. Required when `strategy` is set to `"Webhook"`.
   *
   * @schema CompositeResourceDefinitionSpecConversion#webhook
   */
  readonly webhook?: CompositeResourceDefinitionSpecConversionWebhook;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecConversion' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionSpecConversion(obj: CompositeResourceDefinitionSpecConversion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'strategy': obj.strategy,
    'webhook': toJson_CompositeResourceDefinitionSpecConversionWebhook(obj.webhook),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DefaultCompositeDeletePolicy is the policy used when deleting the Composite
 * that is associated with the Claim if no policy has been specified.
 *
 * @schema CompositeResourceDefinitionSpecDefaultCompositeDeletePolicy
 */
export enum CompositeResourceDefinitionSpecDefaultCompositeDeletePolicy {
  /** Background */
  BACKGROUND = "Background",
  /** Foreground */
  FOREGROUND = "Foreground",
}

/**
 * DefaultCompositionRef refers to the Composition resource that will be used
 * in case no composition selector is given.
 *
 * @schema CompositeResourceDefinitionSpecDefaultCompositionRef
 */
export interface CompositeResourceDefinitionSpecDefaultCompositionRef {
  /**
   * Name of the Composition.
   *
   * @schema CompositeResourceDefinitionSpecDefaultCompositionRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecDefaultCompositionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionSpecDefaultCompositionRef(obj: CompositeResourceDefinitionSpecDefaultCompositionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DefaultCompositionUpdatePolicy is the policy used when updating composites after a new
 * Composition Revision has been created if no policy has been specified on the composite.
 *
 * @schema CompositeResourceDefinitionSpecDefaultCompositionUpdatePolicy
 */
export enum CompositeResourceDefinitionSpecDefaultCompositionUpdatePolicy {
  /** Automatic */
  AUTOMATIC = "Automatic",
  /** Manual */
  MANUAL = "Manual",
}

/**
 * EnforcedCompositionRef refers to the Composition resource that will be used
 * by all composite instances whose schema is defined by this definition.
 *
 * @schema CompositeResourceDefinitionSpecEnforcedCompositionRef
 */
export interface CompositeResourceDefinitionSpecEnforcedCompositionRef {
  /**
   * Name of the Composition.
   *
   * @schema CompositeResourceDefinitionSpecEnforcedCompositionRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecEnforcedCompositionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionSpecEnforcedCompositionRef(obj: CompositeResourceDefinitionSpecEnforcedCompositionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata specifies the desired metadata for the defined composite resource and claim CRD's.
 *
 * @schema CompositeResourceDefinitionSpecMetadata
 */
export interface CompositeResourceDefinitionSpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema CompositeResourceDefinitionSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   * and services.
   * These labels are added to the composite resource and claim CRD's in addition
   * to any labels defined by `CompositionResourceDefinition` `metadata.labels`.
   *
   * @schema CompositeResourceDefinitionSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionSpecMetadata(obj: CompositeResourceDefinitionSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Names specifies the resource and kind names of the defined composite
 * resource.
 *
 * @schema CompositeResourceDefinitionSpecNames
 */
export interface CompositeResourceDefinitionSpecNames {
  /**
   * categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
   * This is published in API discovery documents, and used by clients to support invocations like
   * `kubectl get all`.
   *
   * @schema CompositeResourceDefinitionSpecNames#categories
   */
  readonly categories?: string[];

  /**
   * kind is the serialized kind of the resource. It is normally CamelCase and singular.
   * Custom resource instances will use this value as the `kind` attribute in API calls.
   *
   * @schema CompositeResourceDefinitionSpecNames#kind
   */
  readonly kind: string;

  /**
   * listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
   *
   * @default kind`List".
   * @schema CompositeResourceDefinitionSpecNames#listKind
   */
  readonly listKind?: string;

  /**
   * plural is the plural name of the resource to serve.
   * The custom resources are served under `/apis/<group>/<version>/.../<plural>`.
   * Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`).
   * Must be all lowercase.
   *
   * @schema CompositeResourceDefinitionSpecNames#plural
   */
  readonly plural: string;

  /**
   * shortNames are short names for the resource, exposed in API discovery documents,
   * and used by clients to support invocations like `kubectl get <shortname>`.
   * It must be all lowercase.
   *
   * @schema CompositeResourceDefinitionSpecNames#shortNames
   */
  readonly shortNames?: string[];

  /**
   * singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`.
   *
   * @default lowercased `kind`.
   * @schema CompositeResourceDefinitionSpecNames#singular
   */
  readonly singular?: string;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecNames' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionSpecNames(obj: CompositeResourceDefinitionSpecNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'categories': obj.categories?.map(y => y),
    'kind': obj.kind,
    'listKind': obj.listKind,
    'plural': obj.plural,
    'shortNames': obj.shortNames?.map(y => y),
    'singular': obj.singular,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Scope of the defined composite resource. Namespaced composite resources
 * are scoped to a single namespace. Cluster scoped composite resource exist
 * outside the scope of any namespace. Neither can be claimed. Legacy
 * cluster scoped composite resources are cluster scoped resources that can
 * be claimed.
 *
 * @schema CompositeResourceDefinitionSpecScope
 */
export enum CompositeResourceDefinitionSpecScope {
  /** LegacyCluster */
  LEGACY_CLUSTER = "LegacyCluster",
  /** Namespaced */
  NAMESPACED = "Namespaced",
  /** Cluster */
  CLUSTER = "Cluster",
}

/**
 * CompositeResourceDefinitionVersion describes a version of an XR.
 *
 * @schema CompositeResourceDefinitionSpecVersions
 */
export interface CompositeResourceDefinitionSpecVersions {
  /**
   * AdditionalPrinterColumns specifies additional columns returned in Table
   * output. If no columns are specified, a single column displaying the age
   * of the custom resource is used. See the following link for details:
   * https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
   *
   * @schema CompositeResourceDefinitionSpecVersions#additionalPrinterColumns
   */
  readonly additionalPrinterColumns?: CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns[];

  /**
   * The deprecated field specifies that this version is deprecated and should
   * not be used.
   *
   * @schema CompositeResourceDefinitionSpecVersions#deprecated
   */
  readonly deprecated?: boolean;

  /**
   * DeprecationWarning specifies the message that should be shown to the user
   * when using this version.
   *
   * @schema CompositeResourceDefinitionSpecVersions#deprecationWarning
   */
  readonly deprecationWarning?: string;

  /**
   * Name of this version, e.g. “v1”, “v2beta1”, etc. Composite resources are
   * served under this version at `/apis/<group>/<version>/...` if `served` is
   * true.
   *
   * @schema CompositeResourceDefinitionSpecVersions#name
   */
  readonly name: string;

  /**
   * Referenceable specifies that this version may be referenced by a
   * Composition in order to configure which resources an XR may be composed
   * of. Exactly one version must be marked as referenceable; all Compositions
   * must target only the referenceable version. The referenceable version
   * must be served. It's mapped to the CRD's `spec.versions[*].storage` field.
   *
   * @schema CompositeResourceDefinitionSpecVersions#referenceable
   */
  readonly referenceable: boolean;

  /**
   * Schema describes the schema used for validation, pruning, and defaulting
   * of this version of the defined composite resource. Fields required by all
   * composite resources will be injected into this schema automatically, and
   * will override equivalently named fields in this schema. Omitting this
   * schema results in a schema that contains only the fields required by all
   * composite resources.
   *
   * @schema CompositeResourceDefinitionSpecVersions#schema
   */
  readonly schema?: CompositeResourceDefinitionSpecVersionsSchema;

  /**
   * Served specifies that this version should be served via REST APIs.
   *
   * @schema CompositeResourceDefinitionSpecVersions#served
   */
  readonly served: boolean;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecVersions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionSpecVersions(obj: CompositeResourceDefinitionSpecVersions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalPrinterColumns': obj.additionalPrinterColumns?.map(y => toJson_CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns(y)),
    'deprecated': obj.deprecated,
    'deprecationWarning': obj.deprecationWarning,
    'name': obj.name,
    'referenceable': obj.referenceable,
    'schema': toJson_CompositeResourceDefinitionSpecVersionsSchema(obj.schema),
    'served': obj.served,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * webhook describes how to call the conversion webhook. Required when `strategy` is set to `"Webhook"`.
 *
 * @schema CompositeResourceDefinitionSpecConversionWebhook
 */
export interface CompositeResourceDefinitionSpecConversionWebhook {
  /**
   * clientConfig is the instructions for how to call the webhook if strategy is `Webhook`.
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhook#clientConfig
   */
  readonly clientConfig?: CompositeResourceDefinitionSpecConversionWebhookClientConfig;

  /**
   * conversionReviewVersions is an ordered list of preferred `ConversionReview`
   * versions the Webhook expects. The API server will use the first version in
   * the list which it supports. If none of the versions specified in this list
   * are supported by API server, conversion will fail for the custom resource.
   * If a persisted Webhook configuration specifies allowed versions and does not
   * include any versions known to the API Server, calls to the webhook will fail.
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhook#conversionReviewVersions
   */
  readonly conversionReviewVersions: string[];
}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecConversionWebhook' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionSpecConversionWebhook(obj: CompositeResourceDefinitionSpecConversionWebhook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientConfig': toJson_CompositeResourceDefinitionSpecConversionWebhookClientConfig(obj.clientConfig),
    'conversionReviewVersions': obj.conversionReviewVersions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CustomResourceColumnDefinition specifies a column for server side printing.
 *
 * @schema CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns
 */
export interface CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns {
  /**
   * description is a human readable description of this column.
   *
   * @schema CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns#description
   */
  readonly description?: string;

  /**
   * format is an optional OpenAPI type definition for this column. The 'name' format is applied
   * to the primary identifier column to assist in clients identifying column is the resource name.
   * See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.
   *
   * @schema CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns#format
   */
  readonly format?: string;

  /**
   * jsonPath is a simple JSON path (i.e. with array notation) which is evaluated against
   * each custom resource to produce the value for this column.
   *
   * @schema CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns#jsonPath
   */
  readonly jsonPath: string;

  /**
   * name is a human readable name for the column.
   *
   * @schema CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns#name
   */
  readonly name: string;

  /**
   * priority is an integer defining the relative importance of this column compared to others. Lower
   * numbers are considered higher priority. Columns that may be omitted in limited space scenarios
   * should be given a priority greater than 0.
   *
   * @schema CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns#priority
   */
  readonly priority?: number;

  /**
   * type is an OpenAPI type definition for this column.
   * See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.
   *
   * @schema CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns(obj: CompositeResourceDefinitionSpecVersionsAdditionalPrinterColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'format': obj.format,
    'jsonPath': obj.jsonPath,
    'name': obj.name,
    'priority': obj.priority,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Schema describes the schema used for validation, pruning, and defaulting
 * of this version of the defined composite resource. Fields required by all
 * composite resources will be injected into this schema automatically, and
 * will override equivalently named fields in this schema. Omitting this
 * schema results in a schema that contains only the fields required by all
 * composite resources.
 *
 * @schema CompositeResourceDefinitionSpecVersionsSchema
 */
export interface CompositeResourceDefinitionSpecVersionsSchema {
  /**
   * OpenAPIV3Schema is the OpenAPI v3 schema to use for validation and
   * pruning.
   *
   * @schema CompositeResourceDefinitionSpecVersionsSchema#openAPIV3Schema
   */
  readonly openApiv3Schema?: any;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecVersionsSchema' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionSpecVersionsSchema(obj: CompositeResourceDefinitionSpecVersionsSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'openAPIV3Schema': obj.openApiv3Schema,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * clientConfig is the instructions for how to call the webhook if strategy is `Webhook`.
 *
 * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfig
 */
export interface CompositeResourceDefinitionSpecConversionWebhookClientConfig {
  /**
   * caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
   * If unspecified, system trust roots on the apiserver are used.
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfig#caBundle
   */
  readonly caBundle?: string;

  /**
   * service is a reference to the service for this webhook. Either
   * service or url must be specified.
   *
   * If the webhook is running within the cluster, then you should use `service`.
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfig#service
   */
  readonly service?: CompositeResourceDefinitionSpecConversionWebhookClientConfigService;

  /**
   * url gives the location of the webhook, in standard URL form
   * (`scheme://host:port/path`). Exactly one of `url` or `service`
   * must be specified.
   *
   * The `host` should not refer to a service running in the cluster; use
   * the `service` field instead. The host might be resolved via external
   * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
   * in-cluster DNS as that would be a layering violation). `host` may
   * also be an IP address.
   *
   * Please note that using `localhost` or `127.0.0.1` as a `host` is
   * risky unless you take great care to run this webhook on all hosts
   * which run an apiserver which might need to make calls to this
   * webhook. Such installs are likely to be non-portable, i.e., not easy
   * to turn up in a new cluster.
   *
   * The scheme must be "https"; the URL must begin with "https://".
   *
   * A path is optional, and if present may be any string permissible in
   * a URL. You may use the path to pass an arbitrary string to the
   * webhook, for example, a cluster identifier.
   *
   * Attempting to use a user or basic auth e.g. "user:password@" is not
   * allowed. Fragments ("#...") and query parameters ("?...") are not
   * allowed, either.
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfig#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecConversionWebhookClientConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionSpecConversionWebhookClientConfig(obj: CompositeResourceDefinitionSpecConversionWebhookClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'service': toJson_CompositeResourceDefinitionSpecConversionWebhookClientConfigService(obj.service),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * service is a reference to the service for this webhook. Either
 * service or url must be specified.
 *
 * If the webhook is running within the cluster, then you should use `service`.
 *
 * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfigService
 */
export interface CompositeResourceDefinitionSpecConversionWebhookClientConfigService {
  /**
   * name is the name of the service.
   * Required
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfigService#name
   */
  readonly name: string;

  /**
   * namespace is the namespace of the service.
   * Required
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfigService#namespace
   */
  readonly namespace: string;

  /**
   * path is an optional URL path at which the webhook will be contacted.
   *
   * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfigService#path
   */
  readonly path?: string;

  /**
   * port is an optional service port at which the webhook will be contacted.
   * `port` should be a valid port number (1-65535, inclusive).
   * Defaults to 443 for backward compatibility.
   *
   * @default 443 for backward compatibility.
   * @schema CompositeResourceDefinitionSpecConversionWebhookClientConfigService#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionSpecConversionWebhookClientConfigService' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionSpecConversionWebhookClientConfigService(obj: CompositeResourceDefinitionSpecConversionWebhookClientConfigService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
    'path': obj.path,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * A CompositeResourceDefinition defines the schema for a new custom Kubernetes
API.

Read the Crossplane documentation for
[more information about CustomResourceDefinitions](https://docs.crossplane.io/latest/concepts/composite-resource-definitions).
 *
 * @schema CompositeResourceDefinitionV2
 */
export class CompositeResourceDefinitionV2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CompositeResourceDefinitionV2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apiextensions.crossplane.io/v2',
    kind: 'CompositeResourceDefinition',
  }

  /**
   * Renders a Kubernetes manifest for "CompositeResourceDefinitionV2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CompositeResourceDefinitionV2Props = {}): any {
    return {
      ...CompositeResourceDefinitionV2.GVK,
      ...toJson_CompositeResourceDefinitionV2Props(props),
    };
  }

  /**
   * Defines a "CompositeResourceDefinitionV2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CompositeResourceDefinitionV2Props = {}) {
    super(scope, id, {
      ...CompositeResourceDefinitionV2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...CompositeResourceDefinitionV2.GVK,
      ...toJson_CompositeResourceDefinitionV2Props(resolved),
    };
  }
}

/**
 * A CompositeResourceDefinition defines the schema for a new custom Kubernetes
 * API.
 *
 * Read the Crossplane documentation for
 * [more information about CustomResourceDefinitions](https://docs.crossplane.io/latest/concepts/composite-resource-definitions).
 *
 * @schema CompositeResourceDefinitionV2
 */
export interface CompositeResourceDefinitionV2Props {
  /**
   * @schema CompositeResourceDefinitionV2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CompositeResourceDefinitionSpec specifies the desired state of the definition.
   *
   * @schema CompositeResourceDefinitionV2#spec
   */
  readonly spec?: CompositeResourceDefinitionV2Spec;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionV2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionV2Props(obj: CompositeResourceDefinitionV2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CompositeResourceDefinitionV2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CompositeResourceDefinitionSpec specifies the desired state of the definition.
 *
 * @schema CompositeResourceDefinitionV2Spec
 */
export interface CompositeResourceDefinitionV2Spec {
  /**
   * ClaimNames specifies the names of an optional composite resource claim.
   * When claim names are specified Crossplane will create a namespaced
   * 'composite resource claim' CRD that corresponds to the defined composite
   * resource. This composite resource claim acts as a namespaced proxy for
   * the composite resource; creating, updating, or deleting the claim will
   * create, update, or delete a corresponding composite resource. You may add
   * claim names to an existing CompositeResourceDefinition, but they cannot
   * be changed or removed once they have been set.
   *
   * Deprecated: Claims aren't supported in apiextensions.crossplane.io/v2.
   *
   * @schema CompositeResourceDefinitionV2Spec#claimNames
   */
  readonly claimNames?: CompositeResourceDefinitionV2SpecClaimNames;

  /**
   * ConnectionSecretKeys is the list of connection secret keys the
   * defined XR can publish. If the list is empty, all keys will be
   * published. If the list isn't empty, any connection secret keys that
   * don't appear in the list will be filtered out. Only LegacyCluster XRs
   * support connection secrets.
   *
   * Deprecated: XR connection secrets aren't supported in
   * apiextensions.crossplane.io/v2. Compose a secret instead.
   *
   * @schema CompositeResourceDefinitionV2Spec#connectionSecretKeys
   */
  readonly connectionSecretKeys?: string[];

  /**
   * Conversion defines all conversion settings for the defined Composite resource.
   *
   * @schema CompositeResourceDefinitionV2Spec#conversion
   */
  readonly conversion?: CompositeResourceDefinitionV2SpecConversion;

  /**
   * DefaultCompositeDeletePolicy is the policy used when deleting the Composite
   * that is associated with the Claim if no policy has been specified.
   *
   * Deprecated: Claims aren't supported in apiextensions.crossplane.io/v2.
   *
   * @schema CompositeResourceDefinitionV2Spec#defaultCompositeDeletePolicy
   */
  readonly defaultCompositeDeletePolicy?: CompositeResourceDefinitionV2SpecDefaultCompositeDeletePolicy;

  /**
   * DefaultCompositionRef refers to the Composition resource that will be used
   * in case no composition selector is given.
   *
   * @schema CompositeResourceDefinitionV2Spec#defaultCompositionRef
   */
  readonly defaultCompositionRef?: CompositeResourceDefinitionV2SpecDefaultCompositionRef;

  /**
   * DefaultCompositionUpdatePolicy is the policy used when updating composites after a new
   * Composition Revision has been created if no policy has been specified on the composite.
   *
   * @schema CompositeResourceDefinitionV2Spec#defaultCompositionUpdatePolicy
   */
  readonly defaultCompositionUpdatePolicy?: CompositeResourceDefinitionV2SpecDefaultCompositionUpdatePolicy;

  /**
   * EnforcedCompositionRef refers to the Composition resource that will be used
   * by all composite instances whose schema is defined by this definition.
   *
   * @schema CompositeResourceDefinitionV2Spec#enforcedCompositionRef
   */
  readonly enforcedCompositionRef?: CompositeResourceDefinitionV2SpecEnforcedCompositionRef;

  /**
   * Group specifies the API group of the defined composite resource.
   * Composite resources are served under `/apis/<group>/...`. Must match the
   * name of the XRD (in the form `<names.plural>.<group>`).
   *
   * @schema CompositeResourceDefinitionV2Spec#group
   */
  readonly group: string;

  /**
   * Metadata specifies the desired metadata for the defined composite resource and claim CRD's.
   *
   * @schema CompositeResourceDefinitionV2Spec#metadata
   */
  readonly metadata?: CompositeResourceDefinitionV2SpecMetadata;

  /**
   * Names specifies the resource and kind names of the defined composite
   * resource.
   *
   * @schema CompositeResourceDefinitionV2Spec#names
   */
  readonly names: CompositeResourceDefinitionV2SpecNames;

  /**
   * Scope of the defined composite resource. Namespaced composite resources
   * are scoped to a single namespace. Cluster scoped composite resource exist
   * outside the scope of any namespace.
   *
   * @schema CompositeResourceDefinitionV2Spec#scope
   */
  readonly scope?: CompositeResourceDefinitionV2SpecScope;

  /**
   * Versions is the list of all API versions of the defined composite
   * resource. Version names are used to compute the order in which served
   * versions are listed in API discovery. If the version string is
   * "kube-like", it will sort above non "kube-like" version strings, which
   * are ordered lexicographically. "Kube-like" versions start with a "v",
   * then are followed by a number (the major version), then optionally the
   * string "alpha" or "beta" and another number (the minor version). These
   * are sorted first by GA > beta > alpha (where GA is a version with no
   * suffix such as beta or alpha), and then by comparing major version, then
   * minor version. An example sorted list of versions: v10, v2, v1, v11beta2,
   * v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.
   *
   * @schema CompositeResourceDefinitionV2Spec#versions
   */
  readonly versions: CompositeResourceDefinitionV2SpecVersions[];
}

/**
 * Converts an object of type 'CompositeResourceDefinitionV2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionV2Spec(obj: CompositeResourceDefinitionV2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimNames': toJson_CompositeResourceDefinitionV2SpecClaimNames(obj.claimNames),
    'connectionSecretKeys': obj.connectionSecretKeys?.map(y => y),
    'conversion': toJson_CompositeResourceDefinitionV2SpecConversion(obj.conversion),
    'defaultCompositeDeletePolicy': obj.defaultCompositeDeletePolicy,
    'defaultCompositionRef': toJson_CompositeResourceDefinitionV2SpecDefaultCompositionRef(obj.defaultCompositionRef),
    'defaultCompositionUpdatePolicy': obj.defaultCompositionUpdatePolicy,
    'enforcedCompositionRef': toJson_CompositeResourceDefinitionV2SpecEnforcedCompositionRef(obj.enforcedCompositionRef),
    'group': obj.group,
    'metadata': toJson_CompositeResourceDefinitionV2SpecMetadata(obj.metadata),
    'names': toJson_CompositeResourceDefinitionV2SpecNames(obj.names),
    'scope': obj.scope,
    'versions': obj.versions?.map(y => toJson_CompositeResourceDefinitionV2SpecVersions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClaimNames specifies the names of an optional composite resource claim.
 * When claim names are specified Crossplane will create a namespaced
 * 'composite resource claim' CRD that corresponds to the defined composite
 * resource. This composite resource claim acts as a namespaced proxy for
 * the composite resource; creating, updating, or deleting the claim will
 * create, update, or delete a corresponding composite resource. You may add
 * claim names to an existing CompositeResourceDefinition, but they cannot
 * be changed or removed once they have been set.
 *
 * Deprecated: Claims aren't supported in apiextensions.crossplane.io/v2.
 *
 * @schema CompositeResourceDefinitionV2SpecClaimNames
 */
export interface CompositeResourceDefinitionV2SpecClaimNames {
  /**
   * categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
   * This is published in API discovery documents, and used by clients to support invocations like
   * `kubectl get all`.
   *
   * @schema CompositeResourceDefinitionV2SpecClaimNames#categories
   */
  readonly categories?: string[];

  /**
   * kind is the serialized kind of the resource. It is normally CamelCase and singular.
   * Custom resource instances will use this value as the `kind` attribute in API calls.
   *
   * @schema CompositeResourceDefinitionV2SpecClaimNames#kind
   */
  readonly kind: string;

  /**
   * listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
   *
   * @default kind`List".
   * @schema CompositeResourceDefinitionV2SpecClaimNames#listKind
   */
  readonly listKind?: string;

  /**
   * plural is the plural name of the resource to serve.
   * The custom resources are served under `/apis/<group>/<version>/.../<plural>`.
   * Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`).
   * Must be all lowercase.
   *
   * @schema CompositeResourceDefinitionV2SpecClaimNames#plural
   */
  readonly plural: string;

  /**
   * shortNames are short names for the resource, exposed in API discovery documents,
   * and used by clients to support invocations like `kubectl get <shortname>`.
   * It must be all lowercase.
   *
   * @schema CompositeResourceDefinitionV2SpecClaimNames#shortNames
   */
  readonly shortNames?: string[];

  /**
   * singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`.
   *
   * @default lowercased `kind`.
   * @schema CompositeResourceDefinitionV2SpecClaimNames#singular
   */
  readonly singular?: string;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionV2SpecClaimNames' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionV2SpecClaimNames(obj: CompositeResourceDefinitionV2SpecClaimNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'categories': obj.categories?.map(y => y),
    'kind': obj.kind,
    'listKind': obj.listKind,
    'plural': obj.plural,
    'shortNames': obj.shortNames?.map(y => y),
    'singular': obj.singular,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Conversion defines all conversion settings for the defined Composite resource.
 *
 * @schema CompositeResourceDefinitionV2SpecConversion
 */
export interface CompositeResourceDefinitionV2SpecConversion {
  /**
   * strategy specifies how custom resources are converted between versions. Allowed values are:
   * - `"None"`: The converter only change the apiVersion and would not touch any other field in the custom resource.
   * - `"Webhook"`: API Server will call to an external webhook to do the conversion. Additional information
   * is needed for this option. This requires spec.preserveUnknownFields to be false, and spec.conversion.webhook to be set.
   *
   * @schema CompositeResourceDefinitionV2SpecConversion#strategy
   */
  readonly strategy: string;

  /**
   * webhook describes how to call the conversion webhook. Required when `strategy` is set to `"Webhook"`.
   *
   * @schema CompositeResourceDefinitionV2SpecConversion#webhook
   */
  readonly webhook?: CompositeResourceDefinitionV2SpecConversionWebhook;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionV2SpecConversion' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionV2SpecConversion(obj: CompositeResourceDefinitionV2SpecConversion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'strategy': obj.strategy,
    'webhook': toJson_CompositeResourceDefinitionV2SpecConversionWebhook(obj.webhook),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DefaultCompositeDeletePolicy is the policy used when deleting the Composite
 * that is associated with the Claim if no policy has been specified.
 *
 * Deprecated: Claims aren't supported in apiextensions.crossplane.io/v2.
 *
 * @schema CompositeResourceDefinitionV2SpecDefaultCompositeDeletePolicy
 */
export enum CompositeResourceDefinitionV2SpecDefaultCompositeDeletePolicy {
  /** Background */
  BACKGROUND = "Background",
  /** Foreground */
  FOREGROUND = "Foreground",
}

/**
 * DefaultCompositionRef refers to the Composition resource that will be used
 * in case no composition selector is given.
 *
 * @schema CompositeResourceDefinitionV2SpecDefaultCompositionRef
 */
export interface CompositeResourceDefinitionV2SpecDefaultCompositionRef {
  /**
   * Name of the Composition.
   *
   * @schema CompositeResourceDefinitionV2SpecDefaultCompositionRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionV2SpecDefaultCompositionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionV2SpecDefaultCompositionRef(obj: CompositeResourceDefinitionV2SpecDefaultCompositionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DefaultCompositionUpdatePolicy is the policy used when updating composites after a new
 * Composition Revision has been created if no policy has been specified on the composite.
 *
 * @schema CompositeResourceDefinitionV2SpecDefaultCompositionUpdatePolicy
 */
export enum CompositeResourceDefinitionV2SpecDefaultCompositionUpdatePolicy {
  /** Automatic */
  AUTOMATIC = "Automatic",
  /** Manual */
  MANUAL = "Manual",
}

/**
 * EnforcedCompositionRef refers to the Composition resource that will be used
 * by all composite instances whose schema is defined by this definition.
 *
 * @schema CompositeResourceDefinitionV2SpecEnforcedCompositionRef
 */
export interface CompositeResourceDefinitionV2SpecEnforcedCompositionRef {
  /**
   * Name of the Composition.
   *
   * @schema CompositeResourceDefinitionV2SpecEnforcedCompositionRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionV2SpecEnforcedCompositionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionV2SpecEnforcedCompositionRef(obj: CompositeResourceDefinitionV2SpecEnforcedCompositionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata specifies the desired metadata for the defined composite resource and claim CRD's.
 *
 * @schema CompositeResourceDefinitionV2SpecMetadata
 */
export interface CompositeResourceDefinitionV2SpecMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema CompositeResourceDefinitionV2SpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   * and services.
   * These labels are added to the composite resource and claim CRD's in addition
   * to any labels defined by `CompositionResourceDefinition` `metadata.labels`.
   *
   * @schema CompositeResourceDefinitionV2SpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'CompositeResourceDefinitionV2SpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionV2SpecMetadata(obj: CompositeResourceDefinitionV2SpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Names specifies the resource and kind names of the defined composite
 * resource.
 *
 * @schema CompositeResourceDefinitionV2SpecNames
 */
export interface CompositeResourceDefinitionV2SpecNames {
  /**
   * categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
   * This is published in API discovery documents, and used by clients to support invocations like
   * `kubectl get all`.
   *
   * @schema CompositeResourceDefinitionV2SpecNames#categories
   */
  readonly categories?: string[];

  /**
   * kind is the serialized kind of the resource. It is normally CamelCase and singular.
   * Custom resource instances will use this value as the `kind` attribute in API calls.
   *
   * @schema CompositeResourceDefinitionV2SpecNames#kind
   */
  readonly kind: string;

  /**
   * listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
   *
   * @default kind`List".
   * @schema CompositeResourceDefinitionV2SpecNames#listKind
   */
  readonly listKind?: string;

  /**
   * plural is the plural name of the resource to serve.
   * The custom resources are served under `/apis/<group>/<version>/.../<plural>`.
   * Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`).
   * Must be all lowercase.
   *
   * @schema CompositeResourceDefinitionV2SpecNames#plural
   */
  readonly plural: string;

  /**
   * shortNames are short names for the resource, exposed in API discovery documents,
   * and used by clients to support invocations like `kubectl get <shortname>`.
   * It must be all lowercase.
   *
   * @schema CompositeResourceDefinitionV2SpecNames#shortNames
   */
  readonly shortNames?: string[];

  /**
   * singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`.
   *
   * @default lowercased `kind`.
   * @schema CompositeResourceDefinitionV2SpecNames#singular
   */
  readonly singular?: string;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionV2SpecNames' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionV2SpecNames(obj: CompositeResourceDefinitionV2SpecNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'categories': obj.categories?.map(y => y),
    'kind': obj.kind,
    'listKind': obj.listKind,
    'plural': obj.plural,
    'shortNames': obj.shortNames?.map(y => y),
    'singular': obj.singular,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Scope of the defined composite resource. Namespaced composite resources
 * are scoped to a single namespace. Cluster scoped composite resource exist
 * outside the scope of any namespace.
 *
 * @schema CompositeResourceDefinitionV2SpecScope
 */
export enum CompositeResourceDefinitionV2SpecScope {
  /** Namespaced */
  NAMESPACED = "Namespaced",
  /** Cluster */
  CLUSTER = "Cluster",
}

/**
 * CompositeResourceDefinitionVersion describes a version of an XR.
 *
 * @schema CompositeResourceDefinitionV2SpecVersions
 */
export interface CompositeResourceDefinitionV2SpecVersions {
  /**
   * AdditionalPrinterColumns specifies additional columns returned in Table
   * output. If no columns are specified, a single column displaying the age
   * of the custom resource is used. See the following link for details:
   * https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
   *
   * @schema CompositeResourceDefinitionV2SpecVersions#additionalPrinterColumns
   */
  readonly additionalPrinterColumns?: CompositeResourceDefinitionV2SpecVersionsAdditionalPrinterColumns[];

  /**
   * The deprecated field specifies that this version is deprecated and should
   * not be used.
   *
   * @schema CompositeResourceDefinitionV2SpecVersions#deprecated
   */
  readonly deprecated?: boolean;

  /**
   * DeprecationWarning specifies the message that should be shown to the user
   * when using this version.
   *
   * @schema CompositeResourceDefinitionV2SpecVersions#deprecationWarning
   */
  readonly deprecationWarning?: string;

  /**
   * Name of this version, e.g. “v1”, “v2beta1”, etc. Composite resources are
   * served under this version at `/apis/<group>/<version>/...` if `served` is
   * true.
   *
   * @schema CompositeResourceDefinitionV2SpecVersions#name
   */
  readonly name: string;

  /**
   * Referenceable specifies that this version may be referenced by a
   * Composition in order to configure which resources an XR may be composed
   * of. Exactly one version must be marked as referenceable; all Compositions
   * must target only the referenceable version. The referenceable version
   * must be served. It's mapped to the CRD's `spec.versions[*].storage` field.
   *
   * @schema CompositeResourceDefinitionV2SpecVersions#referenceable
   */
  readonly referenceable: boolean;

  /**
   * Schema describes the schema used for validation, pruning, and defaulting
   * of this version of the defined composite resource. Fields required by all
   * composite resources will be injected into this schema automatically, and
   * will override equivalently named fields in this schema. Omitting this
   * schema results in a schema that contains only the fields required by all
   * composite resources.
   *
   * @schema CompositeResourceDefinitionV2SpecVersions#schema
   */
  readonly schema?: CompositeResourceDefinitionV2SpecVersionsSchema;

  /**
   * Served specifies that this version should be served via REST APIs.
   *
   * @schema CompositeResourceDefinitionV2SpecVersions#served
   */
  readonly served: boolean;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionV2SpecVersions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionV2SpecVersions(obj: CompositeResourceDefinitionV2SpecVersions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalPrinterColumns': obj.additionalPrinterColumns?.map(y => toJson_CompositeResourceDefinitionV2SpecVersionsAdditionalPrinterColumns(y)),
    'deprecated': obj.deprecated,
    'deprecationWarning': obj.deprecationWarning,
    'name': obj.name,
    'referenceable': obj.referenceable,
    'schema': toJson_CompositeResourceDefinitionV2SpecVersionsSchema(obj.schema),
    'served': obj.served,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * webhook describes how to call the conversion webhook. Required when `strategy` is set to `"Webhook"`.
 *
 * @schema CompositeResourceDefinitionV2SpecConversionWebhook
 */
export interface CompositeResourceDefinitionV2SpecConversionWebhook {
  /**
   * clientConfig is the instructions for how to call the webhook if strategy is `Webhook`.
   *
   * @schema CompositeResourceDefinitionV2SpecConversionWebhook#clientConfig
   */
  readonly clientConfig?: CompositeResourceDefinitionV2SpecConversionWebhookClientConfig;

  /**
   * conversionReviewVersions is an ordered list of preferred `ConversionReview`
   * versions the Webhook expects. The API server will use the first version in
   * the list which it supports. If none of the versions specified in this list
   * are supported by API server, conversion will fail for the custom resource.
   * If a persisted Webhook configuration specifies allowed versions and does not
   * include any versions known to the API Server, calls to the webhook will fail.
   *
   * @schema CompositeResourceDefinitionV2SpecConversionWebhook#conversionReviewVersions
   */
  readonly conversionReviewVersions: string[];
}

/**
 * Converts an object of type 'CompositeResourceDefinitionV2SpecConversionWebhook' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionV2SpecConversionWebhook(obj: CompositeResourceDefinitionV2SpecConversionWebhook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientConfig': toJson_CompositeResourceDefinitionV2SpecConversionWebhookClientConfig(obj.clientConfig),
    'conversionReviewVersions': obj.conversionReviewVersions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CustomResourceColumnDefinition specifies a column for server side printing.
 *
 * @schema CompositeResourceDefinitionV2SpecVersionsAdditionalPrinterColumns
 */
export interface CompositeResourceDefinitionV2SpecVersionsAdditionalPrinterColumns {
  /**
   * description is a human readable description of this column.
   *
   * @schema CompositeResourceDefinitionV2SpecVersionsAdditionalPrinterColumns#description
   */
  readonly description?: string;

  /**
   * format is an optional OpenAPI type definition for this column. The 'name' format is applied
   * to the primary identifier column to assist in clients identifying column is the resource name.
   * See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.
   *
   * @schema CompositeResourceDefinitionV2SpecVersionsAdditionalPrinterColumns#format
   */
  readonly format?: string;

  /**
   * jsonPath is a simple JSON path (i.e. with array notation) which is evaluated against
   * each custom resource to produce the value for this column.
   *
   * @schema CompositeResourceDefinitionV2SpecVersionsAdditionalPrinterColumns#jsonPath
   */
  readonly jsonPath: string;

  /**
   * name is a human readable name for the column.
   *
   * @schema CompositeResourceDefinitionV2SpecVersionsAdditionalPrinterColumns#name
   */
  readonly name: string;

  /**
   * priority is an integer defining the relative importance of this column compared to others. Lower
   * numbers are considered higher priority. Columns that may be omitted in limited space scenarios
   * should be given a priority greater than 0.
   *
   * @schema CompositeResourceDefinitionV2SpecVersionsAdditionalPrinterColumns#priority
   */
  readonly priority?: number;

  /**
   * type is an OpenAPI type definition for this column.
   * See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.
   *
   * @schema CompositeResourceDefinitionV2SpecVersionsAdditionalPrinterColumns#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionV2SpecVersionsAdditionalPrinterColumns' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionV2SpecVersionsAdditionalPrinterColumns(obj: CompositeResourceDefinitionV2SpecVersionsAdditionalPrinterColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'format': obj.format,
    'jsonPath': obj.jsonPath,
    'name': obj.name,
    'priority': obj.priority,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Schema describes the schema used for validation, pruning, and defaulting
 * of this version of the defined composite resource. Fields required by all
 * composite resources will be injected into this schema automatically, and
 * will override equivalently named fields in this schema. Omitting this
 * schema results in a schema that contains only the fields required by all
 * composite resources.
 *
 * @schema CompositeResourceDefinitionV2SpecVersionsSchema
 */
export interface CompositeResourceDefinitionV2SpecVersionsSchema {
  /**
   * OpenAPIV3Schema is the OpenAPI v3 schema to use for validation and
   * pruning.
   *
   * @schema CompositeResourceDefinitionV2SpecVersionsSchema#openAPIV3Schema
   */
  readonly openApiv3Schema?: any;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionV2SpecVersionsSchema' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionV2SpecVersionsSchema(obj: CompositeResourceDefinitionV2SpecVersionsSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'openAPIV3Schema': obj.openApiv3Schema,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * clientConfig is the instructions for how to call the webhook if strategy is `Webhook`.
 *
 * @schema CompositeResourceDefinitionV2SpecConversionWebhookClientConfig
 */
export interface CompositeResourceDefinitionV2SpecConversionWebhookClientConfig {
  /**
   * caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
   * If unspecified, system trust roots on the apiserver are used.
   *
   * @schema CompositeResourceDefinitionV2SpecConversionWebhookClientConfig#caBundle
   */
  readonly caBundle?: string;

  /**
   * service is a reference to the service for this webhook. Either
   * service or url must be specified.
   *
   * If the webhook is running within the cluster, then you should use `service`.
   *
   * @schema CompositeResourceDefinitionV2SpecConversionWebhookClientConfig#service
   */
  readonly service?: CompositeResourceDefinitionV2SpecConversionWebhookClientConfigService;

  /**
   * url gives the location of the webhook, in standard URL form
   * (`scheme://host:port/path`). Exactly one of `url` or `service`
   * must be specified.
   *
   * The `host` should not refer to a service running in the cluster; use
   * the `service` field instead. The host might be resolved via external
   * DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
   * in-cluster DNS as that would be a layering violation). `host` may
   * also be an IP address.
   *
   * Please note that using `localhost` or `127.0.0.1` as a `host` is
   * risky unless you take great care to run this webhook on all hosts
   * which run an apiserver which might need to make calls to this
   * webhook. Such installs are likely to be non-portable, i.e., not easy
   * to turn up in a new cluster.
   *
   * The scheme must be "https"; the URL must begin with "https://".
   *
   * A path is optional, and if present may be any string permissible in
   * a URL. You may use the path to pass an arbitrary string to the
   * webhook, for example, a cluster identifier.
   *
   * Attempting to use a user or basic auth e.g. "user:password@" is not
   * allowed. Fragments ("#...") and query parameters ("?...") are not
   * allowed, either.
   *
   * @schema CompositeResourceDefinitionV2SpecConversionWebhookClientConfig#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionV2SpecConversionWebhookClientConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionV2SpecConversionWebhookClientConfig(obj: CompositeResourceDefinitionV2SpecConversionWebhookClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'service': toJson_CompositeResourceDefinitionV2SpecConversionWebhookClientConfigService(obj.service),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * service is a reference to the service for this webhook. Either
 * service or url must be specified.
 *
 * If the webhook is running within the cluster, then you should use `service`.
 *
 * @schema CompositeResourceDefinitionV2SpecConversionWebhookClientConfigService
 */
export interface CompositeResourceDefinitionV2SpecConversionWebhookClientConfigService {
  /**
   * name is the name of the service.
   * Required
   *
   * @schema CompositeResourceDefinitionV2SpecConversionWebhookClientConfigService#name
   */
  readonly name: string;

  /**
   * namespace is the namespace of the service.
   * Required
   *
   * @schema CompositeResourceDefinitionV2SpecConversionWebhookClientConfigService#namespace
   */
  readonly namespace: string;

  /**
   * path is an optional URL path at which the webhook will be contacted.
   *
   * @schema CompositeResourceDefinitionV2SpecConversionWebhookClientConfigService#path
   */
  readonly path?: string;

  /**
   * port is an optional service port at which the webhook will be contacted.
   * `port` should be a valid port number (1-65535, inclusive).
   * Defaults to 443 for backward compatibility.
   *
   * @default 443 for backward compatibility.
   * @schema CompositeResourceDefinitionV2SpecConversionWebhookClientConfigService#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'CompositeResourceDefinitionV2SpecConversionWebhookClientConfigService' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositeResourceDefinitionV2SpecConversionWebhookClientConfigService(obj: CompositeResourceDefinitionV2SpecConversionWebhookClientConfigService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
    'path': obj.path,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * A Composition defines a collection of managed resources or functions that
Crossplane uses to create and manage new composite resources.

Read the Crossplane documentation for
[more information about Compositions](https://docs.crossplane.io/latest/concepts/compositions).
 *
 * @schema Composition
 */
export class Composition extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Composition"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apiextensions.crossplane.io/v1',
    kind: 'Composition',
  }

  /**
   * Renders a Kubernetes manifest for "Composition".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CompositionProps = {}): any {
    return {
      ...Composition.GVK,
      ...toJson_CompositionProps(props),
    };
  }

  /**
   * Defines a "Composition" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CompositionProps = {}) {
    super(scope, id, {
      ...Composition.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Composition.GVK,
      ...toJson_CompositionProps(resolved),
    };
  }
}

/**
 * A Composition defines a collection of managed resources or functions that
 * Crossplane uses to create and manage new composite resources.
 *
 * Read the Crossplane documentation for
 * [more information about Compositions](https://docs.crossplane.io/latest/concepts/compositions).
 *
 * @schema Composition
 */
export interface CompositionProps {
  /**
   * @schema Composition#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CompositionSpec specifies desired state of a composition.
   *
   * @schema Composition#spec
   */
  readonly spec?: CompositionSpec;
}

/**
 * Converts an object of type 'CompositionProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionProps(obj: CompositionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CompositionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CompositionSpec specifies desired state of a composition.
 *
 * @schema CompositionSpec
 */
export interface CompositionSpec {
  /**
   * CompositeTypeRef specifies the type of composite resource that this
   * composition is compatible with.
   *
   * @schema CompositionSpec#compositeTypeRef
   */
  readonly compositeTypeRef: CompositionSpecCompositeTypeRef;

  /**
   * Mode controls what type or "mode" of Composition will be used.
   *
   * "Pipeline" indicates that a Composition specifies a pipeline of
   * functions, each of which is responsible for producing composed
   * resources that Crossplane should create or update.
   *
   * @schema CompositionSpec#mode
   */
  readonly mode?: CompositionSpecMode;

  /**
   * Pipeline is a list of composition function steps that will be used when a
   * composite resource referring to this composition is created. One of
   * resources and pipeline must be specified - you cannot specify both.
   *
   * The Pipeline is only used by the "Pipeline" mode of Composition. It is
   * ignored by other modes.
   *
   * @schema CompositionSpec#pipeline
   */
  readonly pipeline?: CompositionSpecPipeline[];

  /**
   * WriteConnectionSecretsToNamespace specifies the namespace in which the
   * connection secrets of composite resource dynamically provisioned using
   * this composition will be created.
   *
   * @schema CompositionSpec#writeConnectionSecretsToNamespace
   */
  readonly writeConnectionSecretsToNamespace?: string;
}

/**
 * Converts an object of type 'CompositionSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpec(obj: CompositionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compositeTypeRef': toJson_CompositionSpecCompositeTypeRef(obj.compositeTypeRef),
    'mode': obj.mode,
    'pipeline': obj.pipeline?.map(y => toJson_CompositionSpecPipeline(y)),
    'writeConnectionSecretsToNamespace': obj.writeConnectionSecretsToNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CompositeTypeRef specifies the type of composite resource that this
 * composition is compatible with.
 *
 * @schema CompositionSpecCompositeTypeRef
 */
export interface CompositionSpecCompositeTypeRef {
  /**
   * APIVersion of the type.
   *
   * @schema CompositionSpecCompositeTypeRef#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind of the type.
   *
   * @schema CompositionSpecCompositeTypeRef#kind
   */
  readonly kind: string;
}

/**
 * Converts an object of type 'CompositionSpecCompositeTypeRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecCompositeTypeRef(obj: CompositionSpecCompositeTypeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Mode controls what type or "mode" of Composition will be used.
 *
 * "Pipeline" indicates that a Composition specifies a pipeline of
 * functions, each of which is responsible for producing composed
 * resources that Crossplane should create or update.
 *
 * @schema CompositionSpecMode
 */
export enum CompositionSpecMode {
  /** Pipeline */
  PIPELINE = "Pipeline",
}

/**
 * A PipelineStep in a function pipeline.
 *
 * @schema CompositionSpecPipeline
 */
export interface CompositionSpecPipeline {
  /**
   * Credentials are optional credentials that the function needs.
   *
   * @schema CompositionSpecPipeline#credentials
   */
  readonly credentials?: CompositionSpecPipelineCredentials[];

  /**
   * FunctionRef is a reference to the function this step should
   * execute.
   *
   * @schema CompositionSpecPipeline#functionRef
   */
  readonly functionRef: CompositionSpecPipelineFunctionRef;

  /**
   * Input is an optional, arbitrary Kubernetes resource (i.e. a resource
   * with an apiVersion and kind) that will be passed to the function as
   * the 'input' of its RunFunctionRequest.
   *
   * @schema CompositionSpecPipeline#input
   */
  readonly input?: any;

  /**
   * Requirements are resource requirements that will be satisfied before
   * this pipeline step is called for the first time. This allows
   * pre-populating required resources without requiring a function to
   * request them first.
   *
   * @schema CompositionSpecPipeline#requirements
   */
  readonly requirements?: CompositionSpecPipelineRequirements;

  /**
   * Step name. Must be unique within its Pipeline.
   *
   * @schema CompositionSpecPipeline#step
   */
  readonly step: string;
}

/**
 * Converts an object of type 'CompositionSpecPipeline' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPipeline(obj: CompositionSpecPipeline | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': obj.credentials?.map(y => toJson_CompositionSpecPipelineCredentials(y)),
    'functionRef': toJson_CompositionSpecPipelineFunctionRef(obj.functionRef),
    'input': obj.input,
    'requirements': toJson_CompositionSpecPipelineRequirements(obj.requirements),
    'step': obj.step,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FunctionCredentials are optional credentials that a function
 * needs to run.
 *
 * @schema CompositionSpecPipelineCredentials
 */
export interface CompositionSpecPipelineCredentials {
  /**
   * Name of this set of credentials.
   *
   * @schema CompositionSpecPipelineCredentials#name
   */
  readonly name: string;

  /**
   * A SecretRef is a reference to a secret containing credentials that should
   * be supplied to the function.
   *
   * @schema CompositionSpecPipelineCredentials#secretRef
   */
  readonly secretRef?: CompositionSpecPipelineCredentialsSecretRef;

  /**
   * Source of the function credentials.
   *
   * @schema CompositionSpecPipelineCredentials#source
   */
  readonly source: CompositionSpecPipelineCredentialsSource;
}

/**
 * Converts an object of type 'CompositionSpecPipelineCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPipelineCredentials(obj: CompositionSpecPipelineCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'secretRef': toJson_CompositionSpecPipelineCredentialsSecretRef(obj.secretRef),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FunctionRef is a reference to the function this step should
 * execute.
 *
 * @schema CompositionSpecPipelineFunctionRef
 */
export interface CompositionSpecPipelineFunctionRef {
  /**
   * Name of the referenced Function.
   *
   * @schema CompositionSpecPipelineFunctionRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'CompositionSpecPipelineFunctionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPipelineFunctionRef(obj: CompositionSpecPipelineFunctionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Requirements are resource requirements that will be satisfied before
 * this pipeline step is called for the first time. This allows
 * pre-populating required resources without requiring a function to
 * request them first.
 *
 * @schema CompositionSpecPipelineRequirements
 */
export interface CompositionSpecPipelineRequirements {
  /**
   * RequiredResources is a list of resources that must be fetched before
   * this function is called.
   *
   * @schema CompositionSpecPipelineRequirements#requiredResources
   */
  readonly requiredResources?: CompositionSpecPipelineRequirementsRequiredResources[];
}

/**
 * Converts an object of type 'CompositionSpecPipelineRequirements' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPipelineRequirements(obj: CompositionSpecPipelineRequirements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requiredResources': obj.requiredResources?.map(y => toJson_CompositionSpecPipelineRequirementsRequiredResources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A SecretRef is a reference to a secret containing credentials that should
 * be supplied to the function.
 *
 * @schema CompositionSpecPipelineCredentialsSecretRef
 */
export interface CompositionSpecPipelineCredentialsSecretRef {
  /**
   * Name of the secret.
   *
   * @schema CompositionSpecPipelineCredentialsSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CompositionSpecPipelineCredentialsSecretRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'CompositionSpecPipelineCredentialsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPipelineCredentialsSecretRef(obj: CompositionSpecPipelineCredentialsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source of the function credentials.
 *
 * @schema CompositionSpecPipelineCredentialsSource
 */
export enum CompositionSpecPipelineCredentialsSource {
  /** None */
  NONE = "None",
  /** Secret */
  SECRET = "Secret",
}

/**
 * RequiredResourceSelector selects a required resource.
 *
 * @schema CompositionSpecPipelineRequirementsRequiredResources
 */
export interface CompositionSpecPipelineRequirementsRequiredResources {
  /**
   * APIVersion of the required resource.
   *
   * @schema CompositionSpecPipelineRequirementsRequiredResources#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind of the required resource.
   *
   * @schema CompositionSpecPipelineRequirementsRequiredResources#kind
   */
  readonly kind: string;

  /**
   * MatchLabels specifies the set of labels to match for finding the
   * required resource. When specified, Name is ignored.
   *
   * @schema CompositionSpecPipelineRequirementsRequiredResources#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Name of the required resource.
   *
   * @schema CompositionSpecPipelineRequirementsRequiredResources#name
   */
  readonly name?: string;

  /**
   * Namespace of the required resource if it is namespaced.
   *
   * @schema CompositionSpecPipelineRequirementsRequiredResources#namespace
   */
  readonly namespace?: string;

  /**
   * RequirementName is the unique name to identify this required resource
   * in the Required Resources map in the function request.
   *
   * @schema CompositionSpecPipelineRequirementsRequiredResources#requirementName
   */
  readonly requirementName: string;
}

/**
 * Converts an object of type 'CompositionSpecPipelineRequirementsRequiredResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPipelineRequirementsRequiredResources(obj: CompositionSpecPipelineRequirementsRequiredResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
    'requirementName': obj.requirementName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * A CompositionRevision represents a revision of a Composition. Crossplane
creates new revisions when there are changes to the Composition.

Crossplane creates and manages CompositionRevisions. Don't directly edit
CompositionRevisions.
 *
 * @schema CompositionRevision
 */
export class CompositionRevision extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CompositionRevision"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apiextensions.crossplane.io/v1',
    kind: 'CompositionRevision',
  }

  /**
   * Renders a Kubernetes manifest for "CompositionRevision".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CompositionRevisionProps = {}): any {
    return {
      ...CompositionRevision.GVK,
      ...toJson_CompositionRevisionProps(props),
    };
  }

  /**
   * Defines a "CompositionRevision" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CompositionRevisionProps = {}) {
    super(scope, id, {
      ...CompositionRevision.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...CompositionRevision.GVK,
      ...toJson_CompositionRevisionProps(resolved),
    };
  }
}

/**
 * A CompositionRevision represents a revision of a Composition. Crossplane
 * creates new revisions when there are changes to the Composition.
 *
 * Crossplane creates and manages CompositionRevisions. Don't directly edit
 * CompositionRevisions.
 *
 * @schema CompositionRevision
 */
export interface CompositionRevisionProps {
  /**
   * @schema CompositionRevision#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CompositionRevisionSpec specifies the desired state of the composition
   * revision.
   *
   * @schema CompositionRevision#spec
   */
  readonly spec?: CompositionRevisionSpec;
}

/**
 * Converts an object of type 'CompositionRevisionProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionRevisionProps(obj: CompositionRevisionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CompositionRevisionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CompositionRevisionSpec specifies the desired state of the composition
 * revision.
 *
 * @schema CompositionRevisionSpec
 */
export interface CompositionRevisionSpec {
  /**
   * CompositeTypeRef specifies the type of composite resource that this
   * composition is compatible with.
   *
   * @schema CompositionRevisionSpec#compositeTypeRef
   */
  readonly compositeTypeRef: CompositionRevisionSpecCompositeTypeRef;

  /**
   * Mode controls what type or "mode" of Composition will be used.
   *
   * "Pipeline" indicates that a Composition specifies a pipeline of
   * functions, each of which is responsible for producing composed
   * resources that Crossplane should create or update.
   *
   * @schema CompositionRevisionSpec#mode
   */
  readonly mode?: CompositionRevisionSpecMode;

  /**
   * Pipeline is a list of function steps that will be used when a
   * composite resource referring to this composition is created.
   *
   * The Pipeline is only used by the "Pipeline" mode of Composition. It is
   * ignored by other modes.
   *
   * @schema CompositionRevisionSpec#pipeline
   */
  readonly pipeline?: CompositionRevisionSpecPipeline[];

  /**
   * Revision number. Newer revisions have larger numbers.
   *
   * This number can change. When a Composition transitions from state A
   * -> B -> A there will be only two CompositionRevisions. Crossplane will
   * edit the original CompositionRevision to change its revision number from
   * 0 to 2.
   *
   * @schema CompositionRevisionSpec#revision
   */
  readonly revision: number;

  /**
   * WriteConnectionSecretsToNamespace specifies the namespace in which the
   * connection secrets of composite resource dynamically provisioned using
   * this composition will be created.
   *
   * @schema CompositionRevisionSpec#writeConnectionSecretsToNamespace
   */
  readonly writeConnectionSecretsToNamespace?: string;
}

/**
 * Converts an object of type 'CompositionRevisionSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionRevisionSpec(obj: CompositionRevisionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compositeTypeRef': toJson_CompositionRevisionSpecCompositeTypeRef(obj.compositeTypeRef),
    'mode': obj.mode,
    'pipeline': obj.pipeline?.map(y => toJson_CompositionRevisionSpecPipeline(y)),
    'revision': obj.revision,
    'writeConnectionSecretsToNamespace': obj.writeConnectionSecretsToNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CompositeTypeRef specifies the type of composite resource that this
 * composition is compatible with.
 *
 * @schema CompositionRevisionSpecCompositeTypeRef
 */
export interface CompositionRevisionSpecCompositeTypeRef {
  /**
   * APIVersion of the type.
   *
   * @schema CompositionRevisionSpecCompositeTypeRef#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind of the type.
   *
   * @schema CompositionRevisionSpecCompositeTypeRef#kind
   */
  readonly kind: string;
}

/**
 * Converts an object of type 'CompositionRevisionSpecCompositeTypeRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionRevisionSpecCompositeTypeRef(obj: CompositionRevisionSpecCompositeTypeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Mode controls what type or "mode" of Composition will be used.
 *
 * "Pipeline" indicates that a Composition specifies a pipeline of
 * functions, each of which is responsible for producing composed
 * resources that Crossplane should create or update.
 *
 * @schema CompositionRevisionSpecMode
 */
export enum CompositionRevisionSpecMode {
  /** Pipeline */
  PIPELINE = "Pipeline",
}

/**
 * A PipelineStep in a function pipeline.
 *
 * @schema CompositionRevisionSpecPipeline
 */
export interface CompositionRevisionSpecPipeline {
  /**
   * Credentials are optional credentials that the function needs.
   *
   * @schema CompositionRevisionSpecPipeline#credentials
   */
  readonly credentials?: CompositionRevisionSpecPipelineCredentials[];

  /**
   * FunctionRef is a reference to the function this step should
   * execute.
   *
   * @schema CompositionRevisionSpecPipeline#functionRef
   */
  readonly functionRef: CompositionRevisionSpecPipelineFunctionRef;

  /**
   * Input is an optional, arbitrary Kubernetes resource (i.e. a resource
   * with an apiVersion and kind) that will be passed to the function as
   * the 'input' of its RunFunctionRequest.
   *
   * @schema CompositionRevisionSpecPipeline#input
   */
  readonly input?: any;

  /**
   * Requirements are resource requirements that will be satisfied before
   * this pipeline step is called for the first time. This allows
   * pre-populating required resources without requiring a function to
   * request them first.
   *
   * @schema CompositionRevisionSpecPipeline#requirements
   */
  readonly requirements?: CompositionRevisionSpecPipelineRequirements;

  /**
   * Step name. Must be unique within its Pipeline.
   *
   * @schema CompositionRevisionSpecPipeline#step
   */
  readonly step: string;
}

/**
 * Converts an object of type 'CompositionRevisionSpecPipeline' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionRevisionSpecPipeline(obj: CompositionRevisionSpecPipeline | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': obj.credentials?.map(y => toJson_CompositionRevisionSpecPipelineCredentials(y)),
    'functionRef': toJson_CompositionRevisionSpecPipelineFunctionRef(obj.functionRef),
    'input': obj.input,
    'requirements': toJson_CompositionRevisionSpecPipelineRequirements(obj.requirements),
    'step': obj.step,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FunctionCredentials are optional credentials that a function
 * needs to run.
 *
 * @schema CompositionRevisionSpecPipelineCredentials
 */
export interface CompositionRevisionSpecPipelineCredentials {
  /**
   * Name of this set of credentials.
   *
   * @schema CompositionRevisionSpecPipelineCredentials#name
   */
  readonly name: string;

  /**
   * A SecretRef is a reference to a secret containing credentials that should
   * be supplied to the function.
   *
   * @schema CompositionRevisionSpecPipelineCredentials#secretRef
   */
  readonly secretRef?: CompositionRevisionSpecPipelineCredentialsSecretRef;

  /**
   * Source of the function credentials.
   *
   * @schema CompositionRevisionSpecPipelineCredentials#source
   */
  readonly source: CompositionRevisionSpecPipelineCredentialsSource;
}

/**
 * Converts an object of type 'CompositionRevisionSpecPipelineCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionRevisionSpecPipelineCredentials(obj: CompositionRevisionSpecPipelineCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'secretRef': toJson_CompositionRevisionSpecPipelineCredentialsSecretRef(obj.secretRef),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FunctionRef is a reference to the function this step should
 * execute.
 *
 * @schema CompositionRevisionSpecPipelineFunctionRef
 */
export interface CompositionRevisionSpecPipelineFunctionRef {
  /**
   * Name of the referenced Function.
   *
   * @schema CompositionRevisionSpecPipelineFunctionRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'CompositionRevisionSpecPipelineFunctionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionRevisionSpecPipelineFunctionRef(obj: CompositionRevisionSpecPipelineFunctionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Requirements are resource requirements that will be satisfied before
 * this pipeline step is called for the first time. This allows
 * pre-populating required resources without requiring a function to
 * request them first.
 *
 * @schema CompositionRevisionSpecPipelineRequirements
 */
export interface CompositionRevisionSpecPipelineRequirements {
  /**
   * RequiredResources is a list of resources that must be fetched before
   * this function is called.
   *
   * @schema CompositionRevisionSpecPipelineRequirements#requiredResources
   */
  readonly requiredResources?: CompositionRevisionSpecPipelineRequirementsRequiredResources[];
}

/**
 * Converts an object of type 'CompositionRevisionSpecPipelineRequirements' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionRevisionSpecPipelineRequirements(obj: CompositionRevisionSpecPipelineRequirements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requiredResources': obj.requiredResources?.map(y => toJson_CompositionRevisionSpecPipelineRequirementsRequiredResources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A SecretRef is a reference to a secret containing credentials that should
 * be supplied to the function.
 *
 * @schema CompositionRevisionSpecPipelineCredentialsSecretRef
 */
export interface CompositionRevisionSpecPipelineCredentialsSecretRef {
  /**
   * Name of the secret.
   *
   * @schema CompositionRevisionSpecPipelineCredentialsSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CompositionRevisionSpecPipelineCredentialsSecretRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'CompositionRevisionSpecPipelineCredentialsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionRevisionSpecPipelineCredentialsSecretRef(obj: CompositionRevisionSpecPipelineCredentialsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source of the function credentials.
 *
 * @schema CompositionRevisionSpecPipelineCredentialsSource
 */
export enum CompositionRevisionSpecPipelineCredentialsSource {
  /** None */
  NONE = "None",
  /** Secret */
  SECRET = "Secret",
}

/**
 * RequiredResourceSelector selects a required resource.
 *
 * @schema CompositionRevisionSpecPipelineRequirementsRequiredResources
 */
export interface CompositionRevisionSpecPipelineRequirementsRequiredResources {
  /**
   * APIVersion of the required resource.
   *
   * @schema CompositionRevisionSpecPipelineRequirementsRequiredResources#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind of the required resource.
   *
   * @schema CompositionRevisionSpecPipelineRequirementsRequiredResources#kind
   */
  readonly kind: string;

  /**
   * MatchLabels specifies the set of labels to match for finding the
   * required resource. When specified, Name is ignored.
   *
   * @schema CompositionRevisionSpecPipelineRequirementsRequiredResources#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Name of the required resource.
   *
   * @schema CompositionRevisionSpecPipelineRequirementsRequiredResources#name
   */
  readonly name?: string;

  /**
   * Namespace of the required resource if it is namespaced.
   *
   * @schema CompositionRevisionSpecPipelineRequirementsRequiredResources#namespace
   */
  readonly namespace?: string;

  /**
   * RequirementName is the unique name to identify this required resource
   * in the Required Resources map in the function request.
   *
   * @schema CompositionRevisionSpecPipelineRequirementsRequiredResources#requirementName
   */
  readonly requirementName: string;
}

/**
 * Converts an object of type 'CompositionRevisionSpecPipelineRequirementsRequiredResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionRevisionSpecPipelineRequirementsRequiredResources(obj: CompositionRevisionSpecPipelineRequirementsRequiredResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
    'requirementName': obj.requirementName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

