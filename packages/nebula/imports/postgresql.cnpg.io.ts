// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A Backup resource is a request for a PostgreSQL backup by the user.
 *
 * @schema Backup
 */
export class Backup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Backup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'postgresql.cnpg.io/v1',
    kind: 'Backup',
  }

  /**
   * Renders a Kubernetes manifest for "Backup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupProps): any {
    return {
      ...Backup.GVK,
      ...toJson_BackupProps(props),
    };
  }

  /**
   * Defines a "Backup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupProps) {
    super(scope, id, {
      ...Backup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Backup.GVK,
      ...toJson_BackupProps(resolved),
    };
  }
}

/**
 * A Backup resource is a request for a PostgreSQL backup by the user.
 *
 * @schema Backup
 */
export interface BackupProps {
  /**
   * @schema Backup#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Specification of the desired behavior of the backup.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema Backup#spec
   */
  readonly spec: BackupSpec;
}

/**
 * Converts an object of type 'BackupProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupProps(obj: BackupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specification of the desired behavior of the backup.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema BackupSpec
 */
export interface BackupSpec {
  /**
   * The cluster to backup
   *
   * @schema BackupSpec#cluster
   */
  readonly cluster: BackupSpecCluster;

  /**
   * The backup method to be used, possible options are `barmanObjectStore`,
   * `volumeSnapshot` or `plugin`. Defaults to: `barmanObjectStore`.
   *
   * @default barmanObjectStore`.
   * @schema BackupSpec#method
   */
  readonly method?: BackupSpecMethod;

  /**
   * Whether the default type of backup with volume snapshots is
   * online/hot (`true`, default) or offline/cold (`false`)
   * Overrides the default setting specified in the cluster field '.spec.backup.volumeSnapshot.online'
   *
   * @schema BackupSpec#online
   */
  readonly online?: boolean;

  /**
   * Configuration parameters to control the online/hot backup with volume snapshots
   * Overrides the default settings specified in the cluster '.backup.volumeSnapshot.onlineConfiguration' stanza
   *
   * @schema BackupSpec#onlineConfiguration
   */
  readonly onlineConfiguration?: BackupSpecOnlineConfiguration;

  /**
   * Configuration parameters passed to the plugin managing this backup
   *
   * @schema BackupSpec#pluginConfiguration
   */
  readonly pluginConfiguration?: BackupSpecPluginConfiguration;

  /**
   * The policy to decide which instance should perform this backup. If empty,
   * it defaults to `cluster.spec.backup.target`.
   * Available options are empty string, `primary` and `prefer-standby`.
   * `primary` to have backups run always on primary instances,
   * `prefer-standby` to have backups run preferably on the most updated
   * standby, if available.
   *
   * @schema BackupSpec#target
   */
  readonly target?: BackupSpecTarget;
}

/**
 * Converts an object of type 'BackupSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpec(obj: BackupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cluster': toJson_BackupSpecCluster(obj.cluster),
    'method': obj.method,
    'online': obj.online,
    'onlineConfiguration': toJson_BackupSpecOnlineConfiguration(obj.onlineConfiguration),
    'pluginConfiguration': toJson_BackupSpecPluginConfiguration(obj.pluginConfiguration),
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The cluster to backup
 *
 * @schema BackupSpecCluster
 */
export interface BackupSpecCluster {
  /**
   * Name of the referent.
   *
   * @schema BackupSpecCluster#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'BackupSpecCluster' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecCluster(obj: BackupSpecCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The backup method to be used, possible options are `barmanObjectStore`,
 * `volumeSnapshot` or `plugin`. Defaults to: `barmanObjectStore`.
 *
 * @default barmanObjectStore`.
 * @schema BackupSpecMethod
 */
export enum BackupSpecMethod {
  /** barmanObjectStore */
  BARMAN_OBJECT_STORE = "barmanObjectStore",
  /** volumeSnapshot */
  VOLUME_SNAPSHOT = "volumeSnapshot",
  /** plugin */
  PLUGIN = "plugin",
}

/**
 * Configuration parameters to control the online/hot backup with volume snapshots
 * Overrides the default settings specified in the cluster '.backup.volumeSnapshot.onlineConfiguration' stanza
 *
 * @schema BackupSpecOnlineConfiguration
 */
export interface BackupSpecOnlineConfiguration {
  /**
   * Control whether the I/O workload for the backup initial checkpoint will
   * be limited, according to the `checkpoint_completion_target` setting on
   * the PostgreSQL server. If set to true, an immediate checkpoint will be
   * used, meaning PostgreSQL will complete the checkpoint as soon as
   * possible. `false` by default.
   *
   * @schema BackupSpecOnlineConfiguration#immediateCheckpoint
   */
  readonly immediateCheckpoint?: boolean;

  /**
   * If false, the function will return immediately after the backup is completed,
   * without waiting for WAL to be archived.
   * This behavior is only useful with backup software that independently monitors WAL archiving.
   * Otherwise, WAL required to make the backup consistent might be missing and make the backup useless.
   * By default, or when this parameter is true, pg_backup_stop will wait for WAL to be archived when archiving is
   * enabled.
   * On a standby, this means that it will wait only when archive_mode = always.
   * If write activity on the primary is low, it may be useful to run pg_switch_wal on the primary in order to trigger
   * an immediate segment switch.
   *
   * @schema BackupSpecOnlineConfiguration#waitForArchive
   */
  readonly waitForArchive?: boolean;
}

/**
 * Converts an object of type 'BackupSpecOnlineConfiguration' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecOnlineConfiguration(obj: BackupSpecOnlineConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'immediateCheckpoint': obj.immediateCheckpoint,
    'waitForArchive': obj.waitForArchive,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration parameters passed to the plugin managing this backup
 *
 * @schema BackupSpecPluginConfiguration
 */
export interface BackupSpecPluginConfiguration {
  /**
   * Name is the name of the plugin managing this backup
   *
   * @schema BackupSpecPluginConfiguration#name
   */
  readonly name: string;

  /**
   * Parameters are the configuration parameters passed to the backup
   * plugin for this backup
   *
   * @schema BackupSpecPluginConfiguration#parameters
   */
  readonly parameters?: { [key: string]: string };
}

/**
 * Converts an object of type 'BackupSpecPluginConfiguration' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecPluginConfiguration(obj: BackupSpecPluginConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The policy to decide which instance should perform this backup. If empty,
 * it defaults to `cluster.spec.backup.target`.
 * Available options are empty string, `primary` and `prefer-standby`.
 * `primary` to have backups run always on primary instances,
 * `prefer-standby` to have backups run preferably on the most updated
 * standby, if available.
 *
 * @schema BackupSpecTarget
 */
export enum BackupSpecTarget {
  /** primary */
  PRIMARY = "primary",
  /** prefer-standby */
  PREFER_HYPHEN_STANDBY = "prefer-standby",
}


/**
 * Cluster defines the API schema for a highly available PostgreSQL database cluster
managed by CloudNativePG.
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'postgresql.cnpg.io/v1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * Cluster defines the API schema for a highly available PostgreSQL database cluster
 * managed by CloudNativePG.
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Specification of the desired behavior of the cluster.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;
}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specification of the desired behavior of the cluster.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * Affinity/Anti-affinity rules for Pods
   *
   * @schema ClusterSpec#affinity
   */
  readonly affinity?: ClusterSpecAffinity;

  /**
   * The configuration to be used for backups
   *
   * @schema ClusterSpec#backup
   */
  readonly backup?: ClusterSpecBackup;

  /**
   * Instructions to bootstrap this cluster
   *
   * @schema ClusterSpec#bootstrap
   */
  readonly bootstrap?: ClusterSpecBootstrap;

  /**
   * The configuration for the CA and related certificates
   *
   * @schema ClusterSpec#certificates
   */
  readonly certificates?: ClusterSpecCertificates;

  /**
   * Description of this PostgreSQL cluster
   *
   * @schema ClusterSpec#description
   */
  readonly description?: string;

  /**
   * Manage the `PodDisruptionBudget` resources within the cluster. When
   * configured as `true` (default setting), the pod disruption budgets
   * will safeguard the primary node from being terminated. Conversely,
   * setting it to `false` will result in the absence of any
   * `PodDisruptionBudget` resource, permitting the shutdown of all nodes
   * hosting the PostgreSQL cluster. This latter configuration is
   * advisable for any PostgreSQL cluster employed for
   * development/staging purposes.
   *
   * @schema ClusterSpec#enablePDB
   */
  readonly enablePdb?: boolean;

  /**
   * When this option is enabled, the operator will use the `SuperuserSecret`
   * to update the `postgres` user password (if the secret is
   * not present, the operator will automatically create one). When this
   * option is disabled, the operator will ignore the `SuperuserSecret` content, delete
   * it when automatically created, and then blank the password of the `postgres`
   * user by setting it to `NULL`. Disabled by default.
   *
   * @schema ClusterSpec#enableSuperuserAccess
   */
  readonly enableSuperuserAccess?: boolean;

  /**
   * Env follows the Env format to pass environment variables
   * to the pods created in the cluster
   *
   * @schema ClusterSpec#env
   */
  readonly env?: ClusterSpecEnv[];

  /**
   * EnvFrom follows the EnvFrom format to pass environment variables
   * sources to the pods to be used by Env
   *
   * @schema ClusterSpec#envFrom
   */
  readonly envFrom?: ClusterSpecEnvFrom[];

  /**
   * EphemeralVolumeSource allows the user to configure the source of ephemeral volumes.
   *
   * @schema ClusterSpec#ephemeralVolumeSource
   */
  readonly ephemeralVolumeSource?: ClusterSpecEphemeralVolumeSource;

  /**
   * EphemeralVolumesSizeLimit allows the user to set the limits for the ephemeral
   * volumes
   *
   * @schema ClusterSpec#ephemeralVolumesSizeLimit
   */
  readonly ephemeralVolumesSizeLimit?: ClusterSpecEphemeralVolumesSizeLimit;

  /**
   * The list of external clusters which are used in the configuration
   *
   * @schema ClusterSpec#externalClusters
   */
  readonly externalClusters?: ClusterSpecExternalClusters[];

  /**
   * The amount of time (in seconds) to wait before triggering a failover
   * after the primary PostgreSQL instance in the cluster was detected
   * to be unhealthy
   *
   * @schema ClusterSpec#failoverDelay
   */
  readonly failoverDelay?: number;

  /**
   * Defines the major PostgreSQL version we want to use within an ImageCatalog
   *
   * @schema ClusterSpec#imageCatalogRef
   */
  readonly imageCatalogRef?: ClusterSpecImageCatalogRef;

  /**
   * Name of the container image, supporting both tags (`<image>:<tag>`)
   * and digests for deterministic and repeatable deployments
   * (`<image>:<tag>@sha256:<digestValue>`)
   *
   * @schema ClusterSpec#imageName
   */
  readonly imageName?: string;

  /**
   * Image pull policy.
   * One of `Always`, `Never` or `IfNotPresent`.
   * If not defined, it defaults to `IfNotPresent`.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @schema ClusterSpec#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * The list of pull secrets to be used to pull the images
   *
   * @schema ClusterSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: ClusterSpecImagePullSecrets[];

  /**
   * Metadata that will be inherited by all objects related to the Cluster
   *
   * @schema ClusterSpec#inheritedMetadata
   */
  readonly inheritedMetadata?: ClusterSpecInheritedMetadata;

  /**
   * Number of instances required in the cluster
   *
   * @schema ClusterSpec#instances
   */
  readonly instances: number;

  /**
   * LivenessProbeTimeout is the time (in seconds) that is allowed for a PostgreSQL instance
   * to successfully respond to the liveness probe (default 30).
   * The Liveness probe failure threshold is derived from this value using the formula:
   * ceiling(livenessProbe / 10).
   *
   * @schema ClusterSpec#livenessProbeTimeout
   */
  readonly livenessProbeTimeout?: number;

  /**
   * The instances' log level, one of the following values: error, warning, info (default), debug, trace
   *
   * @schema ClusterSpec#logLevel
   */
  readonly logLevel?: ClusterSpecLogLevel;

  /**
   * The configuration that is used by the portions of PostgreSQL that are managed by the instance manager
   *
   * @schema ClusterSpec#managed
   */
  readonly managed?: ClusterSpecManaged;

  /**
   * The target value for the synchronous replication quorum, that can be
   * decreased if the number of ready standbys is lower than this.
   * Undefined or 0 disable synchronous replication.
   *
   * @schema ClusterSpec#maxSyncReplicas
   */
  readonly maxSyncReplicas?: number;

  /**
   * Minimum number of instances required in synchronous replication with the
   * primary. Undefined or 0 allow writes to complete when no standby is
   * available.
   *
   * @schema ClusterSpec#minSyncReplicas
   */
  readonly minSyncReplicas?: number;

  /**
   * The configuration of the monitoring infrastructure of this cluster
   *
   * @schema ClusterSpec#monitoring
   */
  readonly monitoring?: ClusterSpecMonitoring;

  /**
   * Define a maintenance window for the Kubernetes nodes
   *
   * @schema ClusterSpec#nodeMaintenanceWindow
   */
  readonly nodeMaintenanceWindow?: ClusterSpecNodeMaintenanceWindow;

  /**
   * The plugins configuration, containing
   * any plugin to be loaded with the corresponding configuration
   *
   * @schema ClusterSpec#plugins
   */
  readonly plugins?: ClusterSpecPlugins[];

  /**
   * Override the PodSecurityContext applied to every Pod of the cluster.
   * When set, this overrides the operator's default PodSecurityContext for the cluster.
   * If omitted, the operator defaults are used.
   * This field doesn't have any effect if SecurityContextConstraints are present.
   *
   * @schema ClusterSpec#podSecurityContext
   */
  readonly podSecurityContext?: ClusterSpecPodSecurityContext;

  /**
   * The GID of the `postgres` user inside the image, defaults to `26`
   *
   * @schema ClusterSpec#postgresGID
   */
  readonly postgresGid?: number;

  /**
   * The UID of the `postgres` user inside the image, defaults to `26`
   *
   * @schema ClusterSpec#postgresUID
   */
  readonly postgresUid?: number;

  /**
   * Configuration of the PostgreSQL server
   *
   * @schema ClusterSpec#postgresql
   */
  readonly postgresql?: ClusterSpecPostgresql;

  /**
   * Method to follow to upgrade the primary server during a rolling
   * update procedure, after all replicas have been successfully updated:
   * it can be with a switchover (`switchover`) or in-place (`restart` - default).
   * Note: when using `switchover`, the operator will reject updates that change both
   * the image name and PostgreSQL configuration parameters simultaneously to avoid
   * configuration mismatches during the switchover process.
   *
   * @schema ClusterSpec#primaryUpdateMethod
   */
  readonly primaryUpdateMethod?: ClusterSpecPrimaryUpdateMethod;

  /**
   * Deployment strategy to follow to upgrade the primary server during a rolling
   * update procedure, after all replicas have been successfully updated:
   * it can be automated (`unsupervised` - default) or manual (`supervised`)
   *
   * @schema ClusterSpec#primaryUpdateStrategy
   */
  readonly primaryUpdateStrategy?: ClusterSpecPrimaryUpdateStrategy;

  /**
   * Name of the priority class which will be used in every generated Pod, if the PriorityClass
   * specified does not exist, the pod will not be able to schedule.  Please refer to
   * https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass
   * for more information
   *
   * @schema ClusterSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The configuration of the probes to be injected
   * in the PostgreSQL Pods.
   *
   * @schema ClusterSpec#probes
   */
  readonly probes?: ClusterSpecProbes;

  /**
   * Template to be used to define projected volumes, projected volumes will be mounted
   * under `/projected` base folder
   *
   * @schema ClusterSpec#projectedVolumeTemplate
   */
  readonly projectedVolumeTemplate?: ClusterSpecProjectedVolumeTemplate;

  /**
   * Replica cluster configuration
   *
   * @schema ClusterSpec#replica
   */
  readonly replica?: ClusterSpecReplica;

  /**
   * Replication slots management configuration
   *
   * @schema ClusterSpec#replicationSlots
   */
  readonly replicationSlots?: ClusterSpecReplicationSlots;

  /**
   * Resources requirements of every generated Pod. Please refer to
   * https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * for more information.
   *
   * @schema ClusterSpec#resources
   */
  readonly resources?: ClusterSpecResources;

  /**
   * If specified, the pod will be dispatched by specified Kubernetes
   * scheduler. If not specified, the pod will be dispatched by the default
   * scheduler. More info:
   * https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/
   *
   * @schema ClusterSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The SeccompProfile applied to every Pod and Container.
   * Defaults to: `RuntimeDefault`
   *
   * @default RuntimeDefault`
   * @schema ClusterSpec#seccompProfile
   */
  readonly seccompProfile?: ClusterSpecSeccompProfile;

  /**
   * Override the SecurityContext applied to every Container in the Pod of the cluster.
   * When set, this overrides the operator's default Container SecurityContext.
   * If omitted, the operator defaults are used.
   *
   * @schema ClusterSpec#securityContext
   */
  readonly securityContext?: ClusterSpecSecurityContext;

  /**
   * Configure the generation of the service account
   *
   * @schema ClusterSpec#serviceAccountTemplate
   */
  readonly serviceAccountTemplate?: ClusterSpecServiceAccountTemplate;

  /**
   * The time in seconds that controls the window of time reserved for the smart shutdown of Postgres to complete.
   * Make sure you reserve enough time for the operator to request a fast shutdown of Postgres
   * (that is: `stopDelay` - `smartShutdownTimeout`). Default is 180 seconds.
   *
   * @default 180 seconds.
   * @schema ClusterSpec#smartShutdownTimeout
   */
  readonly smartShutdownTimeout?: number;

  /**
   * The time in seconds that is allowed for a PostgreSQL instance to
   * successfully start up (default 3600).
   * The startup probe failure threshold is derived from this value using the formula:
   * ceiling(startDelay / 10).
   *
   * @schema ClusterSpec#startDelay
   */
  readonly startDelay?: number;

  /**
   * The time in seconds that is allowed for a PostgreSQL instance to
   * gracefully shutdown (default 1800)
   *
   * @schema ClusterSpec#stopDelay
   */
  readonly stopDelay?: number;

  /**
   * Configuration of the storage of the instances
   *
   * @schema ClusterSpec#storage
   */
  readonly storage?: ClusterSpecStorage;

  /**
   * The secret containing the superuser password. If not defined a new
   * secret will be created with a randomly generated password
   *
   * @schema ClusterSpec#superuserSecret
   */
  readonly superuserSecret?: ClusterSpecSuperuserSecret;

  /**
   * The time in seconds that is allowed for a primary PostgreSQL instance
   * to gracefully shutdown during a switchover.
   * Default value is 3600 seconds (1 hour).
   *
   * @schema ClusterSpec#switchoverDelay
   */
  readonly switchoverDelay?: number;

  /**
   * The tablespaces configuration
   *
   * @schema ClusterSpec#tablespaces
   */
  readonly tablespaces?: ClusterSpecTablespaces[];

  /**
   * TopologySpreadConstraints specifies how to spread matching pods among the given topology.
   * More info:
   * https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/
   *
   * @schema ClusterSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: ClusterSpecTopologySpreadConstraints[];

  /**
   * Configuration of the storage for PostgreSQL WAL (Write-Ahead Log)
   *
   * @schema ClusterSpec#walStorage
   */
  readonly walStorage?: ClusterSpecWalStorage;
}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': toJson_ClusterSpecAffinity(obj.affinity),
    'backup': toJson_ClusterSpecBackup(obj.backup),
    'bootstrap': toJson_ClusterSpecBootstrap(obj.bootstrap),
    'certificates': toJson_ClusterSpecCertificates(obj.certificates),
    'description': obj.description,
    'enablePDB': obj.enablePdb,
    'enableSuperuserAccess': obj.enableSuperuserAccess,
    'env': obj.env?.map(y => toJson_ClusterSpecEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_ClusterSpecEnvFrom(y)),
    'ephemeralVolumeSource': toJson_ClusterSpecEphemeralVolumeSource(obj.ephemeralVolumeSource),
    'ephemeralVolumesSizeLimit': toJson_ClusterSpecEphemeralVolumesSizeLimit(obj.ephemeralVolumesSizeLimit),
    'externalClusters': obj.externalClusters?.map(y => toJson_ClusterSpecExternalClusters(y)),
    'failoverDelay': obj.failoverDelay,
    'imageCatalogRef': toJson_ClusterSpecImageCatalogRef(obj.imageCatalogRef),
    'imageName': obj.imageName,
    'imagePullPolicy': obj.imagePullPolicy,
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_ClusterSpecImagePullSecrets(y)),
    'inheritedMetadata': toJson_ClusterSpecInheritedMetadata(obj.inheritedMetadata),
    'instances': obj.instances,
    'livenessProbeTimeout': obj.livenessProbeTimeout,
    'logLevel': obj.logLevel,
    'managed': toJson_ClusterSpecManaged(obj.managed),
    'maxSyncReplicas': obj.maxSyncReplicas,
    'minSyncReplicas': obj.minSyncReplicas,
    'monitoring': toJson_ClusterSpecMonitoring(obj.monitoring),
    'nodeMaintenanceWindow': toJson_ClusterSpecNodeMaintenanceWindow(obj.nodeMaintenanceWindow),
    'plugins': obj.plugins?.map(y => toJson_ClusterSpecPlugins(y)),
    'podSecurityContext': toJson_ClusterSpecPodSecurityContext(obj.podSecurityContext),
    'postgresGID': obj.postgresGid,
    'postgresUID': obj.postgresUid,
    'postgresql': toJson_ClusterSpecPostgresql(obj.postgresql),
    'primaryUpdateMethod': obj.primaryUpdateMethod,
    'primaryUpdateStrategy': obj.primaryUpdateStrategy,
    'priorityClassName': obj.priorityClassName,
    'probes': toJson_ClusterSpecProbes(obj.probes),
    'projectedVolumeTemplate': toJson_ClusterSpecProjectedVolumeTemplate(obj.projectedVolumeTemplate),
    'replica': toJson_ClusterSpecReplica(obj.replica),
    'replicationSlots': toJson_ClusterSpecReplicationSlots(obj.replicationSlots),
    'resources': toJson_ClusterSpecResources(obj.resources),
    'schedulerName': obj.schedulerName,
    'seccompProfile': toJson_ClusterSpecSeccompProfile(obj.seccompProfile),
    'securityContext': toJson_ClusterSpecSecurityContext(obj.securityContext),
    'serviceAccountTemplate': toJson_ClusterSpecServiceAccountTemplate(obj.serviceAccountTemplate),
    'smartShutdownTimeout': obj.smartShutdownTimeout,
    'startDelay': obj.startDelay,
    'stopDelay': obj.stopDelay,
    'storage': toJson_ClusterSpecStorage(obj.storage),
    'superuserSecret': toJson_ClusterSpecSuperuserSecret(obj.superuserSecret),
    'switchoverDelay': obj.switchoverDelay,
    'tablespaces': obj.tablespaces?.map(y => toJson_ClusterSpecTablespaces(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_ClusterSpecTopologySpreadConstraints(y)),
    'walStorage': toJson_ClusterSpecWalStorage(obj.walStorage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Affinity/Anti-affinity rules for Pods
 *
 * @schema ClusterSpecAffinity
 */
export interface ClusterSpecAffinity {
  /**
   * AdditionalPodAffinity allows to specify pod affinity terms to be passed to all the cluster's pods.
   *
   * @schema ClusterSpecAffinity#additionalPodAffinity
   */
  readonly additionalPodAffinity?: ClusterSpecAffinityAdditionalPodAffinity;

  /**
   * AdditionalPodAntiAffinity allows to specify pod anti-affinity terms to be added to the ones generated
   * by the operator if EnablePodAntiAffinity is set to true (default) or to be used exclusively if set to false.
   *
   * @schema ClusterSpecAffinity#additionalPodAntiAffinity
   */
  readonly additionalPodAntiAffinity?: ClusterSpecAffinityAdditionalPodAntiAffinity;

  /**
   * Activates anti-affinity for the pods. The operator will define pods
   * anti-affinity unless this field is explicitly set to false
   *
   * @schema ClusterSpecAffinity#enablePodAntiAffinity
   */
  readonly enablePodAntiAffinity?: boolean;

  /**
   * NodeAffinity describes node affinity scheduling rules for the pod.
   * More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity
   *
   * @schema ClusterSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: ClusterSpecAffinityNodeAffinity;

  /**
   * NodeSelector is map of key-value pairs used to define the nodes on which
   * the pods can run.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema ClusterSpecAffinity#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * PodAntiAffinityType allows the user to decide whether pod anti-affinity between cluster instance has to be
   * considered a strong requirement during scheduling or not. Allowed values are: "preferred" (default if empty) or
   * "required". Setting it to "required", could lead to instances remaining pending until new kubernetes nodes are
   * added if all the existing nodes don't match the required pod anti-affinity rule.
   * More info:
   * https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
   *
   * @schema ClusterSpecAffinity#podAntiAffinityType
   */
  readonly podAntiAffinityType?: string;

  /**
   * Tolerations is a list of Tolerations that should be set for all the pods, in order to allow them to run
   * on tainted nodes.
   * More info: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
   *
   * @schema ClusterSpecAffinity#tolerations
   */
  readonly tolerations?: ClusterSpecAffinityTolerations[];

  /**
   * TopologyKey to use for anti-affinity configuration. See k8s documentation
   * for more info on that
   *
   * @schema ClusterSpecAffinity#topologyKey
   */
  readonly topologyKey?: string;
}

/**
 * Converts an object of type 'ClusterSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinity(obj: ClusterSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalPodAffinity': toJson_ClusterSpecAffinityAdditionalPodAffinity(obj.additionalPodAffinity),
    'additionalPodAntiAffinity': toJson_ClusterSpecAffinityAdditionalPodAntiAffinity(obj.additionalPodAntiAffinity),
    'enablePodAntiAffinity': obj.enablePodAntiAffinity,
    'nodeAffinity': toJson_ClusterSpecAffinityNodeAffinity(obj.nodeAffinity),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podAntiAffinityType': obj.podAntiAffinityType,
    'tolerations': obj.tolerations?.map(y => toJson_ClusterSpecAffinityTolerations(y)),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration to be used for backups
 *
 * @schema ClusterSpecBackup
 */
export interface ClusterSpecBackup {
  /**
   * The configuration for the barman-cloud tool suite
   *
   * @schema ClusterSpecBackup#barmanObjectStore
   */
  readonly barmanObjectStore?: ClusterSpecBackupBarmanObjectStore;

  /**
   * RetentionPolicy is the retention policy to be used for backups
   * and WALs (i.e. '60d'). The retention policy is expressed in the form
   * of `XXu` where `XX` is a positive integer and `u` is in `[dwm]` -
   * days, weeks, months.
   * It's currently only applicable when using the BarmanObjectStore method.
   *
   * @schema ClusterSpecBackup#retentionPolicy
   */
  readonly retentionPolicy?: string;

  /**
   * The policy to decide which instance should perform backups. Available
   * options are empty string, which will default to `prefer-standby` policy,
   * `primary` to have backups run always on primary instances, `prefer-standby`
   * to have backups run preferably on the most updated standby, if available.
   *
   * @schema ClusterSpecBackup#target
   */
  readonly target?: ClusterSpecBackupTarget;

  /**
   * VolumeSnapshot provides the configuration for the execution of volume snapshot backups.
   *
   * @schema ClusterSpecBackup#volumeSnapshot
   */
  readonly volumeSnapshot?: ClusterSpecBackupVolumeSnapshot;
}

/**
 * Converts an object of type 'ClusterSpecBackup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackup(obj: ClusterSpecBackup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'barmanObjectStore': toJson_ClusterSpecBackupBarmanObjectStore(obj.barmanObjectStore),
    'retentionPolicy': obj.retentionPolicy,
    'target': obj.target,
    'volumeSnapshot': toJson_ClusterSpecBackupVolumeSnapshot(obj.volumeSnapshot),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Instructions to bootstrap this cluster
 *
 * @schema ClusterSpecBootstrap
 */
export interface ClusterSpecBootstrap {
  /**
   * Bootstrap the cluster via initdb
   *
   * @schema ClusterSpecBootstrap#initdb
   */
  readonly initdb?: ClusterSpecBootstrapInitdb;

  /**
   * Bootstrap the cluster taking a physical backup of another compatible
   * PostgreSQL instance
   *
   * @schema ClusterSpecBootstrap#pg_basebackup
   */
  readonly pgBasebackup?: ClusterSpecBootstrapPgBasebackup;

  /**
   * Bootstrap the cluster from a backup
   *
   * @schema ClusterSpecBootstrap#recovery
   */
  readonly recovery?: ClusterSpecBootstrapRecovery;
}

/**
 * Converts an object of type 'ClusterSpecBootstrap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrap(obj: ClusterSpecBootstrap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initdb': toJson_ClusterSpecBootstrapInitdb(obj.initdb),
    'pg_basebackup': toJson_ClusterSpecBootstrapPgBasebackup(obj.pgBasebackup),
    'recovery': toJson_ClusterSpecBootstrapRecovery(obj.recovery),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration for the CA and related certificates
 *
 * @schema ClusterSpecCertificates
 */
export interface ClusterSpecCertificates {
  /**
   * The secret containing the Client CA certificate. If not defined, a new secret will be created
   * with a self-signed CA and will be used to generate all the client certificates.<br />
   * <br />
   * Contains:<br />
   * <br />
   * - `ca.crt`: CA that should be used to validate the client certificates,
   * used as `ssl_ca_file` of all the instances.<br />
   * - `ca.key`: key used to generate client certificates, if ReplicationTLSSecret is provided,
   * this can be omitted.<br />
   *
   * @schema ClusterSpecCertificates#clientCASecret
   */
  readonly clientCaSecret?: string;

  /**
   * The secret of type kubernetes.io/tls containing the client certificate to authenticate as
   * the `streaming_replica` user.
   * If not defined, ClientCASecret must provide also `ca.key`, and a new secret will be
   * created using the provided CA.
   *
   * @schema ClusterSpecCertificates#replicationTLSSecret
   */
  readonly replicationTlsSecret?: string;

  /**
   * The list of the server alternative DNS names to be added to the generated server TLS certificates, when required.
   *
   * @schema ClusterSpecCertificates#serverAltDNSNames
   */
  readonly serverAltDnsNames?: string[];

  /**
   * The secret containing the Server CA certificate. If not defined, a new secret will be created
   * with a self-signed CA and will be used to generate the TLS certificate ServerTLSSecret.<br />
   * <br />
   * Contains:<br />
   * <br />
   * - `ca.crt`: CA that should be used to validate the server certificate,
   * used as `sslrootcert` in client connection strings.<br />
   * - `ca.key`: key used to generate Server SSL certs, if ServerTLSSecret is provided,
   * this can be omitted.<br />
   *
   * @schema ClusterSpecCertificates#serverCASecret
   */
  readonly serverCaSecret?: string;

  /**
   * The secret of type kubernetes.io/tls containing the server TLS certificate and key that will be set as
   * `ssl_cert_file` and `ssl_key_file` so that clients can connect to postgres securely.
   * If not defined, ServerCASecret must provide also `ca.key` and a new secret will be
   * created using the provided CA.
   *
   * @schema ClusterSpecCertificates#serverTLSSecret
   */
  readonly serverTlsSecret?: string;
}

/**
 * Converts an object of type 'ClusterSpecCertificates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecCertificates(obj: ClusterSpecCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCASecret': obj.clientCaSecret,
    'replicationTLSSecret': obj.replicationTlsSecret,
    'serverAltDNSNames': obj.serverAltDnsNames?.map(y => y),
    'serverCASecret': obj.serverCaSecret,
    'serverTLSSecret': obj.serverTlsSecret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema ClusterSpecEnv
 */
export interface ClusterSpecEnv {
  /**
   * Name of the environment variable.
   * May consist of any printable ASCII characters except '='.
   *
   * @schema ClusterSpecEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema ClusterSpecEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema ClusterSpecEnv#valueFrom
   */
  readonly valueFrom?: ClusterSpecEnvValueFrom;
}

/**
 * Converts an object of type 'ClusterSpecEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEnv(obj: ClusterSpecEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_ClusterSpecEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps or Secrets
 *
 * @schema ClusterSpecEnvFrom
 */
export interface ClusterSpecEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ClusterSpecEnvFrom#configMapRef
   */
  readonly configMapRef?: ClusterSpecEnvFromConfigMapRef;

  /**
   * Optional text to prepend to the name of each environment variable.
   * May consist of any printable ASCII characters except '='.
   *
   * @schema ClusterSpecEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ClusterSpecEnvFrom#secretRef
   */
  readonly secretRef?: ClusterSpecEnvFromSecretRef;
}

/**
 * Converts an object of type 'ClusterSpecEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEnvFrom(obj: ClusterSpecEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_ClusterSpecEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_ClusterSpecEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EphemeralVolumeSource allows the user to configure the source of ephemeral volumes.
 *
 * @schema ClusterSpecEphemeralVolumeSource
 */
export interface ClusterSpecEphemeralVolumeSource {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   * Required, must not be nil.
   *
   * @schema ClusterSpecEphemeralVolumeSource#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate;
}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEphemeralVolumeSource(obj: ClusterSpecEphemeralVolumeSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EphemeralVolumesSizeLimit allows the user to set the limits for the ephemeral
 * volumes
 *
 * @schema ClusterSpecEphemeralVolumesSizeLimit
 */
export interface ClusterSpecEphemeralVolumesSizeLimit {
  /**
   * Shm is the size limit of the shared memory volume
   *
   * @schema ClusterSpecEphemeralVolumesSizeLimit#shm
   */
  readonly shm?: ClusterSpecEphemeralVolumesSizeLimitShm;

  /**
   * TemporaryData is the size limit of the temporary data volume
   *
   * @schema ClusterSpecEphemeralVolumesSizeLimit#temporaryData
   */
  readonly temporaryData?: ClusterSpecEphemeralVolumesSizeLimitTemporaryData;
}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumesSizeLimit' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEphemeralVolumesSizeLimit(obj: ClusterSpecEphemeralVolumesSizeLimit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'shm': obj.shm?.value,
    'temporaryData': obj.temporaryData?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalCluster represents the connection parameters to an
 * external cluster which is used in the other sections of the configuration
 *
 * @schema ClusterSpecExternalClusters
 */
export interface ClusterSpecExternalClusters {
  /**
   * The configuration for the barman-cloud tool suite
   *
   * @schema ClusterSpecExternalClusters#barmanObjectStore
   */
  readonly barmanObjectStore?: ClusterSpecExternalClustersBarmanObjectStore;

  /**
   * The list of connection parameters, such as dbname, host, username, etc
   *
   * @schema ClusterSpecExternalClusters#connectionParameters
   */
  readonly connectionParameters?: { [key: string]: string };

  /**
   * The server name, required
   *
   * @schema ClusterSpecExternalClusters#name
   */
  readonly name: string;

  /**
   * The reference to the password to be used to connect to the server.
   * If a password is provided, CloudNativePG creates a PostgreSQL
   * passfile at `/controller/external/NAME/pass` (where "NAME" is the
   * cluster's name). This passfile is automatically referenced in the
   * connection string when establishing a connection to the remote
   * PostgreSQL server from the current PostgreSQL `Cluster`. This ensures
   * secure and efficient password management for external clusters.
   *
   * @schema ClusterSpecExternalClusters#password
   */
  readonly password?: ClusterSpecExternalClustersPassword;

  /**
   * The configuration of the plugin that is taking care
   * of WAL archiving and backups for this external cluster
   *
   * @schema ClusterSpecExternalClusters#plugin
   */
  readonly plugin?: ClusterSpecExternalClustersPlugin;

  /**
   * The reference to an SSL certificate to be used to connect to this
   * instance
   *
   * @schema ClusterSpecExternalClusters#sslCert
   */
  readonly sslCert?: ClusterSpecExternalClustersSslCert;

  /**
   * The reference to an SSL private key to be used to connect to this
   * instance
   *
   * @schema ClusterSpecExternalClusters#sslKey
   */
  readonly sslKey?: ClusterSpecExternalClustersSslKey;

  /**
   * The reference to an SSL CA public key to be used to connect to this
   * instance
   *
   * @schema ClusterSpecExternalClusters#sslRootCert
   */
  readonly sslRootCert?: ClusterSpecExternalClustersSslRootCert;
}

/**
 * Converts an object of type 'ClusterSpecExternalClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClusters(obj: ClusterSpecExternalClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'barmanObjectStore': toJson_ClusterSpecExternalClustersBarmanObjectStore(obj.barmanObjectStore),
    'connectionParameters': ((obj.connectionParameters) === undefined) ? undefined : (Object.entries(obj.connectionParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'password': toJson_ClusterSpecExternalClustersPassword(obj.password),
    'plugin': toJson_ClusterSpecExternalClustersPlugin(obj.plugin),
    'sslCert': toJson_ClusterSpecExternalClustersSslCert(obj.sslCert),
    'sslKey': toJson_ClusterSpecExternalClustersSslKey(obj.sslKey),
    'sslRootCert': toJson_ClusterSpecExternalClustersSslRootCert(obj.sslRootCert),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines the major PostgreSQL version we want to use within an ImageCatalog
 *
 * @schema ClusterSpecImageCatalogRef
 */
export interface ClusterSpecImageCatalogRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecImageCatalogRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecImageCatalogRef#kind
   */
  readonly kind: string;

  /**
   * The major version of PostgreSQL we want to use from the ImageCatalog
   *
   * @schema ClusterSpecImageCatalogRef#major
   */
  readonly major: number;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecImageCatalogRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecImageCatalogRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecImageCatalogRef(obj: ClusterSpecImageCatalogRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'major': obj.major,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate a
 * local object with a known type inside the same namespace
 *
 * @schema ClusterSpecImagePullSecrets
 */
export interface ClusterSpecImagePullSecrets {
  /**
   * Name of the referent.
   *
   * @schema ClusterSpecImagePullSecrets#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecImagePullSecrets(obj: ClusterSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata that will be inherited by all objects related to the Cluster
 *
 * @schema ClusterSpecInheritedMetadata
 */
export interface ClusterSpecInheritedMetadata {
  /**
   * @schema ClusterSpecInheritedMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ClusterSpecInheritedMetadata#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecInheritedMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInheritedMetadata(obj: ClusterSpecInheritedMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The instances' log level, one of the following values: error, warning, info (default), debug, trace
 *
 * @schema ClusterSpecLogLevel
 */
export enum ClusterSpecLogLevel {
  /** error */
  ERROR = "error",
  /** warning */
  WARNING = "warning",
  /** info */
  INFO = "info",
  /** debug */
  DEBUG = "debug",
  /** trace */
  TRACE = "trace",
}

/**
 * The configuration that is used by the portions of PostgreSQL that are managed by the instance manager
 *
 * @schema ClusterSpecManaged
 */
export interface ClusterSpecManaged {
  /**
   * Database roles managed by the `Cluster`
   *
   * @schema ClusterSpecManaged#roles
   */
  readonly roles?: ClusterSpecManagedRoles[];

  /**
   * Services roles managed by the `Cluster`
   *
   * @schema ClusterSpecManaged#services
   */
  readonly services?: ClusterSpecManagedServices;
}

/**
 * Converts an object of type 'ClusterSpecManaged' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManaged(obj: ClusterSpecManaged | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'roles': obj.roles?.map(y => toJson_ClusterSpecManagedRoles(y)),
    'services': toJson_ClusterSpecManagedServices(obj.services),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration of the monitoring infrastructure of this cluster
 *
 * @schema ClusterSpecMonitoring
 */
export interface ClusterSpecMonitoring {
  /**
   * The list of config maps containing the custom queries
   *
   * @schema ClusterSpecMonitoring#customQueriesConfigMap
   */
  readonly customQueriesConfigMap?: ClusterSpecMonitoringCustomQueriesConfigMap[];

  /**
   * The list of secrets containing the custom queries
   *
   * @schema ClusterSpecMonitoring#customQueriesSecret
   */
  readonly customQueriesSecret?: ClusterSpecMonitoringCustomQueriesSecret[];

  /**
   * Whether the default queries should be injected.
   * Set it to `true` if you don't want to inject default queries into the cluster.
   * Default: false.
   *
   * @schema ClusterSpecMonitoring#disableDefaultQueries
   */
  readonly disableDefaultQueries?: boolean;

  /**
   * Enable or disable the `PodMonitor`
   *
   * Deprecated: This feature will be removed in an upcoming release. If
   * you need this functionality, you can create a PodMonitor manually.
   *
   * @schema ClusterSpecMonitoring#enablePodMonitor
   */
  readonly enablePodMonitor?: boolean;

  /**
   * The interval during which metrics computed from queries are considered current.
   * Once it is exceeded, a new scrape will trigger a rerun
   * of the queries.
   * If not set, defaults to 30 seconds, in line with Prometheus scraping defaults.
   * Setting this to zero disables the caching mechanism and can cause heavy load on the PostgreSQL server.
   *
   * @schema ClusterSpecMonitoring#metricsQueriesTTL
   */
  readonly metricsQueriesTtl?: string;

  /**
   * The list of metric relabelings for the `PodMonitor`. Applied to samples before ingestion.
   *
   * Deprecated: This feature will be removed in an upcoming release. If
   * you need this functionality, you can create a PodMonitor manually.
   *
   * @schema ClusterSpecMonitoring#podMonitorMetricRelabelings
   */
  readonly podMonitorMetricRelabelings?: ClusterSpecMonitoringPodMonitorMetricRelabelings[];

  /**
   * The list of relabelings for the `PodMonitor`. Applied to samples before scraping.
   *
   * Deprecated: This feature will be removed in an upcoming release. If
   * you need this functionality, you can create a PodMonitor manually.
   *
   * @schema ClusterSpecMonitoring#podMonitorRelabelings
   */
  readonly podMonitorRelabelings?: ClusterSpecMonitoringPodMonitorRelabelings[];

  /**
   * Configure TLS communication for the metrics endpoint.
   * Changing tls.enabled option will force a rollout of all instances.
   *
   * @schema ClusterSpecMonitoring#tls
   */
  readonly tls?: ClusterSpecMonitoringTls;
}

/**
 * Converts an object of type 'ClusterSpecMonitoring' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMonitoring(obj: ClusterSpecMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customQueriesConfigMap': obj.customQueriesConfigMap?.map(y => toJson_ClusterSpecMonitoringCustomQueriesConfigMap(y)),
    'customQueriesSecret': obj.customQueriesSecret?.map(y => toJson_ClusterSpecMonitoringCustomQueriesSecret(y)),
    'disableDefaultQueries': obj.disableDefaultQueries,
    'enablePodMonitor': obj.enablePodMonitor,
    'metricsQueriesTTL': obj.metricsQueriesTtl,
    'podMonitorMetricRelabelings': obj.podMonitorMetricRelabelings?.map(y => toJson_ClusterSpecMonitoringPodMonitorMetricRelabelings(y)),
    'podMonitorRelabelings': obj.podMonitorRelabelings?.map(y => toJson_ClusterSpecMonitoringPodMonitorRelabelings(y)),
    'tls': toJson_ClusterSpecMonitoringTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Define a maintenance window for the Kubernetes nodes
 *
 * @schema ClusterSpecNodeMaintenanceWindow
 */
export interface ClusterSpecNodeMaintenanceWindow {
  /**
   * Is there a node maintenance activity in progress?
   *
   * @schema ClusterSpecNodeMaintenanceWindow#inProgress
   */
  readonly inProgress?: boolean;

  /**
   * Reuse the existing PVC (wait for the node to come
   * up again) or not (recreate it elsewhere - when `instances` >1)
   *
   * @schema ClusterSpecNodeMaintenanceWindow#reusePVC
   */
  readonly reusePvc?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecNodeMaintenanceWindow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecNodeMaintenanceWindow(obj: ClusterSpecNodeMaintenanceWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inProgress': obj.inProgress,
    'reusePVC': obj.reusePvc,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PluginConfiguration specifies a plugin that need to be loaded for this
 * cluster to be reconciled
 *
 * @schema ClusterSpecPlugins
 */
export interface ClusterSpecPlugins {
  /**
   * Enabled is true if this plugin will be used
   *
   * @schema ClusterSpecPlugins#enabled
   */
  readonly enabled?: boolean;

  /**
   * Marks the plugin as the WAL archiver. At most one plugin can be
   * designated as a WAL archiver. This cannot be enabled if the
   * `.spec.backup.barmanObjectStore` configuration is present.
   *
   * @schema ClusterSpecPlugins#isWALArchiver
   */
  readonly isWalArchiver?: boolean;

  /**
   * Name is the plugin name
   *
   * @schema ClusterSpecPlugins#name
   */
  readonly name: string;

  /**
   * Parameters is the configuration of the plugin
   *
   * @schema ClusterSpecPlugins#parameters
   */
  readonly parameters?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecPlugins' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPlugins(obj: ClusterSpecPlugins | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'isWALArchiver': obj.isWalArchiver,
    'name': obj.name,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Override the PodSecurityContext applied to every Pod of the cluster.
 * When set, this overrides the operator's default PodSecurityContext for the cluster.
 * If omitted, the operator defaults are used.
 * This field doesn't have any effect if SecurityContextConstraints are present.
 *
 * @schema ClusterSpecPodSecurityContext
 */
export interface ClusterSpecPodSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecPodSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: ClusterSpecPodSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ClusterSpecPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ClusterSpecPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecPodSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ClusterSpecPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ClusterSpecPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecPodSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecPodSecurityContext#sysctls
   */
  readonly sysctls?: ClusterSpecPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ClusterSpecPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ClusterSpecPodSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'ClusterSpecPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPodSecurityContext(obj: ClusterSpecPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appArmorProfile': toJson_ClusterSpecPodSecurityContextAppArmorProfile(obj.appArmorProfile),
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxChangePolicy': obj.seLinuxChangePolicy,
    'seLinuxOptions': toJson_ClusterSpecPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ClusterSpecPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'supplementalGroupsPolicy': obj.supplementalGroupsPolicy,
    'sysctls': obj.sysctls?.map(y => toJson_ClusterSpecPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_ClusterSpecPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of the PostgreSQL server
 *
 * @schema ClusterSpecPostgresql
 */
export interface ClusterSpecPostgresql {
  /**
   * If this parameter is true, the user will be able to invoke `ALTER SYSTEM`
   * on this CloudNativePG Cluster.
   * This should only be used for debugging and troubleshooting.
   * Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecPostgresql#enableAlterSystem
   */
  readonly enableAlterSystem?: boolean;

  /**
   * The configuration of the extensions to be added
   *
   * @schema ClusterSpecPostgresql#extensions
   */
  readonly extensions?: ClusterSpecPostgresqlExtensions[];

  /**
   * Options to specify LDAP configuration
   *
   * @schema ClusterSpecPostgresql#ldap
   */
  readonly ldap?: ClusterSpecPostgresqlLdap;

  /**
   * PostgreSQL configuration options (postgresql.conf)
   *
   * @schema ClusterSpecPostgresql#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * PostgreSQL Host Based Authentication rules (lines to be appended
   * to the pg_hba.conf file)
   *
   * @schema ClusterSpecPostgresql#pg_hba
   */
  readonly pgHba?: string[];

  /**
   * PostgreSQL User Name Maps rules (lines to be appended
   * to the pg_ident.conf file)
   *
   * @schema ClusterSpecPostgresql#pg_ident
   */
  readonly pgIdent?: string[];

  /**
   * Specifies the maximum number of seconds to wait when promoting an instance to primary.
   * Default value is 40000000, greater than one year in seconds,
   * big enough to simulate an infinite timeout
   *
   * @schema ClusterSpecPostgresql#promotionTimeout
   */
  readonly promotionTimeout?: number;

  /**
   * Lists of shared preload libraries to add to the default ones
   *
   * @schema ClusterSpecPostgresql#shared_preload_libraries
   */
  readonly sharedPreloadLibraries?: string[];

  /**
   * Requirements to be met by sync replicas. This will affect how the "synchronous_standby_names" parameter will be
   * set up.
   *
   * @schema ClusterSpecPostgresql#syncReplicaElectionConstraint
   */
  readonly syncReplicaElectionConstraint?: ClusterSpecPostgresqlSyncReplicaElectionConstraint;

  /**
   * Configuration of the PostgreSQL synchronous replication feature
   *
   * @schema ClusterSpecPostgresql#synchronous
   */
  readonly synchronous?: ClusterSpecPostgresqlSynchronous;
}

/**
 * Converts an object of type 'ClusterSpecPostgresql' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPostgresql(obj: ClusterSpecPostgresql | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableAlterSystem': obj.enableAlterSystem,
    'extensions': obj.extensions?.map(y => toJson_ClusterSpecPostgresqlExtensions(y)),
    'ldap': toJson_ClusterSpecPostgresqlLdap(obj.ldap),
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'pg_hba': obj.pgHba?.map(y => y),
    'pg_ident': obj.pgIdent?.map(y => y),
    'promotionTimeout': obj.promotionTimeout,
    'shared_preload_libraries': obj.sharedPreloadLibraries?.map(y => y),
    'syncReplicaElectionConstraint': toJson_ClusterSpecPostgresqlSyncReplicaElectionConstraint(obj.syncReplicaElectionConstraint),
    'synchronous': toJson_ClusterSpecPostgresqlSynchronous(obj.synchronous),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Method to follow to upgrade the primary server during a rolling
 * update procedure, after all replicas have been successfully updated:
 * it can be with a switchover (`switchover`) or in-place (`restart` - default).
 * Note: when using `switchover`, the operator will reject updates that change both
 * the image name and PostgreSQL configuration parameters simultaneously to avoid
 * configuration mismatches during the switchover process.
 *
 * @schema ClusterSpecPrimaryUpdateMethod
 */
export enum ClusterSpecPrimaryUpdateMethod {
  /** switchover */
  SWITCHOVER = "switchover",
  /** restart */
  RESTART = "restart",
}

/**
 * Deployment strategy to follow to upgrade the primary server during a rolling
 * update procedure, after all replicas have been successfully updated:
 * it can be automated (`unsupervised` - default) or manual (`supervised`)
 *
 * @schema ClusterSpecPrimaryUpdateStrategy
 */
export enum ClusterSpecPrimaryUpdateStrategy {
  /** unsupervised */
  UNSUPERVISED = "unsupervised",
  /** supervised */
  SUPERVISED = "supervised",
}

/**
 * The configuration of the probes to be injected
 * in the PostgreSQL Pods.
 *
 * @schema ClusterSpecProbes
 */
export interface ClusterSpecProbes {
  /**
   * The liveness probe configuration
   *
   * @schema ClusterSpecProbes#liveness
   */
  readonly liveness?: ClusterSpecProbesLiveness;

  /**
   * The readiness probe configuration
   *
   * @schema ClusterSpecProbes#readiness
   */
  readonly readiness?: ClusterSpecProbesReadiness;

  /**
   * The startup probe configuration
   *
   * @schema ClusterSpecProbes#startup
   */
  readonly startup?: ClusterSpecProbesStartup;
}

/**
 * Converts an object of type 'ClusterSpecProbes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProbes(obj: ClusterSpecProbes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'liveness': toJson_ClusterSpecProbesLiveness(obj.liveness),
    'readiness': toJson_ClusterSpecProbesReadiness(obj.readiness),
    'startup': toJson_ClusterSpecProbesStartup(obj.startup),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template to be used to define projected volumes, projected volumes will be mounted
 * under `/projected` base folder
 *
 * @schema ClusterSpecProjectedVolumeTemplate
 */
export interface ClusterSpecProjectedVolumeTemplate {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecProjectedVolumeTemplate#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections. Each entry in this list
   * handles one source.
   *
   * @schema ClusterSpecProjectedVolumeTemplate#sources
   */
  readonly sources?: ClusterSpecProjectedVolumeTemplateSources[];
}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplate(obj: ClusterSpecProjectedVolumeTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_ClusterSpecProjectedVolumeTemplateSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Replica cluster configuration
 *
 * @schema ClusterSpecReplica
 */
export interface ClusterSpecReplica {
  /**
   * If replica mode is enabled, this cluster will be a replica of an
   * existing cluster. Replica cluster can be created from a recovery
   * object store or via streaming through pg_basebackup.
   * Refer to the Replica clusters page of the documentation for more information.
   *
   * @schema ClusterSpecReplica#enabled
   */
  readonly enabled?: boolean;

  /**
   * When replica mode is enabled, this parameter allows you to replay
   * transactions only when the system time is at least the configured
   * time past the commit time. This provides an opportunity to correct
   * data loss errors. Note that when this parameter is set, a promotion
   * token cannot be used.
   *
   * @schema ClusterSpecReplica#minApplyDelay
   */
  readonly minApplyDelay?: string;

  /**
   * Primary defines which Cluster is defined to be the primary in the distributed PostgreSQL cluster, based on the
   * topology specified in externalClusters
   *
   * @schema ClusterSpecReplica#primary
   */
  readonly primary?: string;

  /**
   * A demotion token generated by an external cluster used to
   * check if the promotion requirements are met.
   *
   * @schema ClusterSpecReplica#promotionToken
   */
  readonly promotionToken?: string;

  /**
   * Self defines the name of this cluster. It is used to determine if this is a primary
   * or a replica cluster, comparing it with `primary`
   *
   * @schema ClusterSpecReplica#self
   */
  readonly self?: string;

  /**
   * The name of the external cluster which is the replication origin
   *
   * @schema ClusterSpecReplica#source
   */
  readonly source: string;
}

/**
 * Converts an object of type 'ClusterSpecReplica' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecReplica(obj: ClusterSpecReplica | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'minApplyDelay': obj.minApplyDelay,
    'primary': obj.primary,
    'promotionToken': obj.promotionToken,
    'self': obj.self,
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Replication slots management configuration
 *
 * @schema ClusterSpecReplicationSlots
 */
export interface ClusterSpecReplicationSlots {
  /**
   * Replication slots for high availability configuration
   *
   * @schema ClusterSpecReplicationSlots#highAvailability
   */
  readonly highAvailability?: ClusterSpecReplicationSlotsHighAvailability;

  /**
   * Configures the synchronization of the user defined physical replication slots
   *
   * @schema ClusterSpecReplicationSlots#synchronizeReplicas
   */
  readonly synchronizeReplicas?: ClusterSpecReplicationSlotsSynchronizeReplicas;

  /**
   * Standby will update the status of the local replication slots
   * every `updateInterval` seconds (default 30).
   *
   * @schema ClusterSpecReplicationSlots#updateInterval
   */
  readonly updateInterval?: number;
}

/**
 * Converts an object of type 'ClusterSpecReplicationSlots' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecReplicationSlots(obj: ClusterSpecReplicationSlots | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'highAvailability': toJson_ClusterSpecReplicationSlotsHighAvailability(obj.highAvailability),
    'synchronizeReplicas': toJson_ClusterSpecReplicationSlotsSynchronizeReplicas(obj.synchronizeReplicas),
    'updateInterval': obj.updateInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources requirements of every generated Pod. Please refer to
 * https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * for more information.
 *
 * @schema ClusterSpecResources
 */
export interface ClusterSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This field depends on the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ClusterSpecResources#claims
   */
  readonly claims?: ClusterSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecResources#limits
   */
  readonly limits?: { [key: string]: ClusterSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecResources#requests
   */
  readonly requests?: { [key: string]: ClusterSpecResourcesRequests };
}

/**
 * Converts an object of type 'ClusterSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecResources(obj: ClusterSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_ClusterSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SeccompProfile applied to every Pod and Container.
 * Defaults to: `RuntimeDefault`
 *
 * @default RuntimeDefault`
 * @schema ClusterSpecSeccompProfile
 */
export interface ClusterSpecSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ClusterSpecSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ClusterSpecSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ClusterSpecSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecSeccompProfile(obj: ClusterSpecSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Override the SecurityContext applied to every Container in the Pod of the cluster.
 * When set, this overrides the operator's default Container SecurityContext.
 * If omitted, the operator defaults are used.
 *
 * @schema ClusterSpecSecurityContext
 */
export interface ClusterSpecSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: ClusterSpecSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema ClusterSpecSecurityContext#capabilities
   */
  readonly capabilities?: ClusterSpecSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema ClusterSpecSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema ClusterSpecSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ClusterSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ClusterSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ClusterSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ClusterSpecSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ClusterSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ClusterSpecSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'ClusterSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecSecurityContext(obj: ClusterSpecSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'appArmorProfile': toJson_ClusterSpecSecurityContextAppArmorProfile(obj.appArmorProfile),
    'capabilities': toJson_ClusterSpecSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_ClusterSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ClusterSpecSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_ClusterSpecSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configure the generation of the service account
 *
 * @schema ClusterSpecServiceAccountTemplate
 */
export interface ClusterSpecServiceAccountTemplate {
  /**
   * Metadata are the metadata to be used for the generated
   * service account
   *
   * @schema ClusterSpecServiceAccountTemplate#metadata
   */
  readonly metadata: ClusterSpecServiceAccountTemplateMetadata;
}

/**
 * Converts an object of type 'ClusterSpecServiceAccountTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecServiceAccountTemplate(obj: ClusterSpecServiceAccountTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_ClusterSpecServiceAccountTemplateMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of the storage of the instances
 *
 * @schema ClusterSpecStorage
 */
export interface ClusterSpecStorage {
  /**
   * Template to be used to generate the Persistent Volume Claim
   *
   * @schema ClusterSpecStorage#pvcTemplate
   */
  readonly pvcTemplate?: ClusterSpecStoragePvcTemplate;

  /**
   * Resize existent PVCs, defaults to true
   *
   * @schema ClusterSpecStorage#resizeInUseVolumes
   */
  readonly resizeInUseVolumes?: boolean;

  /**
   * Size of the storage. Required if not already specified in the PVC template.
   * Changes to this field are automatically reapplied to the created PVCs.
   * Size cannot be decreased.
   *
   * @schema ClusterSpecStorage#size
   */
  readonly size?: string;

  /**
   * StorageClass to use for PVCs. Applied after
   * evaluating the PVC template, if available.
   * If not specified, the generated PVCs will use the
   * default storage class
   *
   * @schema ClusterSpecStorage#storageClass
   */
  readonly storageClass?: string;
}

/**
 * Converts an object of type 'ClusterSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecStorage(obj: ClusterSpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pvcTemplate': toJson_ClusterSpecStoragePvcTemplate(obj.pvcTemplate),
    'resizeInUseVolumes': obj.resizeInUseVolumes,
    'size': obj.size,
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The secret containing the superuser password. If not defined a new
 * secret will be created with a randomly generated password
 *
 * @schema ClusterSpecSuperuserSecret
 */
export interface ClusterSpecSuperuserSecret {
  /**
   * Name of the referent.
   *
   * @schema ClusterSpecSuperuserSecret#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecSuperuserSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecSuperuserSecret(obj: ClusterSpecSuperuserSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TablespaceConfiguration is the configuration of a tablespace, and includes
 * the storage specification for the tablespace
 *
 * @schema ClusterSpecTablespaces
 */
export interface ClusterSpecTablespaces {
  /**
   * The name of the tablespace
   *
   * @schema ClusterSpecTablespaces#name
   */
  readonly name: string;

  /**
   * Owner is the PostgreSQL user owning the tablespace
   *
   * @schema ClusterSpecTablespaces#owner
   */
  readonly owner?: ClusterSpecTablespacesOwner;

  /**
   * The storage configuration for the tablespace
   *
   * @schema ClusterSpecTablespaces#storage
   */
  readonly storage: ClusterSpecTablespacesStorage;

  /**
   * When set to true, the tablespace will be added as a `temp_tablespaces`
   * entry in PostgreSQL, and will be available to automatically house temp
   * database objects, or other temporary files. Please refer to PostgreSQL
   * documentation for more information on the `temp_tablespaces` GUC.
   *
   * @schema ClusterSpecTablespaces#temporary
   */
  readonly temporary?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecTablespaces' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecTablespaces(obj: ClusterSpecTablespaces | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'owner': toJson_ClusterSpecTablespacesOwner(obj.owner),
    'storage': toJson_ClusterSpecTablespacesStorage(obj.storage),
    'temporary': obj.temporary,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema ClusterSpecTopologySpreadConstraints
 */
export interface ClusterSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema ClusterSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: ClusterSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema ClusterSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema ClusterSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   * @schema ClusterSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   *
   * @schema ClusterSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   *
   * @schema ClusterSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema ClusterSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema ClusterSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'ClusterSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecTopologySpreadConstraints(obj: ClusterSpecTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of the storage for PostgreSQL WAL (Write-Ahead Log)
 *
 * @schema ClusterSpecWalStorage
 */
export interface ClusterSpecWalStorage {
  /**
   * Template to be used to generate the Persistent Volume Claim
   *
   * @schema ClusterSpecWalStorage#pvcTemplate
   */
  readonly pvcTemplate?: ClusterSpecWalStoragePvcTemplate;

  /**
   * Resize existent PVCs, defaults to true
   *
   * @schema ClusterSpecWalStorage#resizeInUseVolumes
   */
  readonly resizeInUseVolumes?: boolean;

  /**
   * Size of the storage. Required if not already specified in the PVC template.
   * Changes to this field are automatically reapplied to the created PVCs.
   * Size cannot be decreased.
   *
   * @schema ClusterSpecWalStorage#size
   */
  readonly size?: string;

  /**
   * StorageClass to use for PVCs. Applied after
   * evaluating the PVC template, if available.
   * If not specified, the generated PVCs will use the
   * default storage class
   *
   * @schema ClusterSpecWalStorage#storageClass
   */
  readonly storageClass?: string;
}

/**
 * Converts an object of type 'ClusterSpecWalStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecWalStorage(obj: ClusterSpecWalStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pvcTemplate': toJson_ClusterSpecWalStoragePvcTemplate(obj.pvcTemplate),
    'resizeInUseVolumes': obj.resizeInUseVolumes,
    'size': obj.size,
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AdditionalPodAffinity allows to specify pod affinity terms to be passed to all the cluster's pods.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinity
 */
export interface ClusterSpecAffinityAdditionalPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinity(obj: ClusterSpecAffinityAdditionalPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AdditionalPodAntiAffinity allows to specify pod anti-affinity terms to be added to the ones generated
 * by the operator if EnablePodAntiAffinity is set to true (default) or to be used exclusively if set to false.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinity
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and subtracting
   * "weight" from the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinity(obj: ClusterSpecAffinityAdditionalPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodeAffinity describes node affinity scheduling rules for the pod.
 * More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity
 *
 * @schema ClusterSpecAffinityNodeAffinity
 */
export interface ClusterSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ClusterSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema ClusterSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityNodeAffinity(obj: ClusterSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ClusterSpecAffinityTolerations
 */
export interface ClusterSpecAffinityTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ClusterSpecAffinityTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ClusterSpecAffinityTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists, Equal, Lt, and Gt. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   * Lt and Gt perform numeric comparisons (requires feature gate TaintTolerationComparisonOperators).
   *
   * @default Equal.
   * @schema ClusterSpecAffinityTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ClusterSpecAffinityTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ClusterSpecAffinityTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterSpecAffinityTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityTolerations(obj: ClusterSpecAffinityTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration for the barman-cloud tool suite
 *
 * @schema ClusterSpecBackupBarmanObjectStore
 */
export interface ClusterSpecBackupBarmanObjectStore {
  /**
   * The credentials to use to upload data to Azure Blob Storage
   *
   * @schema ClusterSpecBackupBarmanObjectStore#azureCredentials
   */
  readonly azureCredentials?: ClusterSpecBackupBarmanObjectStoreAzureCredentials;

  /**
   * The configuration to be used to backup the data files
   * When not defined, base backups files will be stored uncompressed and may
   * be unencrypted in the object store, according to the bucket default
   * policy.
   *
   * @schema ClusterSpecBackupBarmanObjectStore#data
   */
  readonly data?: ClusterSpecBackupBarmanObjectStoreData;

  /**
   * The path where to store the backup (i.e. s3://bucket/path/to/folder)
   * this path, with different destination folders, will be used for WALs
   * and for data
   *
   * @schema ClusterSpecBackupBarmanObjectStore#destinationPath
   */
  readonly destinationPath: string;

  /**
   * EndpointCA store the CA bundle of the barman endpoint.
   * Useful when using self-signed certificates to avoid
   * errors with certificate issuer and barman-cloud-wal-archive
   *
   * @schema ClusterSpecBackupBarmanObjectStore#endpointCA
   */
  readonly endpointCa?: ClusterSpecBackupBarmanObjectStoreEndpointCa;

  /**
   * Endpoint to be used to upload data to the cloud,
   * overriding the automatic endpoint discovery
   *
   * @schema ClusterSpecBackupBarmanObjectStore#endpointURL
   */
  readonly endpointUrl?: string;

  /**
   * The credentials to use to upload data to Google Cloud Storage
   *
   * @schema ClusterSpecBackupBarmanObjectStore#googleCredentials
   */
  readonly googleCredentials?: ClusterSpecBackupBarmanObjectStoreGoogleCredentials;

  /**
   * HistoryTags is a list of key value pairs that will be passed to the
   * Barman --history-tags option.
   *
   * @schema ClusterSpecBackupBarmanObjectStore#historyTags
   */
  readonly historyTags?: { [key: string]: string };

  /**
   * The credentials to use to upload data to S3
   *
   * @schema ClusterSpecBackupBarmanObjectStore#s3Credentials
   */
  readonly s3Credentials?: ClusterSpecBackupBarmanObjectStoreS3Credentials;

  /**
   * The server name on S3, the cluster name is used if this
   * parameter is omitted
   *
   * @schema ClusterSpecBackupBarmanObjectStore#serverName
   */
  readonly serverName?: string;

  /**
   * Tags is a list of key value pairs that will be passed to the
   * Barman --tags option.
   *
   * @schema ClusterSpecBackupBarmanObjectStore#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The configuration for the backup of the WAL stream.
   * When not defined, WAL files will be stored uncompressed and may be
   * unencrypted in the object store, according to the bucket default policy.
   *
   * @schema ClusterSpecBackupBarmanObjectStore#wal
   */
  readonly wal?: ClusterSpecBackupBarmanObjectStoreWal;
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStore(obj: ClusterSpecBackupBarmanObjectStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azureCredentials': toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentials(obj.azureCredentials),
    'data': toJson_ClusterSpecBackupBarmanObjectStoreData(obj.data),
    'destinationPath': obj.destinationPath,
    'endpointCA': toJson_ClusterSpecBackupBarmanObjectStoreEndpointCa(obj.endpointCa),
    'endpointURL': obj.endpointUrl,
    'googleCredentials': toJson_ClusterSpecBackupBarmanObjectStoreGoogleCredentials(obj.googleCredentials),
    'historyTags': ((obj.historyTags) === undefined) ? undefined : (Object.entries(obj.historyTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    's3Credentials': toJson_ClusterSpecBackupBarmanObjectStoreS3Credentials(obj.s3Credentials),
    'serverName': obj.serverName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'wal': toJson_ClusterSpecBackupBarmanObjectStoreWal(obj.wal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The policy to decide which instance should perform backups. Available
 * options are empty string, which will default to `prefer-standby` policy,
 * `primary` to have backups run always on primary instances, `prefer-standby`
 * to have backups run preferably on the most updated standby, if available.
 *
 * @schema ClusterSpecBackupTarget
 */
export enum ClusterSpecBackupTarget {
  /** primary */
  PRIMARY = "primary",
  /** prefer-standby */
  PREFER_HYPHEN_STANDBY = "prefer-standby",
}

/**
 * VolumeSnapshot provides the configuration for the execution of volume snapshot backups.
 *
 * @schema ClusterSpecBackupVolumeSnapshot
 */
export interface ClusterSpecBackupVolumeSnapshot {
  /**
   * Annotations key-value pairs that will be added to .metadata.annotations snapshot resources.
   *
   * @schema ClusterSpecBackupVolumeSnapshot#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * ClassName specifies the Snapshot Class to be used for PG_DATA PersistentVolumeClaim.
   * It is the default class for the other types if no specific class is present
   *
   * @schema ClusterSpecBackupVolumeSnapshot#className
   */
  readonly className?: string;

  /**
   * Labels are key-value pairs that will be added to .metadata.labels snapshot resources.
   *
   * @schema ClusterSpecBackupVolumeSnapshot#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Whether the default type of backup with volume snapshots is
   * online/hot (`true`, default) or offline/cold (`false`)
   *
   * @schema ClusterSpecBackupVolumeSnapshot#online
   */
  readonly online?: boolean;

  /**
   * Configuration parameters to control the online/hot backup with volume snapshots
   *
   * @schema ClusterSpecBackupVolumeSnapshot#onlineConfiguration
   */
  readonly onlineConfiguration?: ClusterSpecBackupVolumeSnapshotOnlineConfiguration;

  /**
   * SnapshotOwnerReference indicates the type of owner reference the snapshot should have
   *
   * @schema ClusterSpecBackupVolumeSnapshot#snapshotOwnerReference
   */
  readonly snapshotOwnerReference?: ClusterSpecBackupVolumeSnapshotSnapshotOwnerReference;

  /**
   * TablespaceClassName specifies the Snapshot Class to be used for the tablespaces.
   * defaults to the PGDATA Snapshot Class, if set
   *
   * @schema ClusterSpecBackupVolumeSnapshot#tablespaceClassName
   */
  readonly tablespaceClassName?: { [key: string]: string };

  /**
   * WalClassName specifies the Snapshot Class to be used for the PG_WAL PersistentVolumeClaim.
   *
   * @schema ClusterSpecBackupVolumeSnapshot#walClassName
   */
  readonly walClassName?: string;
}

/**
 * Converts an object of type 'ClusterSpecBackupVolumeSnapshot' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupVolumeSnapshot(obj: ClusterSpecBackupVolumeSnapshot | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'className': obj.className,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'online': obj.online,
    'onlineConfiguration': toJson_ClusterSpecBackupVolumeSnapshotOnlineConfiguration(obj.onlineConfiguration),
    'snapshotOwnerReference': obj.snapshotOwnerReference,
    'tablespaceClassName': ((obj.tablespaceClassName) === undefined) ? undefined : (Object.entries(obj.tablespaceClassName).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'walClassName': obj.walClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Bootstrap the cluster via initdb
 *
 * @schema ClusterSpecBootstrapInitdb
 */
export interface ClusterSpecBootstrapInitdb {
  /**
   * Specifies the locale name when the builtin provider is used.
   * This option requires `localeProvider` to be set to `builtin`.
   * Available from PostgreSQL 17.
   *
   * @schema ClusterSpecBootstrapInitdb#builtinLocale
   */
  readonly builtinLocale?: string;

  /**
   * Whether the `-k` option should be passed to initdb,
   * enabling checksums on data pages (default: `false`)
   *
   * @schema ClusterSpecBootstrapInitdb#dataChecksums
   */
  readonly dataChecksums?: boolean;

  /**
   * Name of the database used by the application. Default: `app`.
   *
   * @schema ClusterSpecBootstrapInitdb#database
   */
  readonly database?: string;

  /**
   * The value to be passed as option `--encoding` for initdb (default:`UTF8`)
   *
   * @schema ClusterSpecBootstrapInitdb#encoding
   */
  readonly encoding?: string;

  /**
   * Specifies the ICU locale when the ICU provider is used.
   * This option requires `localeProvider` to be set to `icu`.
   * Available from PostgreSQL 15.
   *
   * @schema ClusterSpecBootstrapInitdb#icuLocale
   */
  readonly icuLocale?: string;

  /**
   * Specifies additional collation rules to customize the behavior of the default collation.
   * This option requires `localeProvider` to be set to `icu`.
   * Available from PostgreSQL 16.
   *
   * @schema ClusterSpecBootstrapInitdb#icuRules
   */
  readonly icuRules?: string;

  /**
   * Bootstraps the new cluster by importing data from an existing PostgreSQL
   * instance using logical backup (`pg_dump` and `pg_restore`)
   *
   * @schema ClusterSpecBootstrapInitdb#import
   */
  readonly import?: ClusterSpecBootstrapInitdbImport;

  /**
   * Sets the default collation order and character classification in the new database.
   *
   * @schema ClusterSpecBootstrapInitdb#locale
   */
  readonly locale?: string;

  /**
   * The value to be passed as option `--lc-ctype` for initdb (default:`C`)
   *
   * @schema ClusterSpecBootstrapInitdb#localeCType
   */
  readonly localeCType?: string;

  /**
   * The value to be passed as option `--lc-collate` for initdb (default:`C`)
   *
   * @schema ClusterSpecBootstrapInitdb#localeCollate
   */
  readonly localeCollate?: string;

  /**
   * This option sets the locale provider for databases created in the new cluster.
   * Available from PostgreSQL 16.
   *
   * @schema ClusterSpecBootstrapInitdb#localeProvider
   */
  readonly localeProvider?: string;

  /**
   * The list of options that must be passed to initdb when creating the cluster.
   *
   * Deprecated: This could lead to inconsistent configurations,
   * please use the explicit provided parameters instead.
   * If defined, explicit values will be ignored.
   *
   * @schema ClusterSpecBootstrapInitdb#options
   */
  readonly options?: string[];

  /**
   * Name of the owner of the database in the instance to be used
   * by applications. Defaults to the value of the `database` key.
   *
   * @default the value of the `database` key.
   * @schema ClusterSpecBootstrapInitdb#owner
   */
  readonly owner?: string;

  /**
   * List of SQL queries to be executed as a superuser in the application
   * database right after the cluster has been created - to be used with extreme care
   * (by default empty)
   *
   * @schema ClusterSpecBootstrapInitdb#postInitApplicationSQL
   */
  readonly postInitApplicationSql?: string[];

  /**
   * List of references to ConfigMaps or Secrets containing SQL files
   * to be executed as a superuser in the application database right after
   * the cluster has been created. The references are processed in a specific order:
   * first, all Secrets are processed, followed by all ConfigMaps.
   * Within each group, the processing order follows the sequence specified
   * in their respective arrays.
   * (by default empty)
   *
   * @schema ClusterSpecBootstrapInitdb#postInitApplicationSQLRefs
   */
  readonly postInitApplicationSqlRefs?: ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs;

  /**
   * List of SQL queries to be executed as a superuser in the `postgres`
   * database right after the cluster has been created - to be used with extreme care
   * (by default empty)
   *
   * @schema ClusterSpecBootstrapInitdb#postInitSQL
   */
  readonly postInitSql?: string[];

  /**
   * List of references to ConfigMaps or Secrets containing SQL files
   * to be executed as a superuser in the `postgres` database right after
   * the cluster has been created. The references are processed in a specific order:
   * first, all Secrets are processed, followed by all ConfigMaps.
   * Within each group, the processing order follows the sequence specified
   * in their respective arrays.
   * (by default empty)
   *
   * @schema ClusterSpecBootstrapInitdb#postInitSQLRefs
   */
  readonly postInitSqlRefs?: ClusterSpecBootstrapInitdbPostInitSqlRefs;

  /**
   * List of SQL queries to be executed as a superuser in the `template1`
   * database right after the cluster has been created - to be used with extreme care
   * (by default empty)
   *
   * @schema ClusterSpecBootstrapInitdb#postInitTemplateSQL
   */
  readonly postInitTemplateSql?: string[];

  /**
   * List of references to ConfigMaps or Secrets containing SQL files
   * to be executed as a superuser in the `template1` database right after
   * the cluster has been created. The references are processed in a specific order:
   * first, all Secrets are processed, followed by all ConfigMaps.
   * Within each group, the processing order follows the sequence specified
   * in their respective arrays.
   * (by default empty)
   *
   * @schema ClusterSpecBootstrapInitdb#postInitTemplateSQLRefs
   */
  readonly postInitTemplateSqlRefs?: ClusterSpecBootstrapInitdbPostInitTemplateSqlRefs;

  /**
   * Name of the secret containing the initial credentials for the
   * owner of the user database. If empty a new secret will be
   * created from scratch
   *
   * @schema ClusterSpecBootstrapInitdb#secret
   */
  readonly secret?: ClusterSpecBootstrapInitdbSecret;

  /**
   * The value in megabytes (1 to 1024) to be passed to the `--wal-segsize`
   * option for initdb (default: empty, resulting in PostgreSQL default: 16MB)
   *
   * @schema ClusterSpecBootstrapInitdb#walSegmentSize
   */
  readonly walSegmentSize?: number;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdb' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapInitdb(obj: ClusterSpecBootstrapInitdb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'builtinLocale': obj.builtinLocale,
    'dataChecksums': obj.dataChecksums,
    'database': obj.database,
    'encoding': obj.encoding,
    'icuLocale': obj.icuLocale,
    'icuRules': obj.icuRules,
    'import': toJson_ClusterSpecBootstrapInitdbImport(obj.import),
    'locale': obj.locale,
    'localeCType': obj.localeCType,
    'localeCollate': obj.localeCollate,
    'localeProvider': obj.localeProvider,
    'options': obj.options?.map(y => y),
    'owner': obj.owner,
    'postInitApplicationSQL': obj.postInitApplicationSql?.map(y => y),
    'postInitApplicationSQLRefs': toJson_ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs(obj.postInitApplicationSqlRefs),
    'postInitSQL': obj.postInitSql?.map(y => y),
    'postInitSQLRefs': toJson_ClusterSpecBootstrapInitdbPostInitSqlRefs(obj.postInitSqlRefs),
    'postInitTemplateSQL': obj.postInitTemplateSql?.map(y => y),
    'postInitTemplateSQLRefs': toJson_ClusterSpecBootstrapInitdbPostInitTemplateSqlRefs(obj.postInitTemplateSqlRefs),
    'secret': toJson_ClusterSpecBootstrapInitdbSecret(obj.secret),
    'walSegmentSize': obj.walSegmentSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Bootstrap the cluster taking a physical backup of another compatible
 * PostgreSQL instance
 *
 * @schema ClusterSpecBootstrapPgBasebackup
 */
export interface ClusterSpecBootstrapPgBasebackup {
  /**
   * Name of the database used by the application. Default: `app`.
   *
   * @schema ClusterSpecBootstrapPgBasebackup#database
   */
  readonly database?: string;

  /**
   * Name of the owner of the database in the instance to be used
   * by applications. Defaults to the value of the `database` key.
   *
   * @default the value of the `database` key.
   * @schema ClusterSpecBootstrapPgBasebackup#owner
   */
  readonly owner?: string;

  /**
   * Name of the secret containing the initial credentials for the
   * owner of the user database. If empty a new secret will be
   * created from scratch
   *
   * @schema ClusterSpecBootstrapPgBasebackup#secret
   */
  readonly secret?: ClusterSpecBootstrapPgBasebackupSecret;

  /**
   * The name of the server of which we need to take a physical backup
   *
   * @schema ClusterSpecBootstrapPgBasebackup#source
   */
  readonly source: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapPgBasebackup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapPgBasebackup(obj: ClusterSpecBootstrapPgBasebackup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'owner': obj.owner,
    'secret': toJson_ClusterSpecBootstrapPgBasebackupSecret(obj.secret),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Bootstrap the cluster from a backup
 *
 * @schema ClusterSpecBootstrapRecovery
 */
export interface ClusterSpecBootstrapRecovery {
  /**
   * The backup object containing the physical base backup from which to
   * initiate the recovery procedure.
   * Mutually exclusive with `source` and `volumeSnapshots`.
   *
   * @schema ClusterSpecBootstrapRecovery#backup
   */
  readonly backup?: ClusterSpecBootstrapRecoveryBackup;

  /**
   * Name of the database used by the application. Default: `app`.
   *
   * @schema ClusterSpecBootstrapRecovery#database
   */
  readonly database?: string;

  /**
   * Name of the owner of the database in the instance to be used
   * by applications. Defaults to the value of the `database` key.
   *
   * @default the value of the `database` key.
   * @schema ClusterSpecBootstrapRecovery#owner
   */
  readonly owner?: string;

  /**
   * By default, the recovery process applies all the available
   * WAL files in the archive (full recovery). However, you can also
   * end the recovery as soon as a consistent state is reached or
   * recover to a point-in-time (PITR) by specifying a `RecoveryTarget` object,
   * as expected by PostgreSQL (i.e., timestamp, transaction Id, LSN, ...).
   * More info: https://www.postgresql.org/docs/current/runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET
   *
   * @schema ClusterSpecBootstrapRecovery#recoveryTarget
   */
  readonly recoveryTarget?: ClusterSpecBootstrapRecoveryRecoveryTarget;

  /**
   * Name of the secret containing the initial credentials for the
   * owner of the user database. If empty a new secret will be
   * created from scratch
   *
   * @schema ClusterSpecBootstrapRecovery#secret
   */
  readonly secret?: ClusterSpecBootstrapRecoverySecret;

  /**
   * The external cluster whose backup we will restore. This is also
   * used as the name of the folder under which the backup is stored,
   * so it must be set to the name of the source cluster
   * Mutually exclusive with `backup`.
   *
   * @schema ClusterSpecBootstrapRecovery#source
   */
  readonly source?: string;

  /**
   * The static PVC data source(s) from which to initiate the
   * recovery procedure. Currently supporting `VolumeSnapshot`
   * and `PersistentVolumeClaim` resources that map an existing
   * PVC group, compatible with CloudNativePG, and taken with
   * a cold backup copy on a fenced Postgres instance (limitation
   * which will be removed in the future when online backup
   * will be implemented).
   * Mutually exclusive with `backup`.
   *
   * @schema ClusterSpecBootstrapRecovery#volumeSnapshots
   */
  readonly volumeSnapshots?: ClusterSpecBootstrapRecoveryVolumeSnapshots;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecovery' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapRecovery(obj: ClusterSpecBootstrapRecovery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backup': toJson_ClusterSpecBootstrapRecoveryBackup(obj.backup),
    'database': obj.database,
    'owner': obj.owner,
    'recoveryTarget': toJson_ClusterSpecBootstrapRecoveryRecoveryTarget(obj.recoveryTarget),
    'secret': toJson_ClusterSpecBootstrapRecoverySecret(obj.secret),
    'source': obj.source,
    'volumeSnapshots': toJson_ClusterSpecBootstrapRecoveryVolumeSnapshots(obj.volumeSnapshots),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema ClusterSpecEnvValueFrom
 */
export interface ClusterSpecEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema ClusterSpecEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: ClusterSpecEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema ClusterSpecEnvValueFrom#fieldRef
   */
  readonly fieldRef?: ClusterSpecEnvValueFromFieldRef;

  /**
   * FileKeyRef selects a key of the env file.
   * Requires the EnvFiles feature gate to be enabled.
   *
   * @schema ClusterSpecEnvValueFrom#fileKeyRef
   */
  readonly fileKeyRef?: ClusterSpecEnvValueFromFileKeyRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema ClusterSpecEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: ClusterSpecEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema ClusterSpecEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ClusterSpecEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'ClusterSpecEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEnvValueFrom(obj: ClusterSpecEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_ClusterSpecEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_ClusterSpecEnvValueFromFieldRef(obj.fieldRef),
    'fileKeyRef': toJson_ClusterSpecEnvValueFromFileKeyRef(obj.fileKeyRef),
    'resourceFieldRef': toJson_ClusterSpecEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_ClusterSpecEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ClusterSpecEnvFromConfigMapRef
 */
export interface ClusterSpecEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterSpecEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ClusterSpecEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEnvFromConfigMapRef(obj: ClusterSpecEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema ClusterSpecEnvFromSecretRef
 */
export interface ClusterSpecEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterSpecEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ClusterSpecEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEnvFromSecretRef(obj: ClusterSpecEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 * Required, must not be nil.
 *
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate
 */
export interface ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate#spec
   */
  readonly spec: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate(obj: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Shm is the size limit of the shared memory volume
 *
 * @schema ClusterSpecEphemeralVolumesSizeLimitShm
 */
export class ClusterSpecEphemeralVolumesSizeLimitShm {
  public static fromNumber(value: number): ClusterSpecEphemeralVolumesSizeLimitShm {
    return new ClusterSpecEphemeralVolumesSizeLimitShm(value);
  }
  public static fromString(value: string): ClusterSpecEphemeralVolumesSizeLimitShm {
    return new ClusterSpecEphemeralVolumesSizeLimitShm(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * TemporaryData is the size limit of the temporary data volume
 *
 * @schema ClusterSpecEphemeralVolumesSizeLimitTemporaryData
 */
export class ClusterSpecEphemeralVolumesSizeLimitTemporaryData {
  public static fromNumber(value: number): ClusterSpecEphemeralVolumesSizeLimitTemporaryData {
    return new ClusterSpecEphemeralVolumesSizeLimitTemporaryData(value);
  }
  public static fromString(value: string): ClusterSpecEphemeralVolumesSizeLimitTemporaryData {
    return new ClusterSpecEphemeralVolumesSizeLimitTemporaryData(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The configuration for the barman-cloud tool suite
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStore
 */
export interface ClusterSpecExternalClustersBarmanObjectStore {
  /**
   * The credentials to use to upload data to Azure Blob Storage
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#azureCredentials
   */
  readonly azureCredentials?: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials;

  /**
   * The configuration to be used to backup the data files
   * When not defined, base backups files will be stored uncompressed and may
   * be unencrypted in the object store, according to the bucket default
   * policy.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#data
   */
  readonly data?: ClusterSpecExternalClustersBarmanObjectStoreData;

  /**
   * The path where to store the backup (i.e. s3://bucket/path/to/folder)
   * this path, with different destination folders, will be used for WALs
   * and for data
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#destinationPath
   */
  readonly destinationPath: string;

  /**
   * EndpointCA store the CA bundle of the barman endpoint.
   * Useful when using self-signed certificates to avoid
   * errors with certificate issuer and barman-cloud-wal-archive
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#endpointCA
   */
  readonly endpointCa?: ClusterSpecExternalClustersBarmanObjectStoreEndpointCa;

  /**
   * Endpoint to be used to upload data to the cloud,
   * overriding the automatic endpoint discovery
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#endpointURL
   */
  readonly endpointUrl?: string;

  /**
   * The credentials to use to upload data to Google Cloud Storage
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#googleCredentials
   */
  readonly googleCredentials?: ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials;

  /**
   * HistoryTags is a list of key value pairs that will be passed to the
   * Barman --history-tags option.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#historyTags
   */
  readonly historyTags?: { [key: string]: string };

  /**
   * The credentials to use to upload data to S3
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#s3Credentials
   */
  readonly s3Credentials?: ClusterSpecExternalClustersBarmanObjectStoreS3Credentials;

  /**
   * The server name on S3, the cluster name is used if this
   * parameter is omitted
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#serverName
   */
  readonly serverName?: string;

  /**
   * Tags is a list of key value pairs that will be passed to the
   * Barman --tags option.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The configuration for the backup of the WAL stream.
   * When not defined, WAL files will be stored uncompressed and may be
   * unencrypted in the object store, according to the bucket default policy.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#wal
   */
  readonly wal?: ClusterSpecExternalClustersBarmanObjectStoreWal;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStore(obj: ClusterSpecExternalClustersBarmanObjectStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azureCredentials': toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials(obj.azureCredentials),
    'data': toJson_ClusterSpecExternalClustersBarmanObjectStoreData(obj.data),
    'destinationPath': obj.destinationPath,
    'endpointCA': toJson_ClusterSpecExternalClustersBarmanObjectStoreEndpointCa(obj.endpointCa),
    'endpointURL': obj.endpointUrl,
    'googleCredentials': toJson_ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials(obj.googleCredentials),
    'historyTags': ((obj.historyTags) === undefined) ? undefined : (Object.entries(obj.historyTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    's3Credentials': toJson_ClusterSpecExternalClustersBarmanObjectStoreS3Credentials(obj.s3Credentials),
    'serverName': obj.serverName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'wal': toJson_ClusterSpecExternalClustersBarmanObjectStoreWal(obj.wal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The reference to the password to be used to connect to the server.
 * If a password is provided, CloudNativePG creates a PostgreSQL
 * passfile at `/controller/external/NAME/pass` (where "NAME" is the
 * cluster's name). This passfile is automatically referenced in the
 * connection string when establishing a connection to the remote
 * PostgreSQL server from the current PostgreSQL `Cluster`. This ensures
 * secure and efficient password management for external clusters.
 *
 * @schema ClusterSpecExternalClustersPassword
 */
export interface ClusterSpecExternalClustersPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ClusterSpecExternalClustersPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterSpecExternalClustersPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecExternalClustersPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersPassword(obj: ClusterSpecExternalClustersPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration of the plugin that is taking care
 * of WAL archiving and backups for this external cluster
 *
 * @schema ClusterSpecExternalClustersPlugin
 */
export interface ClusterSpecExternalClustersPlugin {
  /**
   * Enabled is true if this plugin will be used
   *
   * @schema ClusterSpecExternalClustersPlugin#enabled
   */
  readonly enabled?: boolean;

  /**
   * Marks the plugin as the WAL archiver. At most one plugin can be
   * designated as a WAL archiver. This cannot be enabled if the
   * `.spec.backup.barmanObjectStore` configuration is present.
   *
   * @schema ClusterSpecExternalClustersPlugin#isWALArchiver
   */
  readonly isWalArchiver?: boolean;

  /**
   * Name is the plugin name
   *
   * @schema ClusterSpecExternalClustersPlugin#name
   */
  readonly name: string;

  /**
   * Parameters is the configuration of the plugin
   *
   * @schema ClusterSpecExternalClustersPlugin#parameters
   */
  readonly parameters?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersPlugin' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersPlugin(obj: ClusterSpecExternalClustersPlugin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'isWALArchiver': obj.isWalArchiver,
    'name': obj.name,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The reference to an SSL certificate to be used to connect to this
 * instance
 *
 * @schema ClusterSpecExternalClustersSslCert
 */
export interface ClusterSpecExternalClustersSslCert {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ClusterSpecExternalClustersSslCert#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterSpecExternalClustersSslCert#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecExternalClustersSslCert#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersSslCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersSslCert(obj: ClusterSpecExternalClustersSslCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The reference to an SSL private key to be used to connect to this
 * instance
 *
 * @schema ClusterSpecExternalClustersSslKey
 */
export interface ClusterSpecExternalClustersSslKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ClusterSpecExternalClustersSslKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterSpecExternalClustersSslKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecExternalClustersSslKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersSslKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersSslKey(obj: ClusterSpecExternalClustersSslKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The reference to an SSL CA public key to be used to connect to this
 * instance
 *
 * @schema ClusterSpecExternalClustersSslRootCert
 */
export interface ClusterSpecExternalClustersSslRootCert {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ClusterSpecExternalClustersSslRootCert#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterSpecExternalClustersSslRootCert#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecExternalClustersSslRootCert#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersSslRootCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersSslRootCert(obj: ClusterSpecExternalClustersSslRootCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RoleConfiguration is the representation, in Kubernetes, of a PostgreSQL role
 * with the additional field Ensure specifying whether to ensure the presence or
 * absence of the role in the database
 *
 * The defaults of the CREATE ROLE command are applied
 * Reference: https://www.postgresql.org/docs/current/sql-createrole.html
 *
 * @schema ClusterSpecManagedRoles
 */
export interface ClusterSpecManagedRoles {
  /**
   * Whether a role bypasses every row-level security (RLS) policy.
   * Default is `false`.
   *
   * @default false`.
   * @schema ClusterSpecManagedRoles#bypassrls
   */
  readonly bypassrls?: boolean;

  /**
   * Description of the role
   *
   * @schema ClusterSpecManagedRoles#comment
   */
  readonly comment?: string;

  /**
   * If the role can log in, this specifies how many concurrent
   * connections the role can make. `-1` (the default) means no limit.
   *
   * @schema ClusterSpecManagedRoles#connectionLimit
   */
  readonly connectionLimit?: number;

  /**
   * When set to `true`, the role being defined will be allowed to create
   * new databases. Specifying `false` (default) will deny a role the
   * ability to create databases.
   *
   * @schema ClusterSpecManagedRoles#createdb
   */
  readonly createdb?: boolean;

  /**
   * Whether the role will be permitted to create, alter, drop, comment
   * on, change the security label for, and grant or revoke membership in
   * other roles. Default is `false`.
   *
   * @default false`.
   * @schema ClusterSpecManagedRoles#createrole
   */
  readonly createrole?: boolean;

  /**
   * DisablePassword indicates that a role's password should be set to NULL in Postgres
   *
   * @schema ClusterSpecManagedRoles#disablePassword
   */
  readonly disablePassword?: boolean;

  /**
   * Ensure the role is `present` or `absent` - defaults to "present"
   *
   * @schema ClusterSpecManagedRoles#ensure
   */
  readonly ensure?: ClusterSpecManagedRolesEnsure;

  /**
   * List of one or more existing roles to which this role will be
   * immediately added as a new member. Default empty.
   *
   * @schema ClusterSpecManagedRoles#inRoles
   */
  readonly inRoles?: string[];

  /**
   * Whether a role "inherits" the privileges of roles it is a member of.
   * Defaults is `true`.
   *
   * @default true`.
   * @schema ClusterSpecManagedRoles#inherit
   */
  readonly inherit?: boolean;

  /**
   * Whether the role is allowed to log in. A role having the `login`
   * attribute can be thought of as a user. Roles without this attribute
   * are useful for managing database privileges, but are not users in
   * the usual sense of the word. Default is `false`.
   *
   * @default false`.
   * @schema ClusterSpecManagedRoles#login
   */
  readonly login?: boolean;

  /**
   * Name of the role
   *
   * @schema ClusterSpecManagedRoles#name
   */
  readonly name: string;

  /**
   * Secret containing the password of the role (if present)
   * If null, the password will be ignored unless DisablePassword is set
   *
   * @schema ClusterSpecManagedRoles#passwordSecret
   */
  readonly passwordSecret?: ClusterSpecManagedRolesPasswordSecret;

  /**
   * Whether a role is a replication role. A role must have this
   * attribute (or be a superuser) in order to be able to connect to the
   * server in replication mode (physical or logical replication) and in
   * order to be able to create or drop replication slots. A role having
   * the `replication` attribute is a very highly privileged role, and
   * should only be used on roles actually used for replication. Default
   * is `false`.
   *
   * @default false`.
   * @schema ClusterSpecManagedRoles#replication
   */
  readonly replication?: boolean;

  /**
   * Whether the role is a `superuser` who can override all access
   * restrictions within the database - superuser status is dangerous and
   * should be used only when really needed. You must yourself be a
   * superuser to create a new superuser. Defaults is `false`.
   *
   * @default false`.
   * @schema ClusterSpecManagedRoles#superuser
   */
  readonly superuser?: boolean;

  /**
   * Date and time after which the role's password is no longer valid.
   * When omitted, the password will never expire (default).
   *
   * @schema ClusterSpecManagedRoles#validUntil
   */
  readonly validUntil?: Date;
}

/**
 * Converts an object of type 'ClusterSpecManagedRoles' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManagedRoles(obj: ClusterSpecManagedRoles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bypassrls': obj.bypassrls,
    'comment': obj.comment,
    'connectionLimit': obj.connectionLimit,
    'createdb': obj.createdb,
    'createrole': obj.createrole,
    'disablePassword': obj.disablePassword,
    'ensure': obj.ensure,
    'inRoles': obj.inRoles?.map(y => y),
    'inherit': obj.inherit,
    'login': obj.login,
    'name': obj.name,
    'passwordSecret': toJson_ClusterSpecManagedRolesPasswordSecret(obj.passwordSecret),
    'replication': obj.replication,
    'superuser': obj.superuser,
    'validUntil': obj.validUntil?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Services roles managed by the `Cluster`
 *
 * @schema ClusterSpecManagedServices
 */
export interface ClusterSpecManagedServices {
  /**
   * Additional is a list of additional managed services specified by the user.
   *
   * @schema ClusterSpecManagedServices#additional
   */
  readonly additional?: ClusterSpecManagedServicesAdditional[];

  /**
   * DisabledDefaultServices is a list of service types that are disabled by default.
   * Valid values are "r", and "ro", representing read, and read-only services.
   *
   * @schema ClusterSpecManagedServices#disabledDefaultServices
   */
  readonly disabledDefaultServices?: ClusterSpecManagedServicesDisabledDefaultServices[];
}

/**
 * Converts an object of type 'ClusterSpecManagedServices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManagedServices(obj: ClusterSpecManagedServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additional': obj.additional?.map(y => toJson_ClusterSpecManagedServicesAdditional(y)),
    'disabledDefaultServices': obj.disabledDefaultServices?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMapKeySelector contains enough information to let you locate
 * the key of a ConfigMap
 *
 * @schema ClusterSpecMonitoringCustomQueriesConfigMap
 */
export interface ClusterSpecMonitoringCustomQueriesConfigMap {
  /**
   * The key to select
   *
   * @schema ClusterSpecMonitoringCustomQueriesConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecMonitoringCustomQueriesConfigMap#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecMonitoringCustomQueriesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMonitoringCustomQueriesConfigMap(obj: ClusterSpecMonitoringCustomQueriesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKeySelector contains enough information to let you locate
 * the key of a Secret
 *
 * @schema ClusterSpecMonitoringCustomQueriesSecret
 */
export interface ClusterSpecMonitoringCustomQueriesSecret {
  /**
   * The key to select
   *
   * @schema ClusterSpecMonitoringCustomQueriesSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecMonitoringCustomQueriesSecret#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecMonitoringCustomQueriesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMonitoringCustomQueriesSecret(obj: ClusterSpecMonitoringCustomQueriesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings
 */
export interface ClusterSpecMonitoringPodMonitorMetricRelabelings {
  /**
   * action to perform based on the regex matching.
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   * Default: "Replace"
   *
   * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings#action
   */
  readonly action?: ClusterSpecMonitoringPodMonitorMetricRelabelingsAction;

  /**
   * modulus to take of the hash of the source label values.
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * regex defines the regular expression against which the extracted value is matched.
   *
   * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings#regex
   */
  readonly regex?: string;

  /**
   * replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   * Regex capture groups are available.
   *
   * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * separator defines the string between concatenated SourceLabels.
   *
   * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings#separator
   */
  readonly separator?: string;

  /**
   * sourceLabels defines the source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * targetLabel defines the label to which the resulting string is written in a replacement.
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   * Regex capture groups are available.
   *
   * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings#targetLabel
   */
  readonly targetLabel?: string;
}

/**
 * Converts an object of type 'ClusterSpecMonitoringPodMonitorMetricRelabelings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMonitoringPodMonitorMetricRelabelings(obj: ClusterSpecMonitoringPodMonitorMetricRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ClusterSpecMonitoringPodMonitorRelabelings
 */
export interface ClusterSpecMonitoringPodMonitorRelabelings {
  /**
   * action to perform based on the regex matching.
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   * Default: "Replace"
   *
   * @schema ClusterSpecMonitoringPodMonitorRelabelings#action
   */
  readonly action?: ClusterSpecMonitoringPodMonitorRelabelingsAction;

  /**
   * modulus to take of the hash of the source label values.
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema ClusterSpecMonitoringPodMonitorRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * regex defines the regular expression against which the extracted value is matched.
   *
   * @schema ClusterSpecMonitoringPodMonitorRelabelings#regex
   */
  readonly regex?: string;

  /**
   * replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   * Regex capture groups are available.
   *
   * @schema ClusterSpecMonitoringPodMonitorRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * separator defines the string between concatenated SourceLabels.
   *
   * @schema ClusterSpecMonitoringPodMonitorRelabelings#separator
   */
  readonly separator?: string;

  /**
   * sourceLabels defines the source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema ClusterSpecMonitoringPodMonitorRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * targetLabel defines the label to which the resulting string is written in a replacement.
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   * Regex capture groups are available.
   *
   * @schema ClusterSpecMonitoringPodMonitorRelabelings#targetLabel
   */
  readonly targetLabel?: string;
}

/**
 * Converts an object of type 'ClusterSpecMonitoringPodMonitorRelabelings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMonitoringPodMonitorRelabelings(obj: ClusterSpecMonitoringPodMonitorRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configure TLS communication for the metrics endpoint.
 * Changing tls.enabled option will force a rollout of all instances.
 *
 * @schema ClusterSpecMonitoringTls
 */
export interface ClusterSpecMonitoringTls {
  /**
   * Enable TLS for the monitoring endpoint.
   * Changing this option will force a rollout of all instances.
   *
   * @schema ClusterSpecMonitoringTls#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecMonitoringTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecMonitoringTls(obj: ClusterSpecMonitoringTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterSpecPodSecurityContextAppArmorProfile
 */
export interface ClusterSpecPodSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema ClusterSpecPodSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema ClusterSpecPodSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ClusterSpecPodSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPodSecurityContextAppArmorProfile(obj: ClusterSpecPodSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterSpecPodSecurityContextSeLinuxOptions
 */
export interface ClusterSpecPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ClusterSpecPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ClusterSpecPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ClusterSpecPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ClusterSpecPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ClusterSpecPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPodSecurityContextSeLinuxOptions(obj: ClusterSpecPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterSpecPodSecurityContextSeccompProfile
 */
export interface ClusterSpecPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ClusterSpecPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ClusterSpecPodSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ClusterSpecPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPodSecurityContextSeccompProfile(obj: ClusterSpecPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ClusterSpecPodSecurityContextSysctls
 */
export interface ClusterSpecPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ClusterSpecPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ClusterSpecPodSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ClusterSpecPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPodSecurityContextSysctls(obj: ClusterSpecPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ClusterSpecPodSecurityContextWindowsOptions
 */
export interface ClusterSpecPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ClusterSpecPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ClusterSpecPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ClusterSpecPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ClusterSpecPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'ClusterSpecPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPodSecurityContextWindowsOptions(obj: ClusterSpecPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExtensionConfiguration is the configuration used to add
 * PostgreSQL extensions to the Cluster.
 *
 * @schema ClusterSpecPostgresqlExtensions
 */
export interface ClusterSpecPostgresqlExtensions {
  /**
   * The list of directories inside the image which should be added to dynamic_library_path.
   * If not defined, defaults to "/lib".
   *
   * @schema ClusterSpecPostgresqlExtensions#dynamic_library_path
   */
  readonly dynamicLibraryPath?: string[];

  /**
   * The list of directories inside the image which should be added to extension_control_path.
   * If not defined, defaults to "/share".
   *
   * @schema ClusterSpecPostgresqlExtensions#extension_control_path
   */
  readonly extensionControlPath?: string[];

  /**
   * The image containing the extension, required
   *
   * @schema ClusterSpecPostgresqlExtensions#image
   */
  readonly image: ClusterSpecPostgresqlExtensionsImage;

  /**
   * The list of directories inside the image which should be added to ld_library_path.
   *
   * @schema ClusterSpecPostgresqlExtensions#ld_library_path
   */
  readonly ldLibraryPath?: string[];

  /**
   * The name of the extension, required
   *
   * @schema ClusterSpecPostgresqlExtensions#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecPostgresqlExtensions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPostgresqlExtensions(obj: ClusterSpecPostgresqlExtensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dynamic_library_path': obj.dynamicLibraryPath?.map(y => y),
    'extension_control_path': obj.extensionControlPath?.map(y => y),
    'image': toJson_ClusterSpecPostgresqlExtensionsImage(obj.image),
    'ld_library_path': obj.ldLibraryPath?.map(y => y),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Options to specify LDAP configuration
 *
 * @schema ClusterSpecPostgresqlLdap
 */
export interface ClusterSpecPostgresqlLdap {
  /**
   * Bind as authentication configuration
   *
   * @schema ClusterSpecPostgresqlLdap#bindAsAuth
   */
  readonly bindAsAuth?: ClusterSpecPostgresqlLdapBindAsAuth;

  /**
   * Bind+Search authentication configuration
   *
   * @schema ClusterSpecPostgresqlLdap#bindSearchAuth
   */
  readonly bindSearchAuth?: ClusterSpecPostgresqlLdapBindSearchAuth;

  /**
   * LDAP server port
   *
   * @schema ClusterSpecPostgresqlLdap#port
   */
  readonly port?: number;

  /**
   * LDAP schema to be used, possible options are `ldap` and `ldaps`
   *
   * @schema ClusterSpecPostgresqlLdap#scheme
   */
  readonly scheme?: ClusterSpecPostgresqlLdapScheme;

  /**
   * LDAP hostname or IP address
   *
   * @schema ClusterSpecPostgresqlLdap#server
   */
  readonly server?: string;

  /**
   * Set to 'true' to enable LDAP over TLS. 'false' is default
   *
   * @schema ClusterSpecPostgresqlLdap#tls
   */
  readonly tls?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecPostgresqlLdap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPostgresqlLdap(obj: ClusterSpecPostgresqlLdap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bindAsAuth': toJson_ClusterSpecPostgresqlLdapBindAsAuth(obj.bindAsAuth),
    'bindSearchAuth': toJson_ClusterSpecPostgresqlLdapBindSearchAuth(obj.bindSearchAuth),
    'port': obj.port,
    'scheme': obj.scheme,
    'server': obj.server,
    'tls': obj.tls,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Requirements to be met by sync replicas. This will affect how the "synchronous_standby_names" parameter will be
 * set up.
 *
 * @schema ClusterSpecPostgresqlSyncReplicaElectionConstraint
 */
export interface ClusterSpecPostgresqlSyncReplicaElectionConstraint {
  /**
   * This flag enables the constraints for sync replicas
   *
   * @schema ClusterSpecPostgresqlSyncReplicaElectionConstraint#enabled
   */
  readonly enabled: boolean;

  /**
   * A list of node labels values to extract and compare to evaluate if the pods reside in the same topology or not
   *
   * @schema ClusterSpecPostgresqlSyncReplicaElectionConstraint#nodeLabelsAntiAffinity
   */
  readonly nodeLabelsAntiAffinity?: string[];
}

/**
 * Converts an object of type 'ClusterSpecPostgresqlSyncReplicaElectionConstraint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPostgresqlSyncReplicaElectionConstraint(obj: ClusterSpecPostgresqlSyncReplicaElectionConstraint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'nodeLabelsAntiAffinity': obj.nodeLabelsAntiAffinity?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of the PostgreSQL synchronous replication feature
 *
 * @schema ClusterSpecPostgresqlSynchronous
 */
export interface ClusterSpecPostgresqlSynchronous {
  /**
   * If set to "required", data durability is strictly enforced. Write operations
   * with synchronous commit settings (`on`, `remote_write`, or `remote_apply`) will
   * block if there are insufficient healthy replicas, ensuring data persistence.
   * If set to "preferred", data durability is maintained when healthy replicas
   * are available, but the required number of instances will adjust dynamically
   * if replicas become unavailable. This setting relaxes strict durability enforcement
   * to allow for operational continuity. This setting is only applicable if both
   * `standbyNamesPre` and `standbyNamesPost` are unset (empty).
   *
   * @schema ClusterSpecPostgresqlSynchronous#dataDurability
   */
  readonly dataDurability?: ClusterSpecPostgresqlSynchronousDataDurability;

  /**
   * FailoverQuorum enables a quorum-based check before failover, improving
   * data durability and safety during failover events in CloudNativePG-managed
   * PostgreSQL clusters.
   *
   * @schema ClusterSpecPostgresqlSynchronous#failoverQuorum
   */
  readonly failoverQuorum?: boolean;

  /**
   * Specifies the maximum number of local cluster pods that can be
   * automatically included in the `synchronous_standby_names` option in
   * PostgreSQL.
   *
   * @schema ClusterSpecPostgresqlSynchronous#maxStandbyNamesFromCluster
   */
  readonly maxStandbyNamesFromCluster?: number;

  /**
   * Method to select synchronous replication standbys from the listed
   * servers, accepting 'any' (quorum-based synchronous replication) or
   * 'first' (priority-based synchronous replication) as values.
   *
   * @schema ClusterSpecPostgresqlSynchronous#method
   */
  readonly method: ClusterSpecPostgresqlSynchronousMethod;

  /**
   * Specifies the number of synchronous standby servers that
   * transactions must wait for responses from.
   *
   * @schema ClusterSpecPostgresqlSynchronous#number
   */
  readonly number: number;

  /**
   * A user-defined list of application names to be added to
   * `synchronous_standby_names` after local cluster pods (the order is
   * only useful for priority-based synchronous replication).
   *
   * @schema ClusterSpecPostgresqlSynchronous#standbyNamesPost
   */
  readonly standbyNamesPost?: string[];

  /**
   * A user-defined list of application names to be added to
   * `synchronous_standby_names` before local cluster pods (the order is
   * only useful for priority-based synchronous replication).
   *
   * @schema ClusterSpecPostgresqlSynchronous#standbyNamesPre
   */
  readonly standbyNamesPre?: string[];
}

/**
 * Converts an object of type 'ClusterSpecPostgresqlSynchronous' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPostgresqlSynchronous(obj: ClusterSpecPostgresqlSynchronous | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataDurability': obj.dataDurability,
    'failoverQuorum': obj.failoverQuorum,
    'maxStandbyNamesFromCluster': obj.maxStandbyNamesFromCluster,
    'method': obj.method,
    'number': obj.number,
    'standbyNamesPost': obj.standbyNamesPost?.map(y => y),
    'standbyNamesPre': obj.standbyNamesPre?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The liveness probe configuration
 *
 * @schema ClusterSpecProbesLiveness
 */
export interface ClusterSpecProbesLiveness {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ClusterSpecProbesLiveness#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterSpecProbesLiveness#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * Configure the feature that extends the liveness probe for a primary
   * instance. In addition to the basic checks, this verifies whether the
   * primary is isolated from the Kubernetes API server and from its
   * replicas, ensuring that it can be safely shut down if network
   * partition or API unavailability is detected. Enabled by default.
   *
   * @schema ClusterSpecProbesLiveness#isolationCheck
   */
  readonly isolationCheck?: ClusterSpecProbesLivenessIsolationCheck;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ClusterSpecProbesLiveness#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ClusterSpecProbesLiveness#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ClusterSpecProbesLiveness#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ClusterSpecProbesLiveness#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'ClusterSpecProbesLiveness' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProbesLiveness(obj: ClusterSpecProbesLiveness | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'isolationCheck': toJson_ClusterSpecProbesLivenessIsolationCheck(obj.isolationCheck),
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The readiness probe configuration
 *
 * @schema ClusterSpecProbesReadiness
 */
export interface ClusterSpecProbesReadiness {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ClusterSpecProbesReadiness#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterSpecProbesReadiness#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * Lag limit. Used only for `streaming` strategy
   *
   * @schema ClusterSpecProbesReadiness#maximumLag
   */
  readonly maximumLag?: ClusterSpecProbesReadinessMaximumLag;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ClusterSpecProbesReadiness#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ClusterSpecProbesReadiness#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ClusterSpecProbesReadiness#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ClusterSpecProbesReadiness#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

  /**
   * The probe strategy
   *
   * @schema ClusterSpecProbesReadiness#type
   */
  readonly type?: ClusterSpecProbesReadinessType;
}

/**
 * Converts an object of type 'ClusterSpecProbesReadiness' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProbesReadiness(obj: ClusterSpecProbesReadiness | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'maximumLag': obj.maximumLag?.value,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The startup probe configuration
 *
 * @schema ClusterSpecProbesStartup
 */
export interface ClusterSpecProbesStartup {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ClusterSpecProbesStartup#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterSpecProbesStartup#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * Lag limit. Used only for `streaming` strategy
   *
   * @schema ClusterSpecProbesStartup#maximumLag
   */
  readonly maximumLag?: ClusterSpecProbesStartupMaximumLag;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ClusterSpecProbesStartup#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ClusterSpecProbesStartup#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ClusterSpecProbesStartup#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ClusterSpecProbesStartup#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

  /**
   * The probe strategy
   *
   * @schema ClusterSpecProbesStartup#type
   */
  readonly type?: ClusterSpecProbesStartupType;
}

/**
 * Converts an object of type 'ClusterSpecProbesStartup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProbesStartup(obj: ClusterSpecProbesStartup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'maximumLag': obj.maximumLag?.value,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types.
 * Exactly one of these fields must be set.
 *
 * @schema ClusterSpecProjectedVolumeTemplateSources
 */
export interface ClusterSpecProjectedVolumeTemplateSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema ClusterSpecProjectedVolumeTemplateSources#configMap
   */
  readonly configMap?: ClusterSpecProjectedVolumeTemplateSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema ClusterSpecProjectedVolumeTemplateSources#downwardAPI
   */
  readonly downwardApi?: ClusterSpecProjectedVolumeTemplateSourcesDownwardApi;

  /**
   * Projects an auto-rotating credential bundle (private key and certificate
   * chain) that the pod can use either as a TLS client or server.
   *
   * Kubelet generates a private key and uses it to send a
   * PodCertificateRequest to the named signer.  Once the signer approves the
   * request and issues a certificate chain, Kubelet writes the key and
   * certificate chain to the pod filesystem.  The pod does not start until
   * certificates have been issued for each podCertificate projected volume
   * source in its spec.
   *
   * Kubelet will begin trying to rotate the certificate at the time indicated
   * by the signer using the PodCertificateRequest.Status.BeginRefreshAt
   * timestamp.
   *
   * Kubelet can write a single file, indicated by the credentialBundlePath
   * field, or separate files, indicated by the keyPath and
   * certificateChainPath fields.
   *
   * The credential bundle is a single file in PEM format.  The first PEM
   * entry is the private key (in PKCS#8 format), and the remaining PEM
   * entries are the certificate chain issued by the signer (typically,
   * signers will return their certificate chain in leaf-to-root order).
   *
   * Prefer using the credential bundle format, since your application code
   * can read it atomically.  If you use keyPath and certificateChainPath,
   * your application must make two separate file reads. If these coincide
   * with a certificate rotation, it is possible that the private key and leaf
   * certificate you read may not correspond to each other.  Your application
   * will need to check for this condition, and re-read until they are
   * consistent.
   *
   * The named signer controls chooses the format of the certificate it
   * issues; consult the signer implementation's documentation to learn how to
   * use the certificates it issues.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSources#podCertificate
   */
  readonly podCertificate?: ClusterSpecProjectedVolumeTemplateSourcesPodCertificate;

  /**
   * secret information about the secret data to project
   *
   * @schema ClusterSpecProjectedVolumeTemplateSources#secret
   */
  readonly secret?: ClusterSpecProjectedVolumeTemplateSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema ClusterSpecProjectedVolumeTemplateSources#serviceAccountToken
   */
  readonly serviceAccountToken?: ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSources(obj: ClusterSpecProjectedVolumeTemplateSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterTrustBundle': toJson_ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle(obj.clusterTrustBundle),
    'configMap': toJson_ClusterSpecProjectedVolumeTemplateSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApi(obj.downwardApi),
    'podCertificate': toJson_ClusterSpecProjectedVolumeTemplateSourcesPodCertificate(obj.podCertificate),
    'secret': toJson_ClusterSpecProjectedVolumeTemplateSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Replication slots for high availability configuration
 *
 * @schema ClusterSpecReplicationSlotsHighAvailability
 */
export interface ClusterSpecReplicationSlotsHighAvailability {
  /**
   * If enabled (default), the operator will automatically manage replication slots
   * on the primary instance and use them in streaming replication
   * connections with all the standby instances that are part of the HA
   * cluster. If disabled, the operator will not take advantage
   * of replication slots in streaming connections with the replicas.
   * This feature also controls replication slots in replica cluster,
   * from the designated primary to its cascading replicas.
   *
   * @schema ClusterSpecReplicationSlotsHighAvailability#enabled
   */
  readonly enabled?: boolean;

  /**
   * Prefix for replication slots managed by the operator for HA.
   * It may only contain lower case letters, numbers, and the underscore character.
   * This can only be set at creation time. By default set to `_cnpg_`.
   *
   * @schema ClusterSpecReplicationSlotsHighAvailability#slotPrefix
   */
  readonly slotPrefix?: string;

  /**
   * When enabled, the operator automatically manages synchronization of logical
   * decoding (replication) slots across high-availability clusters.
   *
   * Requires one of the following conditions:
   * - PostgreSQL version 17 or later
   * - PostgreSQL version < 17 with pg_failover_slots extension enabled
   *
   * @schema ClusterSpecReplicationSlotsHighAvailability#synchronizeLogicalDecoding
   */
  readonly synchronizeLogicalDecoding?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecReplicationSlotsHighAvailability' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecReplicationSlotsHighAvailability(obj: ClusterSpecReplicationSlotsHighAvailability | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'slotPrefix': obj.slotPrefix,
    'synchronizeLogicalDecoding': obj.synchronizeLogicalDecoding,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configures the synchronization of the user defined physical replication slots
 *
 * @schema ClusterSpecReplicationSlotsSynchronizeReplicas
 */
export interface ClusterSpecReplicationSlotsSynchronizeReplicas {
  /**
   * When set to true, every replication slot that is on the primary is synchronized on each standby
   *
   * @schema ClusterSpecReplicationSlotsSynchronizeReplicas#enabled
   */
  readonly enabled: boolean;

  /**
   * List of regular expression patterns to match the names of replication slots to be excluded (by default empty)
   *
   * @schema ClusterSpecReplicationSlotsSynchronizeReplicas#excludePatterns
   */
  readonly excludePatterns?: string[];
}

/**
 * Converts an object of type 'ClusterSpecReplicationSlotsSynchronizeReplicas' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecReplicationSlotsSynchronizeReplicas(obj: ClusterSpecReplicationSlotsSynchronizeReplicas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'excludePatterns': obj.excludePatterns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ClusterSpecResourcesClaims
 */
export interface ClusterSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ClusterSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema ClusterSpecResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'ClusterSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecResourcesClaims(obj: ClusterSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecResourcesLimits
 */
export class ClusterSpecResourcesLimits {
  public static fromNumber(value: number): ClusterSpecResourcesLimits {
    return new ClusterSpecResourcesLimits(value);
  }
  public static fromString(value: string): ClusterSpecResourcesLimits {
    return new ClusterSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecResourcesRequests
 */
export class ClusterSpecResourcesRequests {
  public static fromNumber(value: number): ClusterSpecResourcesRequests {
    return new ClusterSpecResourcesRequests(value);
  }
  public static fromString(value: string): ClusterSpecResourcesRequests {
    return new ClusterSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterSpecSecurityContextAppArmorProfile
 */
export interface ClusterSpecSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema ClusterSpecSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema ClusterSpecSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ClusterSpecSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecSecurityContextAppArmorProfile(obj: ClusterSpecSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema ClusterSpecSecurityContextCapabilities
 */
export interface ClusterSpecSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema ClusterSpecSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema ClusterSpecSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'ClusterSpecSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecSecurityContextCapabilities(obj: ClusterSpecSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterSpecSecurityContextSeLinuxOptions
 */
export interface ClusterSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ClusterSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ClusterSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ClusterSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ClusterSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ClusterSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecSecurityContextSeLinuxOptions(obj: ClusterSpecSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterSpecSecurityContextSeccompProfile
 */
export interface ClusterSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ClusterSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ClusterSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ClusterSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecSecurityContextSeccompProfile(obj: ClusterSpecSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ClusterSpecSecurityContextWindowsOptions
 */
export interface ClusterSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ClusterSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ClusterSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ClusterSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ClusterSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'ClusterSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecSecurityContextWindowsOptions(obj: ClusterSpecSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata are the metadata to be used for the generated
 * service account
 *
 * @schema ClusterSpecServiceAccountTemplateMetadata
 */
export interface ClusterSpecServiceAccountTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema ClusterSpecServiceAccountTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema ClusterSpecServiceAccountTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The name of the resource. Only supported for certain types
   *
   * @schema ClusterSpecServiceAccountTemplateMetadata#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecServiceAccountTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecServiceAccountTemplateMetadata(obj: ClusterSpecServiceAccountTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template to be used to generate the Persistent Volume Claim
 *
 * @schema ClusterSpecStoragePvcTemplate
 */
export interface ClusterSpecStoragePvcTemplate {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ClusterSpecStoragePvcTemplate#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ClusterSpecStoragePvcTemplate#dataSource
   */
  readonly dataSource?: ClusterSpecStoragePvcTemplateDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecStoragePvcTemplate#dataSourceRef
   */
  readonly dataSourceRef?: ClusterSpecStoragePvcTemplateDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * Users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ClusterSpecStoragePvcTemplate#resources
   */
  readonly resources?: ClusterSpecStoragePvcTemplateResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ClusterSpecStoragePvcTemplate#selector
   */
  readonly selector?: ClusterSpecStoragePvcTemplateSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ClusterSpecStoragePvcTemplate#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string or nil value indicates that no
   * VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
   * this field can be reset to its previous value (including nil) to cancel the modification.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   *
   * @schema ClusterSpecStoragePvcTemplate#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ClusterSpecStoragePvcTemplate#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ClusterSpecStoragePvcTemplate#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'ClusterSpecStoragePvcTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecStoragePvcTemplate(obj: ClusterSpecStoragePvcTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ClusterSpecStoragePvcTemplateDataSource(obj.dataSource),
    'dataSourceRef': toJson_ClusterSpecStoragePvcTemplateDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ClusterSpecStoragePvcTemplateResources(obj.resources),
    'selector': toJson_ClusterSpecStoragePvcTemplateSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Owner is the PostgreSQL user owning the tablespace
 *
 * @schema ClusterSpecTablespacesOwner
 */
export interface ClusterSpecTablespacesOwner {
  /**
   * @schema ClusterSpecTablespacesOwner#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecTablespacesOwner' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecTablespacesOwner(obj: ClusterSpecTablespacesOwner | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The storage configuration for the tablespace
 *
 * @schema ClusterSpecTablespacesStorage
 */
export interface ClusterSpecTablespacesStorage {
  /**
   * Template to be used to generate the Persistent Volume Claim
   *
   * @schema ClusterSpecTablespacesStorage#pvcTemplate
   */
  readonly pvcTemplate?: ClusterSpecTablespacesStoragePvcTemplate;

  /**
   * Resize existent PVCs, defaults to true
   *
   * @schema ClusterSpecTablespacesStorage#resizeInUseVolumes
   */
  readonly resizeInUseVolumes?: boolean;

  /**
   * Size of the storage. Required if not already specified in the PVC template.
   * Changes to this field are automatically reapplied to the created PVCs.
   * Size cannot be decreased.
   *
   * @schema ClusterSpecTablespacesStorage#size
   */
  readonly size?: string;

  /**
   * StorageClass to use for PVCs. Applied after
   * evaluating the PVC template, if available.
   * If not specified, the generated PVCs will use the
   * default storage class
   *
   * @schema ClusterSpecTablespacesStorage#storageClass
   */
  readonly storageClass?: string;
}

/**
 * Converts an object of type 'ClusterSpecTablespacesStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecTablespacesStorage(obj: ClusterSpecTablespacesStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pvcTemplate': toJson_ClusterSpecTablespacesStoragePvcTemplate(obj.pvcTemplate),
    'resizeInUseVolumes': obj.resizeInUseVolumes,
    'size': obj.size,
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema ClusterSpecTopologySpreadConstraintsLabelSelector
 */
export interface ClusterSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecTopologySpreadConstraintsLabelSelector(obj: ClusterSpecTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template to be used to generate the Persistent Volume Claim
 *
 * @schema ClusterSpecWalStoragePvcTemplate
 */
export interface ClusterSpecWalStoragePvcTemplate {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ClusterSpecWalStoragePvcTemplate#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ClusterSpecWalStoragePvcTemplate#dataSource
   */
  readonly dataSource?: ClusterSpecWalStoragePvcTemplateDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecWalStoragePvcTemplate#dataSourceRef
   */
  readonly dataSourceRef?: ClusterSpecWalStoragePvcTemplateDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * Users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ClusterSpecWalStoragePvcTemplate#resources
   */
  readonly resources?: ClusterSpecWalStoragePvcTemplateResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ClusterSpecWalStoragePvcTemplate#selector
   */
  readonly selector?: ClusterSpecWalStoragePvcTemplateSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ClusterSpecWalStoragePvcTemplate#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string or nil value indicates that no
   * VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
   * this field can be reset to its previous value (including nil) to cancel the modification.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   *
   * @schema ClusterSpecWalStoragePvcTemplate#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ClusterSpecWalStoragePvcTemplate#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ClusterSpecWalStoragePvcTemplate#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'ClusterSpecWalStoragePvcTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecWalStoragePvcTemplate(obj: ClusterSpecWalStoragePvcTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ClusterSpecWalStoragePvcTemplateDataSource(obj.dataSource),
    'dataSourceRef': toJson_ClusterSpecWalStoragePvcTemplateDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ClusterSpecWalStoragePvcTemplateResources(obj.resources),
    'selector': toJson_ClusterSpecWalStoragePvcTemplateSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The credentials to use to upload data to Azure Blob Storage
 *
 * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentials
 */
export interface ClusterSpecBackupBarmanObjectStoreAzureCredentials {
  /**
   * The connection string to be used
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentials#connectionString
   */
  readonly connectionString?: ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString;

  /**
   * Use the Azure AD based authentication without providing explicitly the keys.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentials#inheritFromAzureAD
   */
  readonly inheritFromAzureAd?: boolean;

  /**
   * The storage account where to upload data
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentials#storageAccount
   */
  readonly storageAccount?: ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount;

  /**
   * The storage account key to be used in conjunction
   * with the storage account name
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentials#storageKey
   */
  readonly storageKey?: ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey;

  /**
   * A shared-access-signature to be used in conjunction with
   * the storage account name
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentials#storageSasToken
   */
  readonly storageSasToken?: ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken;

  /**
   * Use the default Azure authentication flow, which includes DefaultAzureCredential.
   * This allows authentication using environment variables and managed identities.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentials#useDefaultAzureCredentials
   */
  readonly useDefaultAzureCredentials?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreAzureCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentials(obj: ClusterSpecBackupBarmanObjectStoreAzureCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionString': toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString(obj.connectionString),
    'inheritFromAzureAD': obj.inheritFromAzureAd,
    'storageAccount': toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount(obj.storageAccount),
    'storageKey': toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey(obj.storageKey),
    'storageSasToken': toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken(obj.storageSasToken),
    'useDefaultAzureCredentials': obj.useDefaultAzureCredentials,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration to be used to backup the data files
 * When not defined, base backups files will be stored uncompressed and may
 * be unencrypted in the object store, according to the bucket default
 * policy.
 *
 * @schema ClusterSpecBackupBarmanObjectStoreData
 */
export interface ClusterSpecBackupBarmanObjectStoreData {
  /**
   * AdditionalCommandArgs represents additional arguments that can be appended
   * to the 'barman-cloud-backup' command-line invocation. These arguments
   * provide flexibility to customize the backup process further according to
   * specific requirements or configurations.
   *
   * Example:
   * In a scenario where specialized backup options are required, such as setting
   * a specific timeout or defining custom behavior, users can use this field
   * to specify additional command arguments.
   *
   * Note:
   * It's essential to ensure that the provided arguments are valid and supported
   * by the 'barman-cloud-backup' command, to avoid potential errors or unintended
   * behavior during execution.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreData#additionalCommandArgs
   */
  readonly additionalCommandArgs?: string[];

  /**
   * Compress a backup file (a tar file per tablespace) while streaming it
   * to the object store. Available options are empty string (no
   * compression, default), `gzip`, `bzip2`, and `snappy`.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreData#compression
   */
  readonly compression?: ClusterSpecBackupBarmanObjectStoreDataCompression;

  /**
   * Whenever to force the encryption of files (if the bucket is
   * not already configured for that).
   * Allowed options are empty string (use the bucket policy, default),
   * `AES256` and `aws:kms`
   *
   * @schema ClusterSpecBackupBarmanObjectStoreData#encryption
   */
  readonly encryption?: ClusterSpecBackupBarmanObjectStoreDataEncryption;

  /**
   * Control whether the I/O workload for the backup initial checkpoint will
   * be limited, according to the `checkpoint_completion_target` setting on
   * the PostgreSQL server. If set to true, an immediate checkpoint will be
   * used, meaning PostgreSQL will complete the checkpoint as soon as
   * possible. `false` by default.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreData#immediateCheckpoint
   */
  readonly immediateCheckpoint?: boolean;

  /**
   * The number of parallel jobs to be used to upload the backup, defaults
   * to 2
   *
   * @schema ClusterSpecBackupBarmanObjectStoreData#jobs
   */
  readonly jobs?: number;
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreData(obj: ClusterSpecBackupBarmanObjectStoreData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalCommandArgs': obj.additionalCommandArgs?.map(y => y),
    'compression': obj.compression,
    'encryption': obj.encryption,
    'immediateCheckpoint': obj.immediateCheckpoint,
    'jobs': obj.jobs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EndpointCA store the CA bundle of the barman endpoint.
 * Useful when using self-signed certificates to avoid
 * errors with certificate issuer and barman-cloud-wal-archive
 *
 * @schema ClusterSpecBackupBarmanObjectStoreEndpointCa
 */
export interface ClusterSpecBackupBarmanObjectStoreEndpointCa {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreEndpointCa#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreEndpointCa#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreEndpointCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreEndpointCa(obj: ClusterSpecBackupBarmanObjectStoreEndpointCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The credentials to use to upload data to Google Cloud Storage
 *
 * @schema ClusterSpecBackupBarmanObjectStoreGoogleCredentials
 */
export interface ClusterSpecBackupBarmanObjectStoreGoogleCredentials {
  /**
   * The secret containing the Google Cloud Storage JSON file with the credentials
   *
   * @schema ClusterSpecBackupBarmanObjectStoreGoogleCredentials#applicationCredentials
   */
  readonly applicationCredentials?: ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials;

  /**
   * If set to true, will presume that it's running inside a GKE environment,
   * default to false.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreGoogleCredentials#gkeEnvironment
   */
  readonly gkeEnvironment?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreGoogleCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreGoogleCredentials(obj: ClusterSpecBackupBarmanObjectStoreGoogleCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationCredentials': toJson_ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials(obj.applicationCredentials),
    'gkeEnvironment': obj.gkeEnvironment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The credentials to use to upload data to S3
 *
 * @schema ClusterSpecBackupBarmanObjectStoreS3Credentials
 */
export interface ClusterSpecBackupBarmanObjectStoreS3Credentials {
  /**
   * The reference to the access key id
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3Credentials#accessKeyId
   */
  readonly accessKeyId?: ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId;

  /**
   * Use the role based authentication without providing explicitly the keys.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3Credentials#inheritFromIAMRole
   */
  readonly inheritFromIamRole?: boolean;

  /**
   * The reference to the secret containing the region name
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3Credentials#region
   */
  readonly region?: ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion;

  /**
   * The reference to the secret access key
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3Credentials#secretAccessKey
   */
  readonly secretAccessKey?: ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey;

  /**
   * The references to the session key
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3Credentials#sessionToken
   */
  readonly sessionToken?: ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken;
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreS3Credentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreS3Credentials(obj: ClusterSpecBackupBarmanObjectStoreS3Credentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyId': toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId(obj.accessKeyId),
    'inheritFromIAMRole': obj.inheritFromIamRole,
    'region': toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion(obj.region),
    'secretAccessKey': toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey(obj.secretAccessKey),
    'sessionToken': toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken(obj.sessionToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration for the backup of the WAL stream.
 * When not defined, WAL files will be stored uncompressed and may be
 * unencrypted in the object store, according to the bucket default policy.
 *
 * @schema ClusterSpecBackupBarmanObjectStoreWal
 */
export interface ClusterSpecBackupBarmanObjectStoreWal {
  /**
   * Additional arguments that can be appended to the 'barman-cloud-wal-archive'
   * command-line invocation. These arguments provide flexibility to customize
   * the WAL archive process further, according to specific requirements or configurations.
   *
   * Example:
   * In a scenario where specialized backup options are required, such as setting
   * a specific timeout or defining custom behavior, users can use this field
   * to specify additional command arguments.
   *
   * Note:
   * It's essential to ensure that the provided arguments are valid and supported
   * by the 'barman-cloud-wal-archive' command, to avoid potential errors or unintended
   * behavior during execution.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreWal#archiveAdditionalCommandArgs
   */
  readonly archiveAdditionalCommandArgs?: string[];

  /**
   * Compress a WAL file before sending it to the object store. Available
   * options are empty string (no compression, default), `gzip`, `bzip2`,
   * `lz4`, `snappy`, `xz`, and `zstd`.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreWal#compression
   */
  readonly compression?: ClusterSpecBackupBarmanObjectStoreWalCompression;

  /**
   * Whenever to force the encryption of files (if the bucket is
   * not already configured for that).
   * Allowed options are empty string (use the bucket policy, default),
   * `AES256` and `aws:kms`
   *
   * @schema ClusterSpecBackupBarmanObjectStoreWal#encryption
   */
  readonly encryption?: ClusterSpecBackupBarmanObjectStoreWalEncryption;

  /**
   * Number of WAL files to be either archived in parallel (when the
   * PostgreSQL instance is archiving to a backup object store) or
   * restored in parallel (when a PostgreSQL standby is fetching WAL
   * files from a recovery object store). If not specified, WAL files
   * will be processed one at a time. It accepts a positive integer as a
   * value - with 1 being the minimum accepted value.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreWal#maxParallel
   */
  readonly maxParallel?: number;

  /**
   * Additional arguments that can be appended to the 'barman-cloud-wal-restore'
   * command-line invocation. These arguments provide flexibility to customize
   * the WAL restore process further, according to specific requirements or configurations.
   *
   * Example:
   * In a scenario where specialized backup options are required, such as setting
   * a specific timeout or defining custom behavior, users can use this field
   * to specify additional command arguments.
   *
   * Note:
   * It's essential to ensure that the provided arguments are valid and supported
   * by the 'barman-cloud-wal-restore' command, to avoid potential errors or unintended
   * behavior during execution.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreWal#restoreAdditionalCommandArgs
   */
  readonly restoreAdditionalCommandArgs?: string[];
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreWal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreWal(obj: ClusterSpecBackupBarmanObjectStoreWal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'archiveAdditionalCommandArgs': obj.archiveAdditionalCommandArgs?.map(y => y),
    'compression': obj.compression,
    'encryption': obj.encryption,
    'maxParallel': obj.maxParallel,
    'restoreAdditionalCommandArgs': obj.restoreAdditionalCommandArgs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration parameters to control the online/hot backup with volume snapshots
 *
 * @schema ClusterSpecBackupVolumeSnapshotOnlineConfiguration
 */
export interface ClusterSpecBackupVolumeSnapshotOnlineConfiguration {
  /**
   * Control whether the I/O workload for the backup initial checkpoint will
   * be limited, according to the `checkpoint_completion_target` setting on
   * the PostgreSQL server. If set to true, an immediate checkpoint will be
   * used, meaning PostgreSQL will complete the checkpoint as soon as
   * possible. `false` by default.
   *
   * @schema ClusterSpecBackupVolumeSnapshotOnlineConfiguration#immediateCheckpoint
   */
  readonly immediateCheckpoint?: boolean;

  /**
   * If false, the function will return immediately after the backup is completed,
   * without waiting for WAL to be archived.
   * This behavior is only useful with backup software that independently monitors WAL archiving.
   * Otherwise, WAL required to make the backup consistent might be missing and make the backup useless.
   * By default, or when this parameter is true, pg_backup_stop will wait for WAL to be archived when archiving is
   * enabled.
   * On a standby, this means that it will wait only when archive_mode = always.
   * If write activity on the primary is low, it may be useful to run pg_switch_wal on the primary in order to trigger
   * an immediate segment switch.
   *
   * @schema ClusterSpecBackupVolumeSnapshotOnlineConfiguration#waitForArchive
   */
  readonly waitForArchive?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecBackupVolumeSnapshotOnlineConfiguration' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupVolumeSnapshotOnlineConfiguration(obj: ClusterSpecBackupVolumeSnapshotOnlineConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'immediateCheckpoint': obj.immediateCheckpoint,
    'waitForArchive': obj.waitForArchive,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SnapshotOwnerReference indicates the type of owner reference the snapshot should have
 *
 * @schema ClusterSpecBackupVolumeSnapshotSnapshotOwnerReference
 */
export enum ClusterSpecBackupVolumeSnapshotSnapshotOwnerReference {
  /** none */
  NONE = "none",
  /** cluster */
  CLUSTER = "cluster",
  /** backup */
  BACKUP = "backup",
}

/**
 * Bootstraps the new cluster by importing data from an existing PostgreSQL
 * instance using logical backup (`pg_dump` and `pg_restore`)
 *
 * @schema ClusterSpecBootstrapInitdbImport
 */
export interface ClusterSpecBootstrapInitdbImport {
  /**
   * The databases to import
   *
   * @schema ClusterSpecBootstrapInitdbImport#databases
   */
  readonly databases: string[];

  /**
   * List of custom options to pass to the `pg_dump` command.
   *
   * IMPORTANT: Use with caution. The operator does not validate these options,
   * and certain flags may interfere with its intended functionality or design.
   * You are responsible for ensuring that the provided options are compatible
   * with your environment and desired behavior.
   *
   * @schema ClusterSpecBootstrapInitdbImport#pgDumpExtraOptions
   */
  readonly pgDumpExtraOptions?: string[];

  /**
   * Custom options to pass to the `pg_restore` command during the `data`
   * section. This setting overrides the generic `pgRestoreExtraOptions` value.
   *
   * IMPORTANT: Use with caution. The operator does not validate these options,
   * and certain flags may interfere with its intended functionality or design.
   * You are responsible for ensuring that the provided options are compatible
   * with your environment and desired behavior.
   *
   * @schema ClusterSpecBootstrapInitdbImport#pgRestoreDataOptions
   */
  readonly pgRestoreDataOptions?: string[];

  /**
   * List of custom options to pass to the `pg_restore` command.
   *
   * IMPORTANT: Use with caution. The operator does not validate these options,
   * and certain flags may interfere with its intended functionality or design.
   * You are responsible for ensuring that the provided options are compatible
   * with your environment and desired behavior.
   *
   * @schema ClusterSpecBootstrapInitdbImport#pgRestoreExtraOptions
   */
  readonly pgRestoreExtraOptions?: string[];

  /**
   * Custom options to pass to the `pg_restore` command during the `post-data`
   * section. This setting overrides the generic `pgRestoreExtraOptions` value.
   *
   * IMPORTANT: Use with caution. The operator does not validate these options,
   * and certain flags may interfere with its intended functionality or design.
   * You are responsible for ensuring that the provided options are compatible
   * with your environment and desired behavior.
   *
   * @schema ClusterSpecBootstrapInitdbImport#pgRestorePostdataOptions
   */
  readonly pgRestorePostdataOptions?: string[];

  /**
   * Custom options to pass to the `pg_restore` command during the `pre-data`
   * section. This setting overrides the generic `pgRestoreExtraOptions` value.
   *
   * IMPORTANT: Use with caution. The operator does not validate these options,
   * and certain flags may interfere with its intended functionality or design.
   * You are responsible for ensuring that the provided options are compatible
   * with your environment and desired behavior.
   *
   * @schema ClusterSpecBootstrapInitdbImport#pgRestorePredataOptions
   */
  readonly pgRestorePredataOptions?: string[];

  /**
   * List of SQL queries to be executed as a superuser in the application
   * database right after is imported - to be used with extreme care
   * (by default empty). Only available in microservice type.
   *
   * @schema ClusterSpecBootstrapInitdbImport#postImportApplicationSQL
   */
  readonly postImportApplicationSql?: string[];

  /**
   * The roles to import
   *
   * @schema ClusterSpecBootstrapInitdbImport#roles
   */
  readonly roles?: string[];

  /**
   * When set to true, only the `pre-data` and `post-data` sections of
   * `pg_restore` are invoked, avoiding data import. Default: `false`.
   *
   * @schema ClusterSpecBootstrapInitdbImport#schemaOnly
   */
  readonly schemaOnly?: boolean;

  /**
   * The source of the import
   *
   * @schema ClusterSpecBootstrapInitdbImport#source
   */
  readonly source: ClusterSpecBootstrapInitdbImportSource;

  /**
   * The import type. Can be `microservice` or `monolith`.
   *
   * @schema ClusterSpecBootstrapInitdbImport#type
   */
  readonly type: ClusterSpecBootstrapInitdbImportType;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbImport' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapInitdbImport(obj: ClusterSpecBootstrapInitdbImport | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'databases': obj.databases?.map(y => y),
    'pgDumpExtraOptions': obj.pgDumpExtraOptions?.map(y => y),
    'pgRestoreDataOptions': obj.pgRestoreDataOptions?.map(y => y),
    'pgRestoreExtraOptions': obj.pgRestoreExtraOptions?.map(y => y),
    'pgRestorePostdataOptions': obj.pgRestorePostdataOptions?.map(y => y),
    'pgRestorePredataOptions': obj.pgRestorePredataOptions?.map(y => y),
    'postImportApplicationSQL': obj.postImportApplicationSql?.map(y => y),
    'roles': obj.roles?.map(y => y),
    'schemaOnly': obj.schemaOnly,
    'source': toJson_ClusterSpecBootstrapInitdbImportSource(obj.source),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * List of references to ConfigMaps or Secrets containing SQL files
 * to be executed as a superuser in the application database right after
 * the cluster has been created. The references are processed in a specific order:
 * first, all Secrets are processed, followed by all ConfigMaps.
 * Within each group, the processing order follows the sequence specified
 * in their respective arrays.
 * (by default empty)
 *
 * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs
 */
export interface ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs {
  /**
   * ConfigMapRefs holds a list of references to ConfigMaps
   *
   * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs#configMapRefs
   */
  readonly configMapRefs?: ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs[];

  /**
   * SecretRefs holds a list of references to Secrets
   *
   * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs#secretRefs
   */
  readonly secretRefs?: ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs[];
}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs(obj: ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRefs': obj.configMapRefs?.map(y => toJson_ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs(y)),
    'secretRefs': obj.secretRefs?.map(y => toJson_ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * List of references to ConfigMaps or Secrets containing SQL files
 * to be executed as a superuser in the `postgres` database right after
 * the cluster has been created. The references are processed in a specific order:
 * first, all Secrets are processed, followed by all ConfigMaps.
 * Within each group, the processing order follows the sequence specified
 * in their respective arrays.
 * (by default empty)
 *
 * @schema ClusterSpecBootstrapInitdbPostInitSqlRefs
 */
export interface ClusterSpecBootstrapInitdbPostInitSqlRefs {
  /**
   * ConfigMapRefs holds a list of references to ConfigMaps
   *
   * @schema ClusterSpecBootstrapInitdbPostInitSqlRefs#configMapRefs
   */
  readonly configMapRefs?: ClusterSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs[];

  /**
   * SecretRefs holds a list of references to Secrets
   *
   * @schema ClusterSpecBootstrapInitdbPostInitSqlRefs#secretRefs
   */
  readonly secretRefs?: ClusterSpecBootstrapInitdbPostInitSqlRefsSecretRefs[];
}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbPostInitSqlRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapInitdbPostInitSqlRefs(obj: ClusterSpecBootstrapInitdbPostInitSqlRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRefs': obj.configMapRefs?.map(y => toJson_ClusterSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs(y)),
    'secretRefs': obj.secretRefs?.map(y => toJson_ClusterSpecBootstrapInitdbPostInitSqlRefsSecretRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * List of references to ConfigMaps or Secrets containing SQL files
 * to be executed as a superuser in the `template1` database right after
 * the cluster has been created. The references are processed in a specific order:
 * first, all Secrets are processed, followed by all ConfigMaps.
 * Within each group, the processing order follows the sequence specified
 * in their respective arrays.
 * (by default empty)
 *
 * @schema ClusterSpecBootstrapInitdbPostInitTemplateSqlRefs
 */
export interface ClusterSpecBootstrapInitdbPostInitTemplateSqlRefs {
  /**
   * ConfigMapRefs holds a list of references to ConfigMaps
   *
   * @schema ClusterSpecBootstrapInitdbPostInitTemplateSqlRefs#configMapRefs
   */
  readonly configMapRefs?: ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs[];

  /**
   * SecretRefs holds a list of references to Secrets
   *
   * @schema ClusterSpecBootstrapInitdbPostInitTemplateSqlRefs#secretRefs
   */
  readonly secretRefs?: ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs[];
}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbPostInitTemplateSqlRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapInitdbPostInitTemplateSqlRefs(obj: ClusterSpecBootstrapInitdbPostInitTemplateSqlRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRefs': obj.configMapRefs?.map(y => toJson_ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs(y)),
    'secretRefs': obj.secretRefs?.map(y => toJson_ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name of the secret containing the initial credentials for the
 * owner of the user database. If empty a new secret will be
 * created from scratch
 *
 * @schema ClusterSpecBootstrapInitdbSecret
 */
export interface ClusterSpecBootstrapInitdbSecret {
  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapInitdbSecret#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapInitdbSecret(obj: ClusterSpecBootstrapInitdbSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name of the secret containing the initial credentials for the
 * owner of the user database. If empty a new secret will be
 * created from scratch
 *
 * @schema ClusterSpecBootstrapPgBasebackupSecret
 */
export interface ClusterSpecBootstrapPgBasebackupSecret {
  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapPgBasebackupSecret#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapPgBasebackupSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapPgBasebackupSecret(obj: ClusterSpecBootstrapPgBasebackupSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The backup object containing the physical base backup from which to
 * initiate the recovery procedure.
 * Mutually exclusive with `source` and `volumeSnapshots`.
 *
 * @schema ClusterSpecBootstrapRecoveryBackup
 */
export interface ClusterSpecBootstrapRecoveryBackup {
  /**
   * EndpointCA store the CA bundle of the barman endpoint.
   * Useful when using self-signed certificates to avoid
   * errors with certificate issuer and barman-cloud-wal-archive.
   *
   * @schema ClusterSpecBootstrapRecoveryBackup#endpointCA
   */
  readonly endpointCa?: ClusterSpecBootstrapRecoveryBackupEndpointCa;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapRecoveryBackup#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoveryBackup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapRecoveryBackup(obj: ClusterSpecBootstrapRecoveryBackup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpointCA': toJson_ClusterSpecBootstrapRecoveryBackupEndpointCa(obj.endpointCa),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * By default, the recovery process applies all the available
 * WAL files in the archive (full recovery). However, you can also
 * end the recovery as soon as a consistent state is reached or
 * recover to a point-in-time (PITR) by specifying a `RecoveryTarget` object,
 * as expected by PostgreSQL (i.e., timestamp, transaction Id, LSN, ...).
 * More info: https://www.postgresql.org/docs/current/runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET
 *
 * @schema ClusterSpecBootstrapRecoveryRecoveryTarget
 */
export interface ClusterSpecBootstrapRecoveryRecoveryTarget {
  /**
   * The ID of the backup from which to start the recovery process.
   * If empty (default) the operator will automatically detect the backup
   * based on targetTime or targetLSN if specified. Otherwise use the
   * latest available backup in chronological order.
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#backupID
   */
  readonly backupId?: string;

  /**
   * Set the target to be exclusive. If omitted, defaults to false, so that
   * in Postgres, `recovery_target_inclusive` will be true
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#exclusive
   */
  readonly exclusive?: boolean;

  /**
   * End recovery as soon as a consistent state is reached
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#targetImmediate
   */
  readonly targetImmediate?: boolean;

  /**
   * The target LSN (Log Sequence Number)
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#targetLSN
   */
  readonly targetLsn?: string;

  /**
   * The target name (to be previously created
   * with `pg_create_restore_point`)
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#targetName
   */
  readonly targetName?: string;

  /**
   * The target timeline ("latest" or a positive integer)
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#targetTLI
   */
  readonly targetTli?: string;

  /**
   * The target time as a timestamp in RFC3339 format or PostgreSQL timestamp format.
   * Timestamps without an explicit timezone are interpreted as UTC.
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#targetTime
   */
  readonly targetTime?: string;

  /**
   * The target transaction ID
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#targetXID
   */
  readonly targetXid?: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoveryRecoveryTarget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapRecoveryRecoveryTarget(obj: ClusterSpecBootstrapRecoveryRecoveryTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupID': obj.backupId,
    'exclusive': obj.exclusive,
    'targetImmediate': obj.targetImmediate,
    'targetLSN': obj.targetLsn,
    'targetName': obj.targetName,
    'targetTLI': obj.targetTli,
    'targetTime': obj.targetTime,
    'targetXID': obj.targetXid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name of the secret containing the initial credentials for the
 * owner of the user database. If empty a new secret will be
 * created from scratch
 *
 * @schema ClusterSpecBootstrapRecoverySecret
 */
export interface ClusterSpecBootstrapRecoverySecret {
  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapRecoverySecret#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoverySecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapRecoverySecret(obj: ClusterSpecBootstrapRecoverySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The static PVC data source(s) from which to initiate the
 * recovery procedure. Currently supporting `VolumeSnapshot`
 * and `PersistentVolumeClaim` resources that map an existing
 * PVC group, compatible with CloudNativePG, and taken with
 * a cold backup copy on a fenced Postgres instance (limitation
 * which will be removed in the future when online backup
 * will be implemented).
 * Mutually exclusive with `backup`.
 *
 * @schema ClusterSpecBootstrapRecoveryVolumeSnapshots
 */
export interface ClusterSpecBootstrapRecoveryVolumeSnapshots {
  /**
   * Configuration of the storage of the instances
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshots#storage
   */
  readonly storage: ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage;

  /**
   * Configuration of the storage for PostgreSQL tablespaces
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshots#tablespaceStorage
   */
  readonly tablespaceStorage?: { [key: string]: ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage };

  /**
   * Configuration of the storage for PostgreSQL WAL (Write-Ahead Log)
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshots#walStorage
   */
  readonly walStorage?: ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoveryVolumeSnapshots' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapRecoveryVolumeSnapshots(obj: ClusterSpecBootstrapRecoveryVolumeSnapshots | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'storage': toJson_ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage(obj.storage),
    'tablespaceStorage': ((obj.tablespaceStorage) === undefined) ? undefined : (Object.entries(obj.tablespaceStorage).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage(i[1]) }), {})),
    'walStorage': toJson_ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage(obj.walStorage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema ClusterSpecEnvValueFromConfigMapKeyRef
 */
export interface ClusterSpecEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema ClusterSpecEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterSpecEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ClusterSpecEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEnvValueFromConfigMapKeyRef(obj: ClusterSpecEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema ClusterSpecEnvValueFromFieldRef
 */
export interface ClusterSpecEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ClusterSpecEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ClusterSpecEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'ClusterSpecEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEnvValueFromFieldRef(obj: ClusterSpecEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FileKeyRef selects a key of the env file.
 * Requires the EnvFiles feature gate to be enabled.
 *
 * @schema ClusterSpecEnvValueFromFileKeyRef
 */
export interface ClusterSpecEnvValueFromFileKeyRef {
  /**
   * The key within the env file. An invalid key will prevent the pod from starting.
   * The keys defined within a source may consist of any printable ASCII characters except '='.
   * During Alpha stage of the EnvFiles feature gate, the key size is limited to 128 characters.
   *
   * @schema ClusterSpecEnvValueFromFileKeyRef#key
   */
  readonly key: string;

  /**
   * Specify whether the file or its key must be defined. If the file or key
   * does not exist, then the env var is not published.
   * If optional is set to true and the specified key does not exist,
   * the environment variable will not be set in the Pod's containers.
   *
   * If optional is set to false and the specified key does not exist,
   * an error will be returned during Pod creation.
   *
   * @schema ClusterSpecEnvValueFromFileKeyRef#optional
   */
  readonly optional?: boolean;

  /**
   * The path within the volume from which to select the file.
   * Must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterSpecEnvValueFromFileKeyRef#path
   */
  readonly path: string;

  /**
   * The name of the volume mount containing the env file.
   *
   * @schema ClusterSpecEnvValueFromFileKeyRef#volumeName
   */
  readonly volumeName: string;
}

/**
 * Converts an object of type 'ClusterSpecEnvValueFromFileKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEnvValueFromFileKeyRef(obj: ClusterSpecEnvValueFromFileKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'optional': obj.optional,
    'path': obj.path,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema ClusterSpecEnvValueFromResourceFieldRef
 */
export interface ClusterSpecEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ClusterSpecEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ClusterSpecEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: ClusterSpecEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ClusterSpecEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'ClusterSpecEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEnvValueFromResourceFieldRef(obj: ClusterSpecEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema ClusterSpecEnvValueFromSecretKeyRef
 */
export interface ClusterSpecEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ClusterSpecEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterSpecEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEnvValueFromSecretKeyRef(obj: ClusterSpecEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec
 */
export interface ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * Users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#resources
   */
  readonly resources?: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#selector
   */
  readonly selector?: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string or nil value indicates that no
   * VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
   * this field can be reset to its previous value (including nil) to cancel the modification.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec(obj: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The credentials to use to upload data to Azure Blob Storage
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials {
  /**
   * The connection string to be used
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials#connectionString
   */
  readonly connectionString?: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString;

  /**
   * Use the Azure AD based authentication without providing explicitly the keys.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials#inheritFromAzureAD
   */
  readonly inheritFromAzureAd?: boolean;

  /**
   * The storage account where to upload data
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials#storageAccount
   */
  readonly storageAccount?: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount;

  /**
   * The storage account key to be used in conjunction
   * with the storage account name
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials#storageKey
   */
  readonly storageKey?: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey;

  /**
   * A shared-access-signature to be used in conjunction with
   * the storage account name
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials#storageSasToken
   */
  readonly storageSasToken?: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken;

  /**
   * Use the default Azure authentication flow, which includes DefaultAzureCredential.
   * This allows authentication using environment variables and managed identities.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials#useDefaultAzureCredentials
   */
  readonly useDefaultAzureCredentials?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials(obj: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionString': toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString(obj.connectionString),
    'inheritFromAzureAD': obj.inheritFromAzureAd,
    'storageAccount': toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount(obj.storageAccount),
    'storageKey': toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey(obj.storageKey),
    'storageSasToken': toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken(obj.storageSasToken),
    'useDefaultAzureCredentials': obj.useDefaultAzureCredentials,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration to be used to backup the data files
 * When not defined, base backups files will be stored uncompressed and may
 * be unencrypted in the object store, according to the bucket default
 * policy.
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreData
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreData {
  /**
   * AdditionalCommandArgs represents additional arguments that can be appended
   * to the 'barman-cloud-backup' command-line invocation. These arguments
   * provide flexibility to customize the backup process further according to
   * specific requirements or configurations.
   *
   * Example:
   * In a scenario where specialized backup options are required, such as setting
   * a specific timeout or defining custom behavior, users can use this field
   * to specify additional command arguments.
   *
   * Note:
   * It's essential to ensure that the provided arguments are valid and supported
   * by the 'barman-cloud-backup' command, to avoid potential errors or unintended
   * behavior during execution.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreData#additionalCommandArgs
   */
  readonly additionalCommandArgs?: string[];

  /**
   * Compress a backup file (a tar file per tablespace) while streaming it
   * to the object store. Available options are empty string (no
   * compression, default), `gzip`, `bzip2`, and `snappy`.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreData#compression
   */
  readonly compression?: ClusterSpecExternalClustersBarmanObjectStoreDataCompression;

  /**
   * Whenever to force the encryption of files (if the bucket is
   * not already configured for that).
   * Allowed options are empty string (use the bucket policy, default),
   * `AES256` and `aws:kms`
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreData#encryption
   */
  readonly encryption?: ClusterSpecExternalClustersBarmanObjectStoreDataEncryption;

  /**
   * Control whether the I/O workload for the backup initial checkpoint will
   * be limited, according to the `checkpoint_completion_target` setting on
   * the PostgreSQL server. If set to true, an immediate checkpoint will be
   * used, meaning PostgreSQL will complete the checkpoint as soon as
   * possible. `false` by default.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreData#immediateCheckpoint
   */
  readonly immediateCheckpoint?: boolean;

  /**
   * The number of parallel jobs to be used to upload the backup, defaults
   * to 2
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreData#jobs
   */
  readonly jobs?: number;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreData(obj: ClusterSpecExternalClustersBarmanObjectStoreData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalCommandArgs': obj.additionalCommandArgs?.map(y => y),
    'compression': obj.compression,
    'encryption': obj.encryption,
    'immediateCheckpoint': obj.immediateCheckpoint,
    'jobs': obj.jobs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EndpointCA store the CA bundle of the barman endpoint.
 * Useful when using self-signed certificates to avoid
 * errors with certificate issuer and barman-cloud-wal-archive
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreEndpointCa
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreEndpointCa {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreEndpointCa#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreEndpointCa#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreEndpointCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreEndpointCa(obj: ClusterSpecExternalClustersBarmanObjectStoreEndpointCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The credentials to use to upload data to Google Cloud Storage
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials {
  /**
   * The secret containing the Google Cloud Storage JSON file with the credentials
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials#applicationCredentials
   */
  readonly applicationCredentials?: ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials;

  /**
   * If set to true, will presume that it's running inside a GKE environment,
   * default to false.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials#gkeEnvironment
   */
  readonly gkeEnvironment?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials(obj: ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationCredentials': toJson_ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials(obj.applicationCredentials),
    'gkeEnvironment': obj.gkeEnvironment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The credentials to use to upload data to S3
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreS3Credentials
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreS3Credentials {
  /**
   * The reference to the access key id
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3Credentials#accessKeyId
   */
  readonly accessKeyId?: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId;

  /**
   * Use the role based authentication without providing explicitly the keys.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3Credentials#inheritFromIAMRole
   */
  readonly inheritFromIamRole?: boolean;

  /**
   * The reference to the secret containing the region name
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3Credentials#region
   */
  readonly region?: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion;

  /**
   * The reference to the secret access key
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3Credentials#secretAccessKey
   */
  readonly secretAccessKey?: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey;

  /**
   * The references to the session key
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3Credentials#sessionToken
   */
  readonly sessionToken?: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreS3Credentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreS3Credentials(obj: ClusterSpecExternalClustersBarmanObjectStoreS3Credentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyId': toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId(obj.accessKeyId),
    'inheritFromIAMRole': obj.inheritFromIamRole,
    'region': toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion(obj.region),
    'secretAccessKey': toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey(obj.secretAccessKey),
    'sessionToken': toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken(obj.sessionToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration for the backup of the WAL stream.
 * When not defined, WAL files will be stored uncompressed and may be
 * unencrypted in the object store, according to the bucket default policy.
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreWal
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreWal {
  /**
   * Additional arguments that can be appended to the 'barman-cloud-wal-archive'
   * command-line invocation. These arguments provide flexibility to customize
   * the WAL archive process further, according to specific requirements or configurations.
   *
   * Example:
   * In a scenario where specialized backup options are required, such as setting
   * a specific timeout or defining custom behavior, users can use this field
   * to specify additional command arguments.
   *
   * Note:
   * It's essential to ensure that the provided arguments are valid and supported
   * by the 'barman-cloud-wal-archive' command, to avoid potential errors or unintended
   * behavior during execution.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreWal#archiveAdditionalCommandArgs
   */
  readonly archiveAdditionalCommandArgs?: string[];

  /**
   * Compress a WAL file before sending it to the object store. Available
   * options are empty string (no compression, default), `gzip`, `bzip2`,
   * `lz4`, `snappy`, `xz`, and `zstd`.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreWal#compression
   */
  readonly compression?: ClusterSpecExternalClustersBarmanObjectStoreWalCompression;

  /**
   * Whenever to force the encryption of files (if the bucket is
   * not already configured for that).
   * Allowed options are empty string (use the bucket policy, default),
   * `AES256` and `aws:kms`
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreWal#encryption
   */
  readonly encryption?: ClusterSpecExternalClustersBarmanObjectStoreWalEncryption;

  /**
   * Number of WAL files to be either archived in parallel (when the
   * PostgreSQL instance is archiving to a backup object store) or
   * restored in parallel (when a PostgreSQL standby is fetching WAL
   * files from a recovery object store). If not specified, WAL files
   * will be processed one at a time. It accepts a positive integer as a
   * value - with 1 being the minimum accepted value.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreWal#maxParallel
   */
  readonly maxParallel?: number;

  /**
   * Additional arguments that can be appended to the 'barman-cloud-wal-restore'
   * command-line invocation. These arguments provide flexibility to customize
   * the WAL restore process further, according to specific requirements or configurations.
   *
   * Example:
   * In a scenario where specialized backup options are required, such as setting
   * a specific timeout or defining custom behavior, users can use this field
   * to specify additional command arguments.
   *
   * Note:
   * It's essential to ensure that the provided arguments are valid and supported
   * by the 'barman-cloud-wal-restore' command, to avoid potential errors or unintended
   * behavior during execution.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreWal#restoreAdditionalCommandArgs
   */
  readonly restoreAdditionalCommandArgs?: string[];
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreWal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreWal(obj: ClusterSpecExternalClustersBarmanObjectStoreWal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'archiveAdditionalCommandArgs': obj.archiveAdditionalCommandArgs?.map(y => y),
    'compression': obj.compression,
    'encryption': obj.encryption,
    'maxParallel': obj.maxParallel,
    'restoreAdditionalCommandArgs': obj.restoreAdditionalCommandArgs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Ensure the role is `present` or `absent` - defaults to "present"
 *
 * @schema ClusterSpecManagedRolesEnsure
 */
export enum ClusterSpecManagedRolesEnsure {
  /** present */
  PRESENT = "present",
  /** absent */
  ABSENT = "absent",
}

/**
 * Secret containing the password of the role (if present)
 * If null, the password will be ignored unless DisablePassword is set
 *
 * @schema ClusterSpecManagedRolesPasswordSecret
 */
export interface ClusterSpecManagedRolesPasswordSecret {
  /**
   * Name of the referent.
   *
   * @schema ClusterSpecManagedRolesPasswordSecret#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecManagedRolesPasswordSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManagedRolesPasswordSecret(obj: ClusterSpecManagedRolesPasswordSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ManagedService represents a specific service managed by the cluster.
 * It includes the type of service and its associated template specification.
 *
 * @schema ClusterSpecManagedServicesAdditional
 */
export interface ClusterSpecManagedServicesAdditional {
  /**
   * SelectorType specifies the type of selectors that the service will have.
   * Valid values are "rw", "r", and "ro", representing read-write, read, and read-only services.
   *
   * @schema ClusterSpecManagedServicesAdditional#selectorType
   */
  readonly selectorType: ClusterSpecManagedServicesAdditionalSelectorType;

  /**
   * ServiceTemplate is the template specification for the service.
   *
   * @schema ClusterSpecManagedServicesAdditional#serviceTemplate
   */
  readonly serviceTemplate: ClusterSpecManagedServicesAdditionalServiceTemplate;

  /**
   * UpdateStrategy describes how the service differences should be reconciled
   *
   * @schema ClusterSpecManagedServicesAdditional#updateStrategy
   */
  readonly updateStrategy?: ClusterSpecManagedServicesAdditionalUpdateStrategy;
}

/**
 * Converts an object of type 'ClusterSpecManagedServicesAdditional' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManagedServicesAdditional(obj: ClusterSpecManagedServicesAdditional | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'selectorType': obj.selectorType,
    'serviceTemplate': toJson_ClusterSpecManagedServicesAdditionalServiceTemplate(obj.serviceTemplate),
    'updateStrategy': obj.updateStrategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceSelectorType describes a valid value for generating the service selectors.
 * It indicates which type of service the selector applies to, such as read-write, read, or read-only
 *
 * @schema ClusterSpecManagedServicesDisabledDefaultServices
 */
export enum ClusterSpecManagedServicesDisabledDefaultServices {
  /** rw */
  RW = "rw",
  /** r */
  R = "r",
  /** ro */
  RO = "ro",
}

/**
 * action to perform based on the regex matching.
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 * Default: "Replace"
 *
 * @schema ClusterSpecMonitoringPodMonitorMetricRelabelingsAction
 */
export enum ClusterSpecMonitoringPodMonitorMetricRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * action to perform based on the regex matching.
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 * Default: "Replace"
 *
 * @schema ClusterSpecMonitoringPodMonitorRelabelingsAction
 */
export enum ClusterSpecMonitoringPodMonitorRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * The image containing the extension, required
 *
 * @schema ClusterSpecPostgresqlExtensionsImage
 */
export interface ClusterSpecPostgresqlExtensionsImage {
  /**
   * Policy for pulling OCI objects. Possible values are:
   * Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema ClusterSpecPostgresqlExtensionsImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Required: Image or artifact reference to be used.
   * Behaves in the same way as pod.spec.containers[*].image.
   * Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema ClusterSpecPostgresqlExtensionsImage#reference
   */
  readonly reference?: string;
}

/**
 * Converts an object of type 'ClusterSpecPostgresqlExtensionsImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPostgresqlExtensionsImage(obj: ClusterSpecPostgresqlExtensionsImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Bind as authentication configuration
 *
 * @schema ClusterSpecPostgresqlLdapBindAsAuth
 */
export interface ClusterSpecPostgresqlLdapBindAsAuth {
  /**
   * Prefix for the bind authentication option
   *
   * @schema ClusterSpecPostgresqlLdapBindAsAuth#prefix
   */
  readonly prefix?: string;

  /**
   * Suffix for the bind authentication option
   *
   * @schema ClusterSpecPostgresqlLdapBindAsAuth#suffix
   */
  readonly suffix?: string;
}

/**
 * Converts an object of type 'ClusterSpecPostgresqlLdapBindAsAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPostgresqlLdapBindAsAuth(obj: ClusterSpecPostgresqlLdapBindAsAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Bind+Search authentication configuration
 *
 * @schema ClusterSpecPostgresqlLdapBindSearchAuth
 */
export interface ClusterSpecPostgresqlLdapBindSearchAuth {
  /**
   * Root DN to begin the user search
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuth#baseDN
   */
  readonly baseDn?: string;

  /**
   * DN of the user to bind to the directory
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuth#bindDN
   */
  readonly bindDn?: string;

  /**
   * Secret with the password for the user to bind to the directory
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuth#bindPassword
   */
  readonly bindPassword?: ClusterSpecPostgresqlLdapBindSearchAuthBindPassword;

  /**
   * Attribute to match against the username
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuth#searchAttribute
   */
  readonly searchAttribute?: string;

  /**
   * Search filter to use when doing the search+bind authentication
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuth#searchFilter
   */
  readonly searchFilter?: string;
}

/**
 * Converts an object of type 'ClusterSpecPostgresqlLdapBindSearchAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPostgresqlLdapBindSearchAuth(obj: ClusterSpecPostgresqlLdapBindSearchAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseDN': obj.baseDn,
    'bindDN': obj.bindDn,
    'bindPassword': toJson_ClusterSpecPostgresqlLdapBindSearchAuthBindPassword(obj.bindPassword),
    'searchAttribute': obj.searchAttribute,
    'searchFilter': obj.searchFilter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LDAP schema to be used, possible options are `ldap` and `ldaps`
 *
 * @schema ClusterSpecPostgresqlLdapScheme
 */
export enum ClusterSpecPostgresqlLdapScheme {
  /** ldap */
  LDAP = "ldap",
  /** ldaps */
  LDAPS = "ldaps",
}

/**
 * If set to "required", data durability is strictly enforced. Write operations
 * with synchronous commit settings (`on`, `remote_write`, or `remote_apply`) will
 * block if there are insufficient healthy replicas, ensuring data persistence.
 * If set to "preferred", data durability is maintained when healthy replicas
 * are available, but the required number of instances will adjust dynamically
 * if replicas become unavailable. This setting relaxes strict durability enforcement
 * to allow for operational continuity. This setting is only applicable if both
 * `standbyNamesPre` and `standbyNamesPost` are unset (empty).
 *
 * @schema ClusterSpecPostgresqlSynchronousDataDurability
 */
export enum ClusterSpecPostgresqlSynchronousDataDurability {
  /** required */
  REQUIRED = "required",
  /** preferred */
  PREFERRED = "preferred",
}

/**
 * Method to select synchronous replication standbys from the listed
 * servers, accepting 'any' (quorum-based synchronous replication) or
 * 'first' (priority-based synchronous replication) as values.
 *
 * @schema ClusterSpecPostgresqlSynchronousMethod
 */
export enum ClusterSpecPostgresqlSynchronousMethod {
  /** any */
  ANY = "any",
  /** first */
  FIRST = "first",
}

/**
 * Configure the feature that extends the liveness probe for a primary
 * instance. In addition to the basic checks, this verifies whether the
 * primary is isolated from the Kubernetes API server and from its
 * replicas, ensuring that it can be safely shut down if network
 * partition or API unavailability is detected. Enabled by default.
 *
 * @schema ClusterSpecProbesLivenessIsolationCheck
 */
export interface ClusterSpecProbesLivenessIsolationCheck {
  /**
   * Timeout in milliseconds for connections during the primary isolation check
   *
   * @schema ClusterSpecProbesLivenessIsolationCheck#connectionTimeout
   */
  readonly connectionTimeout?: number;

  /**
   * Whether primary isolation checking is enabled for the liveness probe
   *
   * @schema ClusterSpecProbesLivenessIsolationCheck#enabled
   */
  readonly enabled?: boolean;

  /**
   * Timeout in milliseconds for requests during the primary isolation check
   *
   * @schema ClusterSpecProbesLivenessIsolationCheck#requestTimeout
   */
  readonly requestTimeout?: number;
}

/**
 * Converts an object of type 'ClusterSpecProbesLivenessIsolationCheck' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProbesLivenessIsolationCheck(obj: ClusterSpecProbesLivenessIsolationCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionTimeout': obj.connectionTimeout,
    'enabled': obj.enabled,
    'requestTimeout': obj.requestTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Lag limit. Used only for `streaming` strategy
 *
 * @schema ClusterSpecProbesReadinessMaximumLag
 */
export class ClusterSpecProbesReadinessMaximumLag {
  public static fromNumber(value: number): ClusterSpecProbesReadinessMaximumLag {
    return new ClusterSpecProbesReadinessMaximumLag(value);
  }
  public static fromString(value: string): ClusterSpecProbesReadinessMaximumLag {
    return new ClusterSpecProbesReadinessMaximumLag(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The probe strategy
 *
 * @schema ClusterSpecProbesReadinessType
 */
export enum ClusterSpecProbesReadinessType {
  /** pg_isready */
  PG_UNDERSCORE_ISREADY = "pg_isready",
  /** streaming */
  STREAMING = "streaming",
  /** query */
  QUERY = "query",
}

/**
 * Lag limit. Used only for `streaming` strategy
 *
 * @schema ClusterSpecProbesStartupMaximumLag
 */
export class ClusterSpecProbesStartupMaximumLag {
  public static fromNumber(value: number): ClusterSpecProbesStartupMaximumLag {
    return new ClusterSpecProbesStartupMaximumLag(value);
  }
  public static fromString(value: string): ClusterSpecProbesStartupMaximumLag {
    return new ClusterSpecProbesStartupMaximumLag(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The probe strategy
 *
 * @schema ClusterSpecProbesStartupType
 */
export enum ClusterSpecProbesStartupType {
  /** pg_isready */
  PG_UNDERSCORE_ISREADY = "pg_isready",
  /** streaming */
  STREAMING = "streaming",
  /** query */
  QUERY = "query",
}

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;
}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle(obj: ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector(obj.labelSelector),
    'name': obj.name,
    'optional': obj.optional,
    'path': obj.path,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMap
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMap#items
   */
  readonly items?: ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesConfigMap(obj: ClusterSpecProjectedVolumeTemplateSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApi
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApi#items
   */
  readonly items?: ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApi(obj: ClusterSpecProjectedVolumeTemplateSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projects an auto-rotating credential bundle (private key and certificate
 * chain) that the pod can use either as a TLS client or server.
 *
 * Kubelet generates a private key and uses it to send a
 * PodCertificateRequest to the named signer.  Once the signer approves the
 * request and issues a certificate chain, Kubelet writes the key and
 * certificate chain to the pod filesystem.  The pod does not start until
 * certificates have been issued for each podCertificate projected volume
 * source in its spec.
 *
 * Kubelet will begin trying to rotate the certificate at the time indicated
 * by the signer using the PodCertificateRequest.Status.BeginRefreshAt
 * timestamp.
 *
 * Kubelet can write a single file, indicated by the credentialBundlePath
 * field, or separate files, indicated by the keyPath and
 * certificateChainPath fields.
 *
 * The credential bundle is a single file in PEM format.  The first PEM
 * entry is the private key (in PKCS#8 format), and the remaining PEM
 * entries are the certificate chain issued by the signer (typically,
 * signers will return their certificate chain in leaf-to-root order).
 *
 * Prefer using the credential bundle format, since your application code
 * can read it atomically.  If you use keyPath and certificateChainPath,
 * your application must make two separate file reads. If these coincide
 * with a certificate rotation, it is possible that the private key and leaf
 * certificate you read may not correspond to each other.  Your application
 * will need to check for this condition, and re-read until they are
 * consistent.
 *
 * The named signer controls chooses the format of the certificate it
 * issues; consult the signer implementation's documentation to learn how to
 * use the certificates it issues.
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesPodCertificate
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesPodCertificate {
  /**
   * Write the certificate chain at this path in the projected volume.
   *
   * Most applications should use credentialBundlePath.  When using keyPath
   * and certificateChainPath, your application needs to check that the key
   * and leaf certificate are consistent, because it is possible to read the
   * files mid-rotation.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesPodCertificate#certificateChainPath
   */
  readonly certificateChainPath?: string;

  /**
   * Write the credential bundle at this path in the projected volume.
   *
   * The credential bundle is a single file that contains multiple PEM blocks.
   * The first PEM block is a PRIVATE KEY block, containing a PKCS#8 private
   * key.
   *
   * The remaining blocks are CERTIFICATE blocks, containing the issued
   * certificate chain from the signer (leaf and any intermediates).
   *
   * Using credentialBundlePath lets your Pod's application code make a single
   * atomic read that retrieves a consistent key and certificate chain.  If you
   * project them to separate files, your application code will need to
   * additionally check that the leaf certificate was issued to the key.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesPodCertificate#credentialBundlePath
   */
  readonly credentialBundlePath?: string;

  /**
   * Write the key at this path in the projected volume.
   *
   * Most applications should use credentialBundlePath.  When using keyPath
   * and certificateChainPath, your application needs to check that the key
   * and leaf certificate are consistent, because it is possible to read the
   * files mid-rotation.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesPodCertificate#keyPath
   */
  readonly keyPath?: string;

  /**
   * The type of keypair Kubelet will generate for the pod.
   *
   * Valid values are "RSA3072", "RSA4096", "ECDSAP256", "ECDSAP384",
   * "ECDSAP521", and "ED25519".
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesPodCertificate#keyType
   */
  readonly keyType: string;

  /**
   * maxExpirationSeconds is the maximum lifetime permitted for the
   * certificate.
   *
   * Kubelet copies this value verbatim into the PodCertificateRequests it
   * generates for this projection.
   *
   * If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver
   * will reject values shorter than 3600 (1 hour).  The maximum allowable
   * value is 7862400 (91 days).
   *
   * The signer implementation is then free to issue a certificate with any
   * lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600
   * seconds (1 hour).  This constraint is enforced by kube-apiserver.
   * `kubernetes.io` signers will never issue certificates with a lifetime
   * longer than 24 hours.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesPodCertificate#maxExpirationSeconds
   */
  readonly maxExpirationSeconds?: number;

  /**
   * Kubelet's generated CSRs will be addressed to this signer.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesPodCertificate#signerName
   */
  readonly signerName: string;

  /**
   * userAnnotations allow pod authors to pass additional information to
   * the signer implementation.  Kubernetes does not restrict or validate this
   * metadata in any way.
   *
   * These values are copied verbatim into the `spec.unverifiedUserAnnotations` field of
   * the PodCertificateRequest objects that Kubelet creates.
   *
   * Entries are subject to the same validation as object metadata annotations,
   * with the addition that all keys must be domain-prefixed. No restrictions
   * are placed on values, except an overall size limitation on the entire field.
   *
   * Signers should document the keys and values they support. Signers should
   * deny requests that contain keys they do not recognize.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesPodCertificate#userAnnotations
   */
  readonly userAnnotations?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesPodCertificate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesPodCertificate(obj: ClusterSpecProjectedVolumeTemplateSourcesPodCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChainPath': obj.certificateChainPath,
    'credentialBundlePath': obj.credentialBundlePath,
    'keyPath': obj.keyPath,
    'keyType': obj.keyType,
    'maxExpirationSeconds': obj.maxExpirationSeconds,
    'signerName': obj.signerName,
    'userAnnotations': ((obj.userAnnotations) === undefined) ? undefined : (Object.entries(obj.userAnnotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesSecret
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesSecret#items
   */
  readonly items?: ClusterSpecProjectedVolumeTemplateSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesSecret(obj: ClusterSpecProjectedVolumeTemplateSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterSpecProjectedVolumeTemplateSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken(obj: ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ClusterSpecStoragePvcTemplateDataSource
 */
export interface ClusterSpecStoragePvcTemplateDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecStoragePvcTemplateDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecStoragePvcTemplateDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecStoragePvcTemplateDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecStoragePvcTemplateDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecStoragePvcTemplateDataSource(obj: ClusterSpecStoragePvcTemplateDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ClusterSpecStoragePvcTemplateDataSourceRef
 */
export interface ClusterSpecStoragePvcTemplateDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecStoragePvcTemplateDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecStoragePvcTemplateDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecStoragePvcTemplateDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecStoragePvcTemplateDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSpecStoragePvcTemplateDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecStoragePvcTemplateDataSourceRef(obj: ClusterSpecStoragePvcTemplateDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * Users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ClusterSpecStoragePvcTemplateResources
 */
export interface ClusterSpecStoragePvcTemplateResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecStoragePvcTemplateResources#limits
   */
  readonly limits?: { [key: string]: ClusterSpecStoragePvcTemplateResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecStoragePvcTemplateResources#requests
   */
  readonly requests?: { [key: string]: ClusterSpecStoragePvcTemplateResourcesRequests };
}

/**
 * Converts an object of type 'ClusterSpecStoragePvcTemplateResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecStoragePvcTemplateResources(obj: ClusterSpecStoragePvcTemplateResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ClusterSpecStoragePvcTemplateSelector
 */
export interface ClusterSpecStoragePvcTemplateSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecStoragePvcTemplateSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecStoragePvcTemplateSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecStoragePvcTemplateSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecStoragePvcTemplateSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecStoragePvcTemplateSelector(obj: ClusterSpecStoragePvcTemplateSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecStoragePvcTemplateSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template to be used to generate the Persistent Volume Claim
 *
 * @schema ClusterSpecTablespacesStoragePvcTemplate
 */
export interface ClusterSpecTablespacesStoragePvcTemplate {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#dataSource
   */
  readonly dataSource?: ClusterSpecTablespacesStoragePvcTemplateDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#dataSourceRef
   */
  readonly dataSourceRef?: ClusterSpecTablespacesStoragePvcTemplateDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * Users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#resources
   */
  readonly resources?: ClusterSpecTablespacesStoragePvcTemplateResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#selector
   */
  readonly selector?: ClusterSpecTablespacesStoragePvcTemplateSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string or nil value indicates that no
   * VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
   * this field can be reset to its previous value (including nil) to cancel the modification.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'ClusterSpecTablespacesStoragePvcTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecTablespacesStoragePvcTemplate(obj: ClusterSpecTablespacesStoragePvcTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ClusterSpecTablespacesStoragePvcTemplateDataSource(obj.dataSource),
    'dataSourceRef': toJson_ClusterSpecTablespacesStoragePvcTemplateDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ClusterSpecTablespacesStoragePvcTemplateResources(obj.resources),
    'selector': toJson_ClusterSpecTablespacesStoragePvcTemplateSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ClusterSpecWalStoragePvcTemplateDataSource
 */
export interface ClusterSpecWalStoragePvcTemplateDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecWalStoragePvcTemplateDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecWalStoragePvcTemplateDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecWalStoragePvcTemplateDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecWalStoragePvcTemplateDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecWalStoragePvcTemplateDataSource(obj: ClusterSpecWalStoragePvcTemplateDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ClusterSpecWalStoragePvcTemplateDataSourceRef
 */
export interface ClusterSpecWalStoragePvcTemplateDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecWalStoragePvcTemplateDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecWalStoragePvcTemplateDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecWalStoragePvcTemplateDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecWalStoragePvcTemplateDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSpecWalStoragePvcTemplateDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecWalStoragePvcTemplateDataSourceRef(obj: ClusterSpecWalStoragePvcTemplateDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * Users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ClusterSpecWalStoragePvcTemplateResources
 */
export interface ClusterSpecWalStoragePvcTemplateResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecWalStoragePvcTemplateResources#limits
   */
  readonly limits?: { [key: string]: ClusterSpecWalStoragePvcTemplateResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecWalStoragePvcTemplateResources#requests
   */
  readonly requests?: { [key: string]: ClusterSpecWalStoragePvcTemplateResourcesRequests };
}

/**
 * Converts an object of type 'ClusterSpecWalStoragePvcTemplateResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecWalStoragePvcTemplateResources(obj: ClusterSpecWalStoragePvcTemplateResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ClusterSpecWalStoragePvcTemplateSelector
 */
export interface ClusterSpecWalStoragePvcTemplateSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecWalStoragePvcTemplateSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecWalStoragePvcTemplateSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecWalStoragePvcTemplateSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecWalStoragePvcTemplateSelector(obj: ClusterSpecWalStoragePvcTemplateSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The connection string to be used
 *
 * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString
 */
export interface ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString(obj: ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The storage account where to upload data
 *
 * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount
 */
export interface ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount(obj: ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The storage account key to be used in conjunction
 * with the storage account name
 *
 * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey
 */
export interface ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey(obj: ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A shared-access-signature to be used in conjunction with
 * the storage account name
 *
 * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken
 */
export interface ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken(obj: ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compress a backup file (a tar file per tablespace) while streaming it
 * to the object store. Available options are empty string (no
 * compression, default), `gzip`, `bzip2`, and `snappy`.
 *
 * @schema ClusterSpecBackupBarmanObjectStoreDataCompression
 */
export enum ClusterSpecBackupBarmanObjectStoreDataCompression {
  /** bzip2 */
  BZIP2 = "bzip2",
  /** gzip */
  GZIP = "gzip",
  /** snappy */
  SNAPPY = "snappy",
}

/**
 * Whenever to force the encryption of files (if the bucket is
 * not already configured for that).
 * Allowed options are empty string (use the bucket policy, default),
 * `AES256` and `aws:kms`
 *
 * @schema ClusterSpecBackupBarmanObjectStoreDataEncryption
 */
export enum ClusterSpecBackupBarmanObjectStoreDataEncryption {
  /** AES256 */
  AES256 = "AES256",
  /** aws:kms */
  AWS_KMS = "aws:kms",
}

/**
 * The secret containing the Google Cloud Storage JSON file with the credentials
 *
 * @schema ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials
 */
export interface ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials(obj: ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The reference to the access key id
 *
 * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId
 */
export interface ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId(obj: ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The reference to the secret containing the region name
 *
 * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion
 */
export interface ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion(obj: ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The reference to the secret access key
 *
 * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey
 */
export interface ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey(obj: ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The references to the session key
 *
 * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken
 */
export interface ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken(obj: ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compress a WAL file before sending it to the object store. Available
 * options are empty string (no compression, default), `gzip`, `bzip2`,
 * `lz4`, `snappy`, `xz`, and `zstd`.
 *
 * @schema ClusterSpecBackupBarmanObjectStoreWalCompression
 */
export enum ClusterSpecBackupBarmanObjectStoreWalCompression {
  /** bzip2 */
  BZIP2 = "bzip2",
  /** gzip */
  GZIP = "gzip",
  /** lz4 */
  LZ4 = "lz4",
  /** snappy */
  SNAPPY = "snappy",
  /** xz */
  XZ = "xz",
  /** zstd */
  ZSTD = "zstd",
}

/**
 * Whenever to force the encryption of files (if the bucket is
 * not already configured for that).
 * Allowed options are empty string (use the bucket policy, default),
 * `AES256` and `aws:kms`
 *
 * @schema ClusterSpecBackupBarmanObjectStoreWalEncryption
 */
export enum ClusterSpecBackupBarmanObjectStoreWalEncryption {
  /** AES256 */
  AES256 = "AES256",
  /** aws:kms */
  AWS_KMS = "aws:kms",
}

/**
 * The source of the import
 *
 * @schema ClusterSpecBootstrapInitdbImportSource
 */
export interface ClusterSpecBootstrapInitdbImportSource {
  /**
   * The name of the externalCluster used for import
   *
   * @schema ClusterSpecBootstrapInitdbImportSource#externalCluster
   */
  readonly externalCluster: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbImportSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapInitdbImportSource(obj: ClusterSpecBootstrapInitdbImportSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalCluster': obj.externalCluster,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The import type. Can be `microservice` or `monolith`.
 *
 * @schema ClusterSpecBootstrapInitdbImportType
 */
export enum ClusterSpecBootstrapInitdbImportType {
  /** microservice */
  MICROSERVICE = "microservice",
  /** monolith */
  MONOLITH = "monolith",
}

/**
 * ConfigMapKeySelector contains enough information to let you locate
 * the key of a ConfigMap
 *
 * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs
 */
export interface ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs {
  /**
   * The key to select
   *
   * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs(obj: ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKeySelector contains enough information to let you locate
 * the key of a Secret
 *
 * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs
 */
export interface ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs {
  /**
   * The key to select
   *
   * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs(obj: ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMapKeySelector contains enough information to let you locate
 * the key of a ConfigMap
 *
 * @schema ClusterSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs
 */
export interface ClusterSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs {
  /**
   * The key to select
   *
   * @schema ClusterSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs(obj: ClusterSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKeySelector contains enough information to let you locate
 * the key of a Secret
 *
 * @schema ClusterSpecBootstrapInitdbPostInitSqlRefsSecretRefs
 */
export interface ClusterSpecBootstrapInitdbPostInitSqlRefsSecretRefs {
  /**
   * The key to select
   *
   * @schema ClusterSpecBootstrapInitdbPostInitSqlRefsSecretRefs#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapInitdbPostInitSqlRefsSecretRefs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbPostInitSqlRefsSecretRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapInitdbPostInitSqlRefsSecretRefs(obj: ClusterSpecBootstrapInitdbPostInitSqlRefsSecretRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConfigMapKeySelector contains enough information to let you locate
 * the key of a ConfigMap
 *
 * @schema ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs
 */
export interface ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs {
  /**
   * The key to select
   *
   * @schema ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs(obj: ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKeySelector contains enough information to let you locate
 * the key of a Secret
 *
 * @schema ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs
 */
export interface ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs {
  /**
   * The key to select
   *
   * @schema ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs(obj: ClusterSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EndpointCA store the CA bundle of the barman endpoint.
 * Useful when using self-signed certificates to avoid
 * errors with certificate issuer and barman-cloud-wal-archive.
 *
 * @schema ClusterSpecBootstrapRecoveryBackupEndpointCa
 */
export interface ClusterSpecBootstrapRecoveryBackupEndpointCa {
  /**
   * The key to select
   *
   * @schema ClusterSpecBootstrapRecoveryBackupEndpointCa#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapRecoveryBackupEndpointCa#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoveryBackupEndpointCa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapRecoveryBackupEndpointCa(obj: ClusterSpecBootstrapRecoveryBackupEndpointCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of the storage of the instances
 *
 * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage
 */
export interface ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage(obj: ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TypedLocalObjectReference contains enough information to let you locate the
 * typed referenced object inside the same namespace.
 *
 * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage
 */
export interface ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage(obj: ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of the storage for PostgreSQL WAL (Write-Ahead Log)
 *
 * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage
 */
export interface ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage(obj: ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ClusterSpecEnvValueFromResourceFieldRefDivisor
 */
export class ClusterSpecEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): ClusterSpecEnvValueFromResourceFieldRefDivisor {
    return new ClusterSpecEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ClusterSpecEnvValueFromResourceFieldRefDivisor {
    return new ClusterSpecEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource
 */
export interface ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource(obj: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef
 */
export interface ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef(obj: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * Users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources
 */
export interface ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesRequests };
}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources(obj: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector
 */
export interface ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector(obj: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The connection string to be used
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString(obj: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The storage account where to upload data
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount(obj: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The storage account key to be used in conjunction
 * with the storage account name
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey(obj: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A shared-access-signature to be used in conjunction with
 * the storage account name
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken(obj: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compress a backup file (a tar file per tablespace) while streaming it
 * to the object store. Available options are empty string (no
 * compression, default), `gzip`, `bzip2`, and `snappy`.
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreDataCompression
 */
export enum ClusterSpecExternalClustersBarmanObjectStoreDataCompression {
  /** bzip2 */
  BZIP2 = "bzip2",
  /** gzip */
  GZIP = "gzip",
  /** snappy */
  SNAPPY = "snappy",
}

/**
 * Whenever to force the encryption of files (if the bucket is
 * not already configured for that).
 * Allowed options are empty string (use the bucket policy, default),
 * `AES256` and `aws:kms`
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreDataEncryption
 */
export enum ClusterSpecExternalClustersBarmanObjectStoreDataEncryption {
  /** AES256 */
  AES256 = "AES256",
  /** aws:kms */
  AWS_KMS = "aws:kms",
}

/**
 * The secret containing the Google Cloud Storage JSON file with the credentials
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials(obj: ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The reference to the access key id
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId(obj: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The reference to the secret containing the region name
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion(obj: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The reference to the secret access key
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey(obj: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The references to the session key
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken(obj: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compress a WAL file before sending it to the object store. Available
 * options are empty string (no compression, default), `gzip`, `bzip2`,
 * `lz4`, `snappy`, `xz`, and `zstd`.
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreWalCompression
 */
export enum ClusterSpecExternalClustersBarmanObjectStoreWalCompression {
  /** bzip2 */
  BZIP2 = "bzip2",
  /** gzip */
  GZIP = "gzip",
  /** lz4 */
  LZ4 = "lz4",
  /** snappy */
  SNAPPY = "snappy",
  /** xz */
  XZ = "xz",
  /** zstd */
  ZSTD = "zstd",
}

/**
 * Whenever to force the encryption of files (if the bucket is
 * not already configured for that).
 * Allowed options are empty string (use the bucket policy, default),
 * `AES256` and `aws:kms`
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreWalEncryption
 */
export enum ClusterSpecExternalClustersBarmanObjectStoreWalEncryption {
  /** AES256 */
  AES256 = "AES256",
  /** aws:kms */
  AWS_KMS = "aws:kms",
}

/**
 * SelectorType specifies the type of selectors that the service will have.
 * Valid values are "rw", "r", and "ro", representing read-write, read, and read-only services.
 *
 * @schema ClusterSpecManagedServicesAdditionalSelectorType
 */
export enum ClusterSpecManagedServicesAdditionalSelectorType {
  /** rw */
  RW = "rw",
  /** r */
  R = "r",
  /** ro */
  RO = "ro",
}

/**
 * ServiceTemplate is the template specification for the service.
 *
 * @schema ClusterSpecManagedServicesAdditionalServiceTemplate
 */
export interface ClusterSpecManagedServicesAdditionalServiceTemplate {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplate#metadata
   */
  readonly metadata?: ClusterSpecManagedServicesAdditionalServiceTemplateMetadata;

  /**
   * Specification of the desired behavior of the service.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplate#spec
   */
  readonly spec?: ClusterSpecManagedServicesAdditionalServiceTemplateSpec;
}

/**
 * Converts an object of type 'ClusterSpecManagedServicesAdditionalServiceTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManagedServicesAdditionalServiceTemplate(obj: ClusterSpecManagedServicesAdditionalServiceTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_ClusterSpecManagedServicesAdditionalServiceTemplateMetadata(obj.metadata),
    'spec': toJson_ClusterSpecManagedServicesAdditionalServiceTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UpdateStrategy describes how the service differences should be reconciled
 *
 * @schema ClusterSpecManagedServicesAdditionalUpdateStrategy
 */
export enum ClusterSpecManagedServicesAdditionalUpdateStrategy {
  /** patch */
  PATCH = "patch",
  /** replace */
  REPLACE = "replace",
}

/**
 * Secret with the password for the user to bind to the directory
 *
 * @schema ClusterSpecPostgresqlLdapBindSearchAuthBindPassword
 */
export interface ClusterSpecPostgresqlLdapBindSearchAuthBindPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuthBindPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuthBindPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuthBindPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecPostgresqlLdapBindSearchAuthBindPassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecPostgresqlLdapBindSearchAuthBindPassword(obj: ClusterSpecPostgresqlLdapBindSearchAuthBindPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector(obj: ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems(obj: ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems(obj: ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesSecretItems
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesSecretItems(obj: ClusterSpecProjectedVolumeTemplateSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecStoragePvcTemplateResourcesLimits
 */
export class ClusterSpecStoragePvcTemplateResourcesLimits {
  public static fromNumber(value: number): ClusterSpecStoragePvcTemplateResourcesLimits {
    return new ClusterSpecStoragePvcTemplateResourcesLimits(value);
  }
  public static fromString(value: string): ClusterSpecStoragePvcTemplateResourcesLimits {
    return new ClusterSpecStoragePvcTemplateResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecStoragePvcTemplateResourcesRequests
 */
export class ClusterSpecStoragePvcTemplateResourcesRequests {
  public static fromNumber(value: number): ClusterSpecStoragePvcTemplateResourcesRequests {
    return new ClusterSpecStoragePvcTemplateResourcesRequests(value);
  }
  public static fromString(value: string): ClusterSpecStoragePvcTemplateResourcesRequests {
    return new ClusterSpecStoragePvcTemplateResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecStoragePvcTemplateSelectorMatchExpressions
 */
export interface ClusterSpecStoragePvcTemplateSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecStoragePvcTemplateSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecStoragePvcTemplateSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecStoragePvcTemplateSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecStoragePvcTemplateSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecStoragePvcTemplateSelectorMatchExpressions(obj: ClusterSpecStoragePvcTemplateSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ClusterSpecTablespacesStoragePvcTemplateDataSource
 */
export interface ClusterSpecTablespacesStoragePvcTemplateDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterSpecTablespacesStoragePvcTemplateDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecTablespacesStoragePvcTemplateDataSource(obj: ClusterSpecTablespacesStoragePvcTemplateDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ClusterSpecTablespacesStoragePvcTemplateDataSourceRef
 */
export interface ClusterSpecTablespacesStoragePvcTemplateDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSpecTablespacesStoragePvcTemplateDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecTablespacesStoragePvcTemplateDataSourceRef(obj: ClusterSpecTablespacesStoragePvcTemplateDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * Users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ClusterSpecTablespacesStoragePvcTemplateResources
 */
export interface ClusterSpecTablespacesStoragePvcTemplateResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateResources#limits
   */
  readonly limits?: { [key: string]: ClusterSpecTablespacesStoragePvcTemplateResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateResources#requests
   */
  readonly requests?: { [key: string]: ClusterSpecTablespacesStoragePvcTemplateResourcesRequests };
}

/**
 * Converts an object of type 'ClusterSpecTablespacesStoragePvcTemplateResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecTablespacesStoragePvcTemplateResources(obj: ClusterSpecTablespacesStoragePvcTemplateResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ClusterSpecTablespacesStoragePvcTemplateSelector
 */
export interface ClusterSpecTablespacesStoragePvcTemplateSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecTablespacesStoragePvcTemplateSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecTablespacesStoragePvcTemplateSelector(obj: ClusterSpecTablespacesStoragePvcTemplateSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecWalStoragePvcTemplateResourcesLimits
 */
export class ClusterSpecWalStoragePvcTemplateResourcesLimits {
  public static fromNumber(value: number): ClusterSpecWalStoragePvcTemplateResourcesLimits {
    return new ClusterSpecWalStoragePvcTemplateResourcesLimits(value);
  }
  public static fromString(value: string): ClusterSpecWalStoragePvcTemplateResourcesLimits {
    return new ClusterSpecWalStoragePvcTemplateResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecWalStoragePvcTemplateResourcesRequests
 */
export class ClusterSpecWalStoragePvcTemplateResourcesRequests {
  public static fromNumber(value: number): ClusterSpecWalStoragePvcTemplateResourcesRequests {
    return new ClusterSpecWalStoragePvcTemplateResourcesRequests(value);
  }
  public static fromString(value: string): ClusterSpecWalStoragePvcTemplateResourcesRequests {
    return new ClusterSpecWalStoragePvcTemplateResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions
 */
export interface ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions(obj: ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesLimits
 */
export class ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesLimits {
    return new ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesLimits {
    return new ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesRequests
 */
export class ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesRequests {
    return new ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesRequests {
    return new ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions(obj: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Standard object's metadata.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
 *
 * @schema ClusterSpecManagedServicesAdditionalServiceTemplateMetadata
 */
export interface ClusterSpecManagedServicesAdditionalServiceTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The name of the resource. Only supported for certain types
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateMetadata#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterSpecManagedServicesAdditionalServiceTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManagedServicesAdditionalServiceTemplateMetadata(obj: ClusterSpecManagedServicesAdditionalServiceTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specification of the desired behavior of the service.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec
 */
export interface ClusterSpecManagedServicesAdditionalServiceTemplateSpec {
  /**
   * allocateLoadBalancerNodePorts defines if NodePorts will be automatically
   * allocated for services with type LoadBalancer.  Default is "true". It
   * may be set to "false" if the cluster load-balancer does not rely on
   * NodePorts.  If the caller requests specific NodePorts (by specifying a
   * value), those requests will be respected, regardless of this field.
   * This field may only be set for services with type LoadBalancer and will
   * be cleared if the type is changed to any other type.
   *
   * @default true". It
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#allocateLoadBalancerNodePorts
   */
  readonly allocateLoadBalancerNodePorts?: boolean;

  /**
   * clusterIP is the IP address of the service and is usually assigned
   * randomly. If an address is specified manually, is in-range (as per
   * system configuration), and is not in use, it will be allocated to the
   * service; otherwise creation of the service will fail. This field may not
   * be changed through updates unless the type field is also being changed
   * to ExternalName (which requires this field to be blank) or the type
   * field is being changed from ExternalName (in which case this field may
   * optionally be specified, as describe above).  Valid values are "None",
   * empty string (""), or a valid IP address. Setting this to "None" makes a
   * "headless service" (no virtual IP), which is useful when direct endpoint
   * connections are preferred and proxying is not required.  Only applies to
   * types ClusterIP, NodePort, and LoadBalancer. If this field is specified
   * when creating a Service of type ExternalName, creation will fail. This
   * field will be wiped when updating a Service to type ExternalName.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#clusterIP
   */
  readonly clusterIp?: string;

  /**
   * ClusterIPs is a list of IP addresses assigned to this service, and are
   * usually assigned randomly.  If an address is specified manually, is
   * in-range (as per system configuration), and is not in use, it will be
   * allocated to the service; otherwise creation of the service will fail.
   * This field may not be changed through updates unless the type field is
   * also being changed to ExternalName (which requires this field to be
   * empty) or the type field is being changed from ExternalName (in which
   * case this field may optionally be specified, as describe above).  Valid
   * values are "None", empty string (""), or a valid IP address.  Setting
   * this to "None" makes a "headless service" (no virtual IP), which is
   * useful when direct endpoint connections are preferred and proxying is
   * not required.  Only applies to types ClusterIP, NodePort, and
   * LoadBalancer. If this field is specified when creating a Service of type
   * ExternalName, creation will fail. This field will be wiped when updating
   * a Service to type ExternalName.  If this field is not specified, it will
   * be initialized from the clusterIP field.  If this field is specified,
   * clients must ensure that clusterIPs[0] and clusterIP have the same
   * value.
   *
   * This field may hold a maximum of two entries (dual-stack IPs, in either order).
   * These IPs must correspond to the values of the ipFamilies field. Both
   * clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#clusterIPs
   */
  readonly clusterIPs?: string[];

  /**
   * externalIPs is a list of IP addresses for which nodes in the cluster
   * will also accept traffic for this service.  These IPs are not managed by
   * Kubernetes.  The user is responsible for ensuring that traffic arrives
   * at a node with this IP.  A common example is external load-balancers
   * that are not part of the Kubernetes system.
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#externalIPs
   */
  readonly externalIPs?: string[];

  /**
   * externalName is the external reference that discovery mechanisms will
   * return as an alias for this service (e.g. a DNS CNAME record). No
   * proxying will be involved.  Must be a lowercase RFC-1123 hostname
   * (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#externalName
   */
  readonly externalName?: string;

  /**
   * externalTrafficPolicy describes how nodes distribute service traffic they
   * receive on one of the Service's "externally-facing" addresses (NodePorts,
   * ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
   * the service in a way that assumes that external load balancers will take care
   * of balancing the service traffic between nodes, and so each node will deliver
   * traffic only to the node-local endpoints of the service, without masquerading
   * the client source IP. (Traffic mistakenly sent to a node with no endpoints will
   * be dropped.) The default value, "Cluster", uses the standard behavior of
   * routing to all endpoints evenly (possibly modified by topology and other
   * features). Note that traffic sent to an External IP or LoadBalancer IP from
   * within the cluster will always get "Cluster" semantics, but clients sending to
   * a NodePort from within the cluster may need to take traffic policy into account
   * when picking a node.
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#externalTrafficPolicy
   */
  readonly externalTrafficPolicy?: string;

  /**
   * healthCheckNodePort specifies the healthcheck nodePort for the service.
   * This only applies when type is set to LoadBalancer and
   * externalTrafficPolicy is set to Local. If a value is specified, is
   * in-range, and is not in use, it will be used.  If not specified, a value
   * will be automatically allocated.  External systems (e.g. load-balancers)
   * can use this port to determine if a given node holds endpoints for this
   * service or not.  If this field is specified when creating a Service
   * which does not need it, creation will fail. This field will be wiped
   * when updating a Service to no longer need it (e.g. changing type).
   * This field cannot be updated once set.
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#healthCheckNodePort
   */
  readonly healthCheckNodePort?: number;

  /**
   * InternalTrafficPolicy describes how nodes distribute service traffic they
   * receive on the ClusterIP. If set to "Local", the proxy will assume that pods
   * only want to talk to endpoints of the service on the same node as the pod,
   * dropping the traffic if there are no local endpoints. The default value,
   * "Cluster", uses the standard behavior of routing to all endpoints evenly
   * (possibly modified by topology and other features).
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#internalTrafficPolicy
   */
  readonly internalTrafficPolicy?: string;

  /**
   * IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
   * service. This field is usually assigned automatically based on cluster
   * configuration and the ipFamilyPolicy field. If this field is specified
   * manually, the requested family is available in the cluster,
   * and ipFamilyPolicy allows it, it will be used; otherwise creation of
   * the service will fail. This field is conditionally mutable: it allows
   * for adding or removing a secondary IP family, but it does not allow
   * changing the primary IP family of the Service. Valid values are "IPv4"
   * and "IPv6".  This field only applies to Services of types ClusterIP,
   * NodePort, and LoadBalancer, and does apply to "headless" services.
   * This field will be wiped when updating a Service to type ExternalName.
   *
   * This field may hold a maximum of two entries (dual-stack families, in
   * either order).  These families must correspond to the values of the
   * clusterIPs field, if specified. Both clusterIPs and ipFamilies are
   * governed by the ipFamilyPolicy field.
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#ipFamilies
   */
  readonly ipFamilies?: string[];

  /**
   * IPFamilyPolicy represents the dual-stack-ness requested or required by
   * this Service. If there is no value provided, then this field will be set
   * to SingleStack. Services can be "SingleStack" (a single IP family),
   * "PreferDualStack" (two IP families on dual-stack configured clusters or
   * a single IP family on single-stack clusters), or "RequireDualStack"
   * (two IP families on dual-stack configured clusters, otherwise fail). The
   * ipFamilies and clusterIPs fields depend on the value of this field. This
   * field will be wiped when updating a service to type ExternalName.
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#ipFamilyPolicy
   */
  readonly ipFamilyPolicy?: string;

  /**
   * loadBalancerClass is the class of the load balancer implementation this Service belongs to.
   * If specified, the value of this field must be a label-style identifier, with an optional prefix,
   * e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
   * This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
   * balancer implementation is used, today this is typically done through the cloud provider integration,
   * but should apply for any default implementation. If set, it is assumed that a load balancer
   * implementation is watching for Services with a matching class. Any default load balancer
   * implementation (e.g. cloud providers) should ignore Services that set this field.
   * This field can only be set when creating or updating a Service to type 'LoadBalancer'.
   * Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#loadBalancerClass
   */
  readonly loadBalancerClass?: string;

  /**
   * Only applies to Service Type: LoadBalancer.
   * This feature depends on whether the underlying cloud-provider supports specifying
   * the loadBalancerIP when a load balancer is created.
   * This field will be ignored if the cloud-provider does not support the feature.
   * Deprecated: This field was under-specified and its meaning varies across implementations.
   * Using it is non-portable and it may not support dual-stack.
   * Users are encouraged to use implementation-specific annotations when available.
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#loadBalancerIP
   */
  readonly loadBalancerIp?: string;

  /**
   * If specified and supported by the platform, this will restrict traffic through the cloud-provider
   * load-balancer will be restricted to the specified client IPs. This field will be ignored if the
   * cloud-provider does not support the feature."
   * More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#loadBalancerSourceRanges
   */
  readonly loadBalancerSourceRanges?: string[];

  /**
   * The list of ports that are exposed by this service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#ports
   */
  readonly ports?: ClusterSpecManagedServicesAdditionalServiceTemplateSpecPorts[];

  /**
   * publishNotReadyAddresses indicates that any agent which deals with endpoints for this
   * Service should disregard any indications of ready/not-ready.
   * The primary use case for setting this field is for a StatefulSet's Headless Service to
   * propagate SRV DNS records for its Pods for the purpose of peer discovery.
   * The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
   * Services interpret this to mean that all endpoints are considered "ready" even if the
   * Pods themselves are not. Agents which consume only Kubernetes generated endpoints
   * through the Endpoints or EndpointSlice resources can safely assume this behavior.
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#publishNotReadyAddresses
   */
  readonly publishNotReadyAddresses?: boolean;

  /**
   * Route service traffic to pods with label keys and values matching this
   * selector. If empty or not present, the service is assumed to have an
   * external process managing its endpoints, which Kubernetes will not
   * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
   * Ignored if type is ExternalName.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#selector
   */
  readonly selector?: { [key: string]: string };

  /**
   * Supports "ClientIP" and "None". Used to maintain session affinity.
   * Enable client IP based session affinity.
   * Must be ClientIP or None.
   * Defaults to None.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @default None.
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#sessionAffinity
   */
  readonly sessionAffinity?: string;

  /**
   * sessionAffinityConfig contains the configurations of session affinity.
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#sessionAffinityConfig
   */
  readonly sessionAffinityConfig?: ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig;

  /**
   * TrafficDistribution offers a way to express preferences for how traffic
   * is distributed to Service endpoints. Implementations can use this field
   * as a hint, but are not required to guarantee strict adherence. If the
   * field is not set, the implementation will apply its default routing
   * strategy. If set to "PreferClose", implementations should prioritize
   * endpoints that are in the same zone.
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#trafficDistribution
   */
  readonly trafficDistribution?: string;

  /**
   * type determines how the Service is exposed. Defaults to ClusterIP. Valid
   * options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
   * "ClusterIP" allocates a cluster-internal IP address for load-balancing
   * to endpoints. Endpoints are determined by the selector or if that is not
   * specified, by manual construction of an Endpoints object or
   * EndpointSlice objects. If clusterIP is "None", no virtual IP is
   * allocated and the endpoints are published as a set of endpoints rather
   * than a virtual IP.
   * "NodePort" builds on ClusterIP and allocates a port on every node which
   * routes to the same endpoints as the clusterIP.
   * "LoadBalancer" builds on NodePort and creates an external load-balancer
   * (if supported in the current cloud) which routes to the same endpoints
   * as the clusterIP.
   * "ExternalName" aliases this service to the specified externalName.
   * Several other fields do not apply to ExternalName services.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
   *
   * @default ClusterIP. Valid
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpec#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ClusterSpecManagedServicesAdditionalServiceTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManagedServicesAdditionalServiceTemplateSpec(obj: ClusterSpecManagedServicesAdditionalServiceTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocateLoadBalancerNodePorts': obj.allocateLoadBalancerNodePorts,
    'clusterIP': obj.clusterIp,
    'clusterIPs': obj.clusterIPs?.map(y => y),
    'externalIPs': obj.externalIPs?.map(y => y),
    'externalName': obj.externalName,
    'externalTrafficPolicy': obj.externalTrafficPolicy,
    'healthCheckNodePort': obj.healthCheckNodePort,
    'internalTrafficPolicy': obj.internalTrafficPolicy,
    'ipFamilies': obj.ipFamilies?.map(y => y),
    'ipFamilyPolicy': obj.ipFamilyPolicy,
    'loadBalancerClass': obj.loadBalancerClass,
    'loadBalancerIP': obj.loadBalancerIp,
    'loadBalancerSourceRanges': obj.loadBalancerSourceRanges?.map(y => y),
    'ports': obj.ports?.map(y => toJson_ClusterSpecManagedServicesAdditionalServiceTemplateSpecPorts(y)),
    'publishNotReadyAddresses': obj.publishNotReadyAddresses,
    'selector': ((obj.selector) === undefined) ? undefined : (Object.entries(obj.selector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sessionAffinity': obj.sessionAffinity,
    'sessionAffinityConfig': toJson_ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig(obj.sessionAffinityConfig),
    'trafficDistribution': obj.trafficDistribution,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions(obj: ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef(obj: ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef(obj: ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecTablespacesStoragePvcTemplateResourcesLimits
 */
export class ClusterSpecTablespacesStoragePvcTemplateResourcesLimits {
  public static fromNumber(value: number): ClusterSpecTablespacesStoragePvcTemplateResourcesLimits {
    return new ClusterSpecTablespacesStoragePvcTemplateResourcesLimits(value);
  }
  public static fromString(value: string): ClusterSpecTablespacesStoragePvcTemplateResourcesLimits {
    return new ClusterSpecTablespacesStoragePvcTemplateResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecTablespacesStoragePvcTemplateResourcesRequests
 */
export class ClusterSpecTablespacesStoragePvcTemplateResourcesRequests {
  public static fromNumber(value: number): ClusterSpecTablespacesStoragePvcTemplateResourcesRequests {
    return new ClusterSpecTablespacesStoragePvcTemplateResourcesRequests(value);
  }
  public static fromString(value: string): ClusterSpecTablespacesStoragePvcTemplateResourcesRequests {
    return new ClusterSpecTablespacesStoragePvcTemplateResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions
 */
export interface ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions(obj: ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServicePort contains information on service's port.
 *
 * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpecPorts
 */
export interface ClusterSpecManagedServicesAdditionalServiceTemplateSpecPorts {
  /**
   * The application protocol for this port.
   * This is used as a hint for implementations to offer richer behavior for protocols that they understand.
   * This field follows standard Kubernetes label syntax.
   * Valid values are either:
   *
   * * Un-prefixed protocol names - reserved for IANA standard service names (as per
   * RFC-6335 and https://www.iana.org/assignments/service-names).
   *
   * * Kubernetes-defined prefixed names:
   * * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
   * * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
   * * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
   *
   * * Other protocols should use implementation-defined prefixed names such as
   * mycompany.com/my-custom-protocol.
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpecPorts#appProtocol
   */
  readonly appProtocol?: string;

  /**
   * The name of this port within the service. This must be a DNS_LABEL.
   * All ports within a ServiceSpec must have unique names. When considering
   * the endpoints for a Service, this must match the 'name' field in the
   * EndpointPort.
   * Optional if only one ServicePort is defined on this service.
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpecPorts#name
   */
  readonly name?: string;

  /**
   * The port on each node on which this service is exposed when type is
   * NodePort or LoadBalancer.  Usually assigned by the system. If a value is
   * specified, in-range, and not in use it will be used, otherwise the
   * operation will fail.  If not specified, a port will be allocated if this
   * Service requires one.  If this field is specified when creating a
   * Service which does not need it, creation will fail. This field will be
   * wiped when updating a Service to no longer need it (e.g. changing type
   * from NodePort to ClusterIP).
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpecPorts#nodePort
   */
  readonly nodePort?: number;

  /**
   * The port that will be exposed by this service.
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpecPorts#port
   */
  readonly port: number;

  /**
   * The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
   * Default is TCP.
   *
   * @default TCP.
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpecPorts#protocol
   */
  readonly protocol?: string;

  /**
   * Number or name of the port to access on the pods targeted by the service.
   * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   * If this is a string, it will be looked up as a named port in the
   * target Pod's container ports. If this is not specified, the value
   * of the 'port' field is used (an identity map).
   * This field is ignored for services with clusterIP=None, and should be
   * omitted or set equal to the 'port' field.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpecPorts#targetPort
   */
  readonly targetPort?: ClusterSpecManagedServicesAdditionalServiceTemplateSpecPortsTargetPort;
}

/**
 * Converts an object of type 'ClusterSpecManagedServicesAdditionalServiceTemplateSpecPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManagedServicesAdditionalServiceTemplateSpecPorts(obj: ClusterSpecManagedServicesAdditionalServiceTemplateSpecPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appProtocol': obj.appProtocol,
    'name': obj.name,
    'nodePort': obj.nodePort,
    'port': obj.port,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sessionAffinityConfig contains the configurations of session affinity.
 *
 * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig
 */
export interface ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig {
  /**
   * clientIP contains the configurations of Client IP based session affinity.
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig#clientIP
   */
  readonly clientIp?: ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp;
}

/**
 * Converts an object of type 'ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig(obj: ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientIP': toJson_ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp(obj.clientIp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the pods targeted by the service.
 * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 * If this is a string, it will be looked up as a named port in the
 * target Pod's container ports. If this is not specified, the value
 * of the 'port' field is used (an identity map).
 * This field is ignored for services with clusterIP=None, and should be
 * omitted or set equal to the 'port' field.
 * More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
 *
 * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpecPortsTargetPort
 */
export class ClusterSpecManagedServicesAdditionalServiceTemplateSpecPortsTargetPort {
  public static fromNumber(value: number): ClusterSpecManagedServicesAdditionalServiceTemplateSpecPortsTargetPort {
    return new ClusterSpecManagedServicesAdditionalServiceTemplateSpecPortsTargetPort(value);
  }
  public static fromString(value: string): ClusterSpecManagedServicesAdditionalServiceTemplateSpecPortsTargetPort {
    return new ClusterSpecManagedServicesAdditionalServiceTemplateSpecPortsTargetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * clientIP contains the configurations of Client IP based session affinity.
 *
 * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp
 */
export interface ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp {
  /**
   * timeoutSeconds specifies the seconds of ClientIP type session sticky time.
   * The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
   * Default value is 10800(for 3 hours).
   *
   * @schema ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp(obj: ClusterSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * ScheduledBackup is the Schema for the scheduledbackups API
 *
 * @schema ScheduledBackup
 */
export class ScheduledBackup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ScheduledBackup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'postgresql.cnpg.io/v1',
    kind: 'ScheduledBackup',
  }

  /**
   * Renders a Kubernetes manifest for "ScheduledBackup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ScheduledBackupProps): any {
    return {
      ...ScheduledBackup.GVK,
      ...toJson_ScheduledBackupProps(props),
    };
  }

  /**
   * Defines a "ScheduledBackup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ScheduledBackupProps) {
    super(scope, id, {
      ...ScheduledBackup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ScheduledBackup.GVK,
      ...toJson_ScheduledBackupProps(resolved),
    };
  }
}

/**
 * ScheduledBackup is the Schema for the scheduledbackups API
 *
 * @schema ScheduledBackup
 */
export interface ScheduledBackupProps {
  /**
   * @schema ScheduledBackup#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Specification of the desired behavior of the ScheduledBackup.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema ScheduledBackup#spec
   */
  readonly spec: ScheduledBackupSpec;
}

/**
 * Converts an object of type 'ScheduledBackupProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduledBackupProps(obj: ScheduledBackupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ScheduledBackupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specification of the desired behavior of the ScheduledBackup.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema ScheduledBackupSpec
 */
export interface ScheduledBackupSpec {
  /**
   * Indicates which ownerReference should be put inside the created backup resources.<br />
   * - none: no owner reference for created backup objects (same behavior as before the field was introduced)<br />
   * - self: sets the Scheduled backup object as owner of the backup<br />
   * - cluster: set the cluster as owner of the backup<br />
   *
   * @schema ScheduledBackupSpec#backupOwnerReference
   */
  readonly backupOwnerReference?: ScheduledBackupSpecBackupOwnerReference;

  /**
   * The cluster to backup
   *
   * @schema ScheduledBackupSpec#cluster
   */
  readonly cluster: ScheduledBackupSpecCluster;

  /**
   * If the first backup has to be immediately start after creation or not
   *
   * @schema ScheduledBackupSpec#immediate
   */
  readonly immediate?: boolean;

  /**
   * The backup method to be used, possible options are `barmanObjectStore`,
   * `volumeSnapshot` or `plugin`. Defaults to: `barmanObjectStore`.
   *
   * @default barmanObjectStore`.
   * @schema ScheduledBackupSpec#method
   */
  readonly method?: ScheduledBackupSpecMethod;

  /**
   * Whether the default type of backup with volume snapshots is
   * online/hot (`true`, default) or offline/cold (`false`)
   * Overrides the default setting specified in the cluster field '.spec.backup.volumeSnapshot.online'
   *
   * @schema ScheduledBackupSpec#online
   */
  readonly online?: boolean;

  /**
   * Configuration parameters to control the online/hot backup with volume snapshots
   * Overrides the default settings specified in the cluster '.backup.volumeSnapshot.onlineConfiguration' stanza
   *
   * @schema ScheduledBackupSpec#onlineConfiguration
   */
  readonly onlineConfiguration?: ScheduledBackupSpecOnlineConfiguration;

  /**
   * Configuration parameters passed to the plugin managing this backup
   *
   * @schema ScheduledBackupSpec#pluginConfiguration
   */
  readonly pluginConfiguration?: ScheduledBackupSpecPluginConfiguration;

  /**
   * The schedule does not follow the same format used in Kubernetes CronJobs
   * as it includes an additional seconds specifier,
   * see https://pkg.go.dev/github.com/robfig/cron#hdr-CRON_Expression_Format
   *
   * @schema ScheduledBackupSpec#schedule
   */
  readonly schedule: string;

  /**
   * If this backup is suspended or not
   *
   * @schema ScheduledBackupSpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * The policy to decide which instance should perform this backup. If empty,
   * it defaults to `cluster.spec.backup.target`.
   * Available options are empty string, `primary` and `prefer-standby`.
   * `primary` to have backups run always on primary instances,
   * `prefer-standby` to have backups run preferably on the most updated
   * standby, if available.
   *
   * @schema ScheduledBackupSpec#target
   */
  readonly target?: ScheduledBackupSpecTarget;
}

/**
 * Converts an object of type 'ScheduledBackupSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduledBackupSpec(obj: ScheduledBackupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupOwnerReference': obj.backupOwnerReference,
    'cluster': toJson_ScheduledBackupSpecCluster(obj.cluster),
    'immediate': obj.immediate,
    'method': obj.method,
    'online': obj.online,
    'onlineConfiguration': toJson_ScheduledBackupSpecOnlineConfiguration(obj.onlineConfiguration),
    'pluginConfiguration': toJson_ScheduledBackupSpecPluginConfiguration(obj.pluginConfiguration),
    'schedule': obj.schedule,
    'suspend': obj.suspend,
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Indicates which ownerReference should be put inside the created backup resources.<br />
 * - none: no owner reference for created backup objects (same behavior as before the field was introduced)<br />
 * - self: sets the Scheduled backup object as owner of the backup<br />
 * - cluster: set the cluster as owner of the backup<br />
 *
 * @schema ScheduledBackupSpecBackupOwnerReference
 */
export enum ScheduledBackupSpecBackupOwnerReference {
  /** none */
  NONE = "none",
  /** self */
  SELF = "self",
  /** cluster */
  CLUSTER = "cluster",
}

/**
 * The cluster to backup
 *
 * @schema ScheduledBackupSpecCluster
 */
export interface ScheduledBackupSpecCluster {
  /**
   * Name of the referent.
   *
   * @schema ScheduledBackupSpecCluster#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ScheduledBackupSpecCluster' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduledBackupSpecCluster(obj: ScheduledBackupSpecCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The backup method to be used, possible options are `barmanObjectStore`,
 * `volumeSnapshot` or `plugin`. Defaults to: `barmanObjectStore`.
 *
 * @default barmanObjectStore`.
 * @schema ScheduledBackupSpecMethod
 */
export enum ScheduledBackupSpecMethod {
  /** barmanObjectStore */
  BARMAN_OBJECT_STORE = "barmanObjectStore",
  /** volumeSnapshot */
  VOLUME_SNAPSHOT = "volumeSnapshot",
  /** plugin */
  PLUGIN = "plugin",
}

/**
 * Configuration parameters to control the online/hot backup with volume snapshots
 * Overrides the default settings specified in the cluster '.backup.volumeSnapshot.onlineConfiguration' stanza
 *
 * @schema ScheduledBackupSpecOnlineConfiguration
 */
export interface ScheduledBackupSpecOnlineConfiguration {
  /**
   * Control whether the I/O workload for the backup initial checkpoint will
   * be limited, according to the `checkpoint_completion_target` setting on
   * the PostgreSQL server. If set to true, an immediate checkpoint will be
   * used, meaning PostgreSQL will complete the checkpoint as soon as
   * possible. `false` by default.
   *
   * @schema ScheduledBackupSpecOnlineConfiguration#immediateCheckpoint
   */
  readonly immediateCheckpoint?: boolean;

  /**
   * If false, the function will return immediately after the backup is completed,
   * without waiting for WAL to be archived.
   * This behavior is only useful with backup software that independently monitors WAL archiving.
   * Otherwise, WAL required to make the backup consistent might be missing and make the backup useless.
   * By default, or when this parameter is true, pg_backup_stop will wait for WAL to be archived when archiving is
   * enabled.
   * On a standby, this means that it will wait only when archive_mode = always.
   * If write activity on the primary is low, it may be useful to run pg_switch_wal on the primary in order to trigger
   * an immediate segment switch.
   *
   * @schema ScheduledBackupSpecOnlineConfiguration#waitForArchive
   */
  readonly waitForArchive?: boolean;
}

/**
 * Converts an object of type 'ScheduledBackupSpecOnlineConfiguration' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduledBackupSpecOnlineConfiguration(obj: ScheduledBackupSpecOnlineConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'immediateCheckpoint': obj.immediateCheckpoint,
    'waitForArchive': obj.waitForArchive,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration parameters passed to the plugin managing this backup
 *
 * @schema ScheduledBackupSpecPluginConfiguration
 */
export interface ScheduledBackupSpecPluginConfiguration {
  /**
   * Name is the name of the plugin managing this backup
   *
   * @schema ScheduledBackupSpecPluginConfiguration#name
   */
  readonly name: string;

  /**
   * Parameters are the configuration parameters passed to the backup
   * plugin for this backup
   *
   * @schema ScheduledBackupSpecPluginConfiguration#parameters
   */
  readonly parameters?: { [key: string]: string };
}

/**
 * Converts an object of type 'ScheduledBackupSpecPluginConfiguration' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduledBackupSpecPluginConfiguration(obj: ScheduledBackupSpecPluginConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The policy to decide which instance should perform this backup. If empty,
 * it defaults to `cluster.spec.backup.target`.
 * Available options are empty string, `primary` and `prefer-standby`.
 * `primary` to have backups run always on primary instances,
 * `prefer-standby` to have backups run preferably on the most updated
 * standby, if available.
 *
 * @schema ScheduledBackupSpecTarget
 */
export enum ScheduledBackupSpecTarget {
  /** primary */
  PRIMARY = "primary",
  /** prefer-standby */
  PREFER_HYPHEN_STANDBY = "prefer-standby",
}

