// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ClusterResourceBinding represents a binding of a kubernetes resource with a ClusterPropagationPolicy.
 *
 * @schema ClusterResourceBinding
 */
export class ClusterResourceBinding extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterResourceBinding"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'work.karmada.io/v1alpha1',
    kind: 'ClusterResourceBinding',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterResourceBinding".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterResourceBindingProps): any {
    return {
      ...ClusterResourceBinding.GVK,
      ...toJson_ClusterResourceBindingProps(props),
    };
  }

  /**
   * Defines a "ClusterResourceBinding" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterResourceBindingProps) {
    super(scope, id, {
      ...ClusterResourceBinding.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterResourceBinding.GVK,
      ...toJson_ClusterResourceBindingProps(resolved),
    };
  }
}

/**
 * ClusterResourceBinding represents a binding of a kubernetes resource with a ClusterPropagationPolicy.
 *
 * @schema ClusterResourceBinding
 */
export interface ClusterResourceBindingProps {
  /**
   * @schema ClusterResourceBinding#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec represents the desired behavior.
   *
   * @schema ClusterResourceBinding#spec
   */
  readonly spec: ClusterResourceBindingSpec;
}

/**
 * Converts an object of type 'ClusterResourceBindingProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingProps(obj: ClusterResourceBindingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterResourceBindingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec represents the desired behavior.
 *
 * @schema ClusterResourceBindingSpec
 */
export interface ClusterResourceBindingSpec {
  /**
   * Clusters represents target member clusters where the resource to be deployed.
   *
   * @schema ClusterResourceBindingSpec#clusters
   */
  readonly clusters?: ClusterResourceBindingSpecClusters[];

  /**
   * Resource represents the Kubernetes resource to be propagated.
   *
   * @schema ClusterResourceBindingSpec#resource
   */
  readonly resource: ClusterResourceBindingSpecResource;
}

/**
 * Converts an object of type 'ClusterResourceBindingSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingSpec(obj: ClusterResourceBindingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusters': obj.clusters?.map(y => toJson_ClusterResourceBindingSpecClusters(y)),
    'resource': toJson_ClusterResourceBindingSpecResource(obj.resource),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetCluster represents the identifier of a member cluster.
 *
 * @schema ClusterResourceBindingSpecClusters
 */
export interface ClusterResourceBindingSpecClusters {
  /**
   * Name of target cluster.
   *
   * @schema ClusterResourceBindingSpecClusters#name
   */
  readonly name: string;

  /**
   * Replicas in target cluster
   *
   * @schema ClusterResourceBindingSpecClusters#replicas
   */
  readonly replicas?: number;
}

/**
 * Converts an object of type 'ClusterResourceBindingSpecClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingSpecClusters(obj: ClusterResourceBindingSpecClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'replicas': obj.replicas,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resource represents the Kubernetes resource to be propagated.
 *
 * @schema ClusterResourceBindingSpecResource
 */
export interface ClusterResourceBindingSpecResource {
  /**
   * APIVersion represents the API version of the referent.
   *
   * @schema ClusterResourceBindingSpecResource#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind represents the Kind of the referent.
   *
   * @schema ClusterResourceBindingSpecResource#kind
   */
  readonly kind: string;

  /**
   * Name represents the name of the referent.
   *
   * @schema ClusterResourceBindingSpecResource#name
   */
  readonly name: string;

  /**
   * Namespace represents the namespace for the referent.
   * For non-namespace scoped resources(e.g. 'ClusterRole')，do not need specify Namespace,
   * and for namespace scoped resources, Namespace is required.
   * If Namespace is not specified, means the resource is non-namespace scoped.
   *
   * @schema ClusterResourceBindingSpecResource#namespace
   */
  readonly namespace?: string;

  /**
   * Replicas represents the replica number of the referencing resource.
   *
   * @schema ClusterResourceBindingSpecResource#replicas
   */
  readonly replicas?: number;

  /**
   * ReplicaResourceRequirements represents the resources required by each replica.
   *
   * @schema ClusterResourceBindingSpecResource#resourcePerReplicas
   */
  readonly resourcePerReplicas?: { [key: string]: ClusterResourceBindingSpecResourceResourcePerReplicas };

  /**
   * ResourceVersion represents the internal version of the referenced object, that can be used by clients to
   * determine when object has changed.
   *
   * @schema ClusterResourceBindingSpecResource#resourceVersion
   */
  readonly resourceVersion?: string;
}

/**
 * Converts an object of type 'ClusterResourceBindingSpecResource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingSpecResource(obj: ClusterResourceBindingSpecResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'replicas': obj.replicas,
    'resourcePerReplicas': ((obj.resourcePerReplicas) === undefined) ? undefined : (Object.entries(obj.resourcePerReplicas).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'resourceVersion': obj.resourceVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterResourceBindingSpecResourceResourcePerReplicas
 */
export class ClusterResourceBindingSpecResourceResourcePerReplicas {
  public static fromNumber(value: number): ClusterResourceBindingSpecResourceResourcePerReplicas {
    return new ClusterResourceBindingSpecResourceResourcePerReplicas(value);
  }
  public static fromString(value: string): ClusterResourceBindingSpecResourceResourcePerReplicas {
    return new ClusterResourceBindingSpecResourceResourcePerReplicas(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * ClusterResourceBinding represents a binding of a kubernetes resource with a ClusterPropagationPolicy.
 *
 * @schema ClusterResourceBindingV1Alpha2
 */
export class ClusterResourceBindingV1Alpha2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterResourceBindingV1Alpha2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'work.karmada.io/v1alpha2',
    kind: 'ClusterResourceBinding',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterResourceBindingV1Alpha2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterResourceBindingV1Alpha2Props): any {
    return {
      ...ClusterResourceBindingV1Alpha2.GVK,
      ...toJson_ClusterResourceBindingV1Alpha2Props(props),
    };
  }

  /**
   * Defines a "ClusterResourceBindingV1Alpha2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterResourceBindingV1Alpha2Props) {
    super(scope, id, {
      ...ClusterResourceBindingV1Alpha2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterResourceBindingV1Alpha2.GVK,
      ...toJson_ClusterResourceBindingV1Alpha2Props(resolved),
    };
  }
}

/**
 * ClusterResourceBinding represents a binding of a kubernetes resource with a ClusterPropagationPolicy.
 *
 * @schema ClusterResourceBindingV1Alpha2
 */
export interface ClusterResourceBindingV1Alpha2Props {
  /**
   * @schema ClusterResourceBindingV1Alpha2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec represents the desired behavior.
   *
   * @schema ClusterResourceBindingV1Alpha2#spec
   */
  readonly spec: ClusterResourceBindingV1Alpha2Spec;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2Props(obj: ClusterResourceBindingV1Alpha2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterResourceBindingV1Alpha2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec represents the desired behavior.
 *
 * @schema ClusterResourceBindingV1Alpha2Spec
 */
export interface ClusterResourceBindingV1Alpha2Spec {
  /**
   * Clusters represents target member clusters where the resource to be deployed.
   *
   * @schema ClusterResourceBindingV1Alpha2Spec#clusters
   */
  readonly clusters?: ClusterResourceBindingV1Alpha2SpecClusters[];

  /**
   * Components represents the requirements of multiple pod templates of the referencing resource.
   * It is designed to support workloads that consist of multiple pod templates,
   * such as distributed training jobs (e.g., PyTorch, TensorFlow) and big data workloads (e.g., FlinkDeployment),
   * where each workload is composed of more than one pod template. It is also capable of representing
   * single-component workloads, such as Deployment.
   *
   * Note: This field is intended to replace the legacy ReplicaRequirements and Replicas fields above.
   * It is only populated when the MultiplePodTemplatesScheduling feature gate is enabled.
   *
   * @schema ClusterResourceBindingV1Alpha2Spec#components
   */
  readonly components?: ClusterResourceBindingV1Alpha2SpecComponents[];

  /**
   * ConflictResolution declares how potential conflict should be handled when
   * a resource that is being propagated already exists in the target cluster.
   *
   * It defaults to "Abort" which means stop propagating to avoid unexpected
   * overwrites. The "Overwrite" might be useful when migrating legacy cluster
   * resources to Karmada, in which case conflict is predictable and can be
   * instructed to Karmada take over the resource by overwriting.
   *
   * @schema ClusterResourceBindingV1Alpha2Spec#conflictResolution
   */
  readonly conflictResolution?: ClusterResourceBindingV1Alpha2SpecConflictResolution;

  /**
   * Failover indicates how Karmada migrates applications in case of failures.
   * It inherits directly from the associated PropagationPolicy(or ClusterPropagationPolicy).
   *
   * @schema ClusterResourceBindingV1Alpha2Spec#failover
   */
  readonly failover?: ClusterResourceBindingV1Alpha2SpecFailover;

  /**
   * GracefulEvictionTasks holds the eviction tasks that are expected to perform
   * the eviction in a graceful way.
   * The intended workflow is:
   * 1. Once the controller(such as 'taint-manager') decided to evict the resource that
   * is referenced by current ResourceBinding or ClusterResourceBinding from a target
   * cluster, it removes(or scale down the replicas) the target from Clusters(.spec.Clusters)
   * and builds a graceful eviction task.
   * 2. The scheduler may perform a re-scheduler and probably select a substitute cluster
   * to take over the evicting workload(resource).
   * 3. The graceful eviction controller takes care of the graceful eviction tasks and
   * performs the final removal after the workload(resource) is available on the substitute
   * cluster or exceed the grace termination period(defaults to 10 minutes).
   *
   * @schema ClusterResourceBindingV1Alpha2Spec#gracefulEvictionTasks
   */
  readonly gracefulEvictionTasks?: ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks[];

  /**
   * Placement represents the rule for select clusters to propagate resources.
   *
   * @schema ClusterResourceBindingV1Alpha2Spec#placement
   */
  readonly placement?: ClusterResourceBindingV1Alpha2SpecPlacement;

  /**
   * PreserveResourcesOnDeletion controls whether resources should be preserved on the
   * member clusters when the binding object is deleted.
   * If set to true, resources will be preserved on the member clusters.
   * Default is false, which means resources will be deleted along with the binding object.
   * This setting applies to all Work objects created under this binding object.
   *
   * @default false, which means resources will be deleted along with the binding object.
   * @schema ClusterResourceBindingV1Alpha2Spec#preserveResourcesOnDeletion
   */
  readonly preserveResourcesOnDeletion?: boolean;

  /**
   * PropagateDeps tells if relevant resources should be propagated automatically.
   * It is inherited from PropagationPolicy or ClusterPropagationPolicy.
   * default false.
   *
   * @schema ClusterResourceBindingV1Alpha2Spec#propagateDeps
   */
  readonly propagateDeps?: boolean;

  /**
   * ReplicaRequirements represents the resource and scheduling requirements for each replica.
   *
   * @schema ClusterResourceBindingV1Alpha2Spec#replicaRequirements
   */
  readonly replicaRequirements?: ClusterResourceBindingV1Alpha2SpecReplicaRequirements;

  /**
   * Replicas represents the replica number of the referencing resource.
   *
   * @schema ClusterResourceBindingV1Alpha2Spec#replicas
   */
  readonly replicas?: number;

  /**
   * RequiredBy represents the list of Bindings that depend on the referencing resource.
   *
   * @schema ClusterResourceBindingV1Alpha2Spec#requiredBy
   */
  readonly requiredBy?: ClusterResourceBindingV1Alpha2SpecRequiredBy[];

  /**
   * RescheduleTriggeredAt is a timestamp representing when the referenced resource is triggered rescheduling.
   * When this field is updated, it means a rescheduling is manually triggered by user, and the expected behavior
   * of this action is to do a complete recalculation without referring to last scheduling results.
   * It works with the status.lastScheduledTime field, and only when this timestamp is later than timestamp in
   * status.lastScheduledTime will the rescheduling actually execute, otherwise, ignored.
   *
   * It is represented in RFC3339 form (like '2006-01-02T15:04:05Z') and is in UTC.
   *
   * @schema ClusterResourceBindingV1Alpha2Spec#rescheduleTriggeredAt
   */
  readonly rescheduleTriggeredAt?: Date;

  /**
   * Resource represents the Kubernetes resource to be propagated.
   *
   * @schema ClusterResourceBindingV1Alpha2Spec#resource
   */
  readonly resource: ClusterResourceBindingV1Alpha2SpecResource;

  /**
   * SchedulePriority represents the scheduling priority assigned to workloads.
   *
   * @schema ClusterResourceBindingV1Alpha2Spec#schedulePriority
   */
  readonly schedulePriority?: ClusterResourceBindingV1Alpha2SpecSchedulePriority;

  /**
   * SchedulerName represents which scheduler to proceed the scheduling.
   * It inherits directly from the associated PropagationPolicy(or ClusterPropagationPolicy).
   *
   * @schema ClusterResourceBindingV1Alpha2Spec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Suspension declares the policy for suspending different aspects of propagation.
   * nil means no suspension. no default values.
   *
   * @schema ClusterResourceBindingV1Alpha2Spec#suspension
   */
  readonly suspension?: ClusterResourceBindingV1Alpha2SpecSuspension;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2Spec(obj: ClusterResourceBindingV1Alpha2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusters': obj.clusters?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecClusters(y)),
    'components': obj.components?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecComponents(y)),
    'conflictResolution': obj.conflictResolution,
    'failover': toJson_ClusterResourceBindingV1Alpha2SpecFailover(obj.failover),
    'gracefulEvictionTasks': obj.gracefulEvictionTasks?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks(y)),
    'placement': toJson_ClusterResourceBindingV1Alpha2SpecPlacement(obj.placement),
    'preserveResourcesOnDeletion': obj.preserveResourcesOnDeletion,
    'propagateDeps': obj.propagateDeps,
    'replicaRequirements': toJson_ClusterResourceBindingV1Alpha2SpecReplicaRequirements(obj.replicaRequirements),
    'replicas': obj.replicas,
    'requiredBy': obj.requiredBy?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecRequiredBy(y)),
    'rescheduleTriggeredAt': obj.rescheduleTriggeredAt?.toISOString(),
    'resource': toJson_ClusterResourceBindingV1Alpha2SpecResource(obj.resource),
    'schedulePriority': toJson_ClusterResourceBindingV1Alpha2SpecSchedulePriority(obj.schedulePriority),
    'schedulerName': obj.schedulerName,
    'suspension': toJson_ClusterResourceBindingV1Alpha2SpecSuspension(obj.suspension),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetCluster represents the identifier of a member cluster.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecClusters
 */
export interface ClusterResourceBindingV1Alpha2SpecClusters {
  /**
   * Name of target cluster.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecClusters#name
   */
  readonly name: string;

  /**
   * Replicas in target cluster
   *
   * @schema ClusterResourceBindingV1Alpha2SpecClusters#replicas
   */
  readonly replicas?: number;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecClusters(obj: ClusterResourceBindingV1Alpha2SpecClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'replicas': obj.replicas,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Component represents the requirements for a specific component.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecComponents
 */
export interface ClusterResourceBindingV1Alpha2SpecComponents {
  /**
   * Name of this component.
   * It is required when the resource contains multiple components to ensure proper identification,
   * and must also be unique within the same resource.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponents#name
   */
  readonly name: string;

  /**
   * ReplicaRequirements represents the resource and scheduling requirements for each replica.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponents#replicaRequirements
   */
  readonly replicaRequirements?: ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirements;

  /**
   * Replicas represents the replica number of the resource's component.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponents#replicas
   */
  readonly replicas: number;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecComponents' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecComponents(obj: ClusterResourceBindingV1Alpha2SpecComponents | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'replicaRequirements': toJson_ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirements(obj.replicaRequirements),
    'replicas': obj.replicas,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConflictResolution declares how potential conflict should be handled when
 * a resource that is being propagated already exists in the target cluster.
 *
 * It defaults to "Abort" which means stop propagating to avoid unexpected
 * overwrites. The "Overwrite" might be useful when migrating legacy cluster
 * resources to Karmada, in which case conflict is predictable and can be
 * instructed to Karmada take over the resource by overwriting.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecConflictResolution
 */
export enum ClusterResourceBindingV1Alpha2SpecConflictResolution {
  /** Abort */
  ABORT = "Abort",
  /** Overwrite */
  OVERWRITE = "Overwrite",
}

/**
 * Failover indicates how Karmada migrates applications in case of failures.
 * It inherits directly from the associated PropagationPolicy(or ClusterPropagationPolicy).
 *
 * @schema ClusterResourceBindingV1Alpha2SpecFailover
 */
export interface ClusterResourceBindingV1Alpha2SpecFailover {
  /**
   * Application indicates failover behaviors in case of application failure.
   * If this value is nil, failover is disabled.
   * If set, the PropagateDeps should be true so that the dependencies could
   * be migrated along with the application.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecFailover#application
   */
  readonly application?: ClusterResourceBindingV1Alpha2SpecFailoverApplication;

  /**
   * Cluster indicates failover behaviors in case of cluster failure.
   * If this value is nil, the failover behavior in case of cluster failure
   * will be controlled by the controller's no-execute-taint-eviction-purge-mode
   * parameter.
   * If set, the failover behavior in case of cluster failure will be defined
   * by this value.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecFailover#cluster
   */
  readonly cluster?: ClusterResourceBindingV1Alpha2SpecFailoverCluster;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecFailover(obj: ClusterResourceBindingV1Alpha2SpecFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'application': toJson_ClusterResourceBindingV1Alpha2SpecFailoverApplication(obj.application),
    'cluster': toJson_ClusterResourceBindingV1Alpha2SpecFailoverCluster(obj.cluster),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GracefulEvictionTask represents a graceful eviction task.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks
 */
export interface ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks {
  /**
   * ClustersBeforeFailover records the clusters where running the application before failover.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks#clustersBeforeFailover
   */
  readonly clustersBeforeFailover?: string[];

  /**
   * CreationTimestamp is a timestamp representing the server time when this object was
   * created.
   * Clients should not set this value to avoid the time inconsistency issue.
   * It is represented in RFC3339 form(like '2021-04-25T10:02:10Z') and is in UTC.
   *
   * Populated by the system. Read-only.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks#creationTimestamp
   */
  readonly creationTimestamp?: Date;

  /**
   * FromCluster which cluster the eviction perform from.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks#fromCluster
   */
  readonly fromCluster: string;

  /**
   * GracePeriodSeconds is the maximum waiting duration in seconds before the item
   * should be deleted. If the application on the new cluster cannot reach a Healthy state,
   * Karmada will delete the item after GracePeriodSeconds is reached.
   * Value must be positive integer.
   * It can not co-exist with SuppressDeletion.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks#gracePeriodSeconds
   */
  readonly gracePeriodSeconds?: number;

  /**
   * Message is a human-readable message indicating details about the eviction.
   * This may be an empty string.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks#message
   */
  readonly message?: string;

  /**
   * PreservedLabelState represents the application state information collected from the original cluster,
   * and it will be injected into the new cluster in form of application labels.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks#preservedLabelState
   */
  readonly preservedLabelState?: { [key: string]: string };

  /**
   * Producer indicates the controller who triggered the eviction.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks#producer
   */
  readonly producer: string;

  /**
   * PurgeMode represents how to deal with the legacy applications on the
   * cluster from which the application is migrated.
   * Valid options are "Immediately", "Directly", "Graciously", "Gracefully" and "Never".
   *
   * @schema ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks#purgeMode
   */
  readonly purgeMode?: ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasksPurgeMode;

  /**
   * Reason contains a programmatic identifier indicating the reason for the eviction.
   * Producers may define expected values and meanings for this field,
   * and whether the values are considered a guaranteed API.
   * The value should be a CamelCase string.
   * This field may not be empty.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks#reason
   */
  readonly reason: string;

  /**
   * Replicas indicates the number of replicas should be evicted.
   * Should be ignored for resource type that doesn't have replica.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks#replicas
   */
  readonly replicas?: number;

  /**
   * SuppressDeletion represents the grace period will be persistent until
   * the tools or human intervention stops it.
   * It can not co-exist with GracePeriodSeconds.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks#suppressDeletion
   */
  readonly suppressDeletion?: boolean;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks(obj: ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clustersBeforeFailover': obj.clustersBeforeFailover?.map(y => y),
    'creationTimestamp': obj.creationTimestamp?.toISOString(),
    'fromCluster': obj.fromCluster,
    'gracePeriodSeconds': obj.gracePeriodSeconds,
    'message': obj.message,
    'preservedLabelState': ((obj.preservedLabelState) === undefined) ? undefined : (Object.entries(obj.preservedLabelState).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'producer': obj.producer,
    'purgeMode': obj.purgeMode,
    'reason': obj.reason,
    'replicas': obj.replicas,
    'suppressDeletion': obj.suppressDeletion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Placement represents the rule for select clusters to propagate resources.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacement
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacement {
  /**
   * ClusterAffinities represents scheduling restrictions to multiple cluster
   * groups that indicated by ClusterAffinityTerm.
   *
   * The scheduler will evaluate these groups one by one in the order they
   * appear in the spec, the group that does not satisfy scheduling restrictions
   * will be ignored which means all clusters in this group will not be selected
   * unless it also belongs to the next group(a cluster could belong to multiple
   * groups).
   *
   * If none of the groups satisfy the scheduling restrictions, then scheduling
   * fails, which means no cluster will be selected.
   *
   * Note:
   * 1. ClusterAffinities can not co-exist with ClusterAffinity.
   * 2. If both ClusterAffinity and ClusterAffinities are not set, any cluster
   * can be scheduling candidates.
   *
   * Potential use case 1:
   * The private clusters in the local data center could be the main group, and
   * the managed clusters provided by cluster providers could be the secondary
   * group. So that the Karmada scheduler would prefer to schedule workloads
   * to the main group and the second group will only be considered in case of
   * the main group does not satisfy restrictions(like, lack of resources).
   *
   * Potential use case 2:
   * For the disaster recovery scenario, the clusters could be organized to
   * primary and backup groups, the workloads would be scheduled to primary
   * clusters firstly, and when primary cluster fails(like data center power off),
   * Karmada scheduler could migrate workloads to the backup clusters.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacement#clusterAffinities
   */
  readonly clusterAffinities?: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinities[];

  /**
   * ClusterAffinity represents scheduling restrictions to a certain set of clusters.
   * Note:
   * 1. ClusterAffinity can not co-exist with ClusterAffinities.
   * 2. If both ClusterAffinity and ClusterAffinities are not set, any cluster
   * can be scheduling candidates.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacement#clusterAffinity
   */
  readonly clusterAffinity?: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinity;

  /**
   * ClusterTolerations represents the tolerations.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacement#clusterTolerations
   */
  readonly clusterTolerations?: ClusterResourceBindingV1Alpha2SpecPlacementClusterTolerations[];

  /**
   * ReplicaScheduling represents the scheduling policy on dealing with the number of replicas
   * when propagating resources that have replicas in spec (e.g. deployments, statefulsets) to member clusters.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacement#replicaScheduling
   */
  readonly replicaScheduling?: ClusterResourceBindingV1Alpha2SpecPlacementReplicaScheduling;

  /**
   * SpreadConstraints represents a list of the scheduling constraints.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacement#spreadConstraints
   */
  readonly spreadConstraints?: ClusterResourceBindingV1Alpha2SpecPlacementSpreadConstraints[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacement' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacement(obj: ClusterResourceBindingV1Alpha2SpecPlacement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterAffinities': obj.clusterAffinities?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinities(y)),
    'clusterAffinity': toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinity(obj.clusterAffinity),
    'clusterTolerations': obj.clusterTolerations?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterTolerations(y)),
    'replicaScheduling': toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaScheduling(obj.replicaScheduling),
    'spreadConstraints': obj.spreadConstraints?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecPlacementSpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReplicaRequirements represents the resource and scheduling requirements for each replica.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirements
 */
export interface ClusterResourceBindingV1Alpha2SpecReplicaRequirements {
  /**
   * Namespace represents the resources namespaces
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirements#namespace
   */
  readonly namespace?: string;

  /**
   * NodeClaim represents the node claim HardNodeAffinity, NodeSelector and Tolerations required by each replica.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirements#nodeClaim
   */
  readonly nodeClaim?: ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim;

  /**
   * PriorityClassName represents the resources priorityClassName
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirements#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ResourceRequest represents the resources required by each replica.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirements#resourceRequest
   */
  readonly resourceRequest?: { [key: string]: ClusterResourceBindingV1Alpha2SpecReplicaRequirementsResourceRequest };
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecReplicaRequirements' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecReplicaRequirements(obj: ClusterResourceBindingV1Alpha2SpecReplicaRequirements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'nodeClaim': toJson_ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim(obj.nodeClaim),
    'priorityClassName': obj.priorityClassName,
    'resourceRequest': ((obj.resourceRequest) === undefined) ? undefined : (Object.entries(obj.resourceRequest).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BindingSnapshot is a snapshot of a ResourceBinding or ClusterResourceBinding.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecRequiredBy
 */
export interface ClusterResourceBindingV1Alpha2SpecRequiredBy {
  /**
   * Clusters represents the scheduled result.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecRequiredBy#clusters
   */
  readonly clusters?: ClusterResourceBindingV1Alpha2SpecRequiredByClusters[];

  /**
   * Name represents the name of the Binding.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecRequiredBy#name
   */
  readonly name: string;

  /**
   * Namespace represents the namespace of the Binding.
   * It is required for ResourceBinding.
   * If Namespace is not specified, means the referencing is ClusterResourceBinding.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecRequiredBy#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecRequiredBy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecRequiredBy(obj: ClusterResourceBindingV1Alpha2SpecRequiredBy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusters': obj.clusters?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecRequiredByClusters(y)),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resource represents the Kubernetes resource to be propagated.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecResource
 */
export interface ClusterResourceBindingV1Alpha2SpecResource {
  /**
   * APIVersion represents the API version of the referent.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecResource#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind represents the Kind of the referent.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecResource#kind
   */
  readonly kind: string;

  /**
   * Name represents the name of the referent.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecResource#name
   */
  readonly name: string;

  /**
   * Namespace represents the namespace for the referent.
   * For non-namespace scoped resources(e.g. 'ClusterRole')，do not need specify Namespace,
   * and for namespace scoped resources, Namespace is required.
   * If Namespace is not specified, means the resource is non-namespace scoped.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecResource#namespace
   */
  readonly namespace?: string;

  /**
   * ResourceVersion represents the internal version of the referenced object, that can be used by clients to
   * determine when object has changed.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecResource#resourceVersion
   */
  readonly resourceVersion?: string;

  /**
   * UID of the referent.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecResource#uid
   */
  readonly uid?: string;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecResource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecResource(obj: ClusterResourceBindingV1Alpha2SpecResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'resourceVersion': obj.resourceVersion,
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SchedulePriority represents the scheduling priority assigned to workloads.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecSchedulePriority
 */
export interface ClusterResourceBindingV1Alpha2SpecSchedulePriority {
  /**
   * Priority specifies the scheduling priority for the binding.
   * Higher values indicate a higher priority.
   * If not explicitly set, the default value is 0.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecSchedulePriority#priority
   */
  readonly priority?: number;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecSchedulePriority' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecSchedulePriority(obj: ClusterResourceBindingV1Alpha2SpecSchedulePriority | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'priority': obj.priority,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Suspension declares the policy for suspending different aspects of propagation.
 * nil means no suspension. no default values.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecSuspension
 */
export interface ClusterResourceBindingV1Alpha2SpecSuspension {
  /**
   * Dispatching controls whether dispatching should be suspended.
   * nil means not suspend, no default value, only accepts 'true'.
   * Note: true means stop propagating to all clusters. Can not co-exist
   * with DispatchingOnClusters which is used to suspend particular clusters.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecSuspension#dispatching
   */
  readonly dispatching?: boolean;

  /**
   * DispatchingOnClusters declares a list of clusters to which the dispatching
   * should be suspended.
   * Note: Can not co-exist with Dispatching which is used to suspend all.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecSuspension#dispatchingOnClusters
   */
  readonly dispatchingOnClusters?: ClusterResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters;

  /**
   * Scheduling controls whether scheduling should be suspended, the scheduler will pause scheduling and not
   * process resource binding when the value is true and resume scheduling when it's false or nil.
   * This is designed for third-party systems to temporarily pause the scheduling of applications, which enabling
   * manage resource allocation, prioritize critical workloads, etc.
   * It is expected that third-party systems use an admission webhook to suspend scheduling at the time of
   * ResourceBinding creation. Once a ResourceBinding has been scheduled, it cannot be paused afterward, as it may
   * lead to ineffective suspension.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecSuspension#scheduling
   */
  readonly scheduling?: boolean;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecSuspension' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecSuspension(obj: ClusterResourceBindingV1Alpha2SpecSuspension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dispatching': obj.dispatching,
    'dispatchingOnClusters': toJson_ClusterResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters(obj.dispatchingOnClusters),
    'scheduling': obj.scheduling,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReplicaRequirements represents the resource and scheduling requirements for each replica.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirements
 */
export interface ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirements {
  /**
   * NodeClaim represents the node claim HardNodeAffinity, NodeSelector and Tolerations required by each replica.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirements#nodeClaim
   */
  readonly nodeClaim?: ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim;

  /**
   * PriorityClassName represents the resources priorityClassName
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirements#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ResourceRequest represents the resources required by each replica.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirements#resourceRequest
   */
  readonly resourceRequest?: { [key: string]: ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsResourceRequest };
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirements' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirements(obj: ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeClaim': toJson_ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim(obj.nodeClaim),
    'priorityClassName': obj.priorityClassName,
    'resourceRequest': ((obj.resourceRequest) === undefined) ? undefined : (Object.entries(obj.resourceRequest).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Application indicates failover behaviors in case of application failure.
 * If this value is nil, failover is disabled.
 * If set, the PropagateDeps should be true so that the dependencies could
 * be migrated along with the application.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecFailoverApplication
 */
export interface ClusterResourceBindingV1Alpha2SpecFailoverApplication {
  /**
   * DecisionConditions indicates the decision conditions of performing the failover process.
   * Only when all conditions are met can the failover process be performed.
   * Currently, DecisionConditions includes several conditions:
   * - TolerationSeconds (optional)
   *
   * @schema ClusterResourceBindingV1Alpha2SpecFailoverApplication#decisionConditions
   */
  readonly decisionConditions: ClusterResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions;

  /**
   * GracePeriodSeconds is the maximum waiting duration in seconds before
   * application on the migrated cluster should be deleted.
   * Required only when PurgeMode is "Graciously" and defaults to 600s.
   * If the application on the new cluster cannot reach a Healthy state,
   * Karmada will delete the application after GracePeriodSeconds is reached.
   * Value must be positive integer.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecFailoverApplication#gracePeriodSeconds
   */
  readonly gracePeriodSeconds?: number;

  /**
   * PurgeMode represents how to deal with the legacy applications on the
   * cluster from which the application is migrated.
   * Valid options are "Directly", "Gracefully", "Never", "Immediately"(deprecated),
   * and "Graciously"(deprecated).
   * Defaults to "Gracefully".
   *
   * @default Gracefully".
   * @schema ClusterResourceBindingV1Alpha2SpecFailoverApplication#purgeMode
   */
  readonly purgeMode?: ClusterResourceBindingV1Alpha2SpecFailoverApplicationPurgeMode;

  /**
   * StatePreservation defines the policy for preserving and restoring state data
   * during failover events for stateful applications.
   *
   * When an application fails over from one cluster to another, this policy enables
   * the extraction of critical data from the original resource configuration.
   * Upon successful migration, the extracted data is then re-injected into the new
   * resource, ensuring that the application can resume operation with its previous
   * state intact.
   * This is particularly useful for stateful applications where maintaining data
   * consistency across failover events is crucial.
   * If not specified, means no state data will be preserved.
   *
   * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
   * which is alpha.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecFailoverApplication#statePreservation
   */
  readonly statePreservation?: ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecFailoverApplication' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecFailoverApplication(obj: ClusterResourceBindingV1Alpha2SpecFailoverApplication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'decisionConditions': toJson_ClusterResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions(obj.decisionConditions),
    'gracePeriodSeconds': obj.gracePeriodSeconds,
    'purgeMode': obj.purgeMode,
    'statePreservation': toJson_ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation(obj.statePreservation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cluster indicates failover behaviors in case of cluster failure.
 * If this value is nil, the failover behavior in case of cluster failure
 * will be controlled by the controller's no-execute-taint-eviction-purge-mode
 * parameter.
 * If set, the failover behavior in case of cluster failure will be defined
 * by this value.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecFailoverCluster
 */
export interface ClusterResourceBindingV1Alpha2SpecFailoverCluster {
  /**
   * PurgeMode represents how to deal with the legacy applications on the
   * cluster from which the application is migrated.
   * Valid options are "Directly", "Gracefully".
   * Defaults to "Gracefully".
   *
   * @default Gracefully".
   * @schema ClusterResourceBindingV1Alpha2SpecFailoverCluster#purgeMode
   */
  readonly purgeMode?: ClusterResourceBindingV1Alpha2SpecFailoverClusterPurgeMode;

  /**
   * StatePreservation defines the policy for preserving and restoring state data
   * during failover events for stateful applications.
   *
   * When an application fails over from one cluster to another, this policy enables
   * the extraction of critical data from the original resource configuration.
   * Upon successful migration, the extracted data is then re-injected into the new
   * resource, ensuring that the application can resume operation with its previous
   * state intact.
   * This is particularly useful for stateful applications where maintaining data
   * consistency across failover events is crucial.
   * If not specified, means no state data will be preserved.
   *
   * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
   * which is alpha.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecFailoverCluster#statePreservation
   */
  readonly statePreservation?: ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservation;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecFailoverCluster' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecFailoverCluster(obj: ClusterResourceBindingV1Alpha2SpecFailoverCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'purgeMode': obj.purgeMode,
    'statePreservation': toJson_ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservation(obj.statePreservation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PurgeMode represents how to deal with the legacy applications on the
 * cluster from which the application is migrated.
 * Valid options are "Immediately", "Directly", "Graciously", "Gracefully" and "Never".
 *
 * @schema ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasksPurgeMode
 */
export enum ClusterResourceBindingV1Alpha2SpecGracefulEvictionTasksPurgeMode {
  /** Immediately */
  IMMEDIATELY = "Immediately",
  /** Directly */
  DIRECTLY = "Directly",
  /** Graciously */
  GRACIOUSLY = "Graciously",
  /** Gracefully */
  GRACEFULLY = "Gracefully",
  /** Never */
  NEVER = "Never",
}

/**
 * ClusterAffinityTerm selects a set of cluster.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinities
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinities {
  /**
   * AffinityName is the name of the cluster group.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinities#affinityName
   */
  readonly affinityName: string;

  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinities#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinities#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinities#fieldSelector
   */
  readonly fieldSelector?: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinities#labelSelector
   */
  readonly labelSelector?: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinities(obj: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinityName': obj.affinityName,
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterAffinity represents scheduling restrictions to a certain set of clusters.
 * Note:
 * 1. ClusterAffinity can not co-exist with ClusterAffinities.
 * 2. If both ClusterAffinity and ClusterAffinities are not set, any cluster
 * can be scheduling candidates.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinity
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinity {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinity#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinity#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinity#fieldSelector
   */
  readonly fieldSelector?: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinity#labelSelector
   */
  readonly labelSelector?: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinity(obj: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterTolerations
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementClusterTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementClusterTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterTolerations(obj: ClusterResourceBindingV1Alpha2SpecPlacementClusterTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReplicaScheduling represents the scheduling policy on dealing with the number of replicas
 * when propagating resources that have replicas in spec (e.g. deployments, statefulsets) to member clusters.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaScheduling
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementReplicaScheduling {
  /**
   * ReplicaDivisionPreference determines how the replicas is divided
   * when ReplicaSchedulingType is "Divided". Valid options are Aggregated and Weighted.
   * "Aggregated" divides replicas into clusters as few as possible,
   * while respecting clusters' resource availabilities during the division.
   * "Weighted" divides replicas by weight according to WeightPreference.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaScheduling#replicaDivisionPreference
   */
  readonly replicaDivisionPreference?: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingReplicaDivisionPreference;

  /**
   * ReplicaSchedulingType determines how the replicas is scheduled when karmada propagating
   * a resource. Valid options are Duplicated and Divided.
   * "Duplicated" duplicates the same replicas to each candidate member cluster from resource.
   * "Divided" divides replicas into parts according to number of valid candidate member
   * clusters, and exact replicas for each cluster are determined by ReplicaDivisionPreference.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaScheduling#replicaSchedulingType
   */
  readonly replicaSchedulingType?: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingReplicaSchedulingType;

  /**
   * WeightPreference describes weight for each cluster or for each group of cluster
   * If ReplicaDivisionPreference is set to "Weighted", and WeightPreference is not set, scheduler will weight all clusters the same.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaScheduling#weightPreference
   */
  readonly weightPreference?: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementReplicaScheduling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaScheduling(obj: ClusterResourceBindingV1Alpha2SpecPlacementReplicaScheduling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replicaDivisionPreference': obj.replicaDivisionPreference,
    'replicaSchedulingType': obj.replicaSchedulingType,
    'weightPreference': toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference(obj.weightPreference),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SpreadConstraint represents the spread constraints on resources.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementSpreadConstraints
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementSpreadConstraints {
  /**
   * MaxGroups restricts the maximum number of cluster groups to be selected.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementSpreadConstraints#maxGroups
   */
  readonly maxGroups?: number;

  /**
   * MinGroups restricts the minimum number of cluster groups to be selected.
   * Defaults to 1.
   *
   * @default 1.
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementSpreadConstraints#minGroups
   */
  readonly minGroups?: number;

  /**
   * SpreadByField represents the fields on Karmada cluster API used for
   * dynamically grouping member clusters into different groups.
   * Resources will be spread among different cluster groups.
   * Available fields for spreading are: cluster, region, zone, and provider.
   * SpreadByField should not co-exist with SpreadByLabel.
   * If both SpreadByField and SpreadByLabel are empty, SpreadByField will be set to "cluster" by system.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementSpreadConstraints#spreadByField
   */
  readonly spreadByField?: ClusterResourceBindingV1Alpha2SpecPlacementSpreadConstraintsSpreadByField;

  /**
   * SpreadByLabel represents the label key used for
   * grouping member clusters into different groups.
   * Resources will be spread among different cluster groups.
   * SpreadByLabel should not co-exist with SpreadByField.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementSpreadConstraints#spreadByLabel
   */
  readonly spreadByLabel?: string;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementSpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementSpreadConstraints(obj: ClusterResourceBindingV1Alpha2SpecPlacementSpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxGroups': obj.maxGroups,
    'minGroups': obj.minGroups,
    'spreadByField': obj.spreadByField,
    'spreadByLabel': obj.spreadByLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodeClaim represents the node claim HardNodeAffinity, NodeSelector and Tolerations required by each replica.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim
 */
export interface ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim {
  /**
   * A node selector represents the union of the results of one or more label queries over a set of
   * nodes; that is, it represents the OR of the selectors represented by the node selector terms.
   * Note that only PodSpec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution
   * is included here because it has a hard limit on pod scheduling.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim#hardNodeAffinity
   */
  readonly hardNodeAffinity?: ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * If specified, the pod's tolerations.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim#tolerations
   */
  readonly tolerations?: ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim(obj: ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hardNodeAffinity': toJson_ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity(obj.hardNodeAffinity),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tolerations': obj.tolerations?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsResourceRequest
 */
export class ClusterResourceBindingV1Alpha2SpecReplicaRequirementsResourceRequest {
  public static fromNumber(value: number): ClusterResourceBindingV1Alpha2SpecReplicaRequirementsResourceRequest {
    return new ClusterResourceBindingV1Alpha2SpecReplicaRequirementsResourceRequest(value);
  }
  public static fromString(value: string): ClusterResourceBindingV1Alpha2SpecReplicaRequirementsResourceRequest {
    return new ClusterResourceBindingV1Alpha2SpecReplicaRequirementsResourceRequest(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * TargetCluster represents the identifier of a member cluster.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecRequiredByClusters
 */
export interface ClusterResourceBindingV1Alpha2SpecRequiredByClusters {
  /**
   * Name of target cluster.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecRequiredByClusters#name
   */
  readonly name: string;

  /**
   * Replicas in target cluster
   *
   * @schema ClusterResourceBindingV1Alpha2SpecRequiredByClusters#replicas
   */
  readonly replicas?: number;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecRequiredByClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecRequiredByClusters(obj: ClusterResourceBindingV1Alpha2SpecRequiredByClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'replicas': obj.replicas,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DispatchingOnClusters declares a list of clusters to which the dispatching
 * should be suspended.
 * Note: Can not co-exist with Dispatching which is used to suspend all.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters
 */
export interface ClusterResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters#clusterNames
   */
  readonly clusterNames?: string[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters(obj: ClusterResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodeClaim represents the node claim HardNodeAffinity, NodeSelector and Tolerations required by each replica.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim
 */
export interface ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim {
  /**
   * A node selector represents the union of the results of one or more label queries over a set of
   * nodes; that is, it represents the OR of the selectors represented by the node selector terms.
   * Note that only PodSpec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution
   * is included here because it has a hard limit on pod scheduling.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim#hardNodeAffinity
   */
  readonly hardNodeAffinity?: ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * If specified, the pod's tolerations.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim#tolerations
   */
  readonly tolerations?: ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim(obj: ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hardNodeAffinity': toJson_ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity(obj.hardNodeAffinity),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tolerations': obj.tolerations?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsResourceRequest
 */
export class ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsResourceRequest {
  public static fromNumber(value: number): ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsResourceRequest {
    return new ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsResourceRequest(value);
  }
  public static fromString(value: string): ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsResourceRequest {
    return new ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsResourceRequest(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * DecisionConditions indicates the decision conditions of performing the failover process.
 * Only when all conditions are met can the failover process be performed.
 * Currently, DecisionConditions includes several conditions:
 * - TolerationSeconds (optional)
 *
 * @schema ClusterResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions
 */
export interface ClusterResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions {
  /**
   * TolerationSeconds represents the period of time Karmada should wait
   * after reaching the desired state before performing failover process.
   * If not specified, Karmada will immediately perform failover process.
   * Defaults to 300s.
   *
   * @default 300s.
   * @schema ClusterResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions#tolerationSeconds
   */
  readonly tolerationSeconds?: number;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions(obj: ClusterResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tolerationSeconds': obj.tolerationSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PurgeMode represents how to deal with the legacy applications on the
 * cluster from which the application is migrated.
 * Valid options are "Directly", "Gracefully", "Never", "Immediately"(deprecated),
 * and "Graciously"(deprecated).
 * Defaults to "Gracefully".
 *
 * @default Gracefully".
 * @schema ClusterResourceBindingV1Alpha2SpecFailoverApplicationPurgeMode
 */
export enum ClusterResourceBindingV1Alpha2SpecFailoverApplicationPurgeMode {
  /** Directly */
  DIRECTLY = "Directly",
  /** Gracefully */
  GRACEFULLY = "Gracefully",
  /** Never */
  NEVER = "Never",
  /** Immediately */
  IMMEDIATELY = "Immediately",
  /** Graciously */
  GRACIOUSLY = "Graciously",
}

/**
 * StatePreservation defines the policy for preserving and restoring state data
 * during failover events for stateful applications.
 *
 * When an application fails over from one cluster to another, this policy enables
 * the extraction of critical data from the original resource configuration.
 * Upon successful migration, the extracted data is then re-injected into the new
 * resource, ensuring that the application can resume operation with its previous
 * state intact.
 * This is particularly useful for stateful applications where maintaining data
 * consistency across failover events is crucial.
 * If not specified, means no state data will be preserved.
 *
 * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
 * which is alpha.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation
 */
export interface ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation {
  /**
   * Rules contains a list of StatePreservationRule configurations.
   * Each rule specifies a JSONPath expression targeting specific pieces of
   * state data to be preserved during failover events. An AliasLabelName is associated
   * with each rule, serving as a label key when the preserved data is passed
   * to the new cluster.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation#rules
   */
  readonly rules: ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation(obj: ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PurgeMode represents how to deal with the legacy applications on the
 * cluster from which the application is migrated.
 * Valid options are "Directly", "Gracefully".
 * Defaults to "Gracefully".
 *
 * @default Gracefully".
 * @schema ClusterResourceBindingV1Alpha2SpecFailoverClusterPurgeMode
 */
export enum ClusterResourceBindingV1Alpha2SpecFailoverClusterPurgeMode {
  /** Directly */
  DIRECTLY = "Directly",
  /** Gracefully */
  GRACEFULLY = "Gracefully",
}

/**
 * StatePreservation defines the policy for preserving and restoring state data
 * during failover events for stateful applications.
 *
 * When an application fails over from one cluster to another, this policy enables
 * the extraction of critical data from the original resource configuration.
 * Upon successful migration, the extracted data is then re-injected into the new
 * resource, ensuring that the application can resume operation with its previous
 * state intact.
 * This is particularly useful for stateful applications where maintaining data
 * consistency across failover events is crucial.
 * If not specified, means no state data will be preserved.
 *
 * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
 * which is alpha.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservation
 */
export interface ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservation {
  /**
   * Rules contains a list of StatePreservationRule configurations.
   * Each rule specifies a JSONPath expression targeting specific pieces of
   * state data to be preserved during failover events. An AliasLabelName is associated
   * with each rule, serving as a label key when the preserved data is passed
   * to the new cluster.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservation#rules
   */
  readonly rules: ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservation(obj: ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector(obj: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector(obj: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector(obj: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector(obj: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReplicaDivisionPreference determines how the replicas is divided
 * when ReplicaSchedulingType is "Divided". Valid options are Aggregated and Weighted.
 * "Aggregated" divides replicas into clusters as few as possible,
 * while respecting clusters' resource availabilities during the division.
 * "Weighted" divides replicas by weight according to WeightPreference.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingReplicaDivisionPreference
 */
export enum ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingReplicaDivisionPreference {
  /** Aggregated */
  AGGREGATED = "Aggregated",
  /** Weighted */
  WEIGHTED = "Weighted",
}

/**
 * ReplicaSchedulingType determines how the replicas is scheduled when karmada propagating
 * a resource. Valid options are Duplicated and Divided.
 * "Duplicated" duplicates the same replicas to each candidate member cluster from resource.
 * "Divided" divides replicas into parts according to number of valid candidate member
 * clusters, and exact replicas for each cluster are determined by ReplicaDivisionPreference.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingReplicaSchedulingType
 */
export enum ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingReplicaSchedulingType {
  /** Duplicated */
  DUPLICATED = "Duplicated",
  /** Divided */
  DIVIDED = "Divided",
}

/**
 * WeightPreference describes weight for each cluster or for each group of cluster
 * If ReplicaDivisionPreference is set to "Weighted", and WeightPreference is not set, scheduler will weight all clusters the same.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference {
  /**
   * DynamicWeight specifies the factor to generates dynamic weight list.
   * If specified, StaticWeightList will be ignored.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference#dynamicWeight
   */
  readonly dynamicWeight?: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceDynamicWeight;

  /**
   * StaticWeightList defines the static cluster weight.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference#staticWeightList
   */
  readonly staticWeightList?: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference(obj: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dynamicWeight': obj.dynamicWeight,
    'staticWeightList': obj.staticWeightList?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SpreadByField represents the fields on Karmada cluster API used for
 * dynamically grouping member clusters into different groups.
 * Resources will be spread among different cluster groups.
 * Available fields for spreading are: cluster, region, zone, and provider.
 * SpreadByField should not co-exist with SpreadByLabel.
 * If both SpreadByField and SpreadByLabel are empty, SpreadByField will be set to "cluster" by system.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementSpreadConstraintsSpreadByField
 */
export enum ClusterResourceBindingV1Alpha2SpecPlacementSpreadConstraintsSpreadByField {
  /** cluster */
  CLUSTER = "cluster",
  /** region */
  REGION = "region",
  /** zone */
  ZONE = "zone",
  /** provider */
  PROVIDER = "provider",
}

/**
 * A node selector represents the union of the results of one or more label queries over a set of
 * nodes; that is, it represents the OR of the selectors represented by the node selector terms.
 * Note that only PodSpec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution
 * is included here because it has a hard limit on pod scheduling.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity
 */
export interface ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity(obj: ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations
 */
export interface ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations(obj: ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector represents the union of the results of one or more label queries over a set of
 * nodes; that is, it represents the OR of the selectors represented by the node selector terms.
 * Note that only PodSpec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution
 * is included here because it has a hard limit on pod scheduling.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity
 */
export interface ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity(obj: ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations
 */
export interface ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations(obj: ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StatePreservationRule defines a single rule for state preservation.
 * It includes a JSONPath expression and an alias name that will be used
 * as a label key when passing state information to the new cluster.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules
 */
export interface ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules {
  /**
   * AliasLabelName is the name that will be used as a label key when the preserved
   * data is passed to the new cluster. This facilitates the injection of the
   * preserved state back into the application resources during recovery.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules#aliasLabelName
   */
  readonly aliasLabelName: string;

  /**
   * JSONPath is the JSONPath template used to identify the state data
   * to be preserved from the original resource configuration.
   * The JSONPath syntax follows the Kubernetes specification:
   * https://kubernetes.io/docs/reference/kubectl/jsonpath/
   *
   * Note: The JSONPath expression will start searching from the "status" field of
   * the API resource object by default. For example, to extract the "availableReplicas"
   * from a Deployment, the JSONPath expression should be "{.availableReplicas}", not
   * "{.status.availableReplicas}".
   *
   * @schema ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules#jsonPath
   */
  readonly jsonPath: string;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules(obj: ClusterResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aliasLabelName': obj.aliasLabelName,
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StatePreservationRule defines a single rule for state preservation.
 * It includes a JSONPath expression and an alias name that will be used
 * as a label key when passing state information to the new cluster.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules
 */
export interface ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules {
  /**
   * AliasLabelName is the name that will be used as a label key when the preserved
   * data is passed to the new cluster. This facilitates the injection of the
   * preserved state back into the application resources during recovery.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules#aliasLabelName
   */
  readonly aliasLabelName: string;

  /**
   * JSONPath is the JSONPath template used to identify the state data
   * to be preserved from the original resource configuration.
   * The JSONPath syntax follows the Kubernetes specification:
   * https://kubernetes.io/docs/reference/kubectl/jsonpath/
   *
   * Note: The JSONPath expression will start searching from the "status" field of
   * the API resource object by default. For example, to extract the "availableReplicas"
   * from a Deployment, the JSONPath expression should be "{.availableReplicas}", not
   * "{.status.availableReplicas}".
   *
   * @schema ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules#jsonPath
   */
  readonly jsonPath: string;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules(obj: ClusterResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aliasLabelName': obj.aliasLabelName,
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions(obj: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions(obj: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions(obj: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions(obj: ClusterResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DynamicWeight specifies the factor to generates dynamic weight list.
 * If specified, StaticWeightList will be ignored.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceDynamicWeight
 */
export enum ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceDynamicWeight {
  /** AvailableReplicas */
  AVAILABLE_REPLICAS = "AvailableReplicas",
}

/**
 * StaticClusterWeight defines the static cluster weight.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList {
  /**
   * TargetCluster describes the filter to select clusters.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList#targetCluster
   */
  readonly targetCluster: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster;

  /**
   * Weight expressing the preference to the cluster(s) specified by 'TargetCluster'.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList(obj: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetCluster': toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster(obj.targetCluster),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms
 */
export interface ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms#matchFields
   */
  readonly matchFields?: ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms(obj: ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms
 */
export interface ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms#matchFields
   */
  readonly matchFields?: ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms(obj: ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetCluster describes the filter to select clusters.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#fieldSelector
   */
  readonly fieldSelector?: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#labelSelector
   */
  readonly labelSelector?: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector;
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster(obj: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions
 */
export interface ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions(obj: ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields
 */
export interface ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields(obj: ClusterResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions
 */
export interface ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions(obj: ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields
 */
export interface ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields(obj: ClusterResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector(obj: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector(obj: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions(obj: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions
 */
export interface ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions(obj: ClusterResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * ResourceBinding represents a binding of a kubernetes resource with a propagation policy.
 *
 * @schema ResourceBinding
 */
export class ResourceBinding extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ResourceBinding"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'work.karmada.io/v1alpha1',
    kind: 'ResourceBinding',
  }

  /**
   * Renders a Kubernetes manifest for "ResourceBinding".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResourceBindingProps): any {
    return {
      ...ResourceBinding.GVK,
      ...toJson_ResourceBindingProps(props),
    };
  }

  /**
   * Defines a "ResourceBinding" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResourceBindingProps) {
    super(scope, id, {
      ...ResourceBinding.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ResourceBinding.GVK,
      ...toJson_ResourceBindingProps(resolved),
    };
  }
}

/**
 * ResourceBinding represents a binding of a kubernetes resource with a propagation policy.
 *
 * @schema ResourceBinding
 */
export interface ResourceBindingProps {
  /**
   * @schema ResourceBinding#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec represents the desired behavior.
   *
   * @schema ResourceBinding#spec
   */
  readonly spec: ResourceBindingSpec;
}

/**
 * Converts an object of type 'ResourceBindingProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingProps(obj: ResourceBindingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResourceBindingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec represents the desired behavior.
 *
 * @schema ResourceBindingSpec
 */
export interface ResourceBindingSpec {
  /**
   * Clusters represents target member clusters where the resource to be deployed.
   *
   * @schema ResourceBindingSpec#clusters
   */
  readonly clusters?: ResourceBindingSpecClusters[];

  /**
   * Resource represents the Kubernetes resource to be propagated.
   *
   * @schema ResourceBindingSpec#resource
   */
  readonly resource: ResourceBindingSpecResource;
}

/**
 * Converts an object of type 'ResourceBindingSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingSpec(obj: ResourceBindingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusters': obj.clusters?.map(y => toJson_ResourceBindingSpecClusters(y)),
    'resource': toJson_ResourceBindingSpecResource(obj.resource),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetCluster represents the identifier of a member cluster.
 *
 * @schema ResourceBindingSpecClusters
 */
export interface ResourceBindingSpecClusters {
  /**
   * Name of target cluster.
   *
   * @schema ResourceBindingSpecClusters#name
   */
  readonly name: string;

  /**
   * Replicas in target cluster
   *
   * @schema ResourceBindingSpecClusters#replicas
   */
  readonly replicas?: number;
}

/**
 * Converts an object of type 'ResourceBindingSpecClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingSpecClusters(obj: ResourceBindingSpecClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'replicas': obj.replicas,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resource represents the Kubernetes resource to be propagated.
 *
 * @schema ResourceBindingSpecResource
 */
export interface ResourceBindingSpecResource {
  /**
   * APIVersion represents the API version of the referent.
   *
   * @schema ResourceBindingSpecResource#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind represents the Kind of the referent.
   *
   * @schema ResourceBindingSpecResource#kind
   */
  readonly kind: string;

  /**
   * Name represents the name of the referent.
   *
   * @schema ResourceBindingSpecResource#name
   */
  readonly name: string;

  /**
   * Namespace represents the namespace for the referent.
   * For non-namespace scoped resources(e.g. 'ClusterRole')，do not need specify Namespace,
   * and for namespace scoped resources, Namespace is required.
   * If Namespace is not specified, means the resource is non-namespace scoped.
   *
   * @schema ResourceBindingSpecResource#namespace
   */
  readonly namespace?: string;

  /**
   * Replicas represents the replica number of the referencing resource.
   *
   * @schema ResourceBindingSpecResource#replicas
   */
  readonly replicas?: number;

  /**
   * ReplicaResourceRequirements represents the resources required by each replica.
   *
   * @schema ResourceBindingSpecResource#resourcePerReplicas
   */
  readonly resourcePerReplicas?: { [key: string]: ResourceBindingSpecResourceResourcePerReplicas };

  /**
   * ResourceVersion represents the internal version of the referenced object, that can be used by clients to
   * determine when object has changed.
   *
   * @schema ResourceBindingSpecResource#resourceVersion
   */
  readonly resourceVersion?: string;
}

/**
 * Converts an object of type 'ResourceBindingSpecResource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingSpecResource(obj: ResourceBindingSpecResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'replicas': obj.replicas,
    'resourcePerReplicas': ((obj.resourcePerReplicas) === undefined) ? undefined : (Object.entries(obj.resourcePerReplicas).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'resourceVersion': obj.resourceVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ResourceBindingSpecResourceResourcePerReplicas
 */
export class ResourceBindingSpecResourceResourcePerReplicas {
  public static fromNumber(value: number): ResourceBindingSpecResourceResourcePerReplicas {
    return new ResourceBindingSpecResourceResourcePerReplicas(value);
  }
  public static fromString(value: string): ResourceBindingSpecResourceResourcePerReplicas {
    return new ResourceBindingSpecResourceResourcePerReplicas(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * ResourceBinding represents a binding of a kubernetes resource with a propagation policy.
 *
 * @schema ResourceBindingV1Alpha2
 */
export class ResourceBindingV1Alpha2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ResourceBindingV1Alpha2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'work.karmada.io/v1alpha2',
    kind: 'ResourceBinding',
  }

  /**
   * Renders a Kubernetes manifest for "ResourceBindingV1Alpha2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResourceBindingV1Alpha2Props): any {
    return {
      ...ResourceBindingV1Alpha2.GVK,
      ...toJson_ResourceBindingV1Alpha2Props(props),
    };
  }

  /**
   * Defines a "ResourceBindingV1Alpha2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResourceBindingV1Alpha2Props) {
    super(scope, id, {
      ...ResourceBindingV1Alpha2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ResourceBindingV1Alpha2.GVK,
      ...toJson_ResourceBindingV1Alpha2Props(resolved),
    };
  }
}

/**
 * ResourceBinding represents a binding of a kubernetes resource with a propagation policy.
 *
 * @schema ResourceBindingV1Alpha2
 */
export interface ResourceBindingV1Alpha2Props {
  /**
   * @schema ResourceBindingV1Alpha2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec represents the desired behavior.
   *
   * @schema ResourceBindingV1Alpha2#spec
   */
  readonly spec: ResourceBindingV1Alpha2Spec;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2Props(obj: ResourceBindingV1Alpha2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResourceBindingV1Alpha2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec represents the desired behavior.
 *
 * @schema ResourceBindingV1Alpha2Spec
 */
export interface ResourceBindingV1Alpha2Spec {
  /**
   * Clusters represents target member clusters where the resource to be deployed.
   *
   * @schema ResourceBindingV1Alpha2Spec#clusters
   */
  readonly clusters?: ResourceBindingV1Alpha2SpecClusters[];

  /**
   * Components represents the requirements of multiple pod templates of the referencing resource.
   * It is designed to support workloads that consist of multiple pod templates,
   * such as distributed training jobs (e.g., PyTorch, TensorFlow) and big data workloads (e.g., FlinkDeployment),
   * where each workload is composed of more than one pod template. It is also capable of representing
   * single-component workloads, such as Deployment.
   *
   * Note: This field is intended to replace the legacy ReplicaRequirements and Replicas fields above.
   * It is only populated when the MultiplePodTemplatesScheduling feature gate is enabled.
   *
   * @schema ResourceBindingV1Alpha2Spec#components
   */
  readonly components?: ResourceBindingV1Alpha2SpecComponents[];

  /**
   * ConflictResolution declares how potential conflict should be handled when
   * a resource that is being propagated already exists in the target cluster.
   *
   * It defaults to "Abort" which means stop propagating to avoid unexpected
   * overwrites. The "Overwrite" might be useful when migrating legacy cluster
   * resources to Karmada, in which case conflict is predictable and can be
   * instructed to Karmada take over the resource by overwriting.
   *
   * @schema ResourceBindingV1Alpha2Spec#conflictResolution
   */
  readonly conflictResolution?: ResourceBindingV1Alpha2SpecConflictResolution;

  /**
   * Failover indicates how Karmada migrates applications in case of failures.
   * It inherits directly from the associated PropagationPolicy(or ClusterPropagationPolicy).
   *
   * @schema ResourceBindingV1Alpha2Spec#failover
   */
  readonly failover?: ResourceBindingV1Alpha2SpecFailover;

  /**
   * GracefulEvictionTasks holds the eviction tasks that are expected to perform
   * the eviction in a graceful way.
   * The intended workflow is:
   * 1. Once the controller(such as 'taint-manager') decided to evict the resource that
   * is referenced by current ResourceBinding or ClusterResourceBinding from a target
   * cluster, it removes(or scale down the replicas) the target from Clusters(.spec.Clusters)
   * and builds a graceful eviction task.
   * 2. The scheduler may perform a re-scheduler and probably select a substitute cluster
   * to take over the evicting workload(resource).
   * 3. The graceful eviction controller takes care of the graceful eviction tasks and
   * performs the final removal after the workload(resource) is available on the substitute
   * cluster or exceed the grace termination period(defaults to 10 minutes).
   *
   * @schema ResourceBindingV1Alpha2Spec#gracefulEvictionTasks
   */
  readonly gracefulEvictionTasks?: ResourceBindingV1Alpha2SpecGracefulEvictionTasks[];

  /**
   * Placement represents the rule for select clusters to propagate resources.
   *
   * @schema ResourceBindingV1Alpha2Spec#placement
   */
  readonly placement?: ResourceBindingV1Alpha2SpecPlacement;

  /**
   * PreserveResourcesOnDeletion controls whether resources should be preserved on the
   * member clusters when the binding object is deleted.
   * If set to true, resources will be preserved on the member clusters.
   * Default is false, which means resources will be deleted along with the binding object.
   * This setting applies to all Work objects created under this binding object.
   *
   * @default false, which means resources will be deleted along with the binding object.
   * @schema ResourceBindingV1Alpha2Spec#preserveResourcesOnDeletion
   */
  readonly preserveResourcesOnDeletion?: boolean;

  /**
   * PropagateDeps tells if relevant resources should be propagated automatically.
   * It is inherited from PropagationPolicy or ClusterPropagationPolicy.
   * default false.
   *
   * @schema ResourceBindingV1Alpha2Spec#propagateDeps
   */
  readonly propagateDeps?: boolean;

  /**
   * ReplicaRequirements represents the resource and scheduling requirements for each replica.
   *
   * @schema ResourceBindingV1Alpha2Spec#replicaRequirements
   */
  readonly replicaRequirements?: ResourceBindingV1Alpha2SpecReplicaRequirements;

  /**
   * Replicas represents the replica number of the referencing resource.
   *
   * @schema ResourceBindingV1Alpha2Spec#replicas
   */
  readonly replicas?: number;

  /**
   * RequiredBy represents the list of Bindings that depend on the referencing resource.
   *
   * @schema ResourceBindingV1Alpha2Spec#requiredBy
   */
  readonly requiredBy?: ResourceBindingV1Alpha2SpecRequiredBy[];

  /**
   * RescheduleTriggeredAt is a timestamp representing when the referenced resource is triggered rescheduling.
   * When this field is updated, it means a rescheduling is manually triggered by user, and the expected behavior
   * of this action is to do a complete recalculation without referring to last scheduling results.
   * It works with the status.lastScheduledTime field, and only when this timestamp is later than timestamp in
   * status.lastScheduledTime will the rescheduling actually execute, otherwise, ignored.
   *
   * It is represented in RFC3339 form (like '2006-01-02T15:04:05Z') and is in UTC.
   *
   * @schema ResourceBindingV1Alpha2Spec#rescheduleTriggeredAt
   */
  readonly rescheduleTriggeredAt?: Date;

  /**
   * Resource represents the Kubernetes resource to be propagated.
   *
   * @schema ResourceBindingV1Alpha2Spec#resource
   */
  readonly resource: ResourceBindingV1Alpha2SpecResource;

  /**
   * SchedulePriority represents the scheduling priority assigned to workloads.
   *
   * @schema ResourceBindingV1Alpha2Spec#schedulePriority
   */
  readonly schedulePriority?: ResourceBindingV1Alpha2SpecSchedulePriority;

  /**
   * SchedulerName represents which scheduler to proceed the scheduling.
   * It inherits directly from the associated PropagationPolicy(or ClusterPropagationPolicy).
   *
   * @schema ResourceBindingV1Alpha2Spec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * Suspension declares the policy for suspending different aspects of propagation.
   * nil means no suspension. no default values.
   *
   * @schema ResourceBindingV1Alpha2Spec#suspension
   */
  readonly suspension?: ResourceBindingV1Alpha2SpecSuspension;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2Spec(obj: ResourceBindingV1Alpha2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusters': obj.clusters?.map(y => toJson_ResourceBindingV1Alpha2SpecClusters(y)),
    'components': obj.components?.map(y => toJson_ResourceBindingV1Alpha2SpecComponents(y)),
    'conflictResolution': obj.conflictResolution,
    'failover': toJson_ResourceBindingV1Alpha2SpecFailover(obj.failover),
    'gracefulEvictionTasks': obj.gracefulEvictionTasks?.map(y => toJson_ResourceBindingV1Alpha2SpecGracefulEvictionTasks(y)),
    'placement': toJson_ResourceBindingV1Alpha2SpecPlacement(obj.placement),
    'preserveResourcesOnDeletion': obj.preserveResourcesOnDeletion,
    'propagateDeps': obj.propagateDeps,
    'replicaRequirements': toJson_ResourceBindingV1Alpha2SpecReplicaRequirements(obj.replicaRequirements),
    'replicas': obj.replicas,
    'requiredBy': obj.requiredBy?.map(y => toJson_ResourceBindingV1Alpha2SpecRequiredBy(y)),
    'rescheduleTriggeredAt': obj.rescheduleTriggeredAt?.toISOString(),
    'resource': toJson_ResourceBindingV1Alpha2SpecResource(obj.resource),
    'schedulePriority': toJson_ResourceBindingV1Alpha2SpecSchedulePriority(obj.schedulePriority),
    'schedulerName': obj.schedulerName,
    'suspension': toJson_ResourceBindingV1Alpha2SpecSuspension(obj.suspension),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetCluster represents the identifier of a member cluster.
 *
 * @schema ResourceBindingV1Alpha2SpecClusters
 */
export interface ResourceBindingV1Alpha2SpecClusters {
  /**
   * Name of target cluster.
   *
   * @schema ResourceBindingV1Alpha2SpecClusters#name
   */
  readonly name: string;

  /**
   * Replicas in target cluster
   *
   * @schema ResourceBindingV1Alpha2SpecClusters#replicas
   */
  readonly replicas?: number;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecClusters(obj: ResourceBindingV1Alpha2SpecClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'replicas': obj.replicas,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Component represents the requirements for a specific component.
 *
 * @schema ResourceBindingV1Alpha2SpecComponents
 */
export interface ResourceBindingV1Alpha2SpecComponents {
  /**
   * Name of this component.
   * It is required when the resource contains multiple components to ensure proper identification,
   * and must also be unique within the same resource.
   *
   * @schema ResourceBindingV1Alpha2SpecComponents#name
   */
  readonly name: string;

  /**
   * ReplicaRequirements represents the resource and scheduling requirements for each replica.
   *
   * @schema ResourceBindingV1Alpha2SpecComponents#replicaRequirements
   */
  readonly replicaRequirements?: ResourceBindingV1Alpha2SpecComponentsReplicaRequirements;

  /**
   * Replicas represents the replica number of the resource's component.
   *
   * @schema ResourceBindingV1Alpha2SpecComponents#replicas
   */
  readonly replicas: number;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecComponents' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecComponents(obj: ResourceBindingV1Alpha2SpecComponents | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'replicaRequirements': toJson_ResourceBindingV1Alpha2SpecComponentsReplicaRequirements(obj.replicaRequirements),
    'replicas': obj.replicas,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConflictResolution declares how potential conflict should be handled when
 * a resource that is being propagated already exists in the target cluster.
 *
 * It defaults to "Abort" which means stop propagating to avoid unexpected
 * overwrites. The "Overwrite" might be useful when migrating legacy cluster
 * resources to Karmada, in which case conflict is predictable and can be
 * instructed to Karmada take over the resource by overwriting.
 *
 * @schema ResourceBindingV1Alpha2SpecConflictResolution
 */
export enum ResourceBindingV1Alpha2SpecConflictResolution {
  /** Abort */
  ABORT = "Abort",
  /** Overwrite */
  OVERWRITE = "Overwrite",
}

/**
 * Failover indicates how Karmada migrates applications in case of failures.
 * It inherits directly from the associated PropagationPolicy(or ClusterPropagationPolicy).
 *
 * @schema ResourceBindingV1Alpha2SpecFailover
 */
export interface ResourceBindingV1Alpha2SpecFailover {
  /**
   * Application indicates failover behaviors in case of application failure.
   * If this value is nil, failover is disabled.
   * If set, the PropagateDeps should be true so that the dependencies could
   * be migrated along with the application.
   *
   * @schema ResourceBindingV1Alpha2SpecFailover#application
   */
  readonly application?: ResourceBindingV1Alpha2SpecFailoverApplication;

  /**
   * Cluster indicates failover behaviors in case of cluster failure.
   * If this value is nil, the failover behavior in case of cluster failure
   * will be controlled by the controller's no-execute-taint-eviction-purge-mode
   * parameter.
   * If set, the failover behavior in case of cluster failure will be defined
   * by this value.
   *
   * @schema ResourceBindingV1Alpha2SpecFailover#cluster
   */
  readonly cluster?: ResourceBindingV1Alpha2SpecFailoverCluster;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecFailover(obj: ResourceBindingV1Alpha2SpecFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'application': toJson_ResourceBindingV1Alpha2SpecFailoverApplication(obj.application),
    'cluster': toJson_ResourceBindingV1Alpha2SpecFailoverCluster(obj.cluster),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GracefulEvictionTask represents a graceful eviction task.
 *
 * @schema ResourceBindingV1Alpha2SpecGracefulEvictionTasks
 */
export interface ResourceBindingV1Alpha2SpecGracefulEvictionTasks {
  /**
   * ClustersBeforeFailover records the clusters where running the application before failover.
   *
   * @schema ResourceBindingV1Alpha2SpecGracefulEvictionTasks#clustersBeforeFailover
   */
  readonly clustersBeforeFailover?: string[];

  /**
   * CreationTimestamp is a timestamp representing the server time when this object was
   * created.
   * Clients should not set this value to avoid the time inconsistency issue.
   * It is represented in RFC3339 form(like '2021-04-25T10:02:10Z') and is in UTC.
   *
   * Populated by the system. Read-only.
   *
   * @schema ResourceBindingV1Alpha2SpecGracefulEvictionTasks#creationTimestamp
   */
  readonly creationTimestamp?: Date;

  /**
   * FromCluster which cluster the eviction perform from.
   *
   * @schema ResourceBindingV1Alpha2SpecGracefulEvictionTasks#fromCluster
   */
  readonly fromCluster: string;

  /**
   * GracePeriodSeconds is the maximum waiting duration in seconds before the item
   * should be deleted. If the application on the new cluster cannot reach a Healthy state,
   * Karmada will delete the item after GracePeriodSeconds is reached.
   * Value must be positive integer.
   * It can not co-exist with SuppressDeletion.
   *
   * @schema ResourceBindingV1Alpha2SpecGracefulEvictionTasks#gracePeriodSeconds
   */
  readonly gracePeriodSeconds?: number;

  /**
   * Message is a human-readable message indicating details about the eviction.
   * This may be an empty string.
   *
   * @schema ResourceBindingV1Alpha2SpecGracefulEvictionTasks#message
   */
  readonly message?: string;

  /**
   * PreservedLabelState represents the application state information collected from the original cluster,
   * and it will be injected into the new cluster in form of application labels.
   *
   * @schema ResourceBindingV1Alpha2SpecGracefulEvictionTasks#preservedLabelState
   */
  readonly preservedLabelState?: { [key: string]: string };

  /**
   * Producer indicates the controller who triggered the eviction.
   *
   * @schema ResourceBindingV1Alpha2SpecGracefulEvictionTasks#producer
   */
  readonly producer: string;

  /**
   * PurgeMode represents how to deal with the legacy applications on the
   * cluster from which the application is migrated.
   * Valid options are "Immediately", "Directly", "Graciously", "Gracefully" and "Never".
   *
   * @schema ResourceBindingV1Alpha2SpecGracefulEvictionTasks#purgeMode
   */
  readonly purgeMode?: ResourceBindingV1Alpha2SpecGracefulEvictionTasksPurgeMode;

  /**
   * Reason contains a programmatic identifier indicating the reason for the eviction.
   * Producers may define expected values and meanings for this field,
   * and whether the values are considered a guaranteed API.
   * The value should be a CamelCase string.
   * This field may not be empty.
   *
   * @schema ResourceBindingV1Alpha2SpecGracefulEvictionTasks#reason
   */
  readonly reason: string;

  /**
   * Replicas indicates the number of replicas should be evicted.
   * Should be ignored for resource type that doesn't have replica.
   *
   * @schema ResourceBindingV1Alpha2SpecGracefulEvictionTasks#replicas
   */
  readonly replicas?: number;

  /**
   * SuppressDeletion represents the grace period will be persistent until
   * the tools or human intervention stops it.
   * It can not co-exist with GracePeriodSeconds.
   *
   * @schema ResourceBindingV1Alpha2SpecGracefulEvictionTasks#suppressDeletion
   */
  readonly suppressDeletion?: boolean;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecGracefulEvictionTasks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecGracefulEvictionTasks(obj: ResourceBindingV1Alpha2SpecGracefulEvictionTasks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clustersBeforeFailover': obj.clustersBeforeFailover?.map(y => y),
    'creationTimestamp': obj.creationTimestamp?.toISOString(),
    'fromCluster': obj.fromCluster,
    'gracePeriodSeconds': obj.gracePeriodSeconds,
    'message': obj.message,
    'preservedLabelState': ((obj.preservedLabelState) === undefined) ? undefined : (Object.entries(obj.preservedLabelState).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'producer': obj.producer,
    'purgeMode': obj.purgeMode,
    'reason': obj.reason,
    'replicas': obj.replicas,
    'suppressDeletion': obj.suppressDeletion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Placement represents the rule for select clusters to propagate resources.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacement
 */
export interface ResourceBindingV1Alpha2SpecPlacement {
  /**
   * ClusterAffinities represents scheduling restrictions to multiple cluster
   * groups that indicated by ClusterAffinityTerm.
   *
   * The scheduler will evaluate these groups one by one in the order they
   * appear in the spec, the group that does not satisfy scheduling restrictions
   * will be ignored which means all clusters in this group will not be selected
   * unless it also belongs to the next group(a cluster could belong to multiple
   * groups).
   *
   * If none of the groups satisfy the scheduling restrictions, then scheduling
   * fails, which means no cluster will be selected.
   *
   * Note:
   * 1. ClusterAffinities can not co-exist with ClusterAffinity.
   * 2. If both ClusterAffinity and ClusterAffinities are not set, any cluster
   * can be scheduling candidates.
   *
   * Potential use case 1:
   * The private clusters in the local data center could be the main group, and
   * the managed clusters provided by cluster providers could be the secondary
   * group. So that the Karmada scheduler would prefer to schedule workloads
   * to the main group and the second group will only be considered in case of
   * the main group does not satisfy restrictions(like, lack of resources).
   *
   * Potential use case 2:
   * For the disaster recovery scenario, the clusters could be organized to
   * primary and backup groups, the workloads would be scheduled to primary
   * clusters firstly, and when primary cluster fails(like data center power off),
   * Karmada scheduler could migrate workloads to the backup clusters.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacement#clusterAffinities
   */
  readonly clusterAffinities?: ResourceBindingV1Alpha2SpecPlacementClusterAffinities[];

  /**
   * ClusterAffinity represents scheduling restrictions to a certain set of clusters.
   * Note:
   * 1. ClusterAffinity can not co-exist with ClusterAffinities.
   * 2. If both ClusterAffinity and ClusterAffinities are not set, any cluster
   * can be scheduling candidates.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacement#clusterAffinity
   */
  readonly clusterAffinity?: ResourceBindingV1Alpha2SpecPlacementClusterAffinity;

  /**
   * ClusterTolerations represents the tolerations.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacement#clusterTolerations
   */
  readonly clusterTolerations?: ResourceBindingV1Alpha2SpecPlacementClusterTolerations[];

  /**
   * ReplicaScheduling represents the scheduling policy on dealing with the number of replicas
   * when propagating resources that have replicas in spec (e.g. deployments, statefulsets) to member clusters.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacement#replicaScheduling
   */
  readonly replicaScheduling?: ResourceBindingV1Alpha2SpecPlacementReplicaScheduling;

  /**
   * SpreadConstraints represents a list of the scheduling constraints.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacement#spreadConstraints
   */
  readonly spreadConstraints?: ResourceBindingV1Alpha2SpecPlacementSpreadConstraints[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacement' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacement(obj: ResourceBindingV1Alpha2SpecPlacement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterAffinities': obj.clusterAffinities?.map(y => toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinities(y)),
    'clusterAffinity': toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinity(obj.clusterAffinity),
    'clusterTolerations': obj.clusterTolerations?.map(y => toJson_ResourceBindingV1Alpha2SpecPlacementClusterTolerations(y)),
    'replicaScheduling': toJson_ResourceBindingV1Alpha2SpecPlacementReplicaScheduling(obj.replicaScheduling),
    'spreadConstraints': obj.spreadConstraints?.map(y => toJson_ResourceBindingV1Alpha2SpecPlacementSpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReplicaRequirements represents the resource and scheduling requirements for each replica.
 *
 * @schema ResourceBindingV1Alpha2SpecReplicaRequirements
 */
export interface ResourceBindingV1Alpha2SpecReplicaRequirements {
  /**
   * Namespace represents the resources namespaces
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirements#namespace
   */
  readonly namespace?: string;

  /**
   * NodeClaim represents the node claim HardNodeAffinity, NodeSelector and Tolerations required by each replica.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirements#nodeClaim
   */
  readonly nodeClaim?: ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim;

  /**
   * PriorityClassName represents the resources priorityClassName
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirements#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ResourceRequest represents the resources required by each replica.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirements#resourceRequest
   */
  readonly resourceRequest?: { [key: string]: ResourceBindingV1Alpha2SpecReplicaRequirementsResourceRequest };
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecReplicaRequirements' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecReplicaRequirements(obj: ResourceBindingV1Alpha2SpecReplicaRequirements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'nodeClaim': toJson_ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim(obj.nodeClaim),
    'priorityClassName': obj.priorityClassName,
    'resourceRequest': ((obj.resourceRequest) === undefined) ? undefined : (Object.entries(obj.resourceRequest).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BindingSnapshot is a snapshot of a ResourceBinding or ClusterResourceBinding.
 *
 * @schema ResourceBindingV1Alpha2SpecRequiredBy
 */
export interface ResourceBindingV1Alpha2SpecRequiredBy {
  /**
   * Clusters represents the scheduled result.
   *
   * @schema ResourceBindingV1Alpha2SpecRequiredBy#clusters
   */
  readonly clusters?: ResourceBindingV1Alpha2SpecRequiredByClusters[];

  /**
   * Name represents the name of the Binding.
   *
   * @schema ResourceBindingV1Alpha2SpecRequiredBy#name
   */
  readonly name: string;

  /**
   * Namespace represents the namespace of the Binding.
   * It is required for ResourceBinding.
   * If Namespace is not specified, means the referencing is ClusterResourceBinding.
   *
   * @schema ResourceBindingV1Alpha2SpecRequiredBy#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecRequiredBy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecRequiredBy(obj: ResourceBindingV1Alpha2SpecRequiredBy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusters': obj.clusters?.map(y => toJson_ResourceBindingV1Alpha2SpecRequiredByClusters(y)),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resource represents the Kubernetes resource to be propagated.
 *
 * @schema ResourceBindingV1Alpha2SpecResource
 */
export interface ResourceBindingV1Alpha2SpecResource {
  /**
   * APIVersion represents the API version of the referent.
   *
   * @schema ResourceBindingV1Alpha2SpecResource#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind represents the Kind of the referent.
   *
   * @schema ResourceBindingV1Alpha2SpecResource#kind
   */
  readonly kind: string;

  /**
   * Name represents the name of the referent.
   *
   * @schema ResourceBindingV1Alpha2SpecResource#name
   */
  readonly name: string;

  /**
   * Namespace represents the namespace for the referent.
   * For non-namespace scoped resources(e.g. 'ClusterRole')，do not need specify Namespace,
   * and for namespace scoped resources, Namespace is required.
   * If Namespace is not specified, means the resource is non-namespace scoped.
   *
   * @schema ResourceBindingV1Alpha2SpecResource#namespace
   */
  readonly namespace?: string;

  /**
   * ResourceVersion represents the internal version of the referenced object, that can be used by clients to
   * determine when object has changed.
   *
   * @schema ResourceBindingV1Alpha2SpecResource#resourceVersion
   */
  readonly resourceVersion?: string;

  /**
   * UID of the referent.
   *
   * @schema ResourceBindingV1Alpha2SpecResource#uid
   */
  readonly uid?: string;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecResource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecResource(obj: ResourceBindingV1Alpha2SpecResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'resourceVersion': obj.resourceVersion,
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SchedulePriority represents the scheduling priority assigned to workloads.
 *
 * @schema ResourceBindingV1Alpha2SpecSchedulePriority
 */
export interface ResourceBindingV1Alpha2SpecSchedulePriority {
  /**
   * Priority specifies the scheduling priority for the binding.
   * Higher values indicate a higher priority.
   * If not explicitly set, the default value is 0.
   *
   * @schema ResourceBindingV1Alpha2SpecSchedulePriority#priority
   */
  readonly priority?: number;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecSchedulePriority' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecSchedulePriority(obj: ResourceBindingV1Alpha2SpecSchedulePriority | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'priority': obj.priority,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Suspension declares the policy for suspending different aspects of propagation.
 * nil means no suspension. no default values.
 *
 * @schema ResourceBindingV1Alpha2SpecSuspension
 */
export interface ResourceBindingV1Alpha2SpecSuspension {
  /**
   * Dispatching controls whether dispatching should be suspended.
   * nil means not suspend, no default value, only accepts 'true'.
   * Note: true means stop propagating to all clusters. Can not co-exist
   * with DispatchingOnClusters which is used to suspend particular clusters.
   *
   * @schema ResourceBindingV1Alpha2SpecSuspension#dispatching
   */
  readonly dispatching?: boolean;

  /**
   * DispatchingOnClusters declares a list of clusters to which the dispatching
   * should be suspended.
   * Note: Can not co-exist with Dispatching which is used to suspend all.
   *
   * @schema ResourceBindingV1Alpha2SpecSuspension#dispatchingOnClusters
   */
  readonly dispatchingOnClusters?: ResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters;

  /**
   * Scheduling controls whether scheduling should be suspended, the scheduler will pause scheduling and not
   * process resource binding when the value is true and resume scheduling when it's false or nil.
   * This is designed for third-party systems to temporarily pause the scheduling of applications, which enabling
   * manage resource allocation, prioritize critical workloads, etc.
   * It is expected that third-party systems use an admission webhook to suspend scheduling at the time of
   * ResourceBinding creation. Once a ResourceBinding has been scheduled, it cannot be paused afterward, as it may
   * lead to ineffective suspension.
   *
   * @schema ResourceBindingV1Alpha2SpecSuspension#scheduling
   */
  readonly scheduling?: boolean;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecSuspension' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecSuspension(obj: ResourceBindingV1Alpha2SpecSuspension | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dispatching': obj.dispatching,
    'dispatchingOnClusters': toJson_ResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters(obj.dispatchingOnClusters),
    'scheduling': obj.scheduling,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReplicaRequirements represents the resource and scheduling requirements for each replica.
 *
 * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirements
 */
export interface ResourceBindingV1Alpha2SpecComponentsReplicaRequirements {
  /**
   * NodeClaim represents the node claim HardNodeAffinity, NodeSelector and Tolerations required by each replica.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirements#nodeClaim
   */
  readonly nodeClaim?: ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim;

  /**
   * PriorityClassName represents the resources priorityClassName
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirements#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * ResourceRequest represents the resources required by each replica.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirements#resourceRequest
   */
  readonly resourceRequest?: { [key: string]: ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsResourceRequest };
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecComponentsReplicaRequirements' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecComponentsReplicaRequirements(obj: ResourceBindingV1Alpha2SpecComponentsReplicaRequirements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeClaim': toJson_ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim(obj.nodeClaim),
    'priorityClassName': obj.priorityClassName,
    'resourceRequest': ((obj.resourceRequest) === undefined) ? undefined : (Object.entries(obj.resourceRequest).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Application indicates failover behaviors in case of application failure.
 * If this value is nil, failover is disabled.
 * If set, the PropagateDeps should be true so that the dependencies could
 * be migrated along with the application.
 *
 * @schema ResourceBindingV1Alpha2SpecFailoverApplication
 */
export interface ResourceBindingV1Alpha2SpecFailoverApplication {
  /**
   * DecisionConditions indicates the decision conditions of performing the failover process.
   * Only when all conditions are met can the failover process be performed.
   * Currently, DecisionConditions includes several conditions:
   * - TolerationSeconds (optional)
   *
   * @schema ResourceBindingV1Alpha2SpecFailoverApplication#decisionConditions
   */
  readonly decisionConditions: ResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions;

  /**
   * GracePeriodSeconds is the maximum waiting duration in seconds before
   * application on the migrated cluster should be deleted.
   * Required only when PurgeMode is "Graciously" and defaults to 600s.
   * If the application on the new cluster cannot reach a Healthy state,
   * Karmada will delete the application after GracePeriodSeconds is reached.
   * Value must be positive integer.
   *
   * @schema ResourceBindingV1Alpha2SpecFailoverApplication#gracePeriodSeconds
   */
  readonly gracePeriodSeconds?: number;

  /**
   * PurgeMode represents how to deal with the legacy applications on the
   * cluster from which the application is migrated.
   * Valid options are "Directly", "Gracefully", "Never", "Immediately"(deprecated),
   * and "Graciously"(deprecated).
   * Defaults to "Gracefully".
   *
   * @default Gracefully".
   * @schema ResourceBindingV1Alpha2SpecFailoverApplication#purgeMode
   */
  readonly purgeMode?: ResourceBindingV1Alpha2SpecFailoverApplicationPurgeMode;

  /**
   * StatePreservation defines the policy for preserving and restoring state data
   * during failover events for stateful applications.
   *
   * When an application fails over from one cluster to another, this policy enables
   * the extraction of critical data from the original resource configuration.
   * Upon successful migration, the extracted data is then re-injected into the new
   * resource, ensuring that the application can resume operation with its previous
   * state intact.
   * This is particularly useful for stateful applications where maintaining data
   * consistency across failover events is crucial.
   * If not specified, means no state data will be preserved.
   *
   * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
   * which is alpha.
   *
   * @schema ResourceBindingV1Alpha2SpecFailoverApplication#statePreservation
   */
  readonly statePreservation?: ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecFailoverApplication' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecFailoverApplication(obj: ResourceBindingV1Alpha2SpecFailoverApplication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'decisionConditions': toJson_ResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions(obj.decisionConditions),
    'gracePeriodSeconds': obj.gracePeriodSeconds,
    'purgeMode': obj.purgeMode,
    'statePreservation': toJson_ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation(obj.statePreservation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cluster indicates failover behaviors in case of cluster failure.
 * If this value is nil, the failover behavior in case of cluster failure
 * will be controlled by the controller's no-execute-taint-eviction-purge-mode
 * parameter.
 * If set, the failover behavior in case of cluster failure will be defined
 * by this value.
 *
 * @schema ResourceBindingV1Alpha2SpecFailoverCluster
 */
export interface ResourceBindingV1Alpha2SpecFailoverCluster {
  /**
   * PurgeMode represents how to deal with the legacy applications on the
   * cluster from which the application is migrated.
   * Valid options are "Directly", "Gracefully".
   * Defaults to "Gracefully".
   *
   * @default Gracefully".
   * @schema ResourceBindingV1Alpha2SpecFailoverCluster#purgeMode
   */
  readonly purgeMode?: ResourceBindingV1Alpha2SpecFailoverClusterPurgeMode;

  /**
   * StatePreservation defines the policy for preserving and restoring state data
   * during failover events for stateful applications.
   *
   * When an application fails over from one cluster to another, this policy enables
   * the extraction of critical data from the original resource configuration.
   * Upon successful migration, the extracted data is then re-injected into the new
   * resource, ensuring that the application can resume operation with its previous
   * state intact.
   * This is particularly useful for stateful applications where maintaining data
   * consistency across failover events is crucial.
   * If not specified, means no state data will be preserved.
   *
   * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
   * which is alpha.
   *
   * @schema ResourceBindingV1Alpha2SpecFailoverCluster#statePreservation
   */
  readonly statePreservation?: ResourceBindingV1Alpha2SpecFailoverClusterStatePreservation;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecFailoverCluster' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecFailoverCluster(obj: ResourceBindingV1Alpha2SpecFailoverCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'purgeMode': obj.purgeMode,
    'statePreservation': toJson_ResourceBindingV1Alpha2SpecFailoverClusterStatePreservation(obj.statePreservation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PurgeMode represents how to deal with the legacy applications on the
 * cluster from which the application is migrated.
 * Valid options are "Immediately", "Directly", "Graciously", "Gracefully" and "Never".
 *
 * @schema ResourceBindingV1Alpha2SpecGracefulEvictionTasksPurgeMode
 */
export enum ResourceBindingV1Alpha2SpecGracefulEvictionTasksPurgeMode {
  /** Immediately */
  IMMEDIATELY = "Immediately",
  /** Directly */
  DIRECTLY = "Directly",
  /** Graciously */
  GRACIOUSLY = "Graciously",
  /** Gracefully */
  GRACEFULLY = "Gracefully",
  /** Never */
  NEVER = "Never",
}

/**
 * ClusterAffinityTerm selects a set of cluster.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinities
 */
export interface ResourceBindingV1Alpha2SpecPlacementClusterAffinities {
  /**
   * AffinityName is the name of the cluster group.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinities#affinityName
   */
  readonly affinityName: string;

  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinities#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinities#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinities#fieldSelector
   */
  readonly fieldSelector?: ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinities#labelSelector
   */
  readonly labelSelector?: ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementClusterAffinities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinities(obj: ResourceBindingV1Alpha2SpecPlacementClusterAffinities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinityName': obj.affinityName,
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterAffinity represents scheduling restrictions to a certain set of clusters.
 * Note:
 * 1. ClusterAffinity can not co-exist with ClusterAffinities.
 * 2. If both ClusterAffinity and ClusterAffinities are not set, any cluster
 * can be scheduling candidates.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinity
 */
export interface ResourceBindingV1Alpha2SpecPlacementClusterAffinity {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinity#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinity#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinity#fieldSelector
   */
  readonly fieldSelector?: ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinity#labelSelector
   */
  readonly labelSelector?: ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementClusterAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinity(obj: ResourceBindingV1Alpha2SpecPlacementClusterAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementClusterTolerations
 */
export interface ResourceBindingV1Alpha2SpecPlacementClusterTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementClusterTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementClusterTolerations(obj: ResourceBindingV1Alpha2SpecPlacementClusterTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReplicaScheduling represents the scheduling policy on dealing with the number of replicas
 * when propagating resources that have replicas in spec (e.g. deployments, statefulsets) to member clusters.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementReplicaScheduling
 */
export interface ResourceBindingV1Alpha2SpecPlacementReplicaScheduling {
  /**
   * ReplicaDivisionPreference determines how the replicas is divided
   * when ReplicaSchedulingType is "Divided". Valid options are Aggregated and Weighted.
   * "Aggregated" divides replicas into clusters as few as possible,
   * while respecting clusters' resource availabilities during the division.
   * "Weighted" divides replicas by weight according to WeightPreference.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaScheduling#replicaDivisionPreference
   */
  readonly replicaDivisionPreference?: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingReplicaDivisionPreference;

  /**
   * ReplicaSchedulingType determines how the replicas is scheduled when karmada propagating
   * a resource. Valid options are Duplicated and Divided.
   * "Duplicated" duplicates the same replicas to each candidate member cluster from resource.
   * "Divided" divides replicas into parts according to number of valid candidate member
   * clusters, and exact replicas for each cluster are determined by ReplicaDivisionPreference.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaScheduling#replicaSchedulingType
   */
  readonly replicaSchedulingType?: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingReplicaSchedulingType;

  /**
   * WeightPreference describes weight for each cluster or for each group of cluster
   * If ReplicaDivisionPreference is set to "Weighted", and WeightPreference is not set, scheduler will weight all clusters the same.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaScheduling#weightPreference
   */
  readonly weightPreference?: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementReplicaScheduling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementReplicaScheduling(obj: ResourceBindingV1Alpha2SpecPlacementReplicaScheduling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replicaDivisionPreference': obj.replicaDivisionPreference,
    'replicaSchedulingType': obj.replicaSchedulingType,
    'weightPreference': toJson_ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference(obj.weightPreference),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SpreadConstraint represents the spread constraints on resources.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementSpreadConstraints
 */
export interface ResourceBindingV1Alpha2SpecPlacementSpreadConstraints {
  /**
   * MaxGroups restricts the maximum number of cluster groups to be selected.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementSpreadConstraints#maxGroups
   */
  readonly maxGroups?: number;

  /**
   * MinGroups restricts the minimum number of cluster groups to be selected.
   * Defaults to 1.
   *
   * @default 1.
   * @schema ResourceBindingV1Alpha2SpecPlacementSpreadConstraints#minGroups
   */
  readonly minGroups?: number;

  /**
   * SpreadByField represents the fields on Karmada cluster API used for
   * dynamically grouping member clusters into different groups.
   * Resources will be spread among different cluster groups.
   * Available fields for spreading are: cluster, region, zone, and provider.
   * SpreadByField should not co-exist with SpreadByLabel.
   * If both SpreadByField and SpreadByLabel are empty, SpreadByField will be set to "cluster" by system.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementSpreadConstraints#spreadByField
   */
  readonly spreadByField?: ResourceBindingV1Alpha2SpecPlacementSpreadConstraintsSpreadByField;

  /**
   * SpreadByLabel represents the label key used for
   * grouping member clusters into different groups.
   * Resources will be spread among different cluster groups.
   * SpreadByLabel should not co-exist with SpreadByField.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementSpreadConstraints#spreadByLabel
   */
  readonly spreadByLabel?: string;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementSpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementSpreadConstraints(obj: ResourceBindingV1Alpha2SpecPlacementSpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxGroups': obj.maxGroups,
    'minGroups': obj.minGroups,
    'spreadByField': obj.spreadByField,
    'spreadByLabel': obj.spreadByLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodeClaim represents the node claim HardNodeAffinity, NodeSelector and Tolerations required by each replica.
 *
 * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim
 */
export interface ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim {
  /**
   * A node selector represents the union of the results of one or more label queries over a set of
   * nodes; that is, it represents the OR of the selectors represented by the node selector terms.
   * Note that only PodSpec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution
   * is included here because it has a hard limit on pod scheduling.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim#hardNodeAffinity
   */
  readonly hardNodeAffinity?: ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * If specified, the pod's tolerations.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim#tolerations
   */
  readonly tolerations?: ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim(obj: ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hardNodeAffinity': toJson_ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity(obj.hardNodeAffinity),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tolerations': obj.tolerations?.map(y => toJson_ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsResourceRequest
 */
export class ResourceBindingV1Alpha2SpecReplicaRequirementsResourceRequest {
  public static fromNumber(value: number): ResourceBindingV1Alpha2SpecReplicaRequirementsResourceRequest {
    return new ResourceBindingV1Alpha2SpecReplicaRequirementsResourceRequest(value);
  }
  public static fromString(value: string): ResourceBindingV1Alpha2SpecReplicaRequirementsResourceRequest {
    return new ResourceBindingV1Alpha2SpecReplicaRequirementsResourceRequest(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * TargetCluster represents the identifier of a member cluster.
 *
 * @schema ResourceBindingV1Alpha2SpecRequiredByClusters
 */
export interface ResourceBindingV1Alpha2SpecRequiredByClusters {
  /**
   * Name of target cluster.
   *
   * @schema ResourceBindingV1Alpha2SpecRequiredByClusters#name
   */
  readonly name: string;

  /**
   * Replicas in target cluster
   *
   * @schema ResourceBindingV1Alpha2SpecRequiredByClusters#replicas
   */
  readonly replicas?: number;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecRequiredByClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecRequiredByClusters(obj: ResourceBindingV1Alpha2SpecRequiredByClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'replicas': obj.replicas,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DispatchingOnClusters declares a list of clusters to which the dispatching
 * should be suspended.
 * Note: Can not co-exist with Dispatching which is used to suspend all.
 *
 * @schema ResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters
 */
export interface ResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema ResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters#clusterNames
   */
  readonly clusterNames?: string[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters(obj: ResourceBindingV1Alpha2SpecSuspensionDispatchingOnClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodeClaim represents the node claim HardNodeAffinity, NodeSelector and Tolerations required by each replica.
 *
 * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim
 */
export interface ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim {
  /**
   * A node selector represents the union of the results of one or more label queries over a set of
   * nodes; that is, it represents the OR of the selectors represented by the node selector terms.
   * Note that only PodSpec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution
   * is included here because it has a hard limit on pod scheduling.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim#hardNodeAffinity
   */
  readonly hardNodeAffinity?: ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * If specified, the pod's tolerations.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim#tolerations
   */
  readonly tolerations?: ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim(obj: ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hardNodeAffinity': toJson_ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity(obj.hardNodeAffinity),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tolerations': obj.tolerations?.map(y => toJson_ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsResourceRequest
 */
export class ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsResourceRequest {
  public static fromNumber(value: number): ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsResourceRequest {
    return new ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsResourceRequest(value);
  }
  public static fromString(value: string): ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsResourceRequest {
    return new ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsResourceRequest(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * DecisionConditions indicates the decision conditions of performing the failover process.
 * Only when all conditions are met can the failover process be performed.
 * Currently, DecisionConditions includes several conditions:
 * - TolerationSeconds (optional)
 *
 * @schema ResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions
 */
export interface ResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions {
  /**
   * TolerationSeconds represents the period of time Karmada should wait
   * after reaching the desired state before performing failover process.
   * If not specified, Karmada will immediately perform failover process.
   * Defaults to 300s.
   *
   * @default 300s.
   * @schema ResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions#tolerationSeconds
   */
  readonly tolerationSeconds?: number;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions(obj: ResourceBindingV1Alpha2SpecFailoverApplicationDecisionConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tolerationSeconds': obj.tolerationSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PurgeMode represents how to deal with the legacy applications on the
 * cluster from which the application is migrated.
 * Valid options are "Directly", "Gracefully", "Never", "Immediately"(deprecated),
 * and "Graciously"(deprecated).
 * Defaults to "Gracefully".
 *
 * @default Gracefully".
 * @schema ResourceBindingV1Alpha2SpecFailoverApplicationPurgeMode
 */
export enum ResourceBindingV1Alpha2SpecFailoverApplicationPurgeMode {
  /** Directly */
  DIRECTLY = "Directly",
  /** Gracefully */
  GRACEFULLY = "Gracefully",
  /** Never */
  NEVER = "Never",
  /** Immediately */
  IMMEDIATELY = "Immediately",
  /** Graciously */
  GRACIOUSLY = "Graciously",
}

/**
 * StatePreservation defines the policy for preserving and restoring state data
 * during failover events for stateful applications.
 *
 * When an application fails over from one cluster to another, this policy enables
 * the extraction of critical data from the original resource configuration.
 * Upon successful migration, the extracted data is then re-injected into the new
 * resource, ensuring that the application can resume operation with its previous
 * state intact.
 * This is particularly useful for stateful applications where maintaining data
 * consistency across failover events is crucial.
 * If not specified, means no state data will be preserved.
 *
 * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
 * which is alpha.
 *
 * @schema ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation
 */
export interface ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation {
  /**
   * Rules contains a list of StatePreservationRule configurations.
   * Each rule specifies a JSONPath expression targeting specific pieces of
   * state data to be preserved during failover events. An AliasLabelName is associated
   * with each rule, serving as a label key when the preserved data is passed
   * to the new cluster.
   *
   * @schema ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation#rules
   */
  readonly rules: ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation(obj: ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PurgeMode represents how to deal with the legacy applications on the
 * cluster from which the application is migrated.
 * Valid options are "Directly", "Gracefully".
 * Defaults to "Gracefully".
 *
 * @default Gracefully".
 * @schema ResourceBindingV1Alpha2SpecFailoverClusterPurgeMode
 */
export enum ResourceBindingV1Alpha2SpecFailoverClusterPurgeMode {
  /** Directly */
  DIRECTLY = "Directly",
  /** Gracefully */
  GRACEFULLY = "Gracefully",
}

/**
 * StatePreservation defines the policy for preserving and restoring state data
 * during failover events for stateful applications.
 *
 * When an application fails over from one cluster to another, this policy enables
 * the extraction of critical data from the original resource configuration.
 * Upon successful migration, the extracted data is then re-injected into the new
 * resource, ensuring that the application can resume operation with its previous
 * state intact.
 * This is particularly useful for stateful applications where maintaining data
 * consistency across failover events is crucial.
 * If not specified, means no state data will be preserved.
 *
 * Note: This requires the StatefulFailoverInjection feature gate to be enabled,
 * which is alpha.
 *
 * @schema ResourceBindingV1Alpha2SpecFailoverClusterStatePreservation
 */
export interface ResourceBindingV1Alpha2SpecFailoverClusterStatePreservation {
  /**
   * Rules contains a list of StatePreservationRule configurations.
   * Each rule specifies a JSONPath expression targeting specific pieces of
   * state data to be preserved during failover events. An AliasLabelName is associated
   * with each rule, serving as a label key when the preserved data is passed
   * to the new cluster.
   *
   * @schema ResourceBindingV1Alpha2SpecFailoverClusterStatePreservation#rules
   */
  readonly rules: ResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecFailoverClusterStatePreservation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecFailoverClusterStatePreservation(obj: ResourceBindingV1Alpha2SpecFailoverClusterStatePreservation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_ResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector
 */
export interface ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector#matchExpressions
   */
  readonly matchExpressions?: ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector(obj: ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector
 */
export interface ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector(obj: ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector
 */
export interface ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector#matchExpressions
   */
  readonly matchExpressions?: ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector(obj: ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector
 */
export interface ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector(obj: ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReplicaDivisionPreference determines how the replicas is divided
 * when ReplicaSchedulingType is "Divided". Valid options are Aggregated and Weighted.
 * "Aggregated" divides replicas into clusters as few as possible,
 * while respecting clusters' resource availabilities during the division.
 * "Weighted" divides replicas by weight according to WeightPreference.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingReplicaDivisionPreference
 */
export enum ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingReplicaDivisionPreference {
  /** Aggregated */
  AGGREGATED = "Aggregated",
  /** Weighted */
  WEIGHTED = "Weighted",
}

/**
 * ReplicaSchedulingType determines how the replicas is scheduled when karmada propagating
 * a resource. Valid options are Duplicated and Divided.
 * "Duplicated" duplicates the same replicas to each candidate member cluster from resource.
 * "Divided" divides replicas into parts according to number of valid candidate member
 * clusters, and exact replicas for each cluster are determined by ReplicaDivisionPreference.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingReplicaSchedulingType
 */
export enum ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingReplicaSchedulingType {
  /** Duplicated */
  DUPLICATED = "Duplicated",
  /** Divided */
  DIVIDED = "Divided",
}

/**
 * WeightPreference describes weight for each cluster or for each group of cluster
 * If ReplicaDivisionPreference is set to "Weighted", and WeightPreference is not set, scheduler will weight all clusters the same.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference
 */
export interface ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference {
  /**
   * DynamicWeight specifies the factor to generates dynamic weight list.
   * If specified, StaticWeightList will be ignored.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference#dynamicWeight
   */
  readonly dynamicWeight?: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceDynamicWeight;

  /**
   * StaticWeightList defines the static cluster weight.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference#staticWeightList
   */
  readonly staticWeightList?: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference(obj: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dynamicWeight': obj.dynamicWeight,
    'staticWeightList': obj.staticWeightList?.map(y => toJson_ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SpreadByField represents the fields on Karmada cluster API used for
 * dynamically grouping member clusters into different groups.
 * Resources will be spread among different cluster groups.
 * Available fields for spreading are: cluster, region, zone, and provider.
 * SpreadByField should not co-exist with SpreadByLabel.
 * If both SpreadByField and SpreadByLabel are empty, SpreadByField will be set to "cluster" by system.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementSpreadConstraintsSpreadByField
 */
export enum ResourceBindingV1Alpha2SpecPlacementSpreadConstraintsSpreadByField {
  /** cluster */
  CLUSTER = "cluster",
  /** region */
  REGION = "region",
  /** zone */
  ZONE = "zone",
  /** provider */
  PROVIDER = "provider",
}

/**
 * A node selector represents the union of the results of one or more label queries over a set of
 * nodes; that is, it represents the OR of the selectors represented by the node selector terms.
 * Note that only PodSpec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution
 * is included here because it has a hard limit on pod scheduling.
 *
 * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity
 */
export interface ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity(obj: ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations
 */
export interface ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations(obj: ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector represents the union of the results of one or more label queries over a set of
 * nodes; that is, it represents the OR of the selectors represented by the node selector terms.
 * Note that only PodSpec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution
 * is included here because it has a hard limit on pod scheduling.
 *
 * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity
 */
export interface ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity(obj: ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations
 */
export interface ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations(obj: ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StatePreservationRule defines a single rule for state preservation.
 * It includes a JSONPath expression and an alias name that will be used
 * as a label key when passing state information to the new cluster.
 *
 * @schema ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules
 */
export interface ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules {
  /**
   * AliasLabelName is the name that will be used as a label key when the preserved
   * data is passed to the new cluster. This facilitates the injection of the
   * preserved state back into the application resources during recovery.
   *
   * @schema ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules#aliasLabelName
   */
  readonly aliasLabelName: string;

  /**
   * JSONPath is the JSONPath template used to identify the state data
   * to be preserved from the original resource configuration.
   * The JSONPath syntax follows the Kubernetes specification:
   * https://kubernetes.io/docs/reference/kubectl/jsonpath/
   *
   * Note: The JSONPath expression will start searching from the "status" field of
   * the API resource object by default. For example, to extract the "availableReplicas"
   * from a Deployment, the JSONPath expression should be "{.availableReplicas}", not
   * "{.status.availableReplicas}".
   *
   * @schema ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules#jsonPath
   */
  readonly jsonPath: string;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules(obj: ResourceBindingV1Alpha2SpecFailoverApplicationStatePreservationRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aliasLabelName': obj.aliasLabelName,
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StatePreservationRule defines a single rule for state preservation.
 * It includes a JSONPath expression and an alias name that will be used
 * as a label key when passing state information to the new cluster.
 *
 * @schema ResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules
 */
export interface ResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules {
  /**
   * AliasLabelName is the name that will be used as a label key when the preserved
   * data is passed to the new cluster. This facilitates the injection of the
   * preserved state back into the application resources during recovery.
   *
   * @schema ResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules#aliasLabelName
   */
  readonly aliasLabelName: string;

  /**
   * JSONPath is the JSONPath template used to identify the state data
   * to be preserved from the original resource configuration.
   * The JSONPath syntax follows the Kubernetes specification:
   * https://kubernetes.io/docs/reference/kubectl/jsonpath/
   *
   * Note: The JSONPath expression will start searching from the "status" field of
   * the API resource object by default. For example, to extract the "availableReplicas"
   * from a Deployment, the JSONPath expression should be "{.availableReplicas}", not
   * "{.status.availableReplicas}".
   *
   * @schema ResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules#jsonPath
   */
  readonly jsonPath: string;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules(obj: ResourceBindingV1Alpha2SpecFailoverClusterStatePreservationRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aliasLabelName': obj.aliasLabelName,
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions
 */
export interface ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions(obj: ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions
 */
export interface ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions(obj: ResourceBindingV1Alpha2SpecPlacementClusterAffinitiesLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions
 */
export interface ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions(obj: ResourceBindingV1Alpha2SpecPlacementClusterAffinityFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions
 */
export interface ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions(obj: ResourceBindingV1Alpha2SpecPlacementClusterAffinityLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DynamicWeight specifies the factor to generates dynamic weight list.
 * If specified, StaticWeightList will be ignored.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceDynamicWeight
 */
export enum ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceDynamicWeight {
  /** AvailableReplicas */
  AVAILABLE_REPLICAS = "AvailableReplicas",
}

/**
 * StaticClusterWeight defines the static cluster weight.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList
 */
export interface ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList {
  /**
   * TargetCluster describes the filter to select clusters.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList#targetCluster
   */
  readonly targetCluster: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster;

  /**
   * Weight expressing the preference to the cluster(s) specified by 'TargetCluster'.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList(obj: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetCluster': toJson_ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster(obj.targetCluster),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms
 */
export interface ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms#matchFields
   */
  readonly matchFields?: ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms(obj: ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms
 */
export interface ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms#matchFields
   */
  readonly matchFields?: ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms(obj: ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetCluster describes the filter to select clusters.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster
 */
export interface ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster {
  /**
   * ClusterNames is the list of clusters to be selected.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#clusterNames
   */
  readonly clusterNames?: string[];

  /**
   * ExcludedClusters is the list of clusters to be ignored.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#exclude
   */
  readonly exclude?: string[];

  /**
   * FieldSelector is a filter to select member clusters by fields.
   * The key(field) of the match expression should be 'provider', 'region', or 'zone',
   * and the operator of the match expression should be 'In' or 'NotIn'.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#fieldSelector
   */
  readonly fieldSelector?: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector;

  /**
   * LabelSelector is a filter to select member clusters by labels.
   * If non-nil and non-empty, only the clusters match this filter will be selected.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster#labelSelector
   */
  readonly labelSelector?: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector;
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster(obj: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterNames': obj.clusterNames?.map(y => y),
    'exclude': obj.exclude?.map(y => y),
    'fieldSelector': toJson_ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector(obj.fieldSelector),
    'labelSelector': toJson_ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector(obj.labelSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions
 */
export interface ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions(obj: ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields
 */
export interface ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields(obj: ResourceBindingV1Alpha2SpecReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions
 */
export interface ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions(obj: ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields
 */
export interface ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields(obj: ResourceBindingV1Alpha2SpecComponentsReplicaRequirementsNodeClaimHardNodeAffinityNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FieldSelector is a filter to select member clusters by fields.
 * The key(field) of the match expression should be 'provider', 'region', or 'zone',
 * and the operator of the match expression should be 'In' or 'NotIn'.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector
 */
export interface ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector {
  /**
   * A list of field selector requirements.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector#matchExpressions
   */
  readonly matchExpressions?: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector(obj: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a filter to select member clusters by labels.
 * If non-nil and non-empty, only the clusters match this filter will be selected.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector
 */
export interface ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector(obj: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions
 */
export interface ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions(obj: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterFieldSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions
 */
export interface ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions(obj: ResourceBindingV1Alpha2SpecPlacementReplicaSchedulingWeightPreferenceStaticWeightListTargetClusterLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * Work defines a list of resources to be deployed on the member cluster.
 *
 * @schema Work
 */
export class Work extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Work"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'work.karmada.io/v1alpha1',
    kind: 'Work',
  }

  /**
   * Renders a Kubernetes manifest for "Work".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkProps): any {
    return {
      ...Work.GVK,
      ...toJson_WorkProps(props),
    };
  }

  /**
   * Defines a "Work" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkProps) {
    super(scope, id, {
      ...Work.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Work.GVK,
      ...toJson_WorkProps(resolved),
    };
  }
}

/**
 * Work defines a list of resources to be deployed on the member cluster.
 *
 * @schema Work
 */
export interface WorkProps {
  /**
   * @schema Work#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec represents the desired behavior of Work.
   *
   * @schema Work#spec
   */
  readonly spec: WorkSpec;
}

/**
 * Converts an object of type 'WorkProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkProps(obj: WorkProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec represents the desired behavior of Work.
 *
 * @schema WorkSpec
 */
export interface WorkSpec {
  /**
   * PreserveResourcesOnDeletion controls whether resources should be preserved on the
   * member cluster when the Work object is deleted.
   * If set to true, resources will be preserved on the member cluster.
   * Default is false, which means resources will be deleted along with the Work object.
   *
   * @default false, which means resources will be deleted along with the Work object.
   * @schema WorkSpec#preserveResourcesOnDeletion
   */
  readonly preserveResourcesOnDeletion?: boolean;

  /**
   * SuspendDispatching controls whether dispatching should
   * be suspended, nil means not suspend.
   * Note: true means stop propagating to the corresponding member cluster, and
   * does not prevent status collection.
   *
   * @schema WorkSpec#suspendDispatching
   */
  readonly suspendDispatching?: boolean;

  /**
   * Workload represents the manifest workload to be deployed on managed cluster.
   *
   * @schema WorkSpec#workload
   */
  readonly workload?: WorkSpecWorkload;
}

/**
 * Converts an object of type 'WorkSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkSpec(obj: WorkSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preserveResourcesOnDeletion': obj.preserveResourcesOnDeletion,
    'suspendDispatching': obj.suspendDispatching,
    'workload': toJson_WorkSpecWorkload(obj.workload),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Workload represents the manifest workload to be deployed on managed cluster.
 *
 * @schema WorkSpecWorkload
 */
export interface WorkSpecWorkload {
  /**
   * Manifests represents a list of Kubernetes resources to be deployed on the managed cluster.
   *
   * @schema WorkSpecWorkload#manifests
   */
  readonly manifests?: any[];
}

/**
 * Converts an object of type 'WorkSpecWorkload' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkSpecWorkload(obj: WorkSpecWorkload | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'manifests': obj.manifests?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

