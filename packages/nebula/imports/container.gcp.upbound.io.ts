// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Cluster is the Schema for the Clusters API. Creates a Google Kubernetes Engine (GKE) cluster.
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'container.gcp.upbound.io/v1beta1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * Cluster is the Schema for the Clusters API. Creates a Google Kubernetes Engine (GKE) cluster.
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of Cluster
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;
}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterSpec defines the desired state of Cluster
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSpecDeletionPolicy;

  /**
   * @schema ClusterSpec#forProvider
   */
  readonly forProvider: ClusterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ClusterSpec#initProvider
   */
  readonly initProvider?: ClusterSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSpecForProvider(obj.forProvider),
    'initProvider': toJson_ClusterSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterSpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_ClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSpecDeletionPolicy
 */
export enum ClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterSpecForProvider
 */
export interface ClusterSpecForProvider {
  /**
   * The configuration for addons supported by GKE.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#addonsConfig
   */
  readonly addonsConfig?: ClusterSpecForProviderAddonsConfig[];

  /**
   * Enable NET_ADMIN for the cluster. Defaults to
   * false. This field should only be enabled for Autopilot clusters (enable_autopilot
   * set to true).
   *
   * @default false. This field should only be enabled for Autopilot clusters (enable_autopilot
   * @schema ClusterSpecForProvider#allowNetAdmin
   */
  readonly allowNetAdmin?: boolean;

  /**
   * Configuration for anonymous authentication restrictions. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#anonymousAuthenticationConfig
   */
  readonly anonymousAuthenticationConfig?: ClusterSpecForProviderAnonymousAuthenticationConfig[];

  /**
   * Configuration for the
   * Google Groups for GKE feature.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#authenticatorGroupsConfig
   */
  readonly authenticatorGroupsConfig?: ClusterSpecForProviderAuthenticatorGroupsConfig[];

  /**
   * Configuration options for the Binary
   * Authorization feature. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#binaryAuthorization
   */
  readonly binaryAuthorization?: ClusterSpecForProviderBinaryAuthorization[];

  /**
   * Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to
   * automatically adjust the size of the cluster and create/delete node pools based
   * on the current needs of the cluster's workload. See the
   * guide to using Node Auto-Provisioning
   * for more details. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#clusterAutoscaling
   */
  readonly clusterAutoscaling?: ClusterSpecForProviderClusterAutoscaling[];

  /**
   * The IP address range of the Kubernetes pods
   * in this cluster in CIDR notation (e.g. 10.96.0.0/14). Leave blank to have one
   * automatically chosen or specify a /14 block in 10.0.0.0/8. This field will
   * default a new cluster to routes-based, where ip_allocation_policy is not defined.
   *
   * @schema ClusterSpecForProvider#clusterIpv4Cidr
   */
  readonly clusterIpv4Cidr?: string;

  /**
   * Configuration for Confidential Nodes feature. Structure is documented below documented below.
   *
   * @schema ClusterSpecForProvider#confidentialNodes
   */
  readonly confidentialNodes?: ClusterSpecForProviderConfidentialNodes[];

  /**
   * Configuration for all of the cluster's control plane endpoints.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#controlPlaneEndpointsConfig
   */
  readonly controlPlaneEndpointsConfig?: ClusterSpecForProviderControlPlaneEndpointsConfig[];

  /**
   * Configuration for the
   * Cost Allocation feature.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#costManagementConfig
   */
  readonly costManagementConfig?: ClusterSpecForProviderCostManagementConfig[];

  /**
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#databaseEncryption
   */
  readonly databaseEncryption?: ClusterSpecForProviderDatabaseEncryption[];

  /**
   * The desired datapath provider for this cluster. This is set to LEGACY_DATAPATH by default, which uses the IPTables-based kube-proxy implementation. Set to ADVANCED_DATAPATH to enable Dataplane v2.
   *
   * @schema ClusterSpecForProvider#datapathProvider
   */
  readonly datapathProvider?: string;

  /**
   * The default maximum number of pods
   * per node in this cluster. This doesn't work on "routes-based" clusters, clusters
   * that don't have IP Aliasing enabled. See the official documentation
   * for more information.
   *
   * @schema ClusterSpecForProvider#defaultMaxPodsPerNode
   */
  readonly defaultMaxPodsPerNode?: number;

  /**
   * GKE SNAT DefaultSnatStatus contains the desired state of whether default sNAT should be disabled on the cluster, API doc. Structure is documented below
   *
   * @schema ClusterSpecForProvider#defaultSnatStatus
   */
  readonly defaultSnatStatus?: ClusterSpecForProviderDefaultSnatStatus[];

  /**
   * @schema ClusterSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * Description of the cluster.
   *
   * @schema ClusterSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Disable L4 load balancer VPC firewalls to enable firewall policies.
   *
   * @schema ClusterSpecForProvider#disableL4LbFirewallReconciliation
   */
  readonly disableL4LbFirewallReconciliation?: boolean;

  /**
   * Configuration for Using Cloud DNS for GKE. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#dnsConfig
   */
  readonly dnsConfig?: ClusterSpecForProviderDnsConfig[];

  /**
   * Enable Autopilot for this cluster. Defaults to false.
   * Note that when this option is enabled, certain features of Standard GKE are not available.
   * See the official documentation
   * for available features.
   *
   * @default false.
   * @schema ClusterSpecForProvider#enableAutopilot
   */
  readonly enableAutopilot?: boolean;

  /**
   * Whether CiliumClusterWideNetworkPolicy is enabled on this cluster. Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecForProvider#enableCiliumClusterwideNetworkPolicy
   */
  readonly enableCiliumClusterwideNetworkPolicy?: boolean;

  /**
   * Whether FQDN Network Policy is enabled on this cluster. Users who enable this feature for existing Standard clusters must restart the GKE Dataplane V2 anetd DaemonSet after enabling it. See the Enable FQDN Network Policy in an existing cluster for more information.
   *
   * @schema ClusterSpecForProvider#enableFqdnNetworkPolicy
   */
  readonly enableFqdnNetworkPolicy?: boolean;

  /**
   * Whether Intra-node visibility is enabled for this cluster. This makes same node pod to pod traffic visible for VPC network.
   *
   * @schema ClusterSpecForProvider#enableIntranodeVisibility
   */
  readonly enableIntranodeVisibility?: boolean;

  /**
   * Configuration for Kubernetes Beta APIs.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#enableK8SBetaApis
   */
  readonly enableK8SBetaApis?: ClusterSpecForProviderEnableK8SBetaApis[];

  /**
   * Whether to enable Kubernetes Alpha features for
   * this cluster. Note that when this option is enabled, the cluster cannot be upgraded
   * and will be automatically deleted after 30 days.
   *
   * @schema ClusterSpecForProvider#enableKubernetesAlpha
   */
  readonly enableKubernetesAlpha?: boolean;

  /**
   * Whether L4ILB Subsetting is enabled for this cluster.
   *
   * @schema ClusterSpecForProvider#enableL4IlbSubsetting
   */
  readonly enableL4IlbSubsetting?: boolean;

  /**
   * Whether the ABAC authorizer is enabled for this cluster.
   * When enabled, identities in the system, including service accounts, nodes, and controllers,
   * will have statically granted permissions beyond those provided by the RBAC configuration or IAM.
   * Defaults to false
   *
   * @default false
   * @schema ClusterSpecForProvider#enableLegacyAbac
   */
  readonly enableLegacyAbac?: boolean;

  /**
   * Whether multi-networking is enabled for this cluster.
   *
   * @schema ClusterSpecForProvider#enableMultiNetworking
   */
  readonly enableMultiNetworking?: boolean;

  /**
   * Enable Shielded Nodes features on all nodes in this cluster.  Defaults to true.
   *
   * @default true.
   * @schema ClusterSpecForProvider#enableShieldedNodes
   */
  readonly enableShieldedNodes?: boolean;

  /**
   * Whether to enable Cloud TPU resources in this cluster.
   * See the official documentation.
   *
   * @schema ClusterSpecForProvider#enableTpu
   */
  readonly enableTpu?: boolean;

  /**
   * Configuration for [Enterprise edition].(https://cloud.google.com/kubernetes-engine/enterprise/docs/concepts/gke-editions). Structure is documented below.
   *
   * @schema ClusterSpecForProvider#enterpriseConfig
   */
  readonly enterpriseConfig?: ClusterSpecForProviderEnterpriseConfig[];

  /**
   * Fleet configuration for the cluster. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#fleet
   */
  readonly fleet?: ClusterSpecForProviderFleet[];

  /**
   * Configuration for GKE Gateway API controller. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#gatewayApiConfig
   */
  readonly gatewayApiConfig?: ClusterSpecForProviderGatewayApiConfig[];

  /**
   * Configuration options for the auto-upgrade patch type feature, which provide more control over the speed of automatic upgrades of your GKE clusters.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#gkeAutoUpgradeConfig
   */
  readonly gkeAutoUpgradeConfig?: ClusterSpecForProviderGkeAutoUpgradeConfig[];

  /**
   * . Structure is documented below.
   *
   * @schema ClusterSpecForProvider#identityServiceConfig
   */
  readonly identityServiceConfig?: ClusterSpecForProviderIdentityServiceConfig[];

  /**
   * Defines the config of in-transit encryption. Valid values are IN_TRANSIT_ENCRYPTION_DISABLED and IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT.
   *
   * @schema ClusterSpecForProvider#inTransitEncryptionConfig
   */
  readonly inTransitEncryptionConfig?: string;

  /**
   * The number of nodes to create in this
   * cluster's default node pool. In regional or multi-zonal clusters, this is the
   * number of nodes per zone. Must be set if node_pool is not set. If you're using
   * google_container_node_pool objects with no default node pool, you'll need to
   * set this to a value of at least 1, alongside setting
   * remove_default_node_pool to true.
   *
   * @schema ClusterSpecForProvider#initialNodeCount
   */
  readonly initialNodeCount?: number;

  /**
   * Configuration of cluster IP allocation for
   * VPC-native clusters. If this block is unset during creation, it will be set by the GKE backend.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#ipAllocationPolicy
   */
  readonly ipAllocationPolicy?: ClusterSpecForProviderIpAllocationPolicy[];

  /**
   * The location (region or zone) in which the cluster
   * master will be created, as well as the default node location. If you specify a
   * zone (such as us-central1-a), the cluster will be a zonal cluster with a
   * single cluster master. If you specify a region (such as us-west1), the
   * cluster will be a regional cluster with multiple masters spread across zones in
   * the region, and with default node locations in those zones as well
   *
   * @schema ClusterSpecForProvider#location
   */
  readonly location: string;

  /**
   * Logging configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#loggingConfig
   */
  readonly loggingConfig?: ClusterSpecForProviderLoggingConfig[];

  /**
   * The logging service that the cluster should
   * write logs to. Available options include logging.googleapis.com(Legacy Stackdriver),
   * logging.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Logging), and none. Defaults to logging.googleapis.com/kubernetes
   *
   * @default logging.googleapis.com/kubernetes
   * @schema ClusterSpecForProvider#loggingService
   */
  readonly loggingService?: string;

  /**
   * The maintenance policy to use for the cluster. Structure is
   * documented below.
   *
   * @schema ClusterSpecForProvider#maintenancePolicy
   */
  readonly maintenancePolicy?: ClusterSpecForProviderMaintenancePolicy[];

  /**
   * The authentication information for accessing the
   * Kubernetes master. Some values in this block are only returned by the API if
   * your service account has permission to get credentials for your GKE cluster. If
   * you see an unexpected diff unsetting your client cert, ensure you have the
   * container.clusters.getCredentials permission.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#masterAuth
   */
  readonly masterAuth?: ClusterSpecForProviderMasterAuth[];

  /**
   * The desired
   * configuration options for master authorized networks. Omit the
   * nested cidr_blocks attribute to disallow external access (except
   * the cluster node IPs, which GKE automatically whitelists).
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#masterAuthorizedNetworksConfig
   */
  readonly masterAuthorizedNetworksConfig?: ClusterSpecForProviderMasterAuthorizedNetworksConfig[];

  /**
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#meshCertificates
   */
  readonly meshCertificates?: ClusterSpecForProviderMeshCertificates[];

  /**
   * The minimum version of the master. GKE
   * will auto-update the master to new versions, so this does not guarantee the
   * current master version--use the read-only master_version field to obtain that.
   * If unset, the cluster's version will be set by GKE to the version of the most recent
   * official release (which is not necessarily the latest version). If you intend to specify versions manually,
   * the docs
   * describe the various acceptable formats for this field.
   *
   * @schema ClusterSpecForProvider#minMasterVersion
   */
  readonly minMasterVersion?: string;

  /**
   * Monitoring configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#monitoringConfig
   */
  readonly monitoringConfig?: ClusterSpecForProviderMonitoringConfig[];

  /**
   * The monitoring service that the cluster
   * should write metrics to.
   * Automatically send metrics from pods in the cluster to the Google Cloud Monitoring API.
   * VM metrics will be collected by Google Compute Engine regardless of this setting
   * Available options include
   * monitoring.googleapis.com(Legacy Stackdriver), monitoring.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Monitoring), and none.
   * Defaults to monitoring.googleapis.com/kubernetes
   *
   * @default monitoring.googleapis.com/kubernetes
   * @schema ClusterSpecForProvider#monitoringService
   */
  readonly monitoringService?: string;

  /**
   * The name or self_link of the Google Compute Engine
   * network to which the cluster is connected. For Shared VPC, set this to the self link of the
   * shared network.
   *
   * @schema ClusterSpecForProvider#network
   */
  readonly network?: string;

  /**
   * Network bandwidth tier configuration. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#networkPerformanceConfig
   */
  readonly networkPerformanceConfig?: ClusterSpecForProviderNetworkPerformanceConfig[];

  /**
   * Configuration options for the
   * NetworkPolicy
   * feature. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#networkPolicy
   */
  readonly networkPolicy?: ClusterSpecForProviderNetworkPolicy[];

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema ClusterSpecForProvider#networkRef
   */
  readonly networkRef?: ClusterSpecForProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema ClusterSpecForProvider#networkSelector
   */
  readonly networkSelector?: ClusterSpecForProviderNetworkSelector;

  /**
   * Determines whether alias IPs or routes will be used for pod IPs in the cluster.
   * Options are VPC_NATIVE or ROUTES. VPC_NATIVE enables IP aliasing. Newly created clusters will default to VPC_NATIVE.
   *
   * @schema ClusterSpecForProvider#networkingMode
   */
  readonly networkingMode?: string;

  /**
   * Parameters used in creating the default node pool. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#nodeConfig
   */
  readonly nodeConfig?: ClusterSpecForProviderNodeConfig[];

  /**
   * The list of zones in which the cluster's nodes
   * are located. Nodes must be in the region of their regional cluster or in the
   * same region as their cluster's zone for zonal clusters. If this is specified for
   * a zonal cluster, omit the cluster's zone.
   *
   * @schema ClusterSpecForProvider#nodeLocations
   */
  readonly nodeLocations?: string[];

  /**
   * Node pool configs that apply to auto-provisioned node pools in
   * autopilot clusters and
   * node auto-provisioning-enabled clusters. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#nodePoolAutoConfig
   */
  readonly nodePoolAutoConfig?: ClusterSpecForProviderNodePoolAutoConfig[];

  /**
   * Default NodePool settings for the entire cluster. These settings are overridden if specified on the specific NodePool object. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#nodePoolDefaults
   */
  readonly nodePoolDefaults?: ClusterSpecForProviderNodePoolDefaults[];

  /**
   * The Kubernetes version on the nodes. Must either be unset
   * or set to the same value as min_master_version on create. Defaults to the default
   * version set by GKE which is not necessarily the latest version. This only affects
   * nodes in the default node pool.
   * To update nodes in other node pools, use the version attribute on the node pool.
   *
   * @default the default
   * @schema ClusterSpecForProvider#nodeVersion
   */
  readonly nodeVersion?: string;

  /**
   * Configuration for the cluster upgrade notifications feature. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#notificationConfig
   */
  readonly notificationConfig?: ClusterSpecForProviderNotificationConfig[];

  /**
   * Configuration for the
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#podAutoscaling
   */
  readonly podAutoscaling?: ClusterSpecForProviderPodAutoscaling[];

  /**
   * Configuration for private clusters,
   * clusters with private nodes. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#privateClusterConfig
   */
  readonly privateClusterConfig?: ClusterSpecForProviderPrivateClusterConfig[];

  /**
   * The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4).
   *
   * @schema ClusterSpecForProvider#privateIpv6GoogleAccess
   */
  readonly privateIpv6GoogleAccess?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema ClusterSpecForProvider#project
   */
  readonly project?: string;

  /**
   * RBACBindingConfig allows user to restrict ClusterRoleBindings an RoleBindings that can be created. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#rbacBindingConfig
   */
  readonly rbacBindingConfig?: ClusterSpecForProviderRbacBindingConfig[];

  /**
   * Configuration options for the Release channel
   * feature, which provide more control over automatic upgrades of your GKE clusters.
   * When updating this field, GKE imposes specific version requirements. See
   * Selecting a new release channel
   * for more details; the google_container_engine_versions datasource can provide
   * the default version for a channel. Instead, use the "UNSPECIFIED"
   * channel. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#releaseChannel
   */
  readonly releaseChannel?: ClusterSpecForProviderReleaseChannel[];

  /**
   * If true, deletes the default node
   * pool upon cluster creation. If you're using google_container_node_pool
   * resources with no default node pool, this should be set to true, alongside
   * setting initial_node_count to at least 1.
   *
   * @schema ClusterSpecForProvider#removeDefaultNodePool
   */
  readonly removeDefaultNodePool?: boolean;

  /**
   * The GCE resource labels (a map of key/value pairs) to be applied to the cluster.
   *
   * @schema ClusterSpecForProvider#resourceLabels
   */
  readonly resourceLabels?: { [key: string]: string };

  /**
   * Configuration for the
   * ResourceUsageExportConfig feature.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#resourceUsageExportConfig
   */
  readonly resourceUsageExportConfig?: ClusterSpecForProviderResourceUsageExportConfig[];

  /**
   * Configuration for the
   * SecretManagerConfig feature.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#secretManagerConfig
   */
  readonly secretManagerConfig?: ClusterSpecForProviderSecretManagerConfig[];

  /**
   * Enable/Disable Security Posture API features for the cluster. Structure is documented below.
   *
   * @schema ClusterSpecForProvider#securityPostureConfig
   */
  readonly securityPostureConfig?: ClusterSpecForProviderSecurityPostureConfig[];

  /**
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#serviceExternalIpsConfig
   */
  readonly serviceExternalIpsConfig?: ClusterSpecForProviderServiceExternalIpsConfig[];

  /**
   * The name or self_link of the Google Compute Engine
   * subnetwork in which the cluster's instances are launched.
   *
   * @schema ClusterSpecForProvider#subnetwork
   */
  readonly subnetwork?: string;

  /**
   * Reference to a Subnetwork in compute to populate subnetwork.
   *
   * @schema ClusterSpecForProvider#subnetworkRef
   */
  readonly subnetworkRef?: ClusterSpecForProviderSubnetworkRef;

  /**
   * Selector for a Subnetwork in compute to populate subnetwork.
   *
   * @schema ClusterSpecForProvider#subnetworkSelector
   */
  readonly subnetworkSelector?: ClusterSpecForProviderSubnetworkSelector;

  /**
   * The custom keys configuration of the cluster Structure is documented below.
   *
   * @schema ClusterSpecForProvider#userManagedKeysConfig
   */
  readonly userManagedKeysConfig?: ClusterSpecForProviderUserManagedKeysConfig[];

  /**
   * Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#verticalPodAutoscaling
   */
  readonly verticalPodAutoscaling?: ClusterSpecForProviderVerticalPodAutoscaling[];

  /**
   * Workload Identity allows Kubernetes service accounts to act as a user-managed
   * Google IAM Service Account.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProvider#workloadIdentityConfig
   */
  readonly workloadIdentityConfig?: ClusterSpecForProviderWorkloadIdentityConfig[];
}

/**
 * Converts an object of type 'ClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProvider(obj: ClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addonsConfig': obj.addonsConfig?.map(y => toJson_ClusterSpecForProviderAddonsConfig(y)),
    'allowNetAdmin': obj.allowNetAdmin,
    'anonymousAuthenticationConfig': obj.anonymousAuthenticationConfig?.map(y => toJson_ClusterSpecForProviderAnonymousAuthenticationConfig(y)),
    'authenticatorGroupsConfig': obj.authenticatorGroupsConfig?.map(y => toJson_ClusterSpecForProviderAuthenticatorGroupsConfig(y)),
    'binaryAuthorization': obj.binaryAuthorization?.map(y => toJson_ClusterSpecForProviderBinaryAuthorization(y)),
    'clusterAutoscaling': obj.clusterAutoscaling?.map(y => toJson_ClusterSpecForProviderClusterAutoscaling(y)),
    'clusterIpv4Cidr': obj.clusterIpv4Cidr,
    'confidentialNodes': obj.confidentialNodes?.map(y => toJson_ClusterSpecForProviderConfidentialNodes(y)),
    'controlPlaneEndpointsConfig': obj.controlPlaneEndpointsConfig?.map(y => toJson_ClusterSpecForProviderControlPlaneEndpointsConfig(y)),
    'costManagementConfig': obj.costManagementConfig?.map(y => toJson_ClusterSpecForProviderCostManagementConfig(y)),
    'databaseEncryption': obj.databaseEncryption?.map(y => toJson_ClusterSpecForProviderDatabaseEncryption(y)),
    'datapathProvider': obj.datapathProvider,
    'defaultMaxPodsPerNode': obj.defaultMaxPodsPerNode,
    'defaultSnatStatus': obj.defaultSnatStatus?.map(y => toJson_ClusterSpecForProviderDefaultSnatStatus(y)),
    'deletionProtection': obj.deletionProtection,
    'description': obj.description,
    'disableL4LbFirewallReconciliation': obj.disableL4LbFirewallReconciliation,
    'dnsConfig': obj.dnsConfig?.map(y => toJson_ClusterSpecForProviderDnsConfig(y)),
    'enableAutopilot': obj.enableAutopilot,
    'enableCiliumClusterwideNetworkPolicy': obj.enableCiliumClusterwideNetworkPolicy,
    'enableFqdnNetworkPolicy': obj.enableFqdnNetworkPolicy,
    'enableIntranodeVisibility': obj.enableIntranodeVisibility,
    'enableK8SBetaApis': obj.enableK8SBetaApis?.map(y => toJson_ClusterSpecForProviderEnableK8SBetaApis(y)),
    'enableKubernetesAlpha': obj.enableKubernetesAlpha,
    'enableL4IlbSubsetting': obj.enableL4IlbSubsetting,
    'enableLegacyAbac': obj.enableLegacyAbac,
    'enableMultiNetworking': obj.enableMultiNetworking,
    'enableShieldedNodes': obj.enableShieldedNodes,
    'enableTpu': obj.enableTpu,
    'enterpriseConfig': obj.enterpriseConfig?.map(y => toJson_ClusterSpecForProviderEnterpriseConfig(y)),
    'fleet': obj.fleet?.map(y => toJson_ClusterSpecForProviderFleet(y)),
    'gatewayApiConfig': obj.gatewayApiConfig?.map(y => toJson_ClusterSpecForProviderGatewayApiConfig(y)),
    'gkeAutoUpgradeConfig': obj.gkeAutoUpgradeConfig?.map(y => toJson_ClusterSpecForProviderGkeAutoUpgradeConfig(y)),
    'identityServiceConfig': obj.identityServiceConfig?.map(y => toJson_ClusterSpecForProviderIdentityServiceConfig(y)),
    'inTransitEncryptionConfig': obj.inTransitEncryptionConfig,
    'initialNodeCount': obj.initialNodeCount,
    'ipAllocationPolicy': obj.ipAllocationPolicy?.map(y => toJson_ClusterSpecForProviderIpAllocationPolicy(y)),
    'location': obj.location,
    'loggingConfig': obj.loggingConfig?.map(y => toJson_ClusterSpecForProviderLoggingConfig(y)),
    'loggingService': obj.loggingService,
    'maintenancePolicy': obj.maintenancePolicy?.map(y => toJson_ClusterSpecForProviderMaintenancePolicy(y)),
    'masterAuth': obj.masterAuth?.map(y => toJson_ClusterSpecForProviderMasterAuth(y)),
    'masterAuthorizedNetworksConfig': obj.masterAuthorizedNetworksConfig?.map(y => toJson_ClusterSpecForProviderMasterAuthorizedNetworksConfig(y)),
    'meshCertificates': obj.meshCertificates?.map(y => toJson_ClusterSpecForProviderMeshCertificates(y)),
    'minMasterVersion': obj.minMasterVersion,
    'monitoringConfig': obj.monitoringConfig?.map(y => toJson_ClusterSpecForProviderMonitoringConfig(y)),
    'monitoringService': obj.monitoringService,
    'network': obj.network,
    'networkPerformanceConfig': obj.networkPerformanceConfig?.map(y => toJson_ClusterSpecForProviderNetworkPerformanceConfig(y)),
    'networkPolicy': obj.networkPolicy?.map(y => toJson_ClusterSpecForProviderNetworkPolicy(y)),
    'networkRef': toJson_ClusterSpecForProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_ClusterSpecForProviderNetworkSelector(obj.networkSelector),
    'networkingMode': obj.networkingMode,
    'nodeConfig': obj.nodeConfig?.map(y => toJson_ClusterSpecForProviderNodeConfig(y)),
    'nodeLocations': obj.nodeLocations?.map(y => y),
    'nodePoolAutoConfig': obj.nodePoolAutoConfig?.map(y => toJson_ClusterSpecForProviderNodePoolAutoConfig(y)),
    'nodePoolDefaults': obj.nodePoolDefaults?.map(y => toJson_ClusterSpecForProviderNodePoolDefaults(y)),
    'nodeVersion': obj.nodeVersion,
    'notificationConfig': obj.notificationConfig?.map(y => toJson_ClusterSpecForProviderNotificationConfig(y)),
    'podAutoscaling': obj.podAutoscaling?.map(y => toJson_ClusterSpecForProviderPodAutoscaling(y)),
    'privateClusterConfig': obj.privateClusterConfig?.map(y => toJson_ClusterSpecForProviderPrivateClusterConfig(y)),
    'privateIpv6GoogleAccess': obj.privateIpv6GoogleAccess,
    'project': obj.project,
    'rbacBindingConfig': obj.rbacBindingConfig?.map(y => toJson_ClusterSpecForProviderRbacBindingConfig(y)),
    'releaseChannel': obj.releaseChannel?.map(y => toJson_ClusterSpecForProviderReleaseChannel(y)),
    'removeDefaultNodePool': obj.removeDefaultNodePool,
    'resourceLabels': ((obj.resourceLabels) === undefined) ? undefined : (Object.entries(obj.resourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceUsageExportConfig': obj.resourceUsageExportConfig?.map(y => toJson_ClusterSpecForProviderResourceUsageExportConfig(y)),
    'secretManagerConfig': obj.secretManagerConfig?.map(y => toJson_ClusterSpecForProviderSecretManagerConfig(y)),
    'securityPostureConfig': obj.securityPostureConfig?.map(y => toJson_ClusterSpecForProviderSecurityPostureConfig(y)),
    'serviceExternalIpsConfig': obj.serviceExternalIpsConfig?.map(y => toJson_ClusterSpecForProviderServiceExternalIpsConfig(y)),
    'subnetwork': obj.subnetwork,
    'subnetworkRef': toJson_ClusterSpecForProviderSubnetworkRef(obj.subnetworkRef),
    'subnetworkSelector': toJson_ClusterSpecForProviderSubnetworkSelector(obj.subnetworkSelector),
    'userManagedKeysConfig': obj.userManagedKeysConfig?.map(y => toJson_ClusterSpecForProviderUserManagedKeysConfig(y)),
    'verticalPodAutoscaling': obj.verticalPodAutoscaling?.map(y => toJson_ClusterSpecForProviderVerticalPodAutoscaling(y)),
    'workloadIdentityConfig': obj.workloadIdentityConfig?.map(y => toJson_ClusterSpecForProviderWorkloadIdentityConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ClusterSpecInitProvider
 */
export interface ClusterSpecInitProvider {
  /**
   * The configuration for addons supported by GKE.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#addonsConfig
   */
  readonly addonsConfig?: ClusterSpecInitProviderAddonsConfig[];

  /**
   * Enable NET_ADMIN for the cluster. Defaults to
   * false. This field should only be enabled for Autopilot clusters (enable_autopilot
   * set to true).
   *
   * @default false. This field should only be enabled for Autopilot clusters (enable_autopilot
   * @schema ClusterSpecInitProvider#allowNetAdmin
   */
  readonly allowNetAdmin?: boolean;

  /**
   * Configuration for anonymous authentication restrictions. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#anonymousAuthenticationConfig
   */
  readonly anonymousAuthenticationConfig?: ClusterSpecInitProviderAnonymousAuthenticationConfig[];

  /**
   * Configuration for the
   * Google Groups for GKE feature.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#authenticatorGroupsConfig
   */
  readonly authenticatorGroupsConfig?: ClusterSpecInitProviderAuthenticatorGroupsConfig[];

  /**
   * Configuration options for the Binary
   * Authorization feature. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#binaryAuthorization
   */
  readonly binaryAuthorization?: ClusterSpecInitProviderBinaryAuthorization[];

  /**
   * Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to
   * automatically adjust the size of the cluster and create/delete node pools based
   * on the current needs of the cluster's workload. See the
   * guide to using Node Auto-Provisioning
   * for more details. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#clusterAutoscaling
   */
  readonly clusterAutoscaling?: ClusterSpecInitProviderClusterAutoscaling[];

  /**
   * The IP address range of the Kubernetes pods
   * in this cluster in CIDR notation (e.g. 10.96.0.0/14). Leave blank to have one
   * automatically chosen or specify a /14 block in 10.0.0.0/8. This field will
   * default a new cluster to routes-based, where ip_allocation_policy is not defined.
   *
   * @schema ClusterSpecInitProvider#clusterIpv4Cidr
   */
  readonly clusterIpv4Cidr?: string;

  /**
   * Configuration for Confidential Nodes feature. Structure is documented below documented below.
   *
   * @schema ClusterSpecInitProvider#confidentialNodes
   */
  readonly confidentialNodes?: ClusterSpecInitProviderConfidentialNodes[];

  /**
   * Configuration for all of the cluster's control plane endpoints.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#controlPlaneEndpointsConfig
   */
  readonly controlPlaneEndpointsConfig?: ClusterSpecInitProviderControlPlaneEndpointsConfig[];

  /**
   * Configuration for the
   * Cost Allocation feature.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#costManagementConfig
   */
  readonly costManagementConfig?: ClusterSpecInitProviderCostManagementConfig[];

  /**
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#databaseEncryption
   */
  readonly databaseEncryption?: ClusterSpecInitProviderDatabaseEncryption[];

  /**
   * The desired datapath provider for this cluster. This is set to LEGACY_DATAPATH by default, which uses the IPTables-based kube-proxy implementation. Set to ADVANCED_DATAPATH to enable Dataplane v2.
   *
   * @schema ClusterSpecInitProvider#datapathProvider
   */
  readonly datapathProvider?: string;

  /**
   * The default maximum number of pods
   * per node in this cluster. This doesn't work on "routes-based" clusters, clusters
   * that don't have IP Aliasing enabled. See the official documentation
   * for more information.
   *
   * @schema ClusterSpecInitProvider#defaultMaxPodsPerNode
   */
  readonly defaultMaxPodsPerNode?: number;

  /**
   * GKE SNAT DefaultSnatStatus contains the desired state of whether default sNAT should be disabled on the cluster, API doc. Structure is documented below
   *
   * @schema ClusterSpecInitProvider#defaultSnatStatus
   */
  readonly defaultSnatStatus?: ClusterSpecInitProviderDefaultSnatStatus[];

  /**
   * @schema ClusterSpecInitProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * Description of the cluster.
   *
   * @schema ClusterSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Disable L4 load balancer VPC firewalls to enable firewall policies.
   *
   * @schema ClusterSpecInitProvider#disableL4LbFirewallReconciliation
   */
  readonly disableL4LbFirewallReconciliation?: boolean;

  /**
   * Configuration for Using Cloud DNS for GKE. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#dnsConfig
   */
  readonly dnsConfig?: ClusterSpecInitProviderDnsConfig[];

  /**
   * Enable Autopilot for this cluster. Defaults to false.
   * Note that when this option is enabled, certain features of Standard GKE are not available.
   * See the official documentation
   * for available features.
   *
   * @default false.
   * @schema ClusterSpecInitProvider#enableAutopilot
   */
  readonly enableAutopilot?: boolean;

  /**
   * Whether CiliumClusterWideNetworkPolicy is enabled on this cluster. Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecInitProvider#enableCiliumClusterwideNetworkPolicy
   */
  readonly enableCiliumClusterwideNetworkPolicy?: boolean;

  /**
   * Whether FQDN Network Policy is enabled on this cluster. Users who enable this feature for existing Standard clusters must restart the GKE Dataplane V2 anetd DaemonSet after enabling it. See the Enable FQDN Network Policy in an existing cluster for more information.
   *
   * @schema ClusterSpecInitProvider#enableFqdnNetworkPolicy
   */
  readonly enableFqdnNetworkPolicy?: boolean;

  /**
   * Whether Intra-node visibility is enabled for this cluster. This makes same node pod to pod traffic visible for VPC network.
   *
   * @schema ClusterSpecInitProvider#enableIntranodeVisibility
   */
  readonly enableIntranodeVisibility?: boolean;

  /**
   * Configuration for Kubernetes Beta APIs.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#enableK8SBetaApis
   */
  readonly enableK8SBetaApis?: ClusterSpecInitProviderEnableK8SBetaApis[];

  /**
   * Whether to enable Kubernetes Alpha features for
   * this cluster. Note that when this option is enabled, the cluster cannot be upgraded
   * and will be automatically deleted after 30 days.
   *
   * @schema ClusterSpecInitProvider#enableKubernetesAlpha
   */
  readonly enableKubernetesAlpha?: boolean;

  /**
   * Whether L4ILB Subsetting is enabled for this cluster.
   *
   * @schema ClusterSpecInitProvider#enableL4IlbSubsetting
   */
  readonly enableL4IlbSubsetting?: boolean;

  /**
   * Whether the ABAC authorizer is enabled for this cluster.
   * When enabled, identities in the system, including service accounts, nodes, and controllers,
   * will have statically granted permissions beyond those provided by the RBAC configuration or IAM.
   * Defaults to false
   *
   * @default false
   * @schema ClusterSpecInitProvider#enableLegacyAbac
   */
  readonly enableLegacyAbac?: boolean;

  /**
   * Whether multi-networking is enabled for this cluster.
   *
   * @schema ClusterSpecInitProvider#enableMultiNetworking
   */
  readonly enableMultiNetworking?: boolean;

  /**
   * Enable Shielded Nodes features on all nodes in this cluster.  Defaults to true.
   *
   * @default true.
   * @schema ClusterSpecInitProvider#enableShieldedNodes
   */
  readonly enableShieldedNodes?: boolean;

  /**
   * Whether to enable Cloud TPU resources in this cluster.
   * See the official documentation.
   *
   * @schema ClusterSpecInitProvider#enableTpu
   */
  readonly enableTpu?: boolean;

  /**
   * Configuration for [Enterprise edition].(https://cloud.google.com/kubernetes-engine/enterprise/docs/concepts/gke-editions). Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#enterpriseConfig
   */
  readonly enterpriseConfig?: ClusterSpecInitProviderEnterpriseConfig[];

  /**
   * Fleet configuration for the cluster. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#fleet
   */
  readonly fleet?: ClusterSpecInitProviderFleet[];

  /**
   * Configuration for GKE Gateway API controller. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#gatewayApiConfig
   */
  readonly gatewayApiConfig?: ClusterSpecInitProviderGatewayApiConfig[];

  /**
   * Configuration options for the auto-upgrade patch type feature, which provide more control over the speed of automatic upgrades of your GKE clusters.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#gkeAutoUpgradeConfig
   */
  readonly gkeAutoUpgradeConfig?: ClusterSpecInitProviderGkeAutoUpgradeConfig[];

  /**
   * . Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#identityServiceConfig
   */
  readonly identityServiceConfig?: ClusterSpecInitProviderIdentityServiceConfig[];

  /**
   * Defines the config of in-transit encryption. Valid values are IN_TRANSIT_ENCRYPTION_DISABLED and IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT.
   *
   * @schema ClusterSpecInitProvider#inTransitEncryptionConfig
   */
  readonly inTransitEncryptionConfig?: string;

  /**
   * The number of nodes to create in this
   * cluster's default node pool. In regional or multi-zonal clusters, this is the
   * number of nodes per zone. Must be set if node_pool is not set. If you're using
   * google_container_node_pool objects with no default node pool, you'll need to
   * set this to a value of at least 1, alongside setting
   * remove_default_node_pool to true.
   *
   * @schema ClusterSpecInitProvider#initialNodeCount
   */
  readonly initialNodeCount?: number;

  /**
   * Configuration of cluster IP allocation for
   * VPC-native clusters. If this block is unset during creation, it will be set by the GKE backend.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#ipAllocationPolicy
   */
  readonly ipAllocationPolicy?: ClusterSpecInitProviderIpAllocationPolicy[];

  /**
   * Logging configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#loggingConfig
   */
  readonly loggingConfig?: ClusterSpecInitProviderLoggingConfig[];

  /**
   * The logging service that the cluster should
   * write logs to. Available options include logging.googleapis.com(Legacy Stackdriver),
   * logging.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Logging), and none. Defaults to logging.googleapis.com/kubernetes
   *
   * @default logging.googleapis.com/kubernetes
   * @schema ClusterSpecInitProvider#loggingService
   */
  readonly loggingService?: string;

  /**
   * The maintenance policy to use for the cluster. Structure is
   * documented below.
   *
   * @schema ClusterSpecInitProvider#maintenancePolicy
   */
  readonly maintenancePolicy?: ClusterSpecInitProviderMaintenancePolicy[];

  /**
   * The authentication information for accessing the
   * Kubernetes master. Some values in this block are only returned by the API if
   * your service account has permission to get credentials for your GKE cluster. If
   * you see an unexpected diff unsetting your client cert, ensure you have the
   * container.clusters.getCredentials permission.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#masterAuth
   */
  readonly masterAuth?: ClusterSpecInitProviderMasterAuth[];

  /**
   * The desired
   * configuration options for master authorized networks. Omit the
   * nested cidr_blocks attribute to disallow external access (except
   * the cluster node IPs, which GKE automatically whitelists).
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#masterAuthorizedNetworksConfig
   */
  readonly masterAuthorizedNetworksConfig?: ClusterSpecInitProviderMasterAuthorizedNetworksConfig[];

  /**
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#meshCertificates
   */
  readonly meshCertificates?: ClusterSpecInitProviderMeshCertificates[];

  /**
   * The minimum version of the master. GKE
   * will auto-update the master to new versions, so this does not guarantee the
   * current master version--use the read-only master_version field to obtain that.
   * If unset, the cluster's version will be set by GKE to the version of the most recent
   * official release (which is not necessarily the latest version). If you intend to specify versions manually,
   * the docs
   * describe the various acceptable formats for this field.
   *
   * @schema ClusterSpecInitProvider#minMasterVersion
   */
  readonly minMasterVersion?: string;

  /**
   * Monitoring configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#monitoringConfig
   */
  readonly monitoringConfig?: ClusterSpecInitProviderMonitoringConfig[];

  /**
   * The monitoring service that the cluster
   * should write metrics to.
   * Automatically send metrics from pods in the cluster to the Google Cloud Monitoring API.
   * VM metrics will be collected by Google Compute Engine regardless of this setting
   * Available options include
   * monitoring.googleapis.com(Legacy Stackdriver), monitoring.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Monitoring), and none.
   * Defaults to monitoring.googleapis.com/kubernetes
   *
   * @default monitoring.googleapis.com/kubernetes
   * @schema ClusterSpecInitProvider#monitoringService
   */
  readonly monitoringService?: string;

  /**
   * The name or self_link of the Google Compute Engine
   * network to which the cluster is connected. For Shared VPC, set this to the self link of the
   * shared network.
   *
   * @schema ClusterSpecInitProvider#network
   */
  readonly network?: string;

  /**
   * Network bandwidth tier configuration. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#networkPerformanceConfig
   */
  readonly networkPerformanceConfig?: ClusterSpecInitProviderNetworkPerformanceConfig[];

  /**
   * Configuration options for the
   * NetworkPolicy
   * feature. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#networkPolicy
   */
  readonly networkPolicy?: ClusterSpecInitProviderNetworkPolicy[];

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema ClusterSpecInitProvider#networkRef
   */
  readonly networkRef?: ClusterSpecInitProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema ClusterSpecInitProvider#networkSelector
   */
  readonly networkSelector?: ClusterSpecInitProviderNetworkSelector;

  /**
   * Determines whether alias IPs or routes will be used for pod IPs in the cluster.
   * Options are VPC_NATIVE or ROUTES. VPC_NATIVE enables IP aliasing. Newly created clusters will default to VPC_NATIVE.
   *
   * @schema ClusterSpecInitProvider#networkingMode
   */
  readonly networkingMode?: string;

  /**
   * Parameters used in creating the default node pool. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#nodeConfig
   */
  readonly nodeConfig?: ClusterSpecInitProviderNodeConfig[];

  /**
   * The list of zones in which the cluster's nodes
   * are located. Nodes must be in the region of their regional cluster or in the
   * same region as their cluster's zone for zonal clusters. If this is specified for
   * a zonal cluster, omit the cluster's zone.
   *
   * @schema ClusterSpecInitProvider#nodeLocations
   */
  readonly nodeLocations?: string[];

  /**
   * Node pool configs that apply to auto-provisioned node pools in
   * autopilot clusters and
   * node auto-provisioning-enabled clusters. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#nodePoolAutoConfig
   */
  readonly nodePoolAutoConfig?: ClusterSpecInitProviderNodePoolAutoConfig[];

  /**
   * Default NodePool settings for the entire cluster. These settings are overridden if specified on the specific NodePool object. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#nodePoolDefaults
   */
  readonly nodePoolDefaults?: ClusterSpecInitProviderNodePoolDefaults[];

  /**
   * The Kubernetes version on the nodes. Must either be unset
   * or set to the same value as min_master_version on create. Defaults to the default
   * version set by GKE which is not necessarily the latest version. This only affects
   * nodes in the default node pool.
   * To update nodes in other node pools, use the version attribute on the node pool.
   *
   * @default the default
   * @schema ClusterSpecInitProvider#nodeVersion
   */
  readonly nodeVersion?: string;

  /**
   * Configuration for the cluster upgrade notifications feature. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#notificationConfig
   */
  readonly notificationConfig?: ClusterSpecInitProviderNotificationConfig[];

  /**
   * Configuration for the
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#podAutoscaling
   */
  readonly podAutoscaling?: ClusterSpecInitProviderPodAutoscaling[];

  /**
   * Configuration for private clusters,
   * clusters with private nodes. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#privateClusterConfig
   */
  readonly privateClusterConfig?: ClusterSpecInitProviderPrivateClusterConfig[];

  /**
   * The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4).
   *
   * @schema ClusterSpecInitProvider#privateIpv6GoogleAccess
   */
  readonly privateIpv6GoogleAccess?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema ClusterSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * RBACBindingConfig allows user to restrict ClusterRoleBindings an RoleBindings that can be created. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#rbacBindingConfig
   */
  readonly rbacBindingConfig?: ClusterSpecInitProviderRbacBindingConfig[];

  /**
   * Configuration options for the Release channel
   * feature, which provide more control over automatic upgrades of your GKE clusters.
   * When updating this field, GKE imposes specific version requirements. See
   * Selecting a new release channel
   * for more details; the google_container_engine_versions datasource can provide
   * the default version for a channel. Instead, use the "UNSPECIFIED"
   * channel. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#releaseChannel
   */
  readonly releaseChannel?: ClusterSpecInitProviderReleaseChannel[];

  /**
   * If true, deletes the default node
   * pool upon cluster creation. If you're using google_container_node_pool
   * resources with no default node pool, this should be set to true, alongside
   * setting initial_node_count to at least 1.
   *
   * @schema ClusterSpecInitProvider#removeDefaultNodePool
   */
  readonly removeDefaultNodePool?: boolean;

  /**
   * The GCE resource labels (a map of key/value pairs) to be applied to the cluster.
   *
   * @schema ClusterSpecInitProvider#resourceLabels
   */
  readonly resourceLabels?: { [key: string]: string };

  /**
   * Configuration for the
   * ResourceUsageExportConfig feature.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#resourceUsageExportConfig
   */
  readonly resourceUsageExportConfig?: ClusterSpecInitProviderResourceUsageExportConfig[];

  /**
   * Configuration for the
   * SecretManagerConfig feature.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#secretManagerConfig
   */
  readonly secretManagerConfig?: ClusterSpecInitProviderSecretManagerConfig[];

  /**
   * Enable/Disable Security Posture API features for the cluster. Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#securityPostureConfig
   */
  readonly securityPostureConfig?: ClusterSpecInitProviderSecurityPostureConfig[];

  /**
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#serviceExternalIpsConfig
   */
  readonly serviceExternalIpsConfig?: ClusterSpecInitProviderServiceExternalIpsConfig[];

  /**
   * The name or self_link of the Google Compute Engine
   * subnetwork in which the cluster's instances are launched.
   *
   * @schema ClusterSpecInitProvider#subnetwork
   */
  readonly subnetwork?: string;

  /**
   * Reference to a Subnetwork in compute to populate subnetwork.
   *
   * @schema ClusterSpecInitProvider#subnetworkRef
   */
  readonly subnetworkRef?: ClusterSpecInitProviderSubnetworkRef;

  /**
   * Selector for a Subnetwork in compute to populate subnetwork.
   *
   * @schema ClusterSpecInitProvider#subnetworkSelector
   */
  readonly subnetworkSelector?: ClusterSpecInitProviderSubnetworkSelector;

  /**
   * The custom keys configuration of the cluster Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#userManagedKeysConfig
   */
  readonly userManagedKeysConfig?: ClusterSpecInitProviderUserManagedKeysConfig[];

  /**
   * Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#verticalPodAutoscaling
   */
  readonly verticalPodAutoscaling?: ClusterSpecInitProviderVerticalPodAutoscaling[];

  /**
   * Workload Identity allows Kubernetes service accounts to act as a user-managed
   * Google IAM Service Account.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProvider#workloadIdentityConfig
   */
  readonly workloadIdentityConfig?: ClusterSpecInitProviderWorkloadIdentityConfig[];
}

/**
 * Converts an object of type 'ClusterSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProvider(obj: ClusterSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addonsConfig': obj.addonsConfig?.map(y => toJson_ClusterSpecInitProviderAddonsConfig(y)),
    'allowNetAdmin': obj.allowNetAdmin,
    'anonymousAuthenticationConfig': obj.anonymousAuthenticationConfig?.map(y => toJson_ClusterSpecInitProviderAnonymousAuthenticationConfig(y)),
    'authenticatorGroupsConfig': obj.authenticatorGroupsConfig?.map(y => toJson_ClusterSpecInitProviderAuthenticatorGroupsConfig(y)),
    'binaryAuthorization': obj.binaryAuthorization?.map(y => toJson_ClusterSpecInitProviderBinaryAuthorization(y)),
    'clusterAutoscaling': obj.clusterAutoscaling?.map(y => toJson_ClusterSpecInitProviderClusterAutoscaling(y)),
    'clusterIpv4Cidr': obj.clusterIpv4Cidr,
    'confidentialNodes': obj.confidentialNodes?.map(y => toJson_ClusterSpecInitProviderConfidentialNodes(y)),
    'controlPlaneEndpointsConfig': obj.controlPlaneEndpointsConfig?.map(y => toJson_ClusterSpecInitProviderControlPlaneEndpointsConfig(y)),
    'costManagementConfig': obj.costManagementConfig?.map(y => toJson_ClusterSpecInitProviderCostManagementConfig(y)),
    'databaseEncryption': obj.databaseEncryption?.map(y => toJson_ClusterSpecInitProviderDatabaseEncryption(y)),
    'datapathProvider': obj.datapathProvider,
    'defaultMaxPodsPerNode': obj.defaultMaxPodsPerNode,
    'defaultSnatStatus': obj.defaultSnatStatus?.map(y => toJson_ClusterSpecInitProviderDefaultSnatStatus(y)),
    'deletionProtection': obj.deletionProtection,
    'description': obj.description,
    'disableL4LbFirewallReconciliation': obj.disableL4LbFirewallReconciliation,
    'dnsConfig': obj.dnsConfig?.map(y => toJson_ClusterSpecInitProviderDnsConfig(y)),
    'enableAutopilot': obj.enableAutopilot,
    'enableCiliumClusterwideNetworkPolicy': obj.enableCiliumClusterwideNetworkPolicy,
    'enableFqdnNetworkPolicy': obj.enableFqdnNetworkPolicy,
    'enableIntranodeVisibility': obj.enableIntranodeVisibility,
    'enableK8SBetaApis': obj.enableK8SBetaApis?.map(y => toJson_ClusterSpecInitProviderEnableK8SBetaApis(y)),
    'enableKubernetesAlpha': obj.enableKubernetesAlpha,
    'enableL4IlbSubsetting': obj.enableL4IlbSubsetting,
    'enableLegacyAbac': obj.enableLegacyAbac,
    'enableMultiNetworking': obj.enableMultiNetworking,
    'enableShieldedNodes': obj.enableShieldedNodes,
    'enableTpu': obj.enableTpu,
    'enterpriseConfig': obj.enterpriseConfig?.map(y => toJson_ClusterSpecInitProviderEnterpriseConfig(y)),
    'fleet': obj.fleet?.map(y => toJson_ClusterSpecInitProviderFleet(y)),
    'gatewayApiConfig': obj.gatewayApiConfig?.map(y => toJson_ClusterSpecInitProviderGatewayApiConfig(y)),
    'gkeAutoUpgradeConfig': obj.gkeAutoUpgradeConfig?.map(y => toJson_ClusterSpecInitProviderGkeAutoUpgradeConfig(y)),
    'identityServiceConfig': obj.identityServiceConfig?.map(y => toJson_ClusterSpecInitProviderIdentityServiceConfig(y)),
    'inTransitEncryptionConfig': obj.inTransitEncryptionConfig,
    'initialNodeCount': obj.initialNodeCount,
    'ipAllocationPolicy': obj.ipAllocationPolicy?.map(y => toJson_ClusterSpecInitProviderIpAllocationPolicy(y)),
    'loggingConfig': obj.loggingConfig?.map(y => toJson_ClusterSpecInitProviderLoggingConfig(y)),
    'loggingService': obj.loggingService,
    'maintenancePolicy': obj.maintenancePolicy?.map(y => toJson_ClusterSpecInitProviderMaintenancePolicy(y)),
    'masterAuth': obj.masterAuth?.map(y => toJson_ClusterSpecInitProviderMasterAuth(y)),
    'masterAuthorizedNetworksConfig': obj.masterAuthorizedNetworksConfig?.map(y => toJson_ClusterSpecInitProviderMasterAuthorizedNetworksConfig(y)),
    'meshCertificates': obj.meshCertificates?.map(y => toJson_ClusterSpecInitProviderMeshCertificates(y)),
    'minMasterVersion': obj.minMasterVersion,
    'monitoringConfig': obj.monitoringConfig?.map(y => toJson_ClusterSpecInitProviderMonitoringConfig(y)),
    'monitoringService': obj.monitoringService,
    'network': obj.network,
    'networkPerformanceConfig': obj.networkPerformanceConfig?.map(y => toJson_ClusterSpecInitProviderNetworkPerformanceConfig(y)),
    'networkPolicy': obj.networkPolicy?.map(y => toJson_ClusterSpecInitProviderNetworkPolicy(y)),
    'networkRef': toJson_ClusterSpecInitProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_ClusterSpecInitProviderNetworkSelector(obj.networkSelector),
    'networkingMode': obj.networkingMode,
    'nodeConfig': obj.nodeConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfig(y)),
    'nodeLocations': obj.nodeLocations?.map(y => y),
    'nodePoolAutoConfig': obj.nodePoolAutoConfig?.map(y => toJson_ClusterSpecInitProviderNodePoolAutoConfig(y)),
    'nodePoolDefaults': obj.nodePoolDefaults?.map(y => toJson_ClusterSpecInitProviderNodePoolDefaults(y)),
    'nodeVersion': obj.nodeVersion,
    'notificationConfig': obj.notificationConfig?.map(y => toJson_ClusterSpecInitProviderNotificationConfig(y)),
    'podAutoscaling': obj.podAutoscaling?.map(y => toJson_ClusterSpecInitProviderPodAutoscaling(y)),
    'privateClusterConfig': obj.privateClusterConfig?.map(y => toJson_ClusterSpecInitProviderPrivateClusterConfig(y)),
    'privateIpv6GoogleAccess': obj.privateIpv6GoogleAccess,
    'project': obj.project,
    'rbacBindingConfig': obj.rbacBindingConfig?.map(y => toJson_ClusterSpecInitProviderRbacBindingConfig(y)),
    'releaseChannel': obj.releaseChannel?.map(y => toJson_ClusterSpecInitProviderReleaseChannel(y)),
    'removeDefaultNodePool': obj.removeDefaultNodePool,
    'resourceLabels': ((obj.resourceLabels) === undefined) ? undefined : (Object.entries(obj.resourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceUsageExportConfig': obj.resourceUsageExportConfig?.map(y => toJson_ClusterSpecInitProviderResourceUsageExportConfig(y)),
    'secretManagerConfig': obj.secretManagerConfig?.map(y => toJson_ClusterSpecInitProviderSecretManagerConfig(y)),
    'securityPostureConfig': obj.securityPostureConfig?.map(y => toJson_ClusterSpecInitProviderSecurityPostureConfig(y)),
    'serviceExternalIpsConfig': obj.serviceExternalIpsConfig?.map(y => toJson_ClusterSpecInitProviderServiceExternalIpsConfig(y)),
    'subnetwork': obj.subnetwork,
    'subnetworkRef': toJson_ClusterSpecInitProviderSubnetworkRef(obj.subnetworkRef),
    'subnetworkSelector': toJson_ClusterSpecInitProviderSubnetworkSelector(obj.subnetworkSelector),
    'userManagedKeysConfig': obj.userManagedKeysConfig?.map(y => toJson_ClusterSpecInitProviderUserManagedKeysConfig(y)),
    'verticalPodAutoscaling': obj.verticalPodAutoscaling?.map(y => toJson_ClusterSpecInitProviderVerticalPodAutoscaling(y)),
    'workloadIdentityConfig': obj.workloadIdentityConfig?.map(y => toJson_ClusterSpecInitProviderWorkloadIdentityConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ClusterSpecManagementPolicies
 */
export enum ClusterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ClusterSpecProviderConfigRef
 */
export interface ClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProviderConfigRef(obj: ClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ClusterSpecWriteConnectionSecretToRef
 */
export interface ClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecWriteConnectionSecretToRef(obj: ClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfig
 */
export interface ClusterSpecForProviderAddonsConfig {
  /**
   * . Structure is documented below.
   *
   * @schema ClusterSpecForProviderAddonsConfig#cloudrunConfig
   */
  readonly cloudrunConfig?: ClusterSpecForProviderAddonsConfigCloudrunConfig[];

  /**
   * .
   * The status of the ConfigConnector addon. It is disabled by default; Set enabled = true to enable.
   *
   * @schema ClusterSpecForProviderAddonsConfig#configConnectorConfig
   */
  readonly configConnectorConfig?: ClusterSpecForProviderAddonsConfigConfigConnectorConfig[];

  /**
   * .
   * The status of the NodeLocal DNSCache addon. It is disabled by default.
   * Set enabled = true to enable.
   *
   * @schema ClusterSpecForProviderAddonsConfig#dnsCacheConfig
   */
  readonly dnsCacheConfig?: ClusterSpecForProviderAddonsConfigDnsCacheConfig[];

  /**
   * .
   * Whether this cluster should enable the Google Compute Engine Persistent Disk Container Storage Interface (CSI) Driver. Set enabled = true to enable.
   *
   * @schema ClusterSpecForProviderAddonsConfig#gcePersistentDiskCsiDriverConfig
   */
  readonly gcePersistentDiskCsiDriverConfig?: ClusterSpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig[];

  /**
   * The status of the Filestore CSI driver addon,
   * which allows the usage of filestore instance as volumes.
   * It is disabled by default; set enabled = true to enable.
   *
   * @schema ClusterSpecForProviderAddonsConfig#gcpFilestoreCsiDriverConfig
   */
  readonly gcpFilestoreCsiDriverConfig?: ClusterSpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig[];

  /**
   * The status of the GCSFuse CSI driver addon,
   * which allows the usage of a gcs bucket as volumes.
   * It is disabled by default for Standard clusters; set enabled = true to enable.
   * It is enabled by default for Autopilot clusters with version 1.24 or later; set enabled = true to enable it explicitly.
   * See Enable the Cloud Storage FUSE CSI driver for more information.
   *
   * @schema ClusterSpecForProviderAddonsConfig#gcsFuseCsiDriverConfig
   */
  readonly gcsFuseCsiDriverConfig?: ClusterSpecForProviderAddonsConfigGcsFuseCsiDriverConfig[];

  /**
   * .
   * The status of the Backup for GKE agent addon. It is disabled by default; Set enabled = true to enable.
   *
   * @schema ClusterSpecForProviderAddonsConfig#gkeBackupAgentConfig
   */
  readonly gkeBackupAgentConfig?: ClusterSpecForProviderAddonsConfigGkeBackupAgentConfig[];

  /**
   * The status of the Horizontal Pod Autoscaling
   * addon, which increases or decreases the number of replica pods a replication controller
   * has based on the resource usage of the existing pods.
   * It is enabled by default;
   * set disabled = true to disable.
   *
   * @schema ClusterSpecForProviderAddonsConfig#horizontalPodAutoscaling
   */
  readonly horizontalPodAutoscaling?: ClusterSpecForProviderAddonsConfigHorizontalPodAutoscaling[];

  /**
   * The status of the HTTP (L7) load balancing
   * controller addon, which makes it easy to set up HTTP load balancers for services in a
   * cluster. It is enabled by default; set disabled = true to disable.
   *
   * @schema ClusterSpecForProviderAddonsConfig#httpLoadBalancing
   */
  readonly httpLoadBalancing?: ClusterSpecForProviderAddonsConfigHttpLoadBalancing[];

  /**
   * The status of the Lustre CSI driver addon,
   * which allows the usage of a Lustre instances as volumes.
   * It is disabled by default for Standard clusters; set enabled = true to enable.
   * It is disabled by default for Autopilot clusters; set enabled = true to enable.
   * Lustre CSI Driver Config has optional subfield
   * enable_legacy_lustre_port which allows the Lustre CSI driver to initialize LNet (the virtual networklayer for Lustre kernel module) using port 6988.
   * This flag is required to workaround a port conflict with the gke-metadata-server on GKE nodes.
   * See Enable Lustre CSI driver for more information.
   *
   * @schema ClusterSpecForProviderAddonsConfig#lustreCsiDriverConfig
   */
  readonly lustreCsiDriverConfig?: ClusterSpecForProviderAddonsConfigLustreCsiDriverConfig[];

  /**
   * Whether we should enable the network policy addon
   * for the master.  This must be enabled in order to enable network policy for the nodes.
   * To enable this, you must also define a network_policy block,
   * otherwise nothing will happen.
   * It can only be disabled if the nodes already do not have network policies enabled.
   * Defaults to disabled; set disabled = false to enable.
   *
   * @default disabled; set disabled = false to enable.
   * @schema ClusterSpecForProviderAddonsConfig#networkPolicyConfig
   */
  readonly networkPolicyConfig?: ClusterSpecForProviderAddonsConfigNetworkPolicyConfig[];

  /**
   * The status of the Parallelstore CSI driver addon,
   * which allows the usage of a Parallelstore instances as volumes.
   * It is disabled by default for Standard clusters; set enabled = true to enable.
   * It is enabled by default for Autopilot clusters with version 1.29 or later; set enabled = true to enable it explicitly.
   * See Enable the Parallelstore CSI driver for more information.
   *
   * @schema ClusterSpecForProviderAddonsConfig#parallelstoreCsiDriverConfig
   */
  readonly parallelstoreCsiDriverConfig?: ClusterSpecForProviderAddonsConfigParallelstoreCsiDriverConfig[];

  /**
   * . The status of the Ray Operator
   * addon.
   * It is disabled by default. Set enabled = true to enable. The minimum
   * cluster version to enable Ray is 1.30.0-gke.1747000.
   *
   * @schema ClusterSpecForProviderAddonsConfig#rayOperatorConfig
   */
  readonly rayOperatorConfig?: ClusterSpecForProviderAddonsConfigRayOperatorConfig[];

  /**
   * .
   * The status of the Stateful HA addon, which provides automatic configurable failover for stateful applications.
   * It is disabled by default for Standard clusters. Set enabled = true to enable.
   *
   * @schema ClusterSpecForProviderAddonsConfig#statefulHaConfig
   */
  readonly statefulHaConfig?: ClusterSpecForProviderAddonsConfigStatefulHaConfig[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfig(obj: ClusterSpecForProviderAddonsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudrunConfig': obj.cloudrunConfig?.map(y => toJson_ClusterSpecForProviderAddonsConfigCloudrunConfig(y)),
    'configConnectorConfig': obj.configConnectorConfig?.map(y => toJson_ClusterSpecForProviderAddonsConfigConfigConnectorConfig(y)),
    'dnsCacheConfig': obj.dnsCacheConfig?.map(y => toJson_ClusterSpecForProviderAddonsConfigDnsCacheConfig(y)),
    'gcePersistentDiskCsiDriverConfig': obj.gcePersistentDiskCsiDriverConfig?.map(y => toJson_ClusterSpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig(y)),
    'gcpFilestoreCsiDriverConfig': obj.gcpFilestoreCsiDriverConfig?.map(y => toJson_ClusterSpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig(y)),
    'gcsFuseCsiDriverConfig': obj.gcsFuseCsiDriverConfig?.map(y => toJson_ClusterSpecForProviderAddonsConfigGcsFuseCsiDriverConfig(y)),
    'gkeBackupAgentConfig': obj.gkeBackupAgentConfig?.map(y => toJson_ClusterSpecForProviderAddonsConfigGkeBackupAgentConfig(y)),
    'horizontalPodAutoscaling': obj.horizontalPodAutoscaling?.map(y => toJson_ClusterSpecForProviderAddonsConfigHorizontalPodAutoscaling(y)),
    'httpLoadBalancing': obj.httpLoadBalancing?.map(y => toJson_ClusterSpecForProviderAddonsConfigHttpLoadBalancing(y)),
    'lustreCsiDriverConfig': obj.lustreCsiDriverConfig?.map(y => toJson_ClusterSpecForProviderAddonsConfigLustreCsiDriverConfig(y)),
    'networkPolicyConfig': obj.networkPolicyConfig?.map(y => toJson_ClusterSpecForProviderAddonsConfigNetworkPolicyConfig(y)),
    'parallelstoreCsiDriverConfig': obj.parallelstoreCsiDriverConfig?.map(y => toJson_ClusterSpecForProviderAddonsConfigParallelstoreCsiDriverConfig(y)),
    'rayOperatorConfig': obj.rayOperatorConfig?.map(y => toJson_ClusterSpecForProviderAddonsConfigRayOperatorConfig(y)),
    'statefulHaConfig': obj.statefulHaConfig?.map(y => toJson_ClusterSpecForProviderAddonsConfigStatefulHaConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAnonymousAuthenticationConfig
 */
export interface ClusterSpecForProviderAnonymousAuthenticationConfig {
  /**
   * Sets or removes authentication restrictions. Available options include LIMITED and ENABLED.
   *
   * @schema ClusterSpecForProviderAnonymousAuthenticationConfig#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAnonymousAuthenticationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAnonymousAuthenticationConfig(obj: ClusterSpecForProviderAnonymousAuthenticationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAuthenticatorGroupsConfig
 */
export interface ClusterSpecForProviderAuthenticatorGroupsConfig {
  /**
   * The name of the RBAC security group for use with Google security groups in Kubernetes RBAC. Group name must be in format gke-security-groups@yourdomain.com.
   *
   * @schema ClusterSpecForProviderAuthenticatorGroupsConfig#securityGroup
   */
  readonly securityGroup?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAuthenticatorGroupsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAuthenticatorGroupsConfig(obj: ClusterSpecForProviderAuthenticatorGroupsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroup': obj.securityGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderBinaryAuthorization
 */
export interface ClusterSpecForProviderBinaryAuthorization {
  /**
   * (DEPRECATED) Enable Binary Authorization for this cluster. Deprecated in favor of evaluation_mode.
   *
   * @schema ClusterSpecForProviderBinaryAuthorization#enabled
   */
  readonly enabled?: boolean;

  /**
   * Mode of operation for Binary Authorization policy evaluation. Valid values are DISABLED
   * and PROJECT_SINGLETON_POLICY_ENFORCE.
   *
   * @schema ClusterSpecForProviderBinaryAuthorization#evaluationMode
   */
  readonly evaluationMode?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderBinaryAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderBinaryAuthorization(obj: ClusterSpecForProviderBinaryAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'evaluationMode': obj.evaluationMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderClusterAutoscaling
 */
export interface ClusterSpecForProviderClusterAutoscaling {
  /**
   * Contains defaults for a node pool created by NAP. A subset of fields also apply to
   * GKE Autopilot clusters.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProviderClusterAutoscaling#autoProvisioningDefaults
   */
  readonly autoProvisioningDefaults?: ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults[];

  /**
   * The list of Google Compute Engine
   * zones in which the
   * NodePool's nodes can be created by NAP.
   *
   * @schema ClusterSpecForProviderClusterAutoscaling#autoProvisioningLocations
   */
  readonly autoProvisioningLocations?: string[];

  /**
   * Configuration
   * options for the Autoscaling profile
   * feature, which lets you choose whether the cluster autoscaler should optimize for resource utilization or resource availability
   * when deciding to remove nodes from a cluster. Can be BALANCED or OPTIMIZE_UTILIZATION. Defaults to BALANCED.
   *
   * @default BALANCED.
   * @schema ClusterSpecForProviderClusterAutoscaling#autoscalingProfile
   */
  readonly autoscalingProfile?: string;

  /**
   * Whether node auto-provisioning is enabled. Must be supplied for GKE Standard clusters, true is implied
   * for autopilot clusters. Resource limits for cpu and memory must be defined to enable node auto-provisioning for GKE Standard.
   *
   * @schema ClusterSpecForProviderClusterAutoscaling#enabled
   */
  readonly enabled?: boolean;

  /**
   * Global constraints for machine resources in the
   * cluster. Configuring the cpu and memory types is required if node
   * auto-provisioning is enabled. These limits will apply to node pool autoscaling
   * in addition to node auto-provisioning. Structure is documented below.
   *
   * @schema ClusterSpecForProviderClusterAutoscaling#resourceLimits
   */
  readonly resourceLimits?: ClusterSpecForProviderClusterAutoscalingResourceLimits[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderClusterAutoscaling(obj: ClusterSpecForProviderClusterAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoProvisioningDefaults': obj.autoProvisioningDefaults?.map(y => toJson_ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults(y)),
    'autoProvisioningLocations': obj.autoProvisioningLocations?.map(y => y),
    'autoscalingProfile': obj.autoscalingProfile,
    'enabled': obj.enabled,
    'resourceLimits': obj.resourceLimits?.map(y => toJson_ClusterSpecForProviderClusterAutoscalingResourceLimits(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderConfidentialNodes
 */
export interface ClusterSpecForProviderConfidentialNodes {
  /**
   * Defines the type of technology used
   * by the confidential node.
   *
   * @schema ClusterSpecForProviderConfidentialNodes#confidentialInstanceType
   */
  readonly confidentialInstanceType?: string;

  /**
   * Enable Confidential GKE Nodes for this node pool, to
   * enforce encryption of data in-use.
   *
   * @schema ClusterSpecForProviderConfidentialNodes#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderConfidentialNodes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderConfidentialNodes(obj: ClusterSpecForProviderConfidentialNodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confidentialInstanceType': obj.confidentialInstanceType,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderControlPlaneEndpointsConfig
 */
export interface ClusterSpecForProviderControlPlaneEndpointsConfig {
  /**
   * DNS endpoint configuration.
   *
   * @schema ClusterSpecForProviderControlPlaneEndpointsConfig#dnsEndpointConfig
   */
  readonly dnsEndpointConfig?: ClusterSpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig[];

  /**
   * IP endpoint configuration.
   *
   * @schema ClusterSpecForProviderControlPlaneEndpointsConfig#ipEndpointsConfig
   */
  readonly ipEndpointsConfig?: ClusterSpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderControlPlaneEndpointsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderControlPlaneEndpointsConfig(obj: ClusterSpecForProviderControlPlaneEndpointsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsEndpointConfig': obj.dnsEndpointConfig?.map(y => toJson_ClusterSpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig(y)),
    'ipEndpointsConfig': obj.ipEndpointsConfig?.map(y => toJson_ClusterSpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderCostManagementConfig
 */
export interface ClusterSpecForProviderCostManagementConfig {
  /**
   * Whether to enable the cost allocation feature.
   *
   * @schema ClusterSpecForProviderCostManagementConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderCostManagementConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderCostManagementConfig(obj: ClusterSpecForProviderCostManagementConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderDatabaseEncryption
 */
export interface ClusterSpecForProviderDatabaseEncryption {
  /**
   * the key to use to encrypt/decrypt secrets.  See the DatabaseEncryption definition for more information.
   *
   * @schema ClusterSpecForProviderDatabaseEncryption#keyName
   */
  readonly keyName?: string;

  /**
   * ENCRYPTED or DECRYPTED
   *
   * @schema ClusterSpecForProviderDatabaseEncryption#state
   */
  readonly state?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderDatabaseEncryption' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderDatabaseEncryption(obj: ClusterSpecForProviderDatabaseEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderDefaultSnatStatus
 */
export interface ClusterSpecForProviderDefaultSnatStatus {
  /**
   * Whether the cluster disables default in-node sNAT rules. In-node sNAT rules will be disabled when defaultSnatStatus is disabled.When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic
   *
   * @schema ClusterSpecForProviderDefaultSnatStatus#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderDefaultSnatStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderDefaultSnatStatus(obj: ClusterSpecForProviderDefaultSnatStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderDnsConfig
 */
export interface ClusterSpecForProviderDnsConfig {
  /**
   * This will enable Cloud DNS additive VPC scope. Must provide a domain name that is unique within the VPC. For this to work cluster_dns = "CLOUD_DNS" and cluster_dns_scope = "CLUSTER_SCOPE" must both be set as well.
   *
   * @schema ClusterSpecForProviderDnsConfig#additiveVpcScopeDnsDomain
   */
  readonly additiveVpcScopeDnsDomain?: string;

  /**
   * Which in-cluster DNS provider should be used. PROVIDER_UNSPECIFIED (default) or PLATFORM_DEFAULT or CLOUD_DNS.
   *
   * @schema ClusterSpecForProviderDnsConfig#clusterDns
   */
  readonly clusterDns?: string;

  /**
   * The suffix used for all cluster service records.
   *
   * @schema ClusterSpecForProviderDnsConfig#clusterDnsDomain
   */
  readonly clusterDnsDomain?: string;

  /**
   * The scope of access to cluster DNS records. DNS_SCOPE_UNSPECIFIED (default) or CLUSTER_SCOPE or VPC_SCOPE.
   *
   * @schema ClusterSpecForProviderDnsConfig#clusterDnsScope
   */
  readonly clusterDnsScope?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderDnsConfig(obj: ClusterSpecForProviderDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additiveVpcScopeDnsDomain': obj.additiveVpcScopeDnsDomain,
    'clusterDns': obj.clusterDns,
    'clusterDnsDomain': obj.clusterDnsDomain,
    'clusterDnsScope': obj.clusterDnsScope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderEnableK8SBetaApis
 */
export interface ClusterSpecForProviderEnableK8SBetaApis {
  /**
   * Enabled Kubernetes Beta APIs. To list a Beta API resource, use the representation {group}/{version}/{resource}. The version must be a Beta version. Note that you cannot disable beta APIs that are already enabled on a cluster without recreating it. See the Configure beta APIs for more information.
   *
   * @schema ClusterSpecForProviderEnableK8SBetaApis#enabledApis
   */
  readonly enabledApis?: string[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderEnableK8SBetaApis' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderEnableK8SBetaApis(obj: ClusterSpecForProviderEnableK8SBetaApis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabledApis': obj.enabledApis?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderEnterpriseConfig
 */
export interface ClusterSpecForProviderEnterpriseConfig {
  /**
   * Sets the tier of the cluster. Available options include STANDARD and ENTERPRISE.
   *
   * @schema ClusterSpecForProviderEnterpriseConfig#desiredTier
   */
  readonly desiredTier?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderEnterpriseConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderEnterpriseConfig(obj: ClusterSpecForProviderEnterpriseConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'desiredTier': obj.desiredTier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderFleet
 */
export interface ClusterSpecForProviderFleet {
  /**
   * The name of the Fleet host project where this cluster will be registered.
   *
   * @schema ClusterSpecForProviderFleet#project
   */
  readonly project?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderFleet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderFleet(obj: ClusterSpecForProviderFleet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderGatewayApiConfig
 */
export interface ClusterSpecForProviderGatewayApiConfig {
  /**
   * Which Gateway Api channel should be used. CHANNEL_DISABLED, CHANNEL_EXPERIMENTAL or CHANNEL_STANDARD.
   *
   * @schema ClusterSpecForProviderGatewayApiConfig#channel
   */
  readonly channel?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderGatewayApiConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderGatewayApiConfig(obj: ClusterSpecForProviderGatewayApiConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'channel': obj.channel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderGkeAutoUpgradeConfig
 */
export interface ClusterSpecForProviderGkeAutoUpgradeConfig {
  /**
   * The selected patch mode.
   * Accepted values are:
   *
   * @schema ClusterSpecForProviderGkeAutoUpgradeConfig#patchMode
   */
  readonly patchMode?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderGkeAutoUpgradeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderGkeAutoUpgradeConfig(obj: ClusterSpecForProviderGkeAutoUpgradeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'patchMode': obj.patchMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderIdentityServiceConfig
 */
export interface ClusterSpecForProviderIdentityServiceConfig {
  /**
   * Whether to enable the Identity Service component. It is disabled by default. Set enabled=true to enable.
   *
   * @schema ClusterSpecForProviderIdentityServiceConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderIdentityServiceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderIdentityServiceConfig(obj: ClusterSpecForProviderIdentityServiceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderIpAllocationPolicy
 */
export interface ClusterSpecForProviderIpAllocationPolicy {
  /**
   * The configuration for individual additional subnetworks attached to the cluster.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProviderIpAllocationPolicy#additionalIpRangesConfig
   */
  readonly additionalIpRangesConfig?: ClusterSpecForProviderIpAllocationPolicyAdditionalIpRangesConfig[];

  /**
   * The configuration for additional pod secondary ranges at
   * the cluster level. Used for Autopilot clusters and Standard clusters with which control of the
   * secondary Pod IP address assignment to node pools isn't needed. Structure is documented below.
   *
   * @schema ClusterSpecForProviderIpAllocationPolicy#additionalPodRangesConfig
   */
  readonly additionalPodRangesConfig?: ClusterSpecForProviderIpAllocationPolicyAdditionalPodRangesConfig[];

  /**
   * The IP address range for the cluster pod IPs.
   * Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
   * to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
   * from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
   * pick a specific range to use.
   *
   * @schema ClusterSpecForProviderIpAllocationPolicy#clusterIpv4CidrBlock
   */
  readonly clusterIpv4CidrBlock?: string;

  /**
   * The name of the existing secondary
   * range in the cluster's subnetwork to use for pod IP addresses. Alternatively,
   * cluster_ipv4_cidr_block can be used to automatically create a GKE-managed one.
   *
   * @schema ClusterSpecForProviderIpAllocationPolicy#clusterSecondaryRangeName
   */
  readonly clusterSecondaryRangeName?: string;

  /**
   * @schema ClusterSpecForProviderIpAllocationPolicy#podCidrOverprovisionConfig
   */
  readonly podCidrOverprovisionConfig?: ClusterSpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig[];

  /**
   * The IP address range of the services IPs in this cluster.
   * Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
   * to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
   * from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
   * pick a specific range to use.
   *
   * @schema ClusterSpecForProviderIpAllocationPolicy#servicesIpv4CidrBlock
   */
  readonly servicesIpv4CidrBlock?: string;

  /**
   * The name of the existing
   * secondary range in the cluster's subnetwork to use for service ClusterIPs.
   * Alternatively, services_ipv4_cidr_block can be used to automatically create a
   * GKE-managed one.
   *
   * @schema ClusterSpecForProviderIpAllocationPolicy#servicesSecondaryRangeName
   */
  readonly servicesSecondaryRangeName?: string;

  /**
   * The IP Stack Type of the cluster.
   * Default value is IPV4.
   * Possible values are IPV4 and IPV4_IPV6.
   *
   * @schema ClusterSpecForProviderIpAllocationPolicy#stackType
   */
  readonly stackType?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderIpAllocationPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderIpAllocationPolicy(obj: ClusterSpecForProviderIpAllocationPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalIpRangesConfig': obj.additionalIpRangesConfig?.map(y => toJson_ClusterSpecForProviderIpAllocationPolicyAdditionalIpRangesConfig(y)),
    'additionalPodRangesConfig': obj.additionalPodRangesConfig?.map(y => toJson_ClusterSpecForProviderIpAllocationPolicyAdditionalPodRangesConfig(y)),
    'clusterIpv4CidrBlock': obj.clusterIpv4CidrBlock,
    'clusterSecondaryRangeName': obj.clusterSecondaryRangeName,
    'podCidrOverprovisionConfig': obj.podCidrOverprovisionConfig?.map(y => toJson_ClusterSpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig(y)),
    'servicesIpv4CidrBlock': obj.servicesIpv4CidrBlock,
    'servicesSecondaryRangeName': obj.servicesSecondaryRangeName,
    'stackType': obj.stackType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderLoggingConfig
 */
export interface ClusterSpecForProviderLoggingConfig {
  /**
   * The GKE components exposing logs. Supported values include:
   * SYSTEM_COMPONENTS, APISERVER, CONTROLLER_MANAGER, SCHEDULER, and WORKLOADS.
   *
   * @schema ClusterSpecForProviderLoggingConfig#enableComponents
   */
  readonly enableComponents?: string[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderLoggingConfig(obj: ClusterSpecForProviderLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableComponents': obj.enableComponents?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderMaintenancePolicy
 */
export interface ClusterSpecForProviderMaintenancePolicy {
  /**
   * structure documented below.
   *
   * @schema ClusterSpecForProviderMaintenancePolicy#dailyMaintenanceWindow
   */
  readonly dailyMaintenanceWindow?: ClusterSpecForProviderMaintenancePolicyDailyMaintenanceWindow[];

  /**
   * structure documented below
   *
   * @schema ClusterSpecForProviderMaintenancePolicy#maintenanceExclusion
   */
  readonly maintenanceExclusion?: ClusterSpecForProviderMaintenancePolicyMaintenanceExclusion[];

  /**
   * structure documented below
   *
   * @schema ClusterSpecForProviderMaintenancePolicy#recurringWindow
   */
  readonly recurringWindow?: ClusterSpecForProviderMaintenancePolicyRecurringWindow[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderMaintenancePolicy(obj: ClusterSpecForProviderMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dailyMaintenanceWindow': obj.dailyMaintenanceWindow?.map(y => toJson_ClusterSpecForProviderMaintenancePolicyDailyMaintenanceWindow(y)),
    'maintenanceExclusion': obj.maintenanceExclusion?.map(y => toJson_ClusterSpecForProviderMaintenancePolicyMaintenanceExclusion(y)),
    'recurringWindow': obj.recurringWindow?.map(y => toJson_ClusterSpecForProviderMaintenancePolicyRecurringWindow(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderMasterAuth
 */
export interface ClusterSpecForProviderMasterAuth {
  /**
   * Whether client certificate authorization is enabled for this cluster.  For example:
   *
   * @schema ClusterSpecForProviderMasterAuth#clientCertificateConfig
   */
  readonly clientCertificateConfig?: ClusterSpecForProviderMasterAuthClientCertificateConfig[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderMasterAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderMasterAuth(obj: ClusterSpecForProviderMasterAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertificateConfig': obj.clientCertificateConfig?.map(y => toJson_ClusterSpecForProviderMasterAuthClientCertificateConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderMasterAuthorizedNetworksConfig
 */
export interface ClusterSpecForProviderMasterAuthorizedNetworksConfig {
  /**
   * External networks that can access the
   * Kubernetes cluster master through HTTPS.
   *
   * @schema ClusterSpecForProviderMasterAuthorizedNetworksConfig#cidrBlocks
   */
  readonly cidrBlocks?: ClusterSpecForProviderMasterAuthorizedNetworksConfigCidrBlocks[];

  /**
   * Whether Kubernetes master is
   * accessible via Google Compute Engine Public IPs.
   *
   * @schema ClusterSpecForProviderMasterAuthorizedNetworksConfig#gcpPublicCidrsAccessEnabled
   */
  readonly gcpPublicCidrsAccessEnabled?: boolean;

  /**
   * Whether authorized networks is enforced on the private endpoint or not.
   *
   * @schema ClusterSpecForProviderMasterAuthorizedNetworksConfig#privateEndpointEnforcementEnabled
   */
  readonly privateEndpointEnforcementEnabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderMasterAuthorizedNetworksConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderMasterAuthorizedNetworksConfig(obj: ClusterSpecForProviderMasterAuthorizedNetworksConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrBlocks': obj.cidrBlocks?.map(y => toJson_ClusterSpecForProviderMasterAuthorizedNetworksConfigCidrBlocks(y)),
    'gcpPublicCidrsAccessEnabled': obj.gcpPublicCidrsAccessEnabled,
    'privateEndpointEnforcementEnabled': obj.privateEndpointEnforcementEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderMeshCertificates
 */
export interface ClusterSpecForProviderMeshCertificates {
  /**
   * Controls the issuance of workload mTLS certificates. It is enabled by default. Workload Identity is required, see workload_config.
   *
   * @schema ClusterSpecForProviderMeshCertificates#enableCertificates
   */
  readonly enableCertificates?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderMeshCertificates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderMeshCertificates(obj: ClusterSpecForProviderMeshCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableCertificates': obj.enableCertificates,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderMonitoringConfig
 */
export interface ClusterSpecForProviderMonitoringConfig {
  /**
   * Configuration for Advanced Datapath Monitoring. Structure is documented below.
   *
   * @schema ClusterSpecForProviderMonitoringConfig#advancedDatapathObservabilityConfig
   */
  readonly advancedDatapathObservabilityConfig?: ClusterSpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig[];

  /**
   * The GKE components exposing metrics. Supported values include: SYSTEM_COMPONENTS, APISERVER, SCHEDULER, CONTROLLER_MANAGER, STORAGE, HPA, POD, DAEMONSET, DEPLOYMENT and STATEFULSET. In beta provider, WORKLOADS is supported on top of those 10 values. (WORKLOADS is deprecated and removed in GKE 1.24.)
   *
   * @schema ClusterSpecForProviderMonitoringConfig#enableComponents
   */
  readonly enableComponents?: string[];

  /**
   * Configuration for Managed Service for Prometheus. Structure is documented below.
   *
   * @schema ClusterSpecForProviderMonitoringConfig#managedPrometheus
   */
  readonly managedPrometheus?: ClusterSpecForProviderMonitoringConfigManagedPrometheus[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderMonitoringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderMonitoringConfig(obj: ClusterSpecForProviderMonitoringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedDatapathObservabilityConfig': obj.advancedDatapathObservabilityConfig?.map(y => toJson_ClusterSpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig(y)),
    'enableComponents': obj.enableComponents?.map(y => y),
    'managedPrometheus': obj.managedPrometheus?.map(y => toJson_ClusterSpecForProviderMonitoringConfigManagedPrometheus(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNetworkPerformanceConfig
 */
export interface ClusterSpecForProviderNetworkPerformanceConfig {
  /**
   * Specifies the total network bandwidth tier for NodePools in the cluster.
   *
   * @schema ClusterSpecForProviderNetworkPerformanceConfig#totalEgressBandwidthTier
   */
  readonly totalEgressBandwidthTier?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNetworkPerformanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNetworkPerformanceConfig(obj: ClusterSpecForProviderNetworkPerformanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'totalEgressBandwidthTier': obj.totalEgressBandwidthTier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNetworkPolicy
 */
export interface ClusterSpecForProviderNetworkPolicy {
  /**
   * Whether network policy is enabled on the cluster.
   *
   * @schema ClusterSpecForProviderNetworkPolicy#enabled
   */
  readonly enabled?: boolean;

  /**
   * The selected network policy provider. Defaults to PROVIDER_UNSPECIFIED.
   *
   * @default PROVIDER_UNSPECIFIED.
   * @schema ClusterSpecForProviderNetworkPolicy#provider
   */
  readonly provider?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNetworkPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNetworkPolicy(obj: ClusterSpecForProviderNetworkPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'provider': obj.provider,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema ClusterSpecForProviderNetworkRef
 */
export interface ClusterSpecForProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderNetworkRef#policy
   */
  readonly policy?: ClusterSpecForProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNetworkRef(obj: ClusterSpecForProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema ClusterSpecForProviderNetworkSelector
 */
export interface ClusterSpecForProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderNetworkSelector#policy
   */
  readonly policy?: ClusterSpecForProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNetworkSelector(obj: ClusterSpecForProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfig
 */
export interface ClusterSpecForProviderNodeConfig {
  /**
   * Specifies options for controlling
   * advanced machine features. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#advancedMachineFeatures
   */
  readonly advancedMachineFeatures?: ClusterSpecForProviderNodeConfigAdvancedMachineFeatures[];

  /**
   * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
   *
   * @schema ClusterSpecForProviderNodeConfig#bootDiskKmsKey
   */
  readonly bootDiskKmsKey?: string;

  /**
   * Configuration for Confidential Nodes feature. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#confidentialNodes
   */
  readonly confidentialNodes?: ClusterSpecForProviderNodeConfigConfidentialNodes[];

  /**
   * Parameters to customize containerd runtime. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#containerdConfig
   */
  readonly containerdConfig?: ClusterSpecForProviderNodeConfigContainerdConfig[];

  /**
   * Size of the disk attached to each node, specified
   * in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
   *
   * @default 100GB.
   * @schema ClusterSpecForProviderNodeConfig#diskSizeGb
   */
  readonly diskSizeGb?: number;

  /**
   * Type of the disk attached to each node
   * (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-balanced'
   *
   * @schema ClusterSpecForProviderNodeConfig#diskType
   */
  readonly diskType?: string;

  /**
   * Enabling Confidential Storage will create boot disk with confidential mode. It is disabled by default.
   *
   * @schema ClusterSpecForProviderNodeConfig#enableConfidentialStorage
   */
  readonly enableConfidentialStorage?: boolean;

  /**
   * Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#ephemeralStorageLocalSsdConfig
   */
  readonly ephemeralStorageLocalSsdConfig?: ClusterSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig[];

  /**
   * Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
   * Node Pool must enable gvnic.
   * GKE version 1.25.2-gke.1700 or later.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#fastSocket
   */
  readonly fastSocket?: ClusterSpecForProviderNodeConfigFastSocket[];

  /**
   * Enables Flex Start provisioning model for the node pool.
   *
   * @schema ClusterSpecForProviderNodeConfig#flexStart
   */
  readonly flexStart?: boolean;

  /**
   * Parameters for the Google Container Filesystem (GCFS).
   * If unspecified, GCFS will not be enabled on the node pool. When enabling this feature you must specify image_type = "COS_CONTAINERD" and node_version from GKE versions 1.19 or later to use it.
   * For GKE versions 1.19, 1.20, and 1.21, the recommended minimum node_version would be 1.19.15-gke.1300, 1.20.11-gke.1300, and 1.21.5-gke.1300 respectively.
   * A machine_type that has more than 16 GiB of memory is also recommended.
   * GCFS must be enabled in order to use image streaming.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#gcfsConfig
   */
  readonly gcfsConfig?: ClusterSpecForProviderNodeConfigGcfsConfig[];

  /**
   * List of the type and count of accelerator cards attached to the instance.
   * Structure documented below.
   * Note: As of 6.0.0, argument syntax
   * is no longer supported for this field in favor of block syntax.
   * To dynamically set a list of guest accelerators, use dynamic blocks.
   * To set an empty list, use a single guest_accelerator block with count = 0.
   *
   * @schema ClusterSpecForProviderNodeConfig#guestAccelerator
   */
  readonly guestAccelerator?: ClusterSpecForProviderNodeConfigGuestAccelerator[];

  /**
   * Google Virtual NIC (gVNIC) is a virtual network interface.
   * Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
   * gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
   * GKE node version 1.15.11-gke.15 or later
   * Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#gvnic
   */
  readonly gvnic?: ClusterSpecForProviderNodeConfigGvnic[];

  /**
   * The maintenance policy to use for the cluster. Structure is
   * documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#hostMaintenancePolicy
   */
  readonly hostMaintenancePolicy?: ClusterSpecForProviderNodeConfigHostMaintenancePolicy[];

  /**
   * The image type to use for this node. Note that changing the image type
   * will delete and recreate all nodes in the node pool.
   *
   * @schema ClusterSpecForProviderNodeConfig#imageType
   */
  readonly imageType?: string;

  /**
   * Kubelet configuration, currently supported attributes can be found here.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#kubeletConfig
   */
  readonly kubeletConfig?: ClusterSpecForProviderNodeConfigKubeletConfig[];

  /**
   * The Kubernetes labels (key/value pairs) to be applied to each node. The kubernetes.io/ and k8s.io/ prefixes are
   * reserved by Kubernetes Core components and cannot be specified.
   *
   * @schema ClusterSpecForProviderNodeConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Parameters that can be configured on Linux nodes. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#linuxNodeConfig
   */
  readonly linuxNodeConfig?: ClusterSpecForProviderNodeConfigLinuxNodeConfig[];

  /**
   * Parameters for the local NVMe SSDs. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#localNvmeSsdBlockConfig
   */
  readonly localNvmeSsdBlockConfig?: ClusterSpecForProviderNodeConfigLocalNvmeSsdBlockConfig[];

  /**
   * The amount of local SSD disks that will be
   * attached to each cluster node. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterSpecForProviderNodeConfig#localSsdCount
   */
  readonly localSsdCount?: number;

  /**
   * Possible Local SSD encryption modes:
   * Accepted values are:
   *
   * @schema ClusterSpecForProviderNodeConfig#localSsdEncryptionMode
   */
  readonly localSsdEncryptionMode?: string;

  /**
   * wide default value. Valid values include DEFAULT and MAX_THROUGHPUT. See Increasing logging agent throughput for more information.
   *
   * @schema ClusterSpecForProviderNodeConfig#loggingVariant
   */
  readonly loggingVariant?: string;

  /**
   * The name of a Google Compute Engine machine type.
   * Defaults to e2-medium. To create a custom machine type, value should be set as specified
   * here.
   *
   * @default e2-medium. To create a custom machine type, value should be set as specified
   * @schema ClusterSpecForProviderNodeConfig#machineType
   */
  readonly machineType?: string;

  /**
   * The runtime of each node in the node pool in seconds, terminated by 's'. Example: "3600s".
   *
   * @schema ClusterSpecForProviderNodeConfig#maxRunDuration
   */
  readonly maxRunDuration?: string;

  /**
   * The metadata key/value pairs assigned to instances in
   * the cluster. From GKE 1. To avoid this, set the
   * value in your config.
   *
   * @schema ClusterSpecForProviderNodeConfig#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * Minimum CPU platform to be used by this instance.
   * The instance may be scheduled on the specified or newer CPU platform. Applicable
   * values are the friendly names of CPU platforms, such as Intel Haswell. See the
   * official documentation
   * for more information.
   *
   * @schema ClusterSpecForProviderNodeConfig#minCpuPlatform
   */
  readonly minCpuPlatform?: string;

  /**
   * Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on sole tenant nodes.
   *
   * @schema ClusterSpecForProviderNodeConfig#nodeGroup
   */
  readonly nodeGroup?: string;

  /**
   * The set of Google API scopes to be made available
   * on all of the node VMs under the "default" service account.
   * Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set service_account to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
   *
   * @schema ClusterSpecForProviderNodeConfig#oauthScopes
   */
  readonly oauthScopes?: string[];

  /**
   * A boolean that represents whether or not the underlying node VMs
   * are preemptible. See the official documentation
   * for more information. Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecForProviderNodeConfig#preemptible
   */
  readonly preemptible?: boolean;

  /**
   * The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#reservationAffinity
   */
  readonly reservationAffinity?: ClusterSpecForProviderNodeConfigReservationAffinity[];

  /**
   * The GCP labels (key/value pairs) to be applied to each node. Refer here
   * for how these labels are applied to clusters, node pools and nodes.
   *
   * @schema ClusterSpecForProviderNodeConfig#resourceLabels
   */
  readonly resourceLabels?: { [key: string]: string };

  /**
   * A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found here. A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. tagKeys/{tag_key_id}=tagValues/{tag_value_id} 2. {org_id}/{tag_key_name}={tag_value_name} 3. {project_id}/{tag_key_name}={tag_value_name}.
   *
   * @schema ClusterSpecForProviderNodeConfig#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };

  /**
   * Parameters for secondary boot disks to preload container images and data on new nodes. Structure is documented below. gcfs_config must be enabled=true for this feature to work. min_master_version must also be set to use GKE 1.28.3-gke.106700 or later versions.
   *
   * @schema ClusterSpecForProviderNodeConfig#secondaryBootDisks
   */
  readonly secondaryBootDisks?: ClusterSpecForProviderNodeConfigSecondaryBootDisks[];

  /**
   * The service account to be used by the Node VMs.
   * If not specified, the "default" service account is used.
   *
   * @schema ClusterSpecForProviderNodeConfig#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema ClusterSpecForProviderNodeConfig#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSpecForProviderNodeConfigServiceAccountRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema ClusterSpecForProviderNodeConfig#serviceAccountSelector
   */
  readonly serviceAccountSelector?: ClusterSpecForProviderNodeConfigServiceAccountSelector;

  /**
   * Shielded Instance options. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: ClusterSpecForProviderNodeConfigShieldedInstanceConfig[];

  /**
   * Allows specifying multiple node affinities useful for running workloads on sole tenant nodes. node_affinity structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#soleTenantConfig
   */
  readonly soleTenantConfig?: ClusterSpecForProviderNodeConfigSoleTenantConfig[];

  /**
   * A boolean that represents whether the underlying node VMs are spot.
   * See the official documentation
   * for more information. Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecForProviderNodeConfig#spot
   */
  readonly spot?: boolean;

  /**
   * The list of Storage Pools where boot disks are provisioned.
   *
   * @schema ClusterSpecForProviderNodeConfig#storagePools
   */
  readonly storagePools?: string[];

  /**
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls.
   *
   * @schema ClusterSpecForProviderNodeConfig#tags
   */
  readonly tags?: string[];

  /**
   * A list of
   * Kubernetes taints
   * to apply to nodes. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#taint
   */
  readonly taint?: ClusterSpecForProviderNodeConfigTaint[];

  /**
   * Windows node configuration, currently supporting OSVersion attribute. The value must be one of [OS_VERSION_UNSPECIFIED, OS_VERSION_LTSC2019, OS_VERSION_LTSC2022]. For example:
   *
   * @schema ClusterSpecForProviderNodeConfig#windowsNodeConfig
   */
  readonly windowsNodeConfig?: ClusterSpecForProviderNodeConfigWindowsNodeConfig[];

  /**
   * Metadata configuration to expose to workloads on the node pool.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfig#workloadMetadataConfig
   */
  readonly workloadMetadataConfig?: ClusterSpecForProviderNodeConfigWorkloadMetadataConfig[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfig(obj: ClusterSpecForProviderNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedMachineFeatures': obj.advancedMachineFeatures?.map(y => toJson_ClusterSpecForProviderNodeConfigAdvancedMachineFeatures(y)),
    'bootDiskKmsKey': obj.bootDiskKmsKey,
    'confidentialNodes': obj.confidentialNodes?.map(y => toJson_ClusterSpecForProviderNodeConfigConfidentialNodes(y)),
    'containerdConfig': obj.containerdConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigContainerdConfig(y)),
    'diskSizeGb': obj.diskSizeGb,
    'diskType': obj.diskType,
    'enableConfidentialStorage': obj.enableConfidentialStorage,
    'ephemeralStorageLocalSsdConfig': obj.ephemeralStorageLocalSsdConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig(y)),
    'fastSocket': obj.fastSocket?.map(y => toJson_ClusterSpecForProviderNodeConfigFastSocket(y)),
    'flexStart': obj.flexStart,
    'gcfsConfig': obj.gcfsConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigGcfsConfig(y)),
    'guestAccelerator': obj.guestAccelerator?.map(y => toJson_ClusterSpecForProviderNodeConfigGuestAccelerator(y)),
    'gvnic': obj.gvnic?.map(y => toJson_ClusterSpecForProviderNodeConfigGvnic(y)),
    'hostMaintenancePolicy': obj.hostMaintenancePolicy?.map(y => toJson_ClusterSpecForProviderNodeConfigHostMaintenancePolicy(y)),
    'imageType': obj.imageType,
    'kubeletConfig': obj.kubeletConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigKubeletConfig(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'linuxNodeConfig': obj.linuxNodeConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigLinuxNodeConfig(y)),
    'localNvmeSsdBlockConfig': obj.localNvmeSsdBlockConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigLocalNvmeSsdBlockConfig(y)),
    'localSsdCount': obj.localSsdCount,
    'localSsdEncryptionMode': obj.localSsdEncryptionMode,
    'loggingVariant': obj.loggingVariant,
    'machineType': obj.machineType,
    'maxRunDuration': obj.maxRunDuration,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'minCpuPlatform': obj.minCpuPlatform,
    'nodeGroup': obj.nodeGroup,
    'oauthScopes': obj.oauthScopes?.map(y => y),
    'preemptible': obj.preemptible,
    'reservationAffinity': obj.reservationAffinity?.map(y => toJson_ClusterSpecForProviderNodeConfigReservationAffinity(y)),
    'resourceLabels': ((obj.resourceLabels) === undefined) ? undefined : (Object.entries(obj.resourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'secondaryBootDisks': obj.secondaryBootDisks?.map(y => toJson_ClusterSpecForProviderNodeConfigSecondaryBootDisks(y)),
    'serviceAccount': obj.serviceAccount,
    'serviceAccountRef': toJson_ClusterSpecForProviderNodeConfigServiceAccountRef(obj.serviceAccountRef),
    'serviceAccountSelector': toJson_ClusterSpecForProviderNodeConfigServiceAccountSelector(obj.serviceAccountSelector),
    'shieldedInstanceConfig': obj.shieldedInstanceConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigShieldedInstanceConfig(y)),
    'soleTenantConfig': obj.soleTenantConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigSoleTenantConfig(y)),
    'spot': obj.spot,
    'storagePools': obj.storagePools?.map(y => y),
    'tags': obj.tags?.map(y => y),
    'taint': obj.taint?.map(y => toJson_ClusterSpecForProviderNodeConfigTaint(y)),
    'windowsNodeConfig': obj.windowsNodeConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigWindowsNodeConfig(y)),
    'workloadMetadataConfig': obj.workloadMetadataConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigWorkloadMetadataConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodePoolAutoConfig
 */
export interface ClusterSpecForProviderNodePoolAutoConfig {
  /**
   * Linux system configuration for the cluster's automatically provisioned node pools. Only cgroup_mode field is supported in node_pool_auto_config. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodePoolAutoConfig#linuxNodeConfig
   */
  readonly linuxNodeConfig?: ClusterSpecForProviderNodePoolAutoConfigLinuxNodeConfig[];

  /**
   * The network tag config for the cluster's automatically provisioned node pools.
   *
   * @schema ClusterSpecForProviderNodePoolAutoConfig#networkTags
   */
  readonly networkTags?: ClusterSpecForProviderNodePoolAutoConfigNetworkTags[];

  /**
   * Kubelet configuration for Autopilot clusters. Currently, only insecure_kubelet_readonly_port_enabled is supported here.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodePoolAutoConfig#nodeKubeletConfig
   */
  readonly nodeKubeletConfig?: ClusterSpecForProviderNodePoolAutoConfigNodeKubeletConfig[];

  /**
   * A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found here. A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. tagKeys/{tag_key_id}=tagValues/{tag_value_id} 2. {org_id}/{tag_key_name}={tag_value_name} 3. {project_id}/{tag_key_name}={tag_value_name}.
   *
   * @schema ClusterSpecForProviderNodePoolAutoConfig#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodePoolAutoConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodePoolAutoConfig(obj: ClusterSpecForProviderNodePoolAutoConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'linuxNodeConfig': obj.linuxNodeConfig?.map(y => toJson_ClusterSpecForProviderNodePoolAutoConfigLinuxNodeConfig(y)),
    'networkTags': obj.networkTags?.map(y => toJson_ClusterSpecForProviderNodePoolAutoConfigNetworkTags(y)),
    'nodeKubeletConfig': obj.nodeKubeletConfig?.map(y => toJson_ClusterSpecForProviderNodePoolAutoConfigNodeKubeletConfig(y)),
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodePoolDefaults
 */
export interface ClusterSpecForProviderNodePoolDefaults {
  /**
   * Subset of NodeConfig message that has defaults.
   *
   * @schema ClusterSpecForProviderNodePoolDefaults#nodeConfigDefaults
   */
  readonly nodeConfigDefaults?: ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaults[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodePoolDefaults' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodePoolDefaults(obj: ClusterSpecForProviderNodePoolDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeConfigDefaults': obj.nodeConfigDefaults?.map(y => toJson_ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaults(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNotificationConfig
 */
export interface ClusterSpecForProviderNotificationConfig {
  /**
   * The pubsub config for the cluster's upgrade notifications.
   *
   * @schema ClusterSpecForProviderNotificationConfig#pubsub
   */
  readonly pubsub?: ClusterSpecForProviderNotificationConfigPubsub[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderNotificationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNotificationConfig(obj: ClusterSpecForProviderNotificationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pubsub': obj.pubsub?.map(y => toJson_ClusterSpecForProviderNotificationConfigPubsub(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderPodAutoscaling
 */
export interface ClusterSpecForProviderPodAutoscaling {
  /**
   * Enable the Horizontal Pod Autoscaling profile for this cluster.
   * Acceptable values are:
   *
   * @schema ClusterSpecForProviderPodAutoscaling#hpaProfile
   */
  readonly hpaProfile?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderPodAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderPodAutoscaling(obj: ClusterSpecForProviderPodAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hpaProfile': obj.hpaProfile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderPrivateClusterConfig
 */
export interface ClusterSpecForProviderPrivateClusterConfig {
  /**
   * When true, the cluster's private
   * endpoint is used as the cluster endpoint and access through the public endpoint
   * is disabled. When false, either endpoint can be used. This field only applies
   * to private clusters, when enable_private_nodes is true.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfig#enablePrivateEndpoint
   */
  readonly enablePrivateEndpoint?: boolean;

  /**
   * Enables the private cluster feature,
   * creating a private endpoint on the cluster. In a private cluster, nodes only
   * have RFC 1918 private addresses and communicate with the master's private
   * endpoint via private networking.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfig#enablePrivateNodes
   */
  readonly enablePrivateNodes?: boolean;

  /**
   * Controls cluster master global
   * access settings. Structure is documented below.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfig#masterGlobalAccessConfig
   */
  readonly masterGlobalAccessConfig?: ClusterSpecForProviderPrivateClusterConfigMasterGlobalAccessConfig[];

  /**
   * The IP range in CIDR notation to use for
   * the hosted master network. This range will be used for assigning private IP
   * addresses to the cluster master(s) and the ILB VIP. This range must not overlap
   * with any other ranges in use within the cluster's network, and it must be a /28
   * subnet. See Private Cluster Limitations
   * for more details. This field only applies to private clusters, when
   * enable_private_nodes is true.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfig#masterIpv4CidrBlock
   */
  readonly masterIpv4CidrBlock?: string;

  /**
   * Subnetwork in cluster's network where master's endpoint will be provisioned.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfig#privateEndpointSubnetwork
   */
  readonly privateEndpointSubnetwork?: string;

  /**
   * Reference to a Subnetwork in compute to populate privateEndpointSubnetwork.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfig#privateEndpointSubnetworkRef
   */
  readonly privateEndpointSubnetworkRef?: ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef;

  /**
   * Selector for a Subnetwork in compute to populate privateEndpointSubnetwork.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfig#privateEndpointSubnetworkSelector
   */
  readonly privateEndpointSubnetworkSelector?: ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector;
}

/**
 * Converts an object of type 'ClusterSpecForProviderPrivateClusterConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderPrivateClusterConfig(obj: ClusterSpecForProviderPrivateClusterConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enablePrivateEndpoint': obj.enablePrivateEndpoint,
    'enablePrivateNodes': obj.enablePrivateNodes,
    'masterGlobalAccessConfig': obj.masterGlobalAccessConfig?.map(y => toJson_ClusterSpecForProviderPrivateClusterConfigMasterGlobalAccessConfig(y)),
    'masterIpv4CidrBlock': obj.masterIpv4CidrBlock,
    'privateEndpointSubnetwork': obj.privateEndpointSubnetwork,
    'privateEndpointSubnetworkRef': toJson_ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef(obj.privateEndpointSubnetworkRef),
    'privateEndpointSubnetworkSelector': toJson_ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector(obj.privateEndpointSubnetworkSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderRbacBindingConfig
 */
export interface ClusterSpecForProviderRbacBindingConfig {
  /**
   * Setting this to true will allow any ClusterRoleBinding and RoleBinding with subjects system:authenticated.
   *
   * @schema ClusterSpecForProviderRbacBindingConfig#enableInsecureBindingSystemAuthenticated
   */
  readonly enableInsecureBindingSystemAuthenticated?: boolean;

  /**
   * Setting this to true will allow any ClusterRoleBinding and RoleBinding with subjects system:anonymous or system:unauthenticated.
   *
   * @schema ClusterSpecForProviderRbacBindingConfig#enableInsecureBindingSystemUnauthenticated
   */
  readonly enableInsecureBindingSystemUnauthenticated?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderRbacBindingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderRbacBindingConfig(obj: ClusterSpecForProviderRbacBindingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableInsecureBindingSystemAuthenticated': obj.enableInsecureBindingSystemAuthenticated,
    'enableInsecureBindingSystemUnauthenticated': obj.enableInsecureBindingSystemUnauthenticated,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderReleaseChannel
 */
export interface ClusterSpecForProviderReleaseChannel {
  /**
   * The selected release channel.
   * Accepted values are:
   *
   * @schema ClusterSpecForProviderReleaseChannel#channel
   */
  readonly channel?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderReleaseChannel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderReleaseChannel(obj: ClusterSpecForProviderReleaseChannel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'channel': obj.channel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderResourceUsageExportConfig
 */
export interface ClusterSpecForProviderResourceUsageExportConfig {
  /**
   * Parameters for using BigQuery as the destination of resource usage export.
   *
   * @schema ClusterSpecForProviderResourceUsageExportConfig#bigqueryDestination
   */
  readonly bigqueryDestination?: ClusterSpecForProviderResourceUsageExportConfigBigqueryDestination[];

  /**
   * Whether to enable network egress metering for this cluster. If enabled, a daemonset will be created
   * in the cluster to meter network egress traffic.
   *
   * @schema ClusterSpecForProviderResourceUsageExportConfig#enableNetworkEgressMetering
   */
  readonly enableNetworkEgressMetering?: boolean;

  /**
   * Whether to enable resource
   * consumption metering on this cluster. When enabled, a table will be created in
   * the resource export BigQuery dataset to store resource consumption data. The
   * resulting table can be joined with the resource usage table or with BigQuery
   * billing export. Defaults to true.
   *
   * @default true.
   * @schema ClusterSpecForProviderResourceUsageExportConfig#enableResourceConsumptionMetering
   */
  readonly enableResourceConsumptionMetering?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderResourceUsageExportConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderResourceUsageExportConfig(obj: ClusterSpecForProviderResourceUsageExportConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigqueryDestination': obj.bigqueryDestination?.map(y => toJson_ClusterSpecForProviderResourceUsageExportConfigBigqueryDestination(y)),
    'enableNetworkEgressMetering': obj.enableNetworkEgressMetering,
    'enableResourceConsumptionMetering': obj.enableResourceConsumptionMetering,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderSecretManagerConfig
 */
export interface ClusterSpecForProviderSecretManagerConfig {
  /**
   * Enable the Secret Manager add-on for this cluster.
   *
   * @schema ClusterSpecForProviderSecretManagerConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderSecretManagerConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderSecretManagerConfig(obj: ClusterSpecForProviderSecretManagerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderSecurityPostureConfig
 */
export interface ClusterSpecForProviderSecurityPostureConfig {
  /**
   * Sets the mode of the Kubernetes security posture API's off-cluster features. Available options include DISABLED and BASIC.
   *
   * @schema ClusterSpecForProviderSecurityPostureConfig#mode
   */
  readonly mode?: string;

  /**
   * Sets the mode of the Kubernetes security posture API's workload vulnerability scanning. Available options include VULNERABILITY_DISABLED, VULNERABILITY_BASIC and VULNERABILITY_ENTERPRISE.
   *
   * @schema ClusterSpecForProviderSecurityPostureConfig#vulnerabilityMode
   */
  readonly vulnerabilityMode?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderSecurityPostureConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderSecurityPostureConfig(obj: ClusterSpecForProviderSecurityPostureConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
    'vulnerabilityMode': obj.vulnerabilityMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderServiceExternalIpsConfig
 */
export interface ClusterSpecForProviderServiceExternalIpsConfig {
  /**
   * Controls whether external ips specified by a service will be allowed. It is enabled by default.
   *
   * @schema ClusterSpecForProviderServiceExternalIpsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderServiceExternalIpsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderServiceExternalIpsConfig(obj: ClusterSpecForProviderServiceExternalIpsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Subnetwork in compute to populate subnetwork.
 *
 * @schema ClusterSpecForProviderSubnetworkRef
 */
export interface ClusterSpecForProviderSubnetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderSubnetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderSubnetworkRef#policy
   */
  readonly policy?: ClusterSpecForProviderSubnetworkRefPolicy;
}

/**
 * Converts an object of type 'ClusterSpecForProviderSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderSubnetworkRef(obj: ClusterSpecForProviderSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderSubnetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Subnetwork in compute to populate subnetwork.
 *
 * @schema ClusterSpecForProviderSubnetworkSelector
 */
export interface ClusterSpecForProviderSubnetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderSubnetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderSubnetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderSubnetworkSelector#policy
   */
  readonly policy?: ClusterSpecForProviderSubnetworkSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterSpecForProviderSubnetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderSubnetworkSelector(obj: ClusterSpecForProviderSubnetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderSubnetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderUserManagedKeysConfig
 */
export interface ClusterSpecForProviderUserManagedKeysConfig {
  /**
   * The Certificate Authority Service caPool to use for the aggreation CA in this cluster.
   *
   * @schema ClusterSpecForProviderUserManagedKeysConfig#aggregationCa
   */
  readonly aggregationCa?: string;

  /**
   * The Certificate Authority Service caPool to use for the cluster CA in this cluster.
   *
   * @schema ClusterSpecForProviderUserManagedKeysConfig#clusterCa
   */
  readonly clusterCa?: string;

  /**
   * The Cloud KMS cryptoKey to use for Confidential Hyperdisk on the control plane nodes.
   *
   * @schema ClusterSpecForProviderUserManagedKeysConfig#controlPlaneDiskEncryptionKey
   */
  readonly controlPlaneDiskEncryptionKey?: string;

  /**
   * The Certificate Authority Service caPool to use for the etcd API CA in this cluster.
   *
   * @schema ClusterSpecForProviderUserManagedKeysConfig#etcdApiCa
   */
  readonly etcdApiCa?: string;

  /**
   * The Certificate Authority Service caPool to use for the etcd peer CA in this cluster.
   *
   * @schema ClusterSpecForProviderUserManagedKeysConfig#etcdPeerCa
   */
  readonly etcdPeerCa?: string;

  /**
   * Resource path of the Cloud KMS cryptoKey to use for encryption of internal etcd backups.
   *
   * @schema ClusterSpecForProviderUserManagedKeysConfig#gkeopsEtcdBackupEncryptionKey
   */
  readonly gkeopsEtcdBackupEncryptionKey?: string;

  /**
   * The Cloud KMS cryptoKeyVersions to use for signing service account JWTs issued by this cluster.
   *
   * @schema ClusterSpecForProviderUserManagedKeysConfig#serviceAccountSigningKeys
   */
  readonly serviceAccountSigningKeys?: string[];

  /**
   * The Cloud KMS cryptoKeyVersions to use for verifying service account JWTs issued by this cluster.
   *
   * @schema ClusterSpecForProviderUserManagedKeysConfig#serviceAccountVerificationKeys
   */
  readonly serviceAccountVerificationKeys?: string[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderUserManagedKeysConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderUserManagedKeysConfig(obj: ClusterSpecForProviderUserManagedKeysConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationCa': obj.aggregationCa,
    'clusterCa': obj.clusterCa,
    'controlPlaneDiskEncryptionKey': obj.controlPlaneDiskEncryptionKey,
    'etcdApiCa': obj.etcdApiCa,
    'etcdPeerCa': obj.etcdPeerCa,
    'gkeopsEtcdBackupEncryptionKey': obj.gkeopsEtcdBackupEncryptionKey,
    'serviceAccountSigningKeys': obj.serviceAccountSigningKeys?.map(y => y),
    'serviceAccountVerificationKeys': obj.serviceAccountVerificationKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderVerticalPodAutoscaling
 */
export interface ClusterSpecForProviderVerticalPodAutoscaling {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderVerticalPodAutoscaling#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderVerticalPodAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderVerticalPodAutoscaling(obj: ClusterSpecForProviderVerticalPodAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderWorkloadIdentityConfig
 */
export interface ClusterSpecForProviderWorkloadIdentityConfig {
  /**
   * The workload pool to attach all Kubernetes service accounts to.
   *
   * @schema ClusterSpecForProviderWorkloadIdentityConfig#workloadPool
   */
  readonly workloadPool?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderWorkloadIdentityConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderWorkloadIdentityConfig(obj: ClusterSpecForProviderWorkloadIdentityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'workloadPool': obj.workloadPool,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfig
 */
export interface ClusterSpecInitProviderAddonsConfig {
  /**
   * . Structure is documented below.
   *
   * @schema ClusterSpecInitProviderAddonsConfig#cloudrunConfig
   */
  readonly cloudrunConfig?: ClusterSpecInitProviderAddonsConfigCloudrunConfig[];

  /**
   * .
   * The status of the ConfigConnector addon. It is disabled by default; Set enabled = true to enable.
   *
   * @schema ClusterSpecInitProviderAddonsConfig#configConnectorConfig
   */
  readonly configConnectorConfig?: ClusterSpecInitProviderAddonsConfigConfigConnectorConfig[];

  /**
   * .
   * The status of the NodeLocal DNSCache addon. It is disabled by default.
   * Set enabled = true to enable.
   *
   * @schema ClusterSpecInitProviderAddonsConfig#dnsCacheConfig
   */
  readonly dnsCacheConfig?: ClusterSpecInitProviderAddonsConfigDnsCacheConfig[];

  /**
   * .
   * Whether this cluster should enable the Google Compute Engine Persistent Disk Container Storage Interface (CSI) Driver. Set enabled = true to enable.
   *
   * @schema ClusterSpecInitProviderAddonsConfig#gcePersistentDiskCsiDriverConfig
   */
  readonly gcePersistentDiskCsiDriverConfig?: ClusterSpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig[];

  /**
   * The status of the Filestore CSI driver addon,
   * which allows the usage of filestore instance as volumes.
   * It is disabled by default; set enabled = true to enable.
   *
   * @schema ClusterSpecInitProviderAddonsConfig#gcpFilestoreCsiDriverConfig
   */
  readonly gcpFilestoreCsiDriverConfig?: ClusterSpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig[];

  /**
   * The status of the GCSFuse CSI driver addon,
   * which allows the usage of a gcs bucket as volumes.
   * It is disabled by default for Standard clusters; set enabled = true to enable.
   * It is enabled by default for Autopilot clusters with version 1.24 or later; set enabled = true to enable it explicitly.
   * See Enable the Cloud Storage FUSE CSI driver for more information.
   *
   * @schema ClusterSpecInitProviderAddonsConfig#gcsFuseCsiDriverConfig
   */
  readonly gcsFuseCsiDriverConfig?: ClusterSpecInitProviderAddonsConfigGcsFuseCsiDriverConfig[];

  /**
   * .
   * The status of the Backup for GKE agent addon. It is disabled by default; Set enabled = true to enable.
   *
   * @schema ClusterSpecInitProviderAddonsConfig#gkeBackupAgentConfig
   */
  readonly gkeBackupAgentConfig?: ClusterSpecInitProviderAddonsConfigGkeBackupAgentConfig[];

  /**
   * The status of the Horizontal Pod Autoscaling
   * addon, which increases or decreases the number of replica pods a replication controller
   * has based on the resource usage of the existing pods.
   * It is enabled by default;
   * set disabled = true to disable.
   *
   * @schema ClusterSpecInitProviderAddonsConfig#horizontalPodAutoscaling
   */
  readonly horizontalPodAutoscaling?: ClusterSpecInitProviderAddonsConfigHorizontalPodAutoscaling[];

  /**
   * The status of the HTTP (L7) load balancing
   * controller addon, which makes it easy to set up HTTP load balancers for services in a
   * cluster. It is enabled by default; set disabled = true to disable.
   *
   * @schema ClusterSpecInitProviderAddonsConfig#httpLoadBalancing
   */
  readonly httpLoadBalancing?: ClusterSpecInitProviderAddonsConfigHttpLoadBalancing[];

  /**
   * The status of the Lustre CSI driver addon,
   * which allows the usage of a Lustre instances as volumes.
   * It is disabled by default for Standard clusters; set enabled = true to enable.
   * It is disabled by default for Autopilot clusters; set enabled = true to enable.
   * Lustre CSI Driver Config has optional subfield
   * enable_legacy_lustre_port which allows the Lustre CSI driver to initialize LNet (the virtual networklayer for Lustre kernel module) using port 6988.
   * This flag is required to workaround a port conflict with the gke-metadata-server on GKE nodes.
   * See Enable Lustre CSI driver for more information.
   *
   * @schema ClusterSpecInitProviderAddonsConfig#lustreCsiDriverConfig
   */
  readonly lustreCsiDriverConfig?: ClusterSpecInitProviderAddonsConfigLustreCsiDriverConfig[];

  /**
   * Whether we should enable the network policy addon
   * for the master.  This must be enabled in order to enable network policy for the nodes.
   * To enable this, you must also define a network_policy block,
   * otherwise nothing will happen.
   * It can only be disabled if the nodes already do not have network policies enabled.
   * Defaults to disabled; set disabled = false to enable.
   *
   * @default disabled; set disabled = false to enable.
   * @schema ClusterSpecInitProviderAddonsConfig#networkPolicyConfig
   */
  readonly networkPolicyConfig?: ClusterSpecInitProviderAddonsConfigNetworkPolicyConfig[];

  /**
   * The status of the Parallelstore CSI driver addon,
   * which allows the usage of a Parallelstore instances as volumes.
   * It is disabled by default for Standard clusters; set enabled = true to enable.
   * It is enabled by default for Autopilot clusters with version 1.29 or later; set enabled = true to enable it explicitly.
   * See Enable the Parallelstore CSI driver for more information.
   *
   * @schema ClusterSpecInitProviderAddonsConfig#parallelstoreCsiDriverConfig
   */
  readonly parallelstoreCsiDriverConfig?: ClusterSpecInitProviderAddonsConfigParallelstoreCsiDriverConfig[];

  /**
   * . The status of the Ray Operator
   * addon.
   * It is disabled by default. Set enabled = true to enable. The minimum
   * cluster version to enable Ray is 1.30.0-gke.1747000.
   *
   * @schema ClusterSpecInitProviderAddonsConfig#rayOperatorConfig
   */
  readonly rayOperatorConfig?: ClusterSpecInitProviderAddonsConfigRayOperatorConfig[];

  /**
   * .
   * The status of the Stateful HA addon, which provides automatic configurable failover for stateful applications.
   * It is disabled by default for Standard clusters. Set enabled = true to enable.
   *
   * @schema ClusterSpecInitProviderAddonsConfig#statefulHaConfig
   */
  readonly statefulHaConfig?: ClusterSpecInitProviderAddonsConfigStatefulHaConfig[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfig(obj: ClusterSpecInitProviderAddonsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudrunConfig': obj.cloudrunConfig?.map(y => toJson_ClusterSpecInitProviderAddonsConfigCloudrunConfig(y)),
    'configConnectorConfig': obj.configConnectorConfig?.map(y => toJson_ClusterSpecInitProviderAddonsConfigConfigConnectorConfig(y)),
    'dnsCacheConfig': obj.dnsCacheConfig?.map(y => toJson_ClusterSpecInitProviderAddonsConfigDnsCacheConfig(y)),
    'gcePersistentDiskCsiDriverConfig': obj.gcePersistentDiskCsiDriverConfig?.map(y => toJson_ClusterSpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig(y)),
    'gcpFilestoreCsiDriverConfig': obj.gcpFilestoreCsiDriverConfig?.map(y => toJson_ClusterSpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig(y)),
    'gcsFuseCsiDriverConfig': obj.gcsFuseCsiDriverConfig?.map(y => toJson_ClusterSpecInitProviderAddonsConfigGcsFuseCsiDriverConfig(y)),
    'gkeBackupAgentConfig': obj.gkeBackupAgentConfig?.map(y => toJson_ClusterSpecInitProviderAddonsConfigGkeBackupAgentConfig(y)),
    'horizontalPodAutoscaling': obj.horizontalPodAutoscaling?.map(y => toJson_ClusterSpecInitProviderAddonsConfigHorizontalPodAutoscaling(y)),
    'httpLoadBalancing': obj.httpLoadBalancing?.map(y => toJson_ClusterSpecInitProviderAddonsConfigHttpLoadBalancing(y)),
    'lustreCsiDriverConfig': obj.lustreCsiDriverConfig?.map(y => toJson_ClusterSpecInitProviderAddonsConfigLustreCsiDriverConfig(y)),
    'networkPolicyConfig': obj.networkPolicyConfig?.map(y => toJson_ClusterSpecInitProviderAddonsConfigNetworkPolicyConfig(y)),
    'parallelstoreCsiDriverConfig': obj.parallelstoreCsiDriverConfig?.map(y => toJson_ClusterSpecInitProviderAddonsConfigParallelstoreCsiDriverConfig(y)),
    'rayOperatorConfig': obj.rayOperatorConfig?.map(y => toJson_ClusterSpecInitProviderAddonsConfigRayOperatorConfig(y)),
    'statefulHaConfig': obj.statefulHaConfig?.map(y => toJson_ClusterSpecInitProviderAddonsConfigStatefulHaConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAnonymousAuthenticationConfig
 */
export interface ClusterSpecInitProviderAnonymousAuthenticationConfig {
  /**
   * Sets or removes authentication restrictions. Available options include LIMITED and ENABLED.
   *
   * @schema ClusterSpecInitProviderAnonymousAuthenticationConfig#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAnonymousAuthenticationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAnonymousAuthenticationConfig(obj: ClusterSpecInitProviderAnonymousAuthenticationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAuthenticatorGroupsConfig
 */
export interface ClusterSpecInitProviderAuthenticatorGroupsConfig {
  /**
   * The name of the RBAC security group for use with Google security groups in Kubernetes RBAC. Group name must be in format gke-security-groups@yourdomain.com.
   *
   * @schema ClusterSpecInitProviderAuthenticatorGroupsConfig#securityGroup
   */
  readonly securityGroup?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAuthenticatorGroupsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAuthenticatorGroupsConfig(obj: ClusterSpecInitProviderAuthenticatorGroupsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroup': obj.securityGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderBinaryAuthorization
 */
export interface ClusterSpecInitProviderBinaryAuthorization {
  /**
   * (DEPRECATED) Enable Binary Authorization for this cluster. Deprecated in favor of evaluation_mode.
   *
   * @schema ClusterSpecInitProviderBinaryAuthorization#enabled
   */
  readonly enabled?: boolean;

  /**
   * Mode of operation for Binary Authorization policy evaluation. Valid values are DISABLED
   * and PROJECT_SINGLETON_POLICY_ENFORCE.
   *
   * @schema ClusterSpecInitProviderBinaryAuthorization#evaluationMode
   */
  readonly evaluationMode?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderBinaryAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderBinaryAuthorization(obj: ClusterSpecInitProviderBinaryAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'evaluationMode': obj.evaluationMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderClusterAutoscaling
 */
export interface ClusterSpecInitProviderClusterAutoscaling {
  /**
   * Contains defaults for a node pool created by NAP. A subset of fields also apply to
   * GKE Autopilot clusters.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProviderClusterAutoscaling#autoProvisioningDefaults
   */
  readonly autoProvisioningDefaults?: ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults[];

  /**
   * The list of Google Compute Engine
   * zones in which the
   * NodePool's nodes can be created by NAP.
   *
   * @schema ClusterSpecInitProviderClusterAutoscaling#autoProvisioningLocations
   */
  readonly autoProvisioningLocations?: string[];

  /**
   * Configuration
   * options for the Autoscaling profile
   * feature, which lets you choose whether the cluster autoscaler should optimize for resource utilization or resource availability
   * when deciding to remove nodes from a cluster. Can be BALANCED or OPTIMIZE_UTILIZATION. Defaults to BALANCED.
   *
   * @default BALANCED.
   * @schema ClusterSpecInitProviderClusterAutoscaling#autoscalingProfile
   */
  readonly autoscalingProfile?: string;

  /**
   * Whether node auto-provisioning is enabled. Must be supplied for GKE Standard clusters, true is implied
   * for autopilot clusters. Resource limits for cpu and memory must be defined to enable node auto-provisioning for GKE Standard.
   *
   * @schema ClusterSpecInitProviderClusterAutoscaling#enabled
   */
  readonly enabled?: boolean;

  /**
   * Global constraints for machine resources in the
   * cluster. Configuring the cpu and memory types is required if node
   * auto-provisioning is enabled. These limits will apply to node pool autoscaling
   * in addition to node auto-provisioning. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderClusterAutoscaling#resourceLimits
   */
  readonly resourceLimits?: ClusterSpecInitProviderClusterAutoscalingResourceLimits[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderClusterAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderClusterAutoscaling(obj: ClusterSpecInitProviderClusterAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoProvisioningDefaults': obj.autoProvisioningDefaults?.map(y => toJson_ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults(y)),
    'autoProvisioningLocations': obj.autoProvisioningLocations?.map(y => y),
    'autoscalingProfile': obj.autoscalingProfile,
    'enabled': obj.enabled,
    'resourceLimits': obj.resourceLimits?.map(y => toJson_ClusterSpecInitProviderClusterAutoscalingResourceLimits(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderConfidentialNodes
 */
export interface ClusterSpecInitProviderConfidentialNodes {
  /**
   * Defines the type of technology used
   * by the confidential node.
   *
   * @schema ClusterSpecInitProviderConfidentialNodes#confidentialInstanceType
   */
  readonly confidentialInstanceType?: string;

  /**
   * Enable Confidential GKE Nodes for this node pool, to
   * enforce encryption of data in-use.
   *
   * @schema ClusterSpecInitProviderConfidentialNodes#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderConfidentialNodes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderConfidentialNodes(obj: ClusterSpecInitProviderConfidentialNodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confidentialInstanceType': obj.confidentialInstanceType,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderControlPlaneEndpointsConfig
 */
export interface ClusterSpecInitProviderControlPlaneEndpointsConfig {
  /**
   * DNS endpoint configuration.
   *
   * @schema ClusterSpecInitProviderControlPlaneEndpointsConfig#dnsEndpointConfig
   */
  readonly dnsEndpointConfig?: ClusterSpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig[];

  /**
   * IP endpoint configuration.
   *
   * @schema ClusterSpecInitProviderControlPlaneEndpointsConfig#ipEndpointsConfig
   */
  readonly ipEndpointsConfig?: ClusterSpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderControlPlaneEndpointsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderControlPlaneEndpointsConfig(obj: ClusterSpecInitProviderControlPlaneEndpointsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsEndpointConfig': obj.dnsEndpointConfig?.map(y => toJson_ClusterSpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig(y)),
    'ipEndpointsConfig': obj.ipEndpointsConfig?.map(y => toJson_ClusterSpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderCostManagementConfig
 */
export interface ClusterSpecInitProviderCostManagementConfig {
  /**
   * Whether to enable the cost allocation feature.
   *
   * @schema ClusterSpecInitProviderCostManagementConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderCostManagementConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderCostManagementConfig(obj: ClusterSpecInitProviderCostManagementConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderDatabaseEncryption
 */
export interface ClusterSpecInitProviderDatabaseEncryption {
  /**
   * the key to use to encrypt/decrypt secrets.  See the DatabaseEncryption definition for more information.
   *
   * @schema ClusterSpecInitProviderDatabaseEncryption#keyName
   */
  readonly keyName?: string;

  /**
   * ENCRYPTED or DECRYPTED
   *
   * @schema ClusterSpecInitProviderDatabaseEncryption#state
   */
  readonly state?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderDatabaseEncryption' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderDatabaseEncryption(obj: ClusterSpecInitProviderDatabaseEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderDefaultSnatStatus
 */
export interface ClusterSpecInitProviderDefaultSnatStatus {
  /**
   * Whether the cluster disables default in-node sNAT rules. In-node sNAT rules will be disabled when defaultSnatStatus is disabled.When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic
   *
   * @schema ClusterSpecInitProviderDefaultSnatStatus#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderDefaultSnatStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderDefaultSnatStatus(obj: ClusterSpecInitProviderDefaultSnatStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderDnsConfig
 */
export interface ClusterSpecInitProviderDnsConfig {
  /**
   * This will enable Cloud DNS additive VPC scope. Must provide a domain name that is unique within the VPC. For this to work cluster_dns = "CLOUD_DNS" and cluster_dns_scope = "CLUSTER_SCOPE" must both be set as well.
   *
   * @schema ClusterSpecInitProviderDnsConfig#additiveVpcScopeDnsDomain
   */
  readonly additiveVpcScopeDnsDomain?: string;

  /**
   * Which in-cluster DNS provider should be used. PROVIDER_UNSPECIFIED (default) or PLATFORM_DEFAULT or CLOUD_DNS.
   *
   * @schema ClusterSpecInitProviderDnsConfig#clusterDns
   */
  readonly clusterDns?: string;

  /**
   * The suffix used for all cluster service records.
   *
   * @schema ClusterSpecInitProviderDnsConfig#clusterDnsDomain
   */
  readonly clusterDnsDomain?: string;

  /**
   * The scope of access to cluster DNS records. DNS_SCOPE_UNSPECIFIED (default) or CLUSTER_SCOPE or VPC_SCOPE.
   *
   * @schema ClusterSpecInitProviderDnsConfig#clusterDnsScope
   */
  readonly clusterDnsScope?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderDnsConfig(obj: ClusterSpecInitProviderDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additiveVpcScopeDnsDomain': obj.additiveVpcScopeDnsDomain,
    'clusterDns': obj.clusterDns,
    'clusterDnsDomain': obj.clusterDnsDomain,
    'clusterDnsScope': obj.clusterDnsScope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderEnableK8SBetaApis
 */
export interface ClusterSpecInitProviderEnableK8SBetaApis {
  /**
   * Enabled Kubernetes Beta APIs. To list a Beta API resource, use the representation {group}/{version}/{resource}. The version must be a Beta version. Note that you cannot disable beta APIs that are already enabled on a cluster without recreating it. See the Configure beta APIs for more information.
   *
   * @schema ClusterSpecInitProviderEnableK8SBetaApis#enabledApis
   */
  readonly enabledApis?: string[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderEnableK8SBetaApis' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderEnableK8SBetaApis(obj: ClusterSpecInitProviderEnableK8SBetaApis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabledApis': obj.enabledApis?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderEnterpriseConfig
 */
export interface ClusterSpecInitProviderEnterpriseConfig {
  /**
   * Sets the tier of the cluster. Available options include STANDARD and ENTERPRISE.
   *
   * @schema ClusterSpecInitProviderEnterpriseConfig#desiredTier
   */
  readonly desiredTier?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderEnterpriseConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderEnterpriseConfig(obj: ClusterSpecInitProviderEnterpriseConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'desiredTier': obj.desiredTier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderFleet
 */
export interface ClusterSpecInitProviderFleet {
  /**
   * The name of the Fleet host project where this cluster will be registered.
   *
   * @schema ClusterSpecInitProviderFleet#project
   */
  readonly project?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderFleet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderFleet(obj: ClusterSpecInitProviderFleet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderGatewayApiConfig
 */
export interface ClusterSpecInitProviderGatewayApiConfig {
  /**
   * Which Gateway Api channel should be used. CHANNEL_DISABLED, CHANNEL_EXPERIMENTAL or CHANNEL_STANDARD.
   *
   * @schema ClusterSpecInitProviderGatewayApiConfig#channel
   */
  readonly channel?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderGatewayApiConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderGatewayApiConfig(obj: ClusterSpecInitProviderGatewayApiConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'channel': obj.channel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderGkeAutoUpgradeConfig
 */
export interface ClusterSpecInitProviderGkeAutoUpgradeConfig {
  /**
   * The selected patch mode.
   * Accepted values are:
   *
   * @schema ClusterSpecInitProviderGkeAutoUpgradeConfig#patchMode
   */
  readonly patchMode?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderGkeAutoUpgradeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderGkeAutoUpgradeConfig(obj: ClusterSpecInitProviderGkeAutoUpgradeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'patchMode': obj.patchMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderIdentityServiceConfig
 */
export interface ClusterSpecInitProviderIdentityServiceConfig {
  /**
   * Whether to enable the Identity Service component. It is disabled by default. Set enabled=true to enable.
   *
   * @schema ClusterSpecInitProviderIdentityServiceConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderIdentityServiceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderIdentityServiceConfig(obj: ClusterSpecInitProviderIdentityServiceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderIpAllocationPolicy
 */
export interface ClusterSpecInitProviderIpAllocationPolicy {
  /**
   * The configuration for individual additional subnetworks attached to the cluster.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProviderIpAllocationPolicy#additionalIpRangesConfig
   */
  readonly additionalIpRangesConfig?: ClusterSpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig[];

  /**
   * The configuration for additional pod secondary ranges at
   * the cluster level. Used for Autopilot clusters and Standard clusters with which control of the
   * secondary Pod IP address assignment to node pools isn't needed. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderIpAllocationPolicy#additionalPodRangesConfig
   */
  readonly additionalPodRangesConfig?: ClusterSpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig[];

  /**
   * The IP address range for the cluster pod IPs.
   * Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
   * to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
   * from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
   * pick a specific range to use.
   *
   * @schema ClusterSpecInitProviderIpAllocationPolicy#clusterIpv4CidrBlock
   */
  readonly clusterIpv4CidrBlock?: string;

  /**
   * The name of the existing secondary
   * range in the cluster's subnetwork to use for pod IP addresses. Alternatively,
   * cluster_ipv4_cidr_block can be used to automatically create a GKE-managed one.
   *
   * @schema ClusterSpecInitProviderIpAllocationPolicy#clusterSecondaryRangeName
   */
  readonly clusterSecondaryRangeName?: string;

  /**
   * @schema ClusterSpecInitProviderIpAllocationPolicy#podCidrOverprovisionConfig
   */
  readonly podCidrOverprovisionConfig?: ClusterSpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig[];

  /**
   * The IP address range of the services IPs in this cluster.
   * Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
   * to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
   * from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
   * pick a specific range to use.
   *
   * @schema ClusterSpecInitProviderIpAllocationPolicy#servicesIpv4CidrBlock
   */
  readonly servicesIpv4CidrBlock?: string;

  /**
   * The name of the existing
   * secondary range in the cluster's subnetwork to use for service ClusterIPs.
   * Alternatively, services_ipv4_cidr_block can be used to automatically create a
   * GKE-managed one.
   *
   * @schema ClusterSpecInitProviderIpAllocationPolicy#servicesSecondaryRangeName
   */
  readonly servicesSecondaryRangeName?: string;

  /**
   * The IP Stack Type of the cluster.
   * Default value is IPV4.
   * Possible values are IPV4 and IPV4_IPV6.
   *
   * @schema ClusterSpecInitProviderIpAllocationPolicy#stackType
   */
  readonly stackType?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderIpAllocationPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderIpAllocationPolicy(obj: ClusterSpecInitProviderIpAllocationPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalIpRangesConfig': obj.additionalIpRangesConfig?.map(y => toJson_ClusterSpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig(y)),
    'additionalPodRangesConfig': obj.additionalPodRangesConfig?.map(y => toJson_ClusterSpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig(y)),
    'clusterIpv4CidrBlock': obj.clusterIpv4CidrBlock,
    'clusterSecondaryRangeName': obj.clusterSecondaryRangeName,
    'podCidrOverprovisionConfig': obj.podCidrOverprovisionConfig?.map(y => toJson_ClusterSpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig(y)),
    'servicesIpv4CidrBlock': obj.servicesIpv4CidrBlock,
    'servicesSecondaryRangeName': obj.servicesSecondaryRangeName,
    'stackType': obj.stackType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderLoggingConfig
 */
export interface ClusterSpecInitProviderLoggingConfig {
  /**
   * The GKE components exposing logs. Supported values include:
   * SYSTEM_COMPONENTS, APISERVER, CONTROLLER_MANAGER, SCHEDULER, and WORKLOADS.
   *
   * @schema ClusterSpecInitProviderLoggingConfig#enableComponents
   */
  readonly enableComponents?: string[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderLoggingConfig(obj: ClusterSpecInitProviderLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableComponents': obj.enableComponents?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderMaintenancePolicy
 */
export interface ClusterSpecInitProviderMaintenancePolicy {
  /**
   * structure documented below.
   *
   * @schema ClusterSpecInitProviderMaintenancePolicy#dailyMaintenanceWindow
   */
  readonly dailyMaintenanceWindow?: ClusterSpecInitProviderMaintenancePolicyDailyMaintenanceWindow[];

  /**
   * structure documented below
   *
   * @schema ClusterSpecInitProviderMaintenancePolicy#maintenanceExclusion
   */
  readonly maintenanceExclusion?: ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusion[];

  /**
   * structure documented below
   *
   * @schema ClusterSpecInitProviderMaintenancePolicy#recurringWindow
   */
  readonly recurringWindow?: ClusterSpecInitProviderMaintenancePolicyRecurringWindow[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderMaintenancePolicy(obj: ClusterSpecInitProviderMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dailyMaintenanceWindow': obj.dailyMaintenanceWindow?.map(y => toJson_ClusterSpecInitProviderMaintenancePolicyDailyMaintenanceWindow(y)),
    'maintenanceExclusion': obj.maintenanceExclusion?.map(y => toJson_ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusion(y)),
    'recurringWindow': obj.recurringWindow?.map(y => toJson_ClusterSpecInitProviderMaintenancePolicyRecurringWindow(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderMasterAuth
 */
export interface ClusterSpecInitProviderMasterAuth {
  /**
   * Whether client certificate authorization is enabled for this cluster.  For example:
   *
   * @schema ClusterSpecInitProviderMasterAuth#clientCertificateConfig
   */
  readonly clientCertificateConfig?: ClusterSpecInitProviderMasterAuthClientCertificateConfig[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderMasterAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderMasterAuth(obj: ClusterSpecInitProviderMasterAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertificateConfig': obj.clientCertificateConfig?.map(y => toJson_ClusterSpecInitProviderMasterAuthClientCertificateConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderMasterAuthorizedNetworksConfig
 */
export interface ClusterSpecInitProviderMasterAuthorizedNetworksConfig {
  /**
   * External networks that can access the
   * Kubernetes cluster master through HTTPS.
   *
   * @schema ClusterSpecInitProviderMasterAuthorizedNetworksConfig#cidrBlocks
   */
  readonly cidrBlocks?: ClusterSpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks[];

  /**
   * Whether Kubernetes master is
   * accessible via Google Compute Engine Public IPs.
   *
   * @schema ClusterSpecInitProviderMasterAuthorizedNetworksConfig#gcpPublicCidrsAccessEnabled
   */
  readonly gcpPublicCidrsAccessEnabled?: boolean;

  /**
   * Whether authorized networks is enforced on the private endpoint or not.
   *
   * @schema ClusterSpecInitProviderMasterAuthorizedNetworksConfig#privateEndpointEnforcementEnabled
   */
  readonly privateEndpointEnforcementEnabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderMasterAuthorizedNetworksConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderMasterAuthorizedNetworksConfig(obj: ClusterSpecInitProviderMasterAuthorizedNetworksConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrBlocks': obj.cidrBlocks?.map(y => toJson_ClusterSpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks(y)),
    'gcpPublicCidrsAccessEnabled': obj.gcpPublicCidrsAccessEnabled,
    'privateEndpointEnforcementEnabled': obj.privateEndpointEnforcementEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderMeshCertificates
 */
export interface ClusterSpecInitProviderMeshCertificates {
  /**
   * Controls the issuance of workload mTLS certificates. It is enabled by default. Workload Identity is required, see workload_config.
   *
   * @schema ClusterSpecInitProviderMeshCertificates#enableCertificates
   */
  readonly enableCertificates?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderMeshCertificates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderMeshCertificates(obj: ClusterSpecInitProviderMeshCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableCertificates': obj.enableCertificates,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderMonitoringConfig
 */
export interface ClusterSpecInitProviderMonitoringConfig {
  /**
   * Configuration for Advanced Datapath Monitoring. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderMonitoringConfig#advancedDatapathObservabilityConfig
   */
  readonly advancedDatapathObservabilityConfig?: ClusterSpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig[];

  /**
   * The GKE components exposing metrics. Supported values include: SYSTEM_COMPONENTS, APISERVER, SCHEDULER, CONTROLLER_MANAGER, STORAGE, HPA, POD, DAEMONSET, DEPLOYMENT and STATEFULSET. In beta provider, WORKLOADS is supported on top of those 10 values. (WORKLOADS is deprecated and removed in GKE 1.24.)
   *
   * @schema ClusterSpecInitProviderMonitoringConfig#enableComponents
   */
  readonly enableComponents?: string[];

  /**
   * Configuration for Managed Service for Prometheus. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderMonitoringConfig#managedPrometheus
   */
  readonly managedPrometheus?: ClusterSpecInitProviderMonitoringConfigManagedPrometheus[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderMonitoringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderMonitoringConfig(obj: ClusterSpecInitProviderMonitoringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedDatapathObservabilityConfig': obj.advancedDatapathObservabilityConfig?.map(y => toJson_ClusterSpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig(y)),
    'enableComponents': obj.enableComponents?.map(y => y),
    'managedPrometheus': obj.managedPrometheus?.map(y => toJson_ClusterSpecInitProviderMonitoringConfigManagedPrometheus(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNetworkPerformanceConfig
 */
export interface ClusterSpecInitProviderNetworkPerformanceConfig {
  /**
   * Specifies the total network bandwidth tier for NodePools in the cluster.
   *
   * @schema ClusterSpecInitProviderNetworkPerformanceConfig#totalEgressBandwidthTier
   */
  readonly totalEgressBandwidthTier?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNetworkPerformanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNetworkPerformanceConfig(obj: ClusterSpecInitProviderNetworkPerformanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'totalEgressBandwidthTier': obj.totalEgressBandwidthTier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNetworkPolicy
 */
export interface ClusterSpecInitProviderNetworkPolicy {
  /**
   * Whether network policy is enabled on the cluster.
   *
   * @schema ClusterSpecInitProviderNetworkPolicy#enabled
   */
  readonly enabled?: boolean;

  /**
   * The selected network policy provider. Defaults to PROVIDER_UNSPECIFIED.
   *
   * @default PROVIDER_UNSPECIFIED.
   * @schema ClusterSpecInitProviderNetworkPolicy#provider
   */
  readonly provider?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNetworkPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNetworkPolicy(obj: ClusterSpecInitProviderNetworkPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'provider': obj.provider,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema ClusterSpecInitProviderNetworkRef
 */
export interface ClusterSpecInitProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecInitProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecInitProviderNetworkRef#policy
   */
  readonly policy?: ClusterSpecInitProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNetworkRef(obj: ClusterSpecInitProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecInitProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema ClusterSpecInitProviderNetworkSelector
 */
export interface ClusterSpecInitProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterSpecInitProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecInitProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecInitProviderNetworkSelector#policy
   */
  readonly policy?: ClusterSpecInitProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNetworkSelector(obj: ClusterSpecInitProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecInitProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfig
 */
export interface ClusterSpecInitProviderNodeConfig {
  /**
   * Specifies options for controlling
   * advanced machine features. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#advancedMachineFeatures
   */
  readonly advancedMachineFeatures?: ClusterSpecInitProviderNodeConfigAdvancedMachineFeatures[];

  /**
   * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
   *
   * @schema ClusterSpecInitProviderNodeConfig#bootDiskKmsKey
   */
  readonly bootDiskKmsKey?: string;

  /**
   * Configuration for Confidential Nodes feature. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#confidentialNodes
   */
  readonly confidentialNodes?: ClusterSpecInitProviderNodeConfigConfidentialNodes[];

  /**
   * Parameters to customize containerd runtime. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#containerdConfig
   */
  readonly containerdConfig?: ClusterSpecInitProviderNodeConfigContainerdConfig[];

  /**
   * Size of the disk attached to each node, specified
   * in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
   *
   * @default 100GB.
   * @schema ClusterSpecInitProviderNodeConfig#diskSizeGb
   */
  readonly diskSizeGb?: number;

  /**
   * Type of the disk attached to each node
   * (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-balanced'
   *
   * @schema ClusterSpecInitProviderNodeConfig#diskType
   */
  readonly diskType?: string;

  /**
   * Enabling Confidential Storage will create boot disk with confidential mode. It is disabled by default.
   *
   * @schema ClusterSpecInitProviderNodeConfig#enableConfidentialStorage
   */
  readonly enableConfidentialStorage?: boolean;

  /**
   * Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#ephemeralStorageLocalSsdConfig
   */
  readonly ephemeralStorageLocalSsdConfig?: ClusterSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig[];

  /**
   * Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
   * Node Pool must enable gvnic.
   * GKE version 1.25.2-gke.1700 or later.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#fastSocket
   */
  readonly fastSocket?: ClusterSpecInitProviderNodeConfigFastSocket[];

  /**
   * Enables Flex Start provisioning model for the node pool.
   *
   * @schema ClusterSpecInitProviderNodeConfig#flexStart
   */
  readonly flexStart?: boolean;

  /**
   * Parameters for the Google Container Filesystem (GCFS).
   * If unspecified, GCFS will not be enabled on the node pool. When enabling this feature you must specify image_type = "COS_CONTAINERD" and node_version from GKE versions 1.19 or later to use it.
   * For GKE versions 1.19, 1.20, and 1.21, the recommended minimum node_version would be 1.19.15-gke.1300, 1.20.11-gke.1300, and 1.21.5-gke.1300 respectively.
   * A machine_type that has more than 16 GiB of memory is also recommended.
   * GCFS must be enabled in order to use image streaming.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#gcfsConfig
   */
  readonly gcfsConfig?: ClusterSpecInitProviderNodeConfigGcfsConfig[];

  /**
   * List of the type and count of accelerator cards attached to the instance.
   * Structure documented below.
   * Note: As of 6.0.0, argument syntax
   * is no longer supported for this field in favor of block syntax.
   * To dynamically set a list of guest accelerators, use dynamic blocks.
   * To set an empty list, use a single guest_accelerator block with count = 0.
   *
   * @schema ClusterSpecInitProviderNodeConfig#guestAccelerator
   */
  readonly guestAccelerator?: ClusterSpecInitProviderNodeConfigGuestAccelerator[];

  /**
   * Google Virtual NIC (gVNIC) is a virtual network interface.
   * Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
   * gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
   * GKE node version 1.15.11-gke.15 or later
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#gvnic
   */
  readonly gvnic?: ClusterSpecInitProviderNodeConfigGvnic[];

  /**
   * The maintenance policy to use for the cluster. Structure is
   * documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#hostMaintenancePolicy
   */
  readonly hostMaintenancePolicy?: ClusterSpecInitProviderNodeConfigHostMaintenancePolicy[];

  /**
   * The image type to use for this node. Note that changing the image type
   * will delete and recreate all nodes in the node pool.
   *
   * @schema ClusterSpecInitProviderNodeConfig#imageType
   */
  readonly imageType?: string;

  /**
   * Kubelet configuration, currently supported attributes can be found here.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#kubeletConfig
   */
  readonly kubeletConfig?: ClusterSpecInitProviderNodeConfigKubeletConfig[];

  /**
   * The Kubernetes labels (key/value pairs) to be applied to each node. The kubernetes.io/ and k8s.io/ prefixes are
   * reserved by Kubernetes Core components and cannot be specified.
   *
   * @schema ClusterSpecInitProviderNodeConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Parameters that can be configured on Linux nodes. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#linuxNodeConfig
   */
  readonly linuxNodeConfig?: ClusterSpecInitProviderNodeConfigLinuxNodeConfig[];

  /**
   * Parameters for the local NVMe SSDs. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#localNvmeSsdBlockConfig
   */
  readonly localNvmeSsdBlockConfig?: ClusterSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig[];

  /**
   * The amount of local SSD disks that will be
   * attached to each cluster node. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterSpecInitProviderNodeConfig#localSsdCount
   */
  readonly localSsdCount?: number;

  /**
   * Possible Local SSD encryption modes:
   * Accepted values are:
   *
   * @schema ClusterSpecInitProviderNodeConfig#localSsdEncryptionMode
   */
  readonly localSsdEncryptionMode?: string;

  /**
   * wide default value. Valid values include DEFAULT and MAX_THROUGHPUT. See Increasing logging agent throughput for more information.
   *
   * @schema ClusterSpecInitProviderNodeConfig#loggingVariant
   */
  readonly loggingVariant?: string;

  /**
   * The name of a Google Compute Engine machine type.
   * Defaults to e2-medium. To create a custom machine type, value should be set as specified
   * here.
   *
   * @default e2-medium. To create a custom machine type, value should be set as specified
   * @schema ClusterSpecInitProviderNodeConfig#machineType
   */
  readonly machineType?: string;

  /**
   * The runtime of each node in the node pool in seconds, terminated by 's'. Example: "3600s".
   *
   * @schema ClusterSpecInitProviderNodeConfig#maxRunDuration
   */
  readonly maxRunDuration?: string;

  /**
   * The metadata key/value pairs assigned to instances in
   * the cluster. From GKE 1. To avoid this, set the
   * value in your config.
   *
   * @schema ClusterSpecInitProviderNodeConfig#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * Minimum CPU platform to be used by this instance.
   * The instance may be scheduled on the specified or newer CPU platform. Applicable
   * values are the friendly names of CPU platforms, such as Intel Haswell. See the
   * official documentation
   * for more information.
   *
   * @schema ClusterSpecInitProviderNodeConfig#minCpuPlatform
   */
  readonly minCpuPlatform?: string;

  /**
   * Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on sole tenant nodes.
   *
   * @schema ClusterSpecInitProviderNodeConfig#nodeGroup
   */
  readonly nodeGroup?: string;

  /**
   * The set of Google API scopes to be made available
   * on all of the node VMs under the "default" service account.
   * Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set service_account to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
   *
   * @schema ClusterSpecInitProviderNodeConfig#oauthScopes
   */
  readonly oauthScopes?: string[];

  /**
   * A boolean that represents whether or not the underlying node VMs
   * are preemptible. See the official documentation
   * for more information. Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecInitProviderNodeConfig#preemptible
   */
  readonly preemptible?: boolean;

  /**
   * The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#reservationAffinity
   */
  readonly reservationAffinity?: ClusterSpecInitProviderNodeConfigReservationAffinity[];

  /**
   * The GCP labels (key/value pairs) to be applied to each node. Refer here
   * for how these labels are applied to clusters, node pools and nodes.
   *
   * @schema ClusterSpecInitProviderNodeConfig#resourceLabels
   */
  readonly resourceLabels?: { [key: string]: string };

  /**
   * A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found here. A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. tagKeys/{tag_key_id}=tagValues/{tag_value_id} 2. {org_id}/{tag_key_name}={tag_value_name} 3. {project_id}/{tag_key_name}={tag_value_name}.
   *
   * @schema ClusterSpecInitProviderNodeConfig#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };

  /**
   * Parameters for secondary boot disks to preload container images and data on new nodes. Structure is documented below. gcfs_config must be enabled=true for this feature to work. min_master_version must also be set to use GKE 1.28.3-gke.106700 or later versions.
   *
   * @schema ClusterSpecInitProviderNodeConfig#secondaryBootDisks
   */
  readonly secondaryBootDisks?: ClusterSpecInitProviderNodeConfigSecondaryBootDisks[];

  /**
   * The service account to be used by the Node VMs.
   * If not specified, the "default" service account is used.
   *
   * @schema ClusterSpecInitProviderNodeConfig#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema ClusterSpecInitProviderNodeConfig#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSpecInitProviderNodeConfigServiceAccountRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema ClusterSpecInitProviderNodeConfig#serviceAccountSelector
   */
  readonly serviceAccountSelector?: ClusterSpecInitProviderNodeConfigServiceAccountSelector;

  /**
   * Shielded Instance options. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: ClusterSpecInitProviderNodeConfigShieldedInstanceConfig[];

  /**
   * Allows specifying multiple node affinities useful for running workloads on sole tenant nodes. node_affinity structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#soleTenantConfig
   */
  readonly soleTenantConfig?: ClusterSpecInitProviderNodeConfigSoleTenantConfig[];

  /**
   * A boolean that represents whether the underlying node VMs are spot.
   * See the official documentation
   * for more information. Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecInitProviderNodeConfig#spot
   */
  readonly spot?: boolean;

  /**
   * The list of Storage Pools where boot disks are provisioned.
   *
   * @schema ClusterSpecInitProviderNodeConfig#storagePools
   */
  readonly storagePools?: string[];

  /**
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls.
   *
   * @schema ClusterSpecInitProviderNodeConfig#tags
   */
  readonly tags?: string[];

  /**
   * A list of
   * Kubernetes taints
   * to apply to nodes. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#taint
   */
  readonly taint?: ClusterSpecInitProviderNodeConfigTaint[];

  /**
   * Windows node configuration, currently supporting OSVersion attribute. The value must be one of [OS_VERSION_UNSPECIFIED, OS_VERSION_LTSC2019, OS_VERSION_LTSC2022]. For example:
   *
   * @schema ClusterSpecInitProviderNodeConfig#windowsNodeConfig
   */
  readonly windowsNodeConfig?: ClusterSpecInitProviderNodeConfigWindowsNodeConfig[];

  /**
   * Metadata configuration to expose to workloads on the node pool.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfig#workloadMetadataConfig
   */
  readonly workloadMetadataConfig?: ClusterSpecInitProviderNodeConfigWorkloadMetadataConfig[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfig(obj: ClusterSpecInitProviderNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedMachineFeatures': obj.advancedMachineFeatures?.map(y => toJson_ClusterSpecInitProviderNodeConfigAdvancedMachineFeatures(y)),
    'bootDiskKmsKey': obj.bootDiskKmsKey,
    'confidentialNodes': obj.confidentialNodes?.map(y => toJson_ClusterSpecInitProviderNodeConfigConfidentialNodes(y)),
    'containerdConfig': obj.containerdConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigContainerdConfig(y)),
    'diskSizeGb': obj.diskSizeGb,
    'diskType': obj.diskType,
    'enableConfidentialStorage': obj.enableConfidentialStorage,
    'ephemeralStorageLocalSsdConfig': obj.ephemeralStorageLocalSsdConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig(y)),
    'fastSocket': obj.fastSocket?.map(y => toJson_ClusterSpecInitProviderNodeConfigFastSocket(y)),
    'flexStart': obj.flexStart,
    'gcfsConfig': obj.gcfsConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigGcfsConfig(y)),
    'guestAccelerator': obj.guestAccelerator?.map(y => toJson_ClusterSpecInitProviderNodeConfigGuestAccelerator(y)),
    'gvnic': obj.gvnic?.map(y => toJson_ClusterSpecInitProviderNodeConfigGvnic(y)),
    'hostMaintenancePolicy': obj.hostMaintenancePolicy?.map(y => toJson_ClusterSpecInitProviderNodeConfigHostMaintenancePolicy(y)),
    'imageType': obj.imageType,
    'kubeletConfig': obj.kubeletConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigKubeletConfig(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'linuxNodeConfig': obj.linuxNodeConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigLinuxNodeConfig(y)),
    'localNvmeSsdBlockConfig': obj.localNvmeSsdBlockConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig(y)),
    'localSsdCount': obj.localSsdCount,
    'localSsdEncryptionMode': obj.localSsdEncryptionMode,
    'loggingVariant': obj.loggingVariant,
    'machineType': obj.machineType,
    'maxRunDuration': obj.maxRunDuration,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'minCpuPlatform': obj.minCpuPlatform,
    'nodeGroup': obj.nodeGroup,
    'oauthScopes': obj.oauthScopes?.map(y => y),
    'preemptible': obj.preemptible,
    'reservationAffinity': obj.reservationAffinity?.map(y => toJson_ClusterSpecInitProviderNodeConfigReservationAffinity(y)),
    'resourceLabels': ((obj.resourceLabels) === undefined) ? undefined : (Object.entries(obj.resourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'secondaryBootDisks': obj.secondaryBootDisks?.map(y => toJson_ClusterSpecInitProviderNodeConfigSecondaryBootDisks(y)),
    'serviceAccount': obj.serviceAccount,
    'serviceAccountRef': toJson_ClusterSpecInitProviderNodeConfigServiceAccountRef(obj.serviceAccountRef),
    'serviceAccountSelector': toJson_ClusterSpecInitProviderNodeConfigServiceAccountSelector(obj.serviceAccountSelector),
    'shieldedInstanceConfig': obj.shieldedInstanceConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigShieldedInstanceConfig(y)),
    'soleTenantConfig': obj.soleTenantConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigSoleTenantConfig(y)),
    'spot': obj.spot,
    'storagePools': obj.storagePools?.map(y => y),
    'tags': obj.tags?.map(y => y),
    'taint': obj.taint?.map(y => toJson_ClusterSpecInitProviderNodeConfigTaint(y)),
    'windowsNodeConfig': obj.windowsNodeConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigWindowsNodeConfig(y)),
    'workloadMetadataConfig': obj.workloadMetadataConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigWorkloadMetadataConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodePoolAutoConfig
 */
export interface ClusterSpecInitProviderNodePoolAutoConfig {
  /**
   * Linux system configuration for the cluster's automatically provisioned node pools. Only cgroup_mode field is supported in node_pool_auto_config. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodePoolAutoConfig#linuxNodeConfig
   */
  readonly linuxNodeConfig?: ClusterSpecInitProviderNodePoolAutoConfigLinuxNodeConfig[];

  /**
   * The network tag config for the cluster's automatically provisioned node pools.
   *
   * @schema ClusterSpecInitProviderNodePoolAutoConfig#networkTags
   */
  readonly networkTags?: ClusterSpecInitProviderNodePoolAutoConfigNetworkTags[];

  /**
   * Kubelet configuration for Autopilot clusters. Currently, only insecure_kubelet_readonly_port_enabled is supported here.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodePoolAutoConfig#nodeKubeletConfig
   */
  readonly nodeKubeletConfig?: ClusterSpecInitProviderNodePoolAutoConfigNodeKubeletConfig[];

  /**
   * A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found here. A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. tagKeys/{tag_key_id}=tagValues/{tag_value_id} 2. {org_id}/{tag_key_name}={tag_value_name} 3. {project_id}/{tag_key_name}={tag_value_name}.
   *
   * @schema ClusterSpecInitProviderNodePoolAutoConfig#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodePoolAutoConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodePoolAutoConfig(obj: ClusterSpecInitProviderNodePoolAutoConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'linuxNodeConfig': obj.linuxNodeConfig?.map(y => toJson_ClusterSpecInitProviderNodePoolAutoConfigLinuxNodeConfig(y)),
    'networkTags': obj.networkTags?.map(y => toJson_ClusterSpecInitProviderNodePoolAutoConfigNetworkTags(y)),
    'nodeKubeletConfig': obj.nodeKubeletConfig?.map(y => toJson_ClusterSpecInitProviderNodePoolAutoConfigNodeKubeletConfig(y)),
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodePoolDefaults
 */
export interface ClusterSpecInitProviderNodePoolDefaults {
  /**
   * Subset of NodeConfig message that has defaults.
   *
   * @schema ClusterSpecInitProviderNodePoolDefaults#nodeConfigDefaults
   */
  readonly nodeConfigDefaults?: ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaults[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodePoolDefaults' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodePoolDefaults(obj: ClusterSpecInitProviderNodePoolDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeConfigDefaults': obj.nodeConfigDefaults?.map(y => toJson_ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaults(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNotificationConfig
 */
export interface ClusterSpecInitProviderNotificationConfig {
  /**
   * The pubsub config for the cluster's upgrade notifications.
   *
   * @schema ClusterSpecInitProviderNotificationConfig#pubsub
   */
  readonly pubsub?: ClusterSpecInitProviderNotificationConfigPubsub[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNotificationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNotificationConfig(obj: ClusterSpecInitProviderNotificationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pubsub': obj.pubsub?.map(y => toJson_ClusterSpecInitProviderNotificationConfigPubsub(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderPodAutoscaling
 */
export interface ClusterSpecInitProviderPodAutoscaling {
  /**
   * Enable the Horizontal Pod Autoscaling profile for this cluster.
   * Acceptable values are:
   *
   * @schema ClusterSpecInitProviderPodAutoscaling#hpaProfile
   */
  readonly hpaProfile?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderPodAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderPodAutoscaling(obj: ClusterSpecInitProviderPodAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hpaProfile': obj.hpaProfile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderPrivateClusterConfig
 */
export interface ClusterSpecInitProviderPrivateClusterConfig {
  /**
   * When true, the cluster's private
   * endpoint is used as the cluster endpoint and access through the public endpoint
   * is disabled. When false, either endpoint can be used. This field only applies
   * to private clusters, when enable_private_nodes is true.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfig#enablePrivateEndpoint
   */
  readonly enablePrivateEndpoint?: boolean;

  /**
   * Enables the private cluster feature,
   * creating a private endpoint on the cluster. In a private cluster, nodes only
   * have RFC 1918 private addresses and communicate with the master's private
   * endpoint via private networking.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfig#enablePrivateNodes
   */
  readonly enablePrivateNodes?: boolean;

  /**
   * Controls cluster master global
   * access settings. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfig#masterGlobalAccessConfig
   */
  readonly masterGlobalAccessConfig?: ClusterSpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig[];

  /**
   * The IP range in CIDR notation to use for
   * the hosted master network. This range will be used for assigning private IP
   * addresses to the cluster master(s) and the ILB VIP. This range must not overlap
   * with any other ranges in use within the cluster's network, and it must be a /28
   * subnet. See Private Cluster Limitations
   * for more details. This field only applies to private clusters, when
   * enable_private_nodes is true.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfig#masterIpv4CidrBlock
   */
  readonly masterIpv4CidrBlock?: string;

  /**
   * Subnetwork in cluster's network where master's endpoint will be provisioned.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfig#privateEndpointSubnetwork
   */
  readonly privateEndpointSubnetwork?: string;

  /**
   * Reference to a Subnetwork in compute to populate privateEndpointSubnetwork.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfig#privateEndpointSubnetworkRef
   */
  readonly privateEndpointSubnetworkRef?: ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef;

  /**
   * Selector for a Subnetwork in compute to populate privateEndpointSubnetwork.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfig#privateEndpointSubnetworkSelector
   */
  readonly privateEndpointSubnetworkSelector?: ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderPrivateClusterConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderPrivateClusterConfig(obj: ClusterSpecInitProviderPrivateClusterConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enablePrivateEndpoint': obj.enablePrivateEndpoint,
    'enablePrivateNodes': obj.enablePrivateNodes,
    'masterGlobalAccessConfig': obj.masterGlobalAccessConfig?.map(y => toJson_ClusterSpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig(y)),
    'masterIpv4CidrBlock': obj.masterIpv4CidrBlock,
    'privateEndpointSubnetwork': obj.privateEndpointSubnetwork,
    'privateEndpointSubnetworkRef': toJson_ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef(obj.privateEndpointSubnetworkRef),
    'privateEndpointSubnetworkSelector': toJson_ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector(obj.privateEndpointSubnetworkSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderRbacBindingConfig
 */
export interface ClusterSpecInitProviderRbacBindingConfig {
  /**
   * Setting this to true will allow any ClusterRoleBinding and RoleBinding with subjects system:authenticated.
   *
   * @schema ClusterSpecInitProviderRbacBindingConfig#enableInsecureBindingSystemAuthenticated
   */
  readonly enableInsecureBindingSystemAuthenticated?: boolean;

  /**
   * Setting this to true will allow any ClusterRoleBinding and RoleBinding with subjects system:anonymous or system:unauthenticated.
   *
   * @schema ClusterSpecInitProviderRbacBindingConfig#enableInsecureBindingSystemUnauthenticated
   */
  readonly enableInsecureBindingSystemUnauthenticated?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderRbacBindingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderRbacBindingConfig(obj: ClusterSpecInitProviderRbacBindingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableInsecureBindingSystemAuthenticated': obj.enableInsecureBindingSystemAuthenticated,
    'enableInsecureBindingSystemUnauthenticated': obj.enableInsecureBindingSystemUnauthenticated,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderReleaseChannel
 */
export interface ClusterSpecInitProviderReleaseChannel {
  /**
   * The selected release channel.
   * Accepted values are:
   *
   * @schema ClusterSpecInitProviderReleaseChannel#channel
   */
  readonly channel?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderReleaseChannel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderReleaseChannel(obj: ClusterSpecInitProviderReleaseChannel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'channel': obj.channel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderResourceUsageExportConfig
 */
export interface ClusterSpecInitProviderResourceUsageExportConfig {
  /**
   * Parameters for using BigQuery as the destination of resource usage export.
   *
   * @schema ClusterSpecInitProviderResourceUsageExportConfig#bigqueryDestination
   */
  readonly bigqueryDestination?: ClusterSpecInitProviderResourceUsageExportConfigBigqueryDestination[];

  /**
   * Whether to enable network egress metering for this cluster. If enabled, a daemonset will be created
   * in the cluster to meter network egress traffic.
   *
   * @schema ClusterSpecInitProviderResourceUsageExportConfig#enableNetworkEgressMetering
   */
  readonly enableNetworkEgressMetering?: boolean;

  /**
   * Whether to enable resource
   * consumption metering on this cluster. When enabled, a table will be created in
   * the resource export BigQuery dataset to store resource consumption data. The
   * resulting table can be joined with the resource usage table or with BigQuery
   * billing export. Defaults to true.
   *
   * @default true.
   * @schema ClusterSpecInitProviderResourceUsageExportConfig#enableResourceConsumptionMetering
   */
  readonly enableResourceConsumptionMetering?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderResourceUsageExportConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderResourceUsageExportConfig(obj: ClusterSpecInitProviderResourceUsageExportConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigqueryDestination': obj.bigqueryDestination?.map(y => toJson_ClusterSpecInitProviderResourceUsageExportConfigBigqueryDestination(y)),
    'enableNetworkEgressMetering': obj.enableNetworkEgressMetering,
    'enableResourceConsumptionMetering': obj.enableResourceConsumptionMetering,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderSecretManagerConfig
 */
export interface ClusterSpecInitProviderSecretManagerConfig {
  /**
   * Enable the Secret Manager add-on for this cluster.
   *
   * @schema ClusterSpecInitProviderSecretManagerConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderSecretManagerConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderSecretManagerConfig(obj: ClusterSpecInitProviderSecretManagerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderSecurityPostureConfig
 */
export interface ClusterSpecInitProviderSecurityPostureConfig {
  /**
   * Sets the mode of the Kubernetes security posture API's off-cluster features. Available options include DISABLED and BASIC.
   *
   * @schema ClusterSpecInitProviderSecurityPostureConfig#mode
   */
  readonly mode?: string;

  /**
   * Sets the mode of the Kubernetes security posture API's workload vulnerability scanning. Available options include VULNERABILITY_DISABLED, VULNERABILITY_BASIC and VULNERABILITY_ENTERPRISE.
   *
   * @schema ClusterSpecInitProviderSecurityPostureConfig#vulnerabilityMode
   */
  readonly vulnerabilityMode?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderSecurityPostureConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderSecurityPostureConfig(obj: ClusterSpecInitProviderSecurityPostureConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
    'vulnerabilityMode': obj.vulnerabilityMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderServiceExternalIpsConfig
 */
export interface ClusterSpecInitProviderServiceExternalIpsConfig {
  /**
   * Controls whether external ips specified by a service will be allowed. It is enabled by default.
   *
   * @schema ClusterSpecInitProviderServiceExternalIpsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderServiceExternalIpsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderServiceExternalIpsConfig(obj: ClusterSpecInitProviderServiceExternalIpsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Subnetwork in compute to populate subnetwork.
 *
 * @schema ClusterSpecInitProviderSubnetworkRef
 */
export interface ClusterSpecInitProviderSubnetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecInitProviderSubnetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecInitProviderSubnetworkRef#policy
   */
  readonly policy?: ClusterSpecInitProviderSubnetworkRefPolicy;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderSubnetworkRef(obj: ClusterSpecInitProviderSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecInitProviderSubnetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Subnetwork in compute to populate subnetwork.
 *
 * @schema ClusterSpecInitProviderSubnetworkSelector
 */
export interface ClusterSpecInitProviderSubnetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterSpecInitProviderSubnetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecInitProviderSubnetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecInitProviderSubnetworkSelector#policy
   */
  readonly policy?: ClusterSpecInitProviderSubnetworkSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderSubnetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderSubnetworkSelector(obj: ClusterSpecInitProviderSubnetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecInitProviderSubnetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderUserManagedKeysConfig
 */
export interface ClusterSpecInitProviderUserManagedKeysConfig {
  /**
   * The Certificate Authority Service caPool to use for the aggreation CA in this cluster.
   *
   * @schema ClusterSpecInitProviderUserManagedKeysConfig#aggregationCa
   */
  readonly aggregationCa?: string;

  /**
   * The Certificate Authority Service caPool to use for the cluster CA in this cluster.
   *
   * @schema ClusterSpecInitProviderUserManagedKeysConfig#clusterCa
   */
  readonly clusterCa?: string;

  /**
   * The Cloud KMS cryptoKey to use for Confidential Hyperdisk on the control plane nodes.
   *
   * @schema ClusterSpecInitProviderUserManagedKeysConfig#controlPlaneDiskEncryptionKey
   */
  readonly controlPlaneDiskEncryptionKey?: string;

  /**
   * The Certificate Authority Service caPool to use for the etcd API CA in this cluster.
   *
   * @schema ClusterSpecInitProviderUserManagedKeysConfig#etcdApiCa
   */
  readonly etcdApiCa?: string;

  /**
   * The Certificate Authority Service caPool to use for the etcd peer CA in this cluster.
   *
   * @schema ClusterSpecInitProviderUserManagedKeysConfig#etcdPeerCa
   */
  readonly etcdPeerCa?: string;

  /**
   * Resource path of the Cloud KMS cryptoKey to use for encryption of internal etcd backups.
   *
   * @schema ClusterSpecInitProviderUserManagedKeysConfig#gkeopsEtcdBackupEncryptionKey
   */
  readonly gkeopsEtcdBackupEncryptionKey?: string;

  /**
   * The Cloud KMS cryptoKeyVersions to use for signing service account JWTs issued by this cluster.
   *
   * @schema ClusterSpecInitProviderUserManagedKeysConfig#serviceAccountSigningKeys
   */
  readonly serviceAccountSigningKeys?: string[];

  /**
   * The Cloud KMS cryptoKeyVersions to use for verifying service account JWTs issued by this cluster.
   *
   * @schema ClusterSpecInitProviderUserManagedKeysConfig#serviceAccountVerificationKeys
   */
  readonly serviceAccountVerificationKeys?: string[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderUserManagedKeysConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderUserManagedKeysConfig(obj: ClusterSpecInitProviderUserManagedKeysConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationCa': obj.aggregationCa,
    'clusterCa': obj.clusterCa,
    'controlPlaneDiskEncryptionKey': obj.controlPlaneDiskEncryptionKey,
    'etcdApiCa': obj.etcdApiCa,
    'etcdPeerCa': obj.etcdPeerCa,
    'gkeopsEtcdBackupEncryptionKey': obj.gkeopsEtcdBackupEncryptionKey,
    'serviceAccountSigningKeys': obj.serviceAccountSigningKeys?.map(y => y),
    'serviceAccountVerificationKeys': obj.serviceAccountVerificationKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderVerticalPodAutoscaling
 */
export interface ClusterSpecInitProviderVerticalPodAutoscaling {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderVerticalPodAutoscaling#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderVerticalPodAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderVerticalPodAutoscaling(obj: ClusterSpecInitProviderVerticalPodAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderWorkloadIdentityConfig
 */
export interface ClusterSpecInitProviderWorkloadIdentityConfig {
  /**
   * The workload pool to attach all Kubernetes service accounts to.
   *
   * @schema ClusterSpecInitProviderWorkloadIdentityConfig#workloadPool
   */
  readonly workloadPool?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderWorkloadIdentityConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderWorkloadIdentityConfig(obj: ClusterSpecInitProviderWorkloadIdentityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'workloadPool': obj.workloadPool,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderConfigRefPolicy
 */
export interface ClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecProviderConfigRefPolicy(obj: ClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfigCloudrunConfig
 */
export interface ClusterSpecForProviderAddonsConfigCloudrunConfig {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterSpecForProviderAddonsConfigCloudrunConfig#disabled
   */
  readonly disabled?: boolean;

  /**
   * The load balancer type of CloudRun ingress service. It is external load balancer by default.
   * Set load_balancer_type=LOAD_BALANCER_TYPE_INTERNAL to configure it as internal load balancer.
   *
   * @schema ClusterSpecForProviderAddonsConfigCloudrunConfig#loadBalancerType
   */
  readonly loadBalancerType?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigCloudrunConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigCloudrunConfig(obj: ClusterSpecForProviderAddonsConfigCloudrunConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
    'loadBalancerType': obj.loadBalancerType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfigConfigConnectorConfig
 */
export interface ClusterSpecForProviderAddonsConfigConfigConnectorConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderAddonsConfigConfigConnectorConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigConfigConnectorConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigConfigConnectorConfig(obj: ClusterSpecForProviderAddonsConfigConfigConnectorConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfigDnsCacheConfig
 */
export interface ClusterSpecForProviderAddonsConfigDnsCacheConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderAddonsConfigDnsCacheConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigDnsCacheConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigDnsCacheConfig(obj: ClusterSpecForProviderAddonsConfigDnsCacheConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig
 */
export interface ClusterSpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig(obj: ClusterSpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig
 */
export interface ClusterSpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig(obj: ClusterSpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfigGcsFuseCsiDriverConfig
 */
export interface ClusterSpecForProviderAddonsConfigGcsFuseCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderAddonsConfigGcsFuseCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigGcsFuseCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigGcsFuseCsiDriverConfig(obj: ClusterSpecForProviderAddonsConfigGcsFuseCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfigGkeBackupAgentConfig
 */
export interface ClusterSpecForProviderAddonsConfigGkeBackupAgentConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderAddonsConfigGkeBackupAgentConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigGkeBackupAgentConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigGkeBackupAgentConfig(obj: ClusterSpecForProviderAddonsConfigGkeBackupAgentConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfigHorizontalPodAutoscaling
 */
export interface ClusterSpecForProviderAddonsConfigHorizontalPodAutoscaling {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterSpecForProviderAddonsConfigHorizontalPodAutoscaling#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigHorizontalPodAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigHorizontalPodAutoscaling(obj: ClusterSpecForProviderAddonsConfigHorizontalPodAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfigHttpLoadBalancing
 */
export interface ClusterSpecForProviderAddonsConfigHttpLoadBalancing {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterSpecForProviderAddonsConfigHttpLoadBalancing#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigHttpLoadBalancing' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigHttpLoadBalancing(obj: ClusterSpecForProviderAddonsConfigHttpLoadBalancing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfigLustreCsiDriverConfig
 */
export interface ClusterSpecForProviderAddonsConfigLustreCsiDriverConfig {
  /**
   * @schema ClusterSpecForProviderAddonsConfigLustreCsiDriverConfig#enableLegacyLustrePort
   */
  readonly enableLegacyLustrePort?: boolean;

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderAddonsConfigLustreCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigLustreCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigLustreCsiDriverConfig(obj: ClusterSpecForProviderAddonsConfigLustreCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableLegacyLustrePort': obj.enableLegacyLustrePort,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfigNetworkPolicyConfig
 */
export interface ClusterSpecForProviderAddonsConfigNetworkPolicyConfig {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterSpecForProviderAddonsConfigNetworkPolicyConfig#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigNetworkPolicyConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigNetworkPolicyConfig(obj: ClusterSpecForProviderAddonsConfigNetworkPolicyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfigParallelstoreCsiDriverConfig
 */
export interface ClusterSpecForProviderAddonsConfigParallelstoreCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderAddonsConfigParallelstoreCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigParallelstoreCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigParallelstoreCsiDriverConfig(obj: ClusterSpecForProviderAddonsConfigParallelstoreCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfigRayOperatorConfig
 */
export interface ClusterSpecForProviderAddonsConfigRayOperatorConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderAddonsConfigRayOperatorConfig#enabled
   */
  readonly enabled?: boolean;

  /**
   * Logging configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProviderAddonsConfigRayOperatorConfig#rayClusterLoggingConfig
   */
  readonly rayClusterLoggingConfig?: ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig[];

  /**
   * Monitoring configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterSpecForProviderAddonsConfigRayOperatorConfig#rayClusterMonitoringConfig
   */
  readonly rayClusterMonitoringConfig?: ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigRayOperatorConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigRayOperatorConfig(obj: ClusterSpecForProviderAddonsConfigRayOperatorConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'rayClusterLoggingConfig': obj.rayClusterLoggingConfig?.map(y => toJson_ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig(y)),
    'rayClusterMonitoringConfig': obj.rayClusterMonitoringConfig?.map(y => toJson_ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfigStatefulHaConfig
 */
export interface ClusterSpecForProviderAddonsConfigStatefulHaConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderAddonsConfigStatefulHaConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigStatefulHaConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigStatefulHaConfig(obj: ClusterSpecForProviderAddonsConfigStatefulHaConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults
 */
export interface ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults {
  /**
   * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults#bootDiskKmsKey
   */
  readonly bootDiskKmsKey?: string;

  /**
   * Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Defaults to 100
   *
   * @default 100
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults#diskSize
   */
  readonly diskSize?: number;

  /**
   * Type of the disk attached to each node
   * (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-standard'
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults#diskType
   */
  readonly diskType?: string;

  /**
   * The image type to use for this node. Note that changing the image type
   * will delete and recreate all nodes in the node pool.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults#imageType
   */
  readonly imageType?: string;

  /**
   * NodeManagement configuration for this NodePool. Structure is documented below.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults#management
   */
  readonly management?: ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement[];

  /**
   * Minimum CPU platform to be used by this instance.
   * The instance may be scheduled on the specified or newer CPU platform. Applicable
   * values are the friendly names of CPU platforms, such as Intel Haswell. See the
   * official documentation
   * for more information.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults#minCpuPlatform
   */
  readonly minCpuPlatform?: string;

  /**
   * The set of Google API scopes to be made available
   * on all of the node VMs under the "default" service account.
   * Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set service_account to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults#oauthScopes
   */
  readonly oauthScopes?: string[];

  /**
   * The service account to be used by the Node VMs.
   * If not specified, the "default" service account is used.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Shielded Instance options. Structure is documented below.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig[];

  /**
   * Specifies the upgrade settings for NAP created node pools. Structure is documented below.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults#upgradeSettings
   */
  readonly upgradeSettings?: ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults(obj: ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bootDiskKmsKey': obj.bootDiskKmsKey,
    'diskSize': obj.diskSize,
    'diskType': obj.diskType,
    'imageType': obj.imageType,
    'management': obj.management?.map(y => toJson_ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement(y)),
    'minCpuPlatform': obj.minCpuPlatform,
    'oauthScopes': obj.oauthScopes?.map(y => y),
    'serviceAccount': obj.serviceAccount,
    'shieldedInstanceConfig': obj.shieldedInstanceConfig?.map(y => toJson_ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig(y)),
    'upgradeSettings': obj.upgradeSettings?.map(y => toJson_ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderClusterAutoscalingResourceLimits
 */
export interface ClusterSpecForProviderClusterAutoscalingResourceLimits {
  /**
   * Maximum amount of the resource in the cluster.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingResourceLimits#maximum
   */
  readonly maximum?: number;

  /**
   * Minimum amount of the resource in the cluster.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingResourceLimits#minimum
   */
  readonly minimum?: number;

  /**
   * The type of the resource. For example, cpu and
   * memory.  See the guide to using Node Auto-Provisioning
   * for a list of types.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingResourceLimits#resourceType
   */
  readonly resourceType?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterAutoscalingResourceLimits' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderClusterAutoscalingResourceLimits(obj: ClusterSpecForProviderClusterAutoscalingResourceLimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximum': obj.maximum,
    'minimum': obj.minimum,
    'resourceType': obj.resourceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig
 */
export interface ClusterSpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig {
  /**
   * Controls whether user traffic is allowed over this endpoint. Note that GCP-managed services may still use the endpoint even if this is false.
   *
   * @schema ClusterSpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig#allowExternalTraffic
   */
  readonly allowExternalTraffic?: boolean;

  /**
   * (Output) The cluster's DNS endpoint.
   *
   * @schema ClusterSpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig#endpoint
   */
  readonly endpoint?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig(obj: ClusterSpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowExternalTraffic': obj.allowExternalTraffic,
    'endpoint': obj.endpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig
 */
export interface ClusterSpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig {
  /**
   * Controls whether to allow direct IP access. Defaults to true.
   *
   * @default true.
   * @schema ClusterSpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig(obj: ClusterSpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderIpAllocationPolicyAdditionalIpRangesConfig
 */
export interface ClusterSpecForProviderIpAllocationPolicyAdditionalIpRangesConfig {
  /**
   * List of secondary ranges names within this subnetwork that can be used for pod IPs.
   *
   * @schema ClusterSpecForProviderIpAllocationPolicyAdditionalIpRangesConfig#podIpv4RangeNames
   */
  readonly podIpv4RangeNames?: string[];

  /**
   * The name or self_link of the Google Compute Engine
   * subnetwork in which the cluster's instances are launched.
   *
   * @schema ClusterSpecForProviderIpAllocationPolicyAdditionalIpRangesConfig#subnetwork
   */
  readonly subnetwork?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderIpAllocationPolicyAdditionalIpRangesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderIpAllocationPolicyAdditionalIpRangesConfig(obj: ClusterSpecForProviderIpAllocationPolicyAdditionalIpRangesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podIpv4RangeNames': obj.podIpv4RangeNames?.map(y => y),
    'subnetwork': obj.subnetwork,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderIpAllocationPolicyAdditionalPodRangesConfig
 */
export interface ClusterSpecForProviderIpAllocationPolicyAdditionalPodRangesConfig {
  /**
   * The names of the Pod ranges to add to the cluster.
   *
   * @schema ClusterSpecForProviderIpAllocationPolicyAdditionalPodRangesConfig#podRangeNames
   */
  readonly podRangeNames?: string[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderIpAllocationPolicyAdditionalPodRangesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderIpAllocationPolicyAdditionalPodRangesConfig(obj: ClusterSpecForProviderIpAllocationPolicyAdditionalPodRangesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podRangeNames': obj.podRangeNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig
 */
export interface ClusterSpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterSpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig(obj: ClusterSpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderMaintenancePolicyDailyMaintenanceWindow
 */
export interface ClusterSpecForProviderMaintenancePolicyDailyMaintenanceWindow {
  /**
   * @schema ClusterSpecForProviderMaintenancePolicyDailyMaintenanceWindow#startTime
   */
  readonly startTime?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderMaintenancePolicyDailyMaintenanceWindow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderMaintenancePolicyDailyMaintenanceWindow(obj: ClusterSpecForProviderMaintenancePolicyDailyMaintenanceWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderMaintenancePolicyMaintenanceExclusion
 */
export interface ClusterSpecForProviderMaintenancePolicyMaintenanceExclusion {
  /**
   * @schema ClusterSpecForProviderMaintenancePolicyMaintenanceExclusion#endTime
   */
  readonly endTime?: string;

  /**
   * The name of the cluster, unique within the project and
   * location.
   *
   * @schema ClusterSpecForProviderMaintenancePolicyMaintenanceExclusion#exclusionName
   */
  readonly exclusionName?: string;

  /**
   * MaintenanceExclusionOptions provides maintenance exclusion related options.
   *
   * @schema ClusterSpecForProviderMaintenancePolicyMaintenanceExclusion#exclusionOptions
   */
  readonly exclusionOptions?: ClusterSpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions[];

  /**
   * @schema ClusterSpecForProviderMaintenancePolicyMaintenanceExclusion#startTime
   */
  readonly startTime?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderMaintenancePolicyMaintenanceExclusion' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderMaintenancePolicyMaintenanceExclusion(obj: ClusterSpecForProviderMaintenancePolicyMaintenanceExclusion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'exclusionName': obj.exclusionName,
    'exclusionOptions': obj.exclusionOptions?.map(y => toJson_ClusterSpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions(y)),
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderMaintenancePolicyRecurringWindow
 */
export interface ClusterSpecForProviderMaintenancePolicyRecurringWindow {
  /**
   * @schema ClusterSpecForProviderMaintenancePolicyRecurringWindow#endTime
   */
  readonly endTime?: string;

  /**
   * @schema ClusterSpecForProviderMaintenancePolicyRecurringWindow#recurrence
   */
  readonly recurrence?: string;

  /**
   * @schema ClusterSpecForProviderMaintenancePolicyRecurringWindow#startTime
   */
  readonly startTime?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderMaintenancePolicyRecurringWindow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderMaintenancePolicyRecurringWindow(obj: ClusterSpecForProviderMaintenancePolicyRecurringWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'recurrence': obj.recurrence,
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderMasterAuthClientCertificateConfig
 */
export interface ClusterSpecForProviderMasterAuthClientCertificateConfig {
  /**
   * @schema ClusterSpecForProviderMasterAuthClientCertificateConfig#issueClientCertificate
   */
  readonly issueClientCertificate?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderMasterAuthClientCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderMasterAuthClientCertificateConfig(obj: ClusterSpecForProviderMasterAuthClientCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'issueClientCertificate': obj.issueClientCertificate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderMasterAuthorizedNetworksConfigCidrBlocks
 */
export interface ClusterSpecForProviderMasterAuthorizedNetworksConfigCidrBlocks {
  /**
   * External network that can access Kubernetes master through HTTPS.
   * Must be specified in CIDR notation.
   *
   * @schema ClusterSpecForProviderMasterAuthorizedNetworksConfigCidrBlocks#cidrBlock
   */
  readonly cidrBlock?: string;

  /**
   * Field for users to identify CIDR blocks.
   *
   * @schema ClusterSpecForProviderMasterAuthorizedNetworksConfigCidrBlocks#displayName
   */
  readonly displayName?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderMasterAuthorizedNetworksConfigCidrBlocks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderMasterAuthorizedNetworksConfigCidrBlocks(obj: ClusterSpecForProviderMasterAuthorizedNetworksConfigCidrBlocks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrBlock': obj.cidrBlock,
    'displayName': obj.displayName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig
 */
export interface ClusterSpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig {
  /**
   * Whether or not to enable advanced datapath metrics.
   *
   * @schema ClusterSpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig#enableMetrics
   */
  readonly enableMetrics?: boolean;

  /**
   * Whether or not Relay is enabled.
   *
   * @schema ClusterSpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig#enableRelay
   */
  readonly enableRelay?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig(obj: ClusterSpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableMetrics': obj.enableMetrics,
    'enableRelay': obj.enableRelay,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderMonitoringConfigManagedPrometheus
 */
export interface ClusterSpecForProviderMonitoringConfigManagedPrometheus {
  /**
   * Configuration options for GKE Auto-Monitoring.
   *
   * @schema ClusterSpecForProviderMonitoringConfigManagedPrometheus#autoMonitoringConfig
   */
  readonly autoMonitoringConfig?: ClusterSpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig[];

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderMonitoringConfigManagedPrometheus#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderMonitoringConfigManagedPrometheus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderMonitoringConfigManagedPrometheus(obj: ClusterSpecForProviderMonitoringConfigManagedPrometheus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoMonitoringConfig': obj.autoMonitoringConfig?.map(y => toJson_ClusterSpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig(y)),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderNetworkRefPolicy
 */
export interface ClusterSpecForProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecForProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNetworkRefPolicy(obj: ClusterSpecForProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderNetworkSelectorPolicy
 */
export interface ClusterSpecForProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecForProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNetworkSelectorPolicy(obj: ClusterSpecForProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigAdvancedMachineFeatures
 */
export interface ClusterSpecForProviderNodeConfigAdvancedMachineFeatures {
  /**
   * Defines whether the instance should have nested virtualization enabled. Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecForProviderNodeConfigAdvancedMachineFeatures#enableNestedVirtualization
   */
  readonly enableNestedVirtualization?: boolean;

  /**
   * Defines the performance monitoring unit PMU level. Valid values are ARCHITECTURAL, STANDARD, or ENHANCED. Defaults to off.
   *
   * @default off.
   * @schema ClusterSpecForProviderNodeConfigAdvancedMachineFeatures#performanceMonitoringUnit
   */
  readonly performanceMonitoringUnit?: string;

  /**
   * The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
   *
   * @schema ClusterSpecForProviderNodeConfigAdvancedMachineFeatures#threadsPerCore
   */
  readonly threadsPerCore?: number;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigAdvancedMachineFeatures' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigAdvancedMachineFeatures(obj: ClusterSpecForProviderNodeConfigAdvancedMachineFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableNestedVirtualization': obj.enableNestedVirtualization,
    'performanceMonitoringUnit': obj.performanceMonitoringUnit,
    'threadsPerCore': obj.threadsPerCore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigConfidentialNodes
 */
export interface ClusterSpecForProviderNodeConfigConfidentialNodes {
  /**
   * Defines the type of technology used
   * by the confidential node.
   *
   * @schema ClusterSpecForProviderNodeConfigConfidentialNodes#confidentialInstanceType
   */
  readonly confidentialInstanceType?: string;

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderNodeConfigConfidentialNodes#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigConfidentialNodes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigConfidentialNodes(obj: ClusterSpecForProviderNodeConfigConfidentialNodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confidentialInstanceType': obj.confidentialInstanceType,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigContainerdConfig
 */
export interface ClusterSpecForProviderNodeConfigContainerdConfig {
  /**
   * Configuration for private container registries. There are two fields in this config:
   *
   * @schema ClusterSpecForProviderNodeConfigContainerdConfig#privateRegistryAccessConfig
   */
  readonly privateRegistryAccessConfig?: ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigContainerdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigContainerdConfig(obj: ClusterSpecForProviderNodeConfigContainerdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateRegistryAccessConfig': obj.privateRegistryAccessConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig
 */
export interface ClusterSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig {
  /**
   * Number of raw-block local NVMe SSD disks to be attached to the node utilized for GKE Data Cache. If zero, then GKE Data Cache will not be enabled in the nodes.
   *
   * @schema ClusterSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig#dataCacheCount
   */
  readonly dataCacheCount?: number;

  /**
   * The amount of local SSD disks that will be
   * attached to each cluster node. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig(obj: ClusterSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataCacheCount': obj.dataCacheCount,
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigFastSocket
 */
export interface ClusterSpecForProviderNodeConfigFastSocket {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderNodeConfigFastSocket#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigFastSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigFastSocket(obj: ClusterSpecForProviderNodeConfigFastSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigGcfsConfig
 */
export interface ClusterSpecForProviderNodeConfigGcfsConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderNodeConfigGcfsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigGcfsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigGcfsConfig(obj: ClusterSpecForProviderNodeConfigGcfsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigGuestAccelerator
 */
export interface ClusterSpecForProviderNodeConfigGuestAccelerator {
  /**
   * The number of the guest accelerator cards exposed to this instance.
   *
   * @schema ClusterSpecForProviderNodeConfigGuestAccelerator#count
   */
  readonly count?: number;

  /**
   * Configuration for auto installation of GPU driver. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfigGuestAccelerator#gpuDriverInstallationConfig
   */
  readonly gpuDriverInstallationConfig?: ClusterSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig[];

  /**
   * Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig user guide.
   *
   * @schema ClusterSpecForProviderNodeConfigGuestAccelerator#gpuPartitionSize
   */
  readonly gpuPartitionSize?: string;

  /**
   * Configuration for GPU sharing. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfigGuestAccelerator#gpuSharingConfig
   */
  readonly gpuSharingConfig?: ClusterSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig[];

  /**
   * The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
   *
   * @schema ClusterSpecForProviderNodeConfigGuestAccelerator#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigGuestAccelerator' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigGuestAccelerator(obj: ClusterSpecForProviderNodeConfigGuestAccelerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'gpuDriverInstallationConfig': obj.gpuDriverInstallationConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(y)),
    'gpuPartitionSize': obj.gpuPartitionSize,
    'gpuSharingConfig': obj.gpuSharingConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigGvnic
 */
export interface ClusterSpecForProviderNodeConfigGvnic {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderNodeConfigGvnic#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigGvnic' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigGvnic(obj: ClusterSpecForProviderNodeConfigGvnic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigHostMaintenancePolicy
 */
export interface ClusterSpecForProviderNodeConfigHostMaintenancePolicy {
  /**
   * @schema ClusterSpecForProviderNodeConfigHostMaintenancePolicy#maintenanceInterval
   */
  readonly maintenanceInterval?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigHostMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigHostMaintenancePolicy(obj: ClusterSpecForProviderNodeConfigHostMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maintenanceInterval': obj.maintenanceInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigKubeletConfig
 */
export interface ClusterSpecForProviderNodeConfigKubeletConfig {
  /**
   * Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods. The allowed sysctl groups are kernel.shm*, kernel.msg*, kernel.sem, fs.mqueue.*, and net.*.
   *
   * @schema ClusterSpecForProviderNodeConfigKubeletConfig#allowedUnsafeSysctls
   */
  readonly allowedUnsafeSysctls?: string[];

  /**
   * Defines the maximum number of container log files that can be present for a container. The integer must be between 2 and 10, inclusive.
   *
   * @schema ClusterSpecForProviderNodeConfigKubeletConfig#containerLogMaxFiles
   */
  readonly containerLogMaxFiles?: number;

  /**
   * Defines the maximum size of the
   * container log file before it is rotated. Specified as a positive number and a
   * unit suffix, such as "100Ki", "10Mi". Valid units are "Ki", "Mi", "Gi".
   * The value must be between "10Mi" and "500Mi", inclusive. And the total container log size
   * (container_log_max_size * container_log_max_files) cannot exceed 1% of the total storage of the node.
   *
   * @schema ClusterSpecForProviderNodeConfigKubeletConfig#containerLogMaxSize
   */
  readonly containerLogMaxSize?: string;

  /**
   * If true, enables CPU CFS quota enforcement for
   * containers that specify CPU limits.
   *
   * @schema ClusterSpecForProviderNodeConfigKubeletConfig#cpuCfsQuota
   */
  readonly cpuCfsQuota?: boolean;

  /**
   * The CPU CFS quota period value. Specified
   * as a sequence of decimal numbers, each with optional fraction and a unit suffix,
   * such as "300ms". Valid time units are "ns", "us" (or "s"), "ms", "s", "m",
   * "h". The value must be a positive duration.
   *
   * @schema ClusterSpecForProviderNodeConfigKubeletConfig#cpuCfsQuotaPeriod
   */
  readonly cpuCfsQuotaPeriod?: string;

  /**
   * The CPU management policy on the node. See
   * K8S CPU Management Policies.
   * One of "none" or "static". If unset (or set to the empty string ""), the API will treat the field as if set to "none".
   * Prior to the 6.4.0 this field was marked as required. The workaround for the required field
   * is setting the empty string "", which will function identically to not setting this field.
   *
   * @schema ClusterSpecForProviderNodeConfigKubeletConfig#cpuManagerPolicy
   */
  readonly cpuManagerPolicy?: string;

  /**
   * Defines the percent of disk usage after which image garbage collection is always run. The integer must be between 10 and 85, inclusive.
   *
   * @schema ClusterSpecForProviderNodeConfigKubeletConfig#imageGcHighThresholdPercent
   */
  readonly imageGcHighThresholdPercent?: number;

  /**
   * Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to. The integer must be between 10 and 85, inclusive.
   *
   * @schema ClusterSpecForProviderNodeConfigKubeletConfig#imageGcLowThresholdPercent
   */
  readonly imageGcLowThresholdPercent?: number;

  /**
   * Defines the maximum age an image can be unused before it is garbage collected. Specified as a sequence of decimal numbers, each with optional fraction and a unit suffix, such as "300s", "1.5m", and "2h45m". Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h". The value must be a positive duration.
   *
   * @schema ClusterSpecForProviderNodeConfigKubeletConfig#imageMaximumGcAge
   */
  readonly imageMaximumGcAge?: string;

  /**
   * Defines the minimum age for an unused image before it is garbage collected. Specified as a sequence of decimal numbers, each with optional fraction and a unit suffix, such as "300s", "1.5m". The value cannot be greater than "2m".
   *
   * @schema ClusterSpecForProviderNodeConfigKubeletConfig#imageMinimumGcAge
   */
  readonly imageMinimumGcAge?: string;

  /**
   * only port is enabled for newly created node pools in the cluster. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
   *
   * @schema ClusterSpecForProviderNodeConfigKubeletConfig#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;

  /**
   * Controls the maximum number of processes allowed to run in a pod. The value must be greater than or equal to 1024 and less than 4194304.
   *
   * @schema ClusterSpecForProviderNodeConfigKubeletConfig#podPidsLimit
   */
  readonly podPidsLimit?: number;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigKubeletConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigKubeletConfig(obj: ClusterSpecForProviderNodeConfigKubeletConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedUnsafeSysctls': obj.allowedUnsafeSysctls?.map(y => y),
    'containerLogMaxFiles': obj.containerLogMaxFiles,
    'containerLogMaxSize': obj.containerLogMaxSize,
    'cpuCfsQuota': obj.cpuCfsQuota,
    'cpuCfsQuotaPeriod': obj.cpuCfsQuotaPeriod,
    'cpuManagerPolicy': obj.cpuManagerPolicy,
    'imageGcHighThresholdPercent': obj.imageGcHighThresholdPercent,
    'imageGcLowThresholdPercent': obj.imageGcLowThresholdPercent,
    'imageMaximumGcAge': obj.imageMaximumGcAge,
    'imageMinimumGcAge': obj.imageMinimumGcAge,
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
    'podPidsLimit': obj.podPidsLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigLinuxNodeConfig
 */
export interface ClusterSpecForProviderNodeConfigLinuxNodeConfig {
  /**
   * Possible cgroup modes that can be used.
   * Accepted values are:
   *
   * @schema ClusterSpecForProviderNodeConfigLinuxNodeConfig#cgroupMode
   */
  readonly cgroupMode?: string;

  /**
   * Amounts for 2M and 1G hugepages. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodeConfigLinuxNodeConfig#hugepagesConfig
   */
  readonly hugepagesConfig?: ClusterSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig[];

  /**
   * The Linux kernel parameters to be applied to the nodes
   * and all pods running on the nodes. Specified as a map from the key, such as
   * net.core.wmem_max, to a string value. Currently supported attributes can be found here.
   * Note that validations happen all server side. All attributes are optional.
   *
   * @schema ClusterSpecForProviderNodeConfigLinuxNodeConfig#sysctls
   */
  readonly sysctls?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigLinuxNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigLinuxNodeConfig(obj: ClusterSpecForProviderNodeConfigLinuxNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cgroupMode': obj.cgroupMode,
    'hugepagesConfig': obj.hugepagesConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig(y)),
    'sysctls': ((obj.sysctls) === undefined) ? undefined : (Object.entries(obj.sysctls).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigLocalNvmeSsdBlockConfig
 */
export interface ClusterSpecForProviderNodeConfigLocalNvmeSsdBlockConfig {
  /**
   * The amount of local SSD disks that will be
   * attached to each cluster node. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterSpecForProviderNodeConfigLocalNvmeSsdBlockConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigLocalNvmeSsdBlockConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigLocalNvmeSsdBlockConfig(obj: ClusterSpecForProviderNodeConfigLocalNvmeSsdBlockConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigReservationAffinity
 */
export interface ClusterSpecForProviderNodeConfigReservationAffinity {
  /**
   * The type of reservation consumption
   * Accepted values are:
   *
   * @schema ClusterSpecForProviderNodeConfigReservationAffinity#consumeReservationType
   */
  readonly consumeReservationType?: string;

  /**
   * Key for taint.
   *
   * @schema ClusterSpecForProviderNodeConfigReservationAffinity#key
   */
  readonly key?: string;

  /**
   * name"
   *
   * @schema ClusterSpecForProviderNodeConfigReservationAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigReservationAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigReservationAffinity(obj: ClusterSpecForProviderNodeConfigReservationAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumeReservationType': obj.consumeReservationType,
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigSecondaryBootDisks
 */
export interface ClusterSpecForProviderNodeConfigSecondaryBootDisks {
  /**
   * Path to disk image to create the secondary boot disk from. After using the gke-disk-image-builder, this argument should be global/images/DISK_IMAGE_NAME.
   *
   * @schema ClusterSpecForProviderNodeConfigSecondaryBootDisks#diskImage
   */
  readonly diskImage?: string;

  /**
   * How to expose the node metadata to the workload running on the node.
   * Accepted values are:
   *
   * @schema ClusterSpecForProviderNodeConfigSecondaryBootDisks#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigSecondaryBootDisks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigSecondaryBootDisks(obj: ClusterSpecForProviderNodeConfigSecondaryBootDisks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'diskImage': obj.diskImage,
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema ClusterSpecForProviderNodeConfigServiceAccountRef
 */
export interface ClusterSpecForProviderNodeConfigServiceAccountRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderNodeConfigServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderNodeConfigServiceAccountRef#policy
   */
  readonly policy?: ClusterSpecForProviderNodeConfigServiceAccountRefPolicy;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigServiceAccountRef(obj: ClusterSpecForProviderNodeConfigServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderNodeConfigServiceAccountRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema ClusterSpecForProviderNodeConfigServiceAccountSelector
 */
export interface ClusterSpecForProviderNodeConfigServiceAccountSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderNodeConfigServiceAccountSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderNodeConfigServiceAccountSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderNodeConfigServiceAccountSelector#policy
   */
  readonly policy?: ClusterSpecForProviderNodeConfigServiceAccountSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigServiceAccountSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigServiceAccountSelector(obj: ClusterSpecForProviderNodeConfigServiceAccountSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderNodeConfigServiceAccountSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigShieldedInstanceConfig
 */
export interface ClusterSpecForProviderNodeConfigShieldedInstanceConfig {
  /**
   * Defines if the instance has integrity monitoring enabled.
   *
   * @schema ClusterSpecForProviderNodeConfigShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * Defines if the instance has Secure Boot enabled.
   *
   * @schema ClusterSpecForProviderNodeConfigShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigShieldedInstanceConfig(obj: ClusterSpecForProviderNodeConfigShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigSoleTenantConfig
 */
export interface ClusterSpecForProviderNodeConfigSoleTenantConfig {
  /**
   * @schema ClusterSpecForProviderNodeConfigSoleTenantConfig#nodeAffinity
   */
  readonly nodeAffinity?: ClusterSpecForProviderNodeConfigSoleTenantConfigNodeAffinity[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigSoleTenantConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigSoleTenantConfig(obj: ClusterSpecForProviderNodeConfigSoleTenantConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': obj.nodeAffinity?.map(y => toJson_ClusterSpecForProviderNodeConfigSoleTenantConfigNodeAffinity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigTaint
 */
export interface ClusterSpecForProviderNodeConfigTaint {
  /**
   * Effect for taint. Accepted values are NO_SCHEDULE, PREFER_NO_SCHEDULE, and NO_EXECUTE.
   *
   * @schema ClusterSpecForProviderNodeConfigTaint#effect
   */
  readonly effect?: string;

  /**
   * Key for taint.
   *
   * @schema ClusterSpecForProviderNodeConfigTaint#key
   */
  readonly key?: string;

  /**
   * Value for taint.
   *
   * @schema ClusterSpecForProviderNodeConfigTaint#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigTaint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigTaint(obj: ClusterSpecForProviderNodeConfigTaint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigWindowsNodeConfig
 */
export interface ClusterSpecForProviderNodeConfigWindowsNodeConfig {
  /**
   * @schema ClusterSpecForProviderNodeConfigWindowsNodeConfig#osversion
   */
  readonly osversion?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigWindowsNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigWindowsNodeConfig(obj: ClusterSpecForProviderNodeConfigWindowsNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'osversion': obj.osversion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigWorkloadMetadataConfig
 */
export interface ClusterSpecForProviderNodeConfigWorkloadMetadataConfig {
  /**
   * How to expose the node metadata to the workload running on the node.
   * Accepted values are:
   *
   * @schema ClusterSpecForProviderNodeConfigWorkloadMetadataConfig#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigWorkloadMetadataConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigWorkloadMetadataConfig(obj: ClusterSpecForProviderNodeConfigWorkloadMetadataConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodePoolAutoConfigLinuxNodeConfig
 */
export interface ClusterSpecForProviderNodePoolAutoConfigLinuxNodeConfig {
  /**
   * Possible cgroup modes that can be used.
   * Accepted values are:
   *
   * @schema ClusterSpecForProviderNodePoolAutoConfigLinuxNodeConfig#cgroupMode
   */
  readonly cgroupMode?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodePoolAutoConfigLinuxNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodePoolAutoConfigLinuxNodeConfig(obj: ClusterSpecForProviderNodePoolAutoConfigLinuxNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cgroupMode': obj.cgroupMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodePoolAutoConfigNetworkTags
 */
export interface ClusterSpecForProviderNodePoolAutoConfigNetworkTags {
  /**
   * List of network tags applied to auto-provisioned node pools.
   *
   * @schema ClusterSpecForProviderNodePoolAutoConfigNetworkTags#tags
   */
  readonly tags?: string[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodePoolAutoConfigNetworkTags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodePoolAutoConfigNetworkTags(obj: ClusterSpecForProviderNodePoolAutoConfigNetworkTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodePoolAutoConfigNodeKubeletConfig
 */
export interface ClusterSpecForProviderNodePoolAutoConfigNodeKubeletConfig {
  /**
   * Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
   *
   * @schema ClusterSpecForProviderNodePoolAutoConfigNodeKubeletConfig#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodePoolAutoConfigNodeKubeletConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodePoolAutoConfigNodeKubeletConfig(obj: ClusterSpecForProviderNodePoolAutoConfigNodeKubeletConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaults
 */
export interface ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaults {
  /**
   * Parameters to customize containerd runtime. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaults#containerdConfig
   */
  readonly containerdConfig?: ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig[];

  /**
   * The default Google Container Filesystem (GCFS) configuration at the cluster level. e.g. enable image streaming across all the node pools within the cluster. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaults#gcfsConfig
   */
  readonly gcfsConfig?: ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig[];

  /**
   * only port is enabled for newly created node pools in the cluster. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
   *
   * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaults#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;

  /**
   * The type of logging agent that is deployed by default for newly created node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. See Increasing logging agent throughput for more information.
   *
   * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaults#loggingVariant
   */
  readonly loggingVariant?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaults' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaults(obj: ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerdConfig': obj.containerdConfig?.map(y => toJson_ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig(y)),
    'gcfsConfig': obj.gcfsConfig?.map(y => toJson_ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig(y)),
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
    'loggingVariant': obj.loggingVariant,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNotificationConfigPubsub
 */
export interface ClusterSpecForProviderNotificationConfigPubsub {
  /**
   * Whether or not the notification config is enabled
   *
   * @schema ClusterSpecForProviderNotificationConfigPubsub#enabled
   */
  readonly enabled?: boolean;

  /**
   * Choose what type of notifications you want to receive. If no filters are applied, you'll receive all notification types. Structure is documented below.
   *
   * @schema ClusterSpecForProviderNotificationConfigPubsub#filter
   */
  readonly filter?: ClusterSpecForProviderNotificationConfigPubsubFilter[];

  /**
   * The pubsub topic to push upgrade notifications to. Must be in the same project as the cluster. Must be in the format: projects/{project}/topics/{topic}.
   *
   * @schema ClusterSpecForProviderNotificationConfigPubsub#topic
   */
  readonly topic?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNotificationConfigPubsub' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNotificationConfigPubsub(obj: ClusterSpecForProviderNotificationConfigPubsub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'filter': obj.filter?.map(y => toJson_ClusterSpecForProviderNotificationConfigPubsubFilter(y)),
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderPrivateClusterConfigMasterGlobalAccessConfig
 */
export interface ClusterSpecForProviderPrivateClusterConfigMasterGlobalAccessConfig {
  /**
   * Whether the cluster master is accessible globally or
   * not.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfigMasterGlobalAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderPrivateClusterConfigMasterGlobalAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderPrivateClusterConfigMasterGlobalAccessConfig(obj: ClusterSpecForProviderPrivateClusterConfigMasterGlobalAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Subnetwork in compute to populate privateEndpointSubnetwork.
 *
 * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef
 */
export interface ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef#policy
   */
  readonly policy?: ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy;
}

/**
 * Converts an object of type 'ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef(obj: ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Subnetwork in compute to populate privateEndpointSubnetwork.
 *
 * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector
 */
export interface ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector#policy
   */
  readonly policy?: ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector(obj: ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderResourceUsageExportConfigBigqueryDestination
 */
export interface ClusterSpecForProviderResourceUsageExportConfigBigqueryDestination {
  /**
   * The ID of a BigQuery Dataset. For Example:
   *
   * @schema ClusterSpecForProviderResourceUsageExportConfigBigqueryDestination#datasetId
   */
  readonly datasetId?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderResourceUsageExportConfigBigqueryDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderResourceUsageExportConfigBigqueryDestination(obj: ClusterSpecForProviderResourceUsageExportConfigBigqueryDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderSubnetworkRefPolicy
 */
export interface ClusterSpecForProviderSubnetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderSubnetworkRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderSubnetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecForProviderSubnetworkRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderSubnetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecForProviderSubnetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderSubnetworkRefPolicy(obj: ClusterSpecForProviderSubnetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderSubnetworkSelectorPolicy
 */
export interface ClusterSpecForProviderSubnetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderSubnetworkSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderSubnetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecForProviderSubnetworkSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderSubnetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecForProviderSubnetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderSubnetworkSelectorPolicy(obj: ClusterSpecForProviderSubnetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfigCloudrunConfig
 */
export interface ClusterSpecInitProviderAddonsConfigCloudrunConfig {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterSpecInitProviderAddonsConfigCloudrunConfig#disabled
   */
  readonly disabled?: boolean;

  /**
   * The load balancer type of CloudRun ingress service. It is external load balancer by default.
   * Set load_balancer_type=LOAD_BALANCER_TYPE_INTERNAL to configure it as internal load balancer.
   *
   * @schema ClusterSpecInitProviderAddonsConfigCloudrunConfig#loadBalancerType
   */
  readonly loadBalancerType?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigCloudrunConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigCloudrunConfig(obj: ClusterSpecInitProviderAddonsConfigCloudrunConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
    'loadBalancerType': obj.loadBalancerType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfigConfigConnectorConfig
 */
export interface ClusterSpecInitProviderAddonsConfigConfigConnectorConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderAddonsConfigConfigConnectorConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigConfigConnectorConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigConfigConnectorConfig(obj: ClusterSpecInitProviderAddonsConfigConfigConnectorConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfigDnsCacheConfig
 */
export interface ClusterSpecInitProviderAddonsConfigDnsCacheConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderAddonsConfigDnsCacheConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigDnsCacheConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigDnsCacheConfig(obj: ClusterSpecInitProviderAddonsConfigDnsCacheConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig
 */
export interface ClusterSpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig(obj: ClusterSpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig
 */
export interface ClusterSpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig(obj: ClusterSpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfigGcsFuseCsiDriverConfig
 */
export interface ClusterSpecInitProviderAddonsConfigGcsFuseCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderAddonsConfigGcsFuseCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigGcsFuseCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigGcsFuseCsiDriverConfig(obj: ClusterSpecInitProviderAddonsConfigGcsFuseCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfigGkeBackupAgentConfig
 */
export interface ClusterSpecInitProviderAddonsConfigGkeBackupAgentConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderAddonsConfigGkeBackupAgentConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigGkeBackupAgentConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigGkeBackupAgentConfig(obj: ClusterSpecInitProviderAddonsConfigGkeBackupAgentConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfigHorizontalPodAutoscaling
 */
export interface ClusterSpecInitProviderAddonsConfigHorizontalPodAutoscaling {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterSpecInitProviderAddonsConfigHorizontalPodAutoscaling#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigHorizontalPodAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigHorizontalPodAutoscaling(obj: ClusterSpecInitProviderAddonsConfigHorizontalPodAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfigHttpLoadBalancing
 */
export interface ClusterSpecInitProviderAddonsConfigHttpLoadBalancing {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterSpecInitProviderAddonsConfigHttpLoadBalancing#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigHttpLoadBalancing' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigHttpLoadBalancing(obj: ClusterSpecInitProviderAddonsConfigHttpLoadBalancing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfigLustreCsiDriverConfig
 */
export interface ClusterSpecInitProviderAddonsConfigLustreCsiDriverConfig {
  /**
   * @schema ClusterSpecInitProviderAddonsConfigLustreCsiDriverConfig#enableLegacyLustrePort
   */
  readonly enableLegacyLustrePort?: boolean;

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderAddonsConfigLustreCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigLustreCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigLustreCsiDriverConfig(obj: ClusterSpecInitProviderAddonsConfigLustreCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableLegacyLustrePort': obj.enableLegacyLustrePort,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfigNetworkPolicyConfig
 */
export interface ClusterSpecInitProviderAddonsConfigNetworkPolicyConfig {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterSpecInitProviderAddonsConfigNetworkPolicyConfig#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigNetworkPolicyConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigNetworkPolicyConfig(obj: ClusterSpecInitProviderAddonsConfigNetworkPolicyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfigParallelstoreCsiDriverConfig
 */
export interface ClusterSpecInitProviderAddonsConfigParallelstoreCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderAddonsConfigParallelstoreCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigParallelstoreCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigParallelstoreCsiDriverConfig(obj: ClusterSpecInitProviderAddonsConfigParallelstoreCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfigRayOperatorConfig
 */
export interface ClusterSpecInitProviderAddonsConfigRayOperatorConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderAddonsConfigRayOperatorConfig#enabled
   */
  readonly enabled?: boolean;

  /**
   * Logging configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProviderAddonsConfigRayOperatorConfig#rayClusterLoggingConfig
   */
  readonly rayClusterLoggingConfig?: ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig[];

  /**
   * Monitoring configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterSpecInitProviderAddonsConfigRayOperatorConfig#rayClusterMonitoringConfig
   */
  readonly rayClusterMonitoringConfig?: ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigRayOperatorConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigRayOperatorConfig(obj: ClusterSpecInitProviderAddonsConfigRayOperatorConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'rayClusterLoggingConfig': obj.rayClusterLoggingConfig?.map(y => toJson_ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig(y)),
    'rayClusterMonitoringConfig': obj.rayClusterMonitoringConfig?.map(y => toJson_ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfigStatefulHaConfig
 */
export interface ClusterSpecInitProviderAddonsConfigStatefulHaConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderAddonsConfigStatefulHaConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigStatefulHaConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigStatefulHaConfig(obj: ClusterSpecInitProviderAddonsConfigStatefulHaConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults
 */
export interface ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults {
  /**
   * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults#bootDiskKmsKey
   */
  readonly bootDiskKmsKey?: string;

  /**
   * Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Defaults to 100
   *
   * @default 100
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults#diskSize
   */
  readonly diskSize?: number;

  /**
   * Type of the disk attached to each node
   * (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-standard'
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults#diskType
   */
  readonly diskType?: string;

  /**
   * The image type to use for this node. Note that changing the image type
   * will delete and recreate all nodes in the node pool.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults#imageType
   */
  readonly imageType?: string;

  /**
   * NodeManagement configuration for this NodePool. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults#management
   */
  readonly management?: ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement[];

  /**
   * Minimum CPU platform to be used by this instance.
   * The instance may be scheduled on the specified or newer CPU platform. Applicable
   * values are the friendly names of CPU platforms, such as Intel Haswell. See the
   * official documentation
   * for more information.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults#minCpuPlatform
   */
  readonly minCpuPlatform?: string;

  /**
   * The set of Google API scopes to be made available
   * on all of the node VMs under the "default" service account.
   * Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set service_account to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults#oauthScopes
   */
  readonly oauthScopes?: string[];

  /**
   * The service account to be used by the Node VMs.
   * If not specified, the "default" service account is used.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Shielded Instance options. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig[];

  /**
   * Specifies the upgrade settings for NAP created node pools. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults#upgradeSettings
   */
  readonly upgradeSettings?: ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults(obj: ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bootDiskKmsKey': obj.bootDiskKmsKey,
    'diskSize': obj.diskSize,
    'diskType': obj.diskType,
    'imageType': obj.imageType,
    'management': obj.management?.map(y => toJson_ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement(y)),
    'minCpuPlatform': obj.minCpuPlatform,
    'oauthScopes': obj.oauthScopes?.map(y => y),
    'serviceAccount': obj.serviceAccount,
    'shieldedInstanceConfig': obj.shieldedInstanceConfig?.map(y => toJson_ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig(y)),
    'upgradeSettings': obj.upgradeSettings?.map(y => toJson_ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderClusterAutoscalingResourceLimits
 */
export interface ClusterSpecInitProviderClusterAutoscalingResourceLimits {
  /**
   * Maximum amount of the resource in the cluster.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingResourceLimits#maximum
   */
  readonly maximum?: number;

  /**
   * Minimum amount of the resource in the cluster.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingResourceLimits#minimum
   */
  readonly minimum?: number;

  /**
   * The type of the resource. For example, cpu and
   * memory.  See the guide to using Node Auto-Provisioning
   * for a list of types.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingResourceLimits#resourceType
   */
  readonly resourceType?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderClusterAutoscalingResourceLimits' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderClusterAutoscalingResourceLimits(obj: ClusterSpecInitProviderClusterAutoscalingResourceLimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximum': obj.maximum,
    'minimum': obj.minimum,
    'resourceType': obj.resourceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig
 */
export interface ClusterSpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig {
  /**
   * Controls whether user traffic is allowed over this endpoint. Note that GCP-managed services may still use the endpoint even if this is false.
   *
   * @schema ClusterSpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig#allowExternalTraffic
   */
  readonly allowExternalTraffic?: boolean;

  /**
   * (Output) The cluster's DNS endpoint.
   *
   * @schema ClusterSpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig#endpoint
   */
  readonly endpoint?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig(obj: ClusterSpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowExternalTraffic': obj.allowExternalTraffic,
    'endpoint': obj.endpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig
 */
export interface ClusterSpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig {
  /**
   * Controls whether to allow direct IP access. Defaults to true.
   *
   * @default true.
   * @schema ClusterSpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig(obj: ClusterSpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig
 */
export interface ClusterSpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig {
  /**
   * List of secondary ranges names within this subnetwork that can be used for pod IPs.
   *
   * @schema ClusterSpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig#podIpv4RangeNames
   */
  readonly podIpv4RangeNames?: string[];

  /**
   * The name or self_link of the Google Compute Engine
   * subnetwork in which the cluster's instances are launched.
   *
   * @schema ClusterSpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig#subnetwork
   */
  readonly subnetwork?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig(obj: ClusterSpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podIpv4RangeNames': obj.podIpv4RangeNames?.map(y => y),
    'subnetwork': obj.subnetwork,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig
 */
export interface ClusterSpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig {
  /**
   * The names of the Pod ranges to add to the cluster.
   *
   * @schema ClusterSpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig#podRangeNames
   */
  readonly podRangeNames?: string[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig(obj: ClusterSpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podRangeNames': obj.podRangeNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig
 */
export interface ClusterSpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterSpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig(obj: ClusterSpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderMaintenancePolicyDailyMaintenanceWindow
 */
export interface ClusterSpecInitProviderMaintenancePolicyDailyMaintenanceWindow {
  /**
   * @schema ClusterSpecInitProviderMaintenancePolicyDailyMaintenanceWindow#startTime
   */
  readonly startTime?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderMaintenancePolicyDailyMaintenanceWindow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderMaintenancePolicyDailyMaintenanceWindow(obj: ClusterSpecInitProviderMaintenancePolicyDailyMaintenanceWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusion
 */
export interface ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusion {
  /**
   * @schema ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusion#endTime
   */
  readonly endTime?: string;

  /**
   * The name of the cluster, unique within the project and
   * location.
   *
   * @schema ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusion#exclusionName
   */
  readonly exclusionName?: string;

  /**
   * MaintenanceExclusionOptions provides maintenance exclusion related options.
   *
   * @schema ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusion#exclusionOptions
   */
  readonly exclusionOptions?: ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions[];

  /**
   * @schema ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusion#startTime
   */
  readonly startTime?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusion' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusion(obj: ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'exclusionName': obj.exclusionName,
    'exclusionOptions': obj.exclusionOptions?.map(y => toJson_ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions(y)),
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderMaintenancePolicyRecurringWindow
 */
export interface ClusterSpecInitProviderMaintenancePolicyRecurringWindow {
  /**
   * @schema ClusterSpecInitProviderMaintenancePolicyRecurringWindow#endTime
   */
  readonly endTime?: string;

  /**
   * @schema ClusterSpecInitProviderMaintenancePolicyRecurringWindow#recurrence
   */
  readonly recurrence?: string;

  /**
   * @schema ClusterSpecInitProviderMaintenancePolicyRecurringWindow#startTime
   */
  readonly startTime?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderMaintenancePolicyRecurringWindow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderMaintenancePolicyRecurringWindow(obj: ClusterSpecInitProviderMaintenancePolicyRecurringWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'recurrence': obj.recurrence,
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderMasterAuthClientCertificateConfig
 */
export interface ClusterSpecInitProviderMasterAuthClientCertificateConfig {
  /**
   * @schema ClusterSpecInitProviderMasterAuthClientCertificateConfig#issueClientCertificate
   */
  readonly issueClientCertificate?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderMasterAuthClientCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderMasterAuthClientCertificateConfig(obj: ClusterSpecInitProviderMasterAuthClientCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'issueClientCertificate': obj.issueClientCertificate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks
 */
export interface ClusterSpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks {
  /**
   * External network that can access Kubernetes master through HTTPS.
   * Must be specified in CIDR notation.
   *
   * @schema ClusterSpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks#cidrBlock
   */
  readonly cidrBlock?: string;

  /**
   * Field for users to identify CIDR blocks.
   *
   * @schema ClusterSpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks#displayName
   */
  readonly displayName?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks(obj: ClusterSpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrBlock': obj.cidrBlock,
    'displayName': obj.displayName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig
 */
export interface ClusterSpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig {
  /**
   * Whether or not to enable advanced datapath metrics.
   *
   * @schema ClusterSpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig#enableMetrics
   */
  readonly enableMetrics?: boolean;

  /**
   * Whether or not Relay is enabled.
   *
   * @schema ClusterSpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig#enableRelay
   */
  readonly enableRelay?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig(obj: ClusterSpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableMetrics': obj.enableMetrics,
    'enableRelay': obj.enableRelay,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderMonitoringConfigManagedPrometheus
 */
export interface ClusterSpecInitProviderMonitoringConfigManagedPrometheus {
  /**
   * Configuration options for GKE Auto-Monitoring.
   *
   * @schema ClusterSpecInitProviderMonitoringConfigManagedPrometheus#autoMonitoringConfig
   */
  readonly autoMonitoringConfig?: ClusterSpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig[];

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderMonitoringConfigManagedPrometheus#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderMonitoringConfigManagedPrometheus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderMonitoringConfigManagedPrometheus(obj: ClusterSpecInitProviderMonitoringConfigManagedPrometheus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoMonitoringConfig': obj.autoMonitoringConfig?.map(y => toJson_ClusterSpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig(y)),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecInitProviderNetworkRefPolicy
 */
export interface ClusterSpecInitProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecInitProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecInitProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecInitProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecInitProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNetworkRefPolicy(obj: ClusterSpecInitProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecInitProviderNetworkSelectorPolicy
 */
export interface ClusterSpecInitProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecInitProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecInitProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecInitProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecInitProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNetworkSelectorPolicy(obj: ClusterSpecInitProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigAdvancedMachineFeatures
 */
export interface ClusterSpecInitProviderNodeConfigAdvancedMachineFeatures {
  /**
   * Defines whether the instance should have nested virtualization enabled. Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecInitProviderNodeConfigAdvancedMachineFeatures#enableNestedVirtualization
   */
  readonly enableNestedVirtualization?: boolean;

  /**
   * Defines the performance monitoring unit PMU level. Valid values are ARCHITECTURAL, STANDARD, or ENHANCED. Defaults to off.
   *
   * @default off.
   * @schema ClusterSpecInitProviderNodeConfigAdvancedMachineFeatures#performanceMonitoringUnit
   */
  readonly performanceMonitoringUnit?: string;

  /**
   * The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
   *
   * @schema ClusterSpecInitProviderNodeConfigAdvancedMachineFeatures#threadsPerCore
   */
  readonly threadsPerCore?: number;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigAdvancedMachineFeatures' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigAdvancedMachineFeatures(obj: ClusterSpecInitProviderNodeConfigAdvancedMachineFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableNestedVirtualization': obj.enableNestedVirtualization,
    'performanceMonitoringUnit': obj.performanceMonitoringUnit,
    'threadsPerCore': obj.threadsPerCore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigConfidentialNodes
 */
export interface ClusterSpecInitProviderNodeConfigConfidentialNodes {
  /**
   * Defines the type of technology used
   * by the confidential node.
   *
   * @schema ClusterSpecInitProviderNodeConfigConfidentialNodes#confidentialInstanceType
   */
  readonly confidentialInstanceType?: string;

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderNodeConfigConfidentialNodes#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigConfidentialNodes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigConfidentialNodes(obj: ClusterSpecInitProviderNodeConfigConfidentialNodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confidentialInstanceType': obj.confidentialInstanceType,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigContainerdConfig
 */
export interface ClusterSpecInitProviderNodeConfigContainerdConfig {
  /**
   * Configuration for private container registries. There are two fields in this config:
   *
   * @schema ClusterSpecInitProviderNodeConfigContainerdConfig#privateRegistryAccessConfig
   */
  readonly privateRegistryAccessConfig?: ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigContainerdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigContainerdConfig(obj: ClusterSpecInitProviderNodeConfigContainerdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateRegistryAccessConfig': obj.privateRegistryAccessConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig
 */
export interface ClusterSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig {
  /**
   * Number of raw-block local NVMe SSD disks to be attached to the node utilized for GKE Data Cache. If zero, then GKE Data Cache will not be enabled in the nodes.
   *
   * @schema ClusterSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig#dataCacheCount
   */
  readonly dataCacheCount?: number;

  /**
   * The amount of local SSD disks that will be
   * attached to each cluster node. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig(obj: ClusterSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataCacheCount': obj.dataCacheCount,
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigFastSocket
 */
export interface ClusterSpecInitProviderNodeConfigFastSocket {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderNodeConfigFastSocket#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigFastSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigFastSocket(obj: ClusterSpecInitProviderNodeConfigFastSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigGcfsConfig
 */
export interface ClusterSpecInitProviderNodeConfigGcfsConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderNodeConfigGcfsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigGcfsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigGcfsConfig(obj: ClusterSpecInitProviderNodeConfigGcfsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigGuestAccelerator
 */
export interface ClusterSpecInitProviderNodeConfigGuestAccelerator {
  /**
   * The number of the guest accelerator cards exposed to this instance.
   *
   * @schema ClusterSpecInitProviderNodeConfigGuestAccelerator#count
   */
  readonly count?: number;

  /**
   * Configuration for auto installation of GPU driver. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfigGuestAccelerator#gpuDriverInstallationConfig
   */
  readonly gpuDriverInstallationConfig?: ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig[];

  /**
   * Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig user guide.
   *
   * @schema ClusterSpecInitProviderNodeConfigGuestAccelerator#gpuPartitionSize
   */
  readonly gpuPartitionSize?: string;

  /**
   * Configuration for GPU sharing. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfigGuestAccelerator#gpuSharingConfig
   */
  readonly gpuSharingConfig?: ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig[];

  /**
   * The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
   *
   * @schema ClusterSpecInitProviderNodeConfigGuestAccelerator#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigGuestAccelerator' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigGuestAccelerator(obj: ClusterSpecInitProviderNodeConfigGuestAccelerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'gpuDriverInstallationConfig': obj.gpuDriverInstallationConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(y)),
    'gpuPartitionSize': obj.gpuPartitionSize,
    'gpuSharingConfig': obj.gpuSharingConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigGvnic
 */
export interface ClusterSpecInitProviderNodeConfigGvnic {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderNodeConfigGvnic#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigGvnic' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigGvnic(obj: ClusterSpecInitProviderNodeConfigGvnic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigHostMaintenancePolicy
 */
export interface ClusterSpecInitProviderNodeConfigHostMaintenancePolicy {
  /**
   * @schema ClusterSpecInitProviderNodeConfigHostMaintenancePolicy#maintenanceInterval
   */
  readonly maintenanceInterval?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigHostMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigHostMaintenancePolicy(obj: ClusterSpecInitProviderNodeConfigHostMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maintenanceInterval': obj.maintenanceInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigKubeletConfig
 */
export interface ClusterSpecInitProviderNodeConfigKubeletConfig {
  /**
   * Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods. The allowed sysctl groups are kernel.shm*, kernel.msg*, kernel.sem, fs.mqueue.*, and net.*.
   *
   * @schema ClusterSpecInitProviderNodeConfigKubeletConfig#allowedUnsafeSysctls
   */
  readonly allowedUnsafeSysctls?: string[];

  /**
   * Defines the maximum number of container log files that can be present for a container. The integer must be between 2 and 10, inclusive.
   *
   * @schema ClusterSpecInitProviderNodeConfigKubeletConfig#containerLogMaxFiles
   */
  readonly containerLogMaxFiles?: number;

  /**
   * Defines the maximum size of the
   * container log file before it is rotated. Specified as a positive number and a
   * unit suffix, such as "100Ki", "10Mi". Valid units are "Ki", "Mi", "Gi".
   * The value must be between "10Mi" and "500Mi", inclusive. And the total container log size
   * (container_log_max_size * container_log_max_files) cannot exceed 1% of the total storage of the node.
   *
   * @schema ClusterSpecInitProviderNodeConfigKubeletConfig#containerLogMaxSize
   */
  readonly containerLogMaxSize?: string;

  /**
   * If true, enables CPU CFS quota enforcement for
   * containers that specify CPU limits.
   *
   * @schema ClusterSpecInitProviderNodeConfigKubeletConfig#cpuCfsQuota
   */
  readonly cpuCfsQuota?: boolean;

  /**
   * The CPU CFS quota period value. Specified
   * as a sequence of decimal numbers, each with optional fraction and a unit suffix,
   * such as "300ms". Valid time units are "ns", "us" (or "s"), "ms", "s", "m",
   * "h". The value must be a positive duration.
   *
   * @schema ClusterSpecInitProviderNodeConfigKubeletConfig#cpuCfsQuotaPeriod
   */
  readonly cpuCfsQuotaPeriod?: string;

  /**
   * The CPU management policy on the node. See
   * K8S CPU Management Policies.
   * One of "none" or "static". If unset (or set to the empty string ""), the API will treat the field as if set to "none".
   * Prior to the 6.4.0 this field was marked as required. The workaround for the required field
   * is setting the empty string "", which will function identically to not setting this field.
   *
   * @schema ClusterSpecInitProviderNodeConfigKubeletConfig#cpuManagerPolicy
   */
  readonly cpuManagerPolicy?: string;

  /**
   * Defines the percent of disk usage after which image garbage collection is always run. The integer must be between 10 and 85, inclusive.
   *
   * @schema ClusterSpecInitProviderNodeConfigKubeletConfig#imageGcHighThresholdPercent
   */
  readonly imageGcHighThresholdPercent?: number;

  /**
   * Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to. The integer must be between 10 and 85, inclusive.
   *
   * @schema ClusterSpecInitProviderNodeConfigKubeletConfig#imageGcLowThresholdPercent
   */
  readonly imageGcLowThresholdPercent?: number;

  /**
   * Defines the maximum age an image can be unused before it is garbage collected. Specified as a sequence of decimal numbers, each with optional fraction and a unit suffix, such as "300s", "1.5m", and "2h45m". Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h". The value must be a positive duration.
   *
   * @schema ClusterSpecInitProviderNodeConfigKubeletConfig#imageMaximumGcAge
   */
  readonly imageMaximumGcAge?: string;

  /**
   * Defines the minimum age for an unused image before it is garbage collected. Specified as a sequence of decimal numbers, each with optional fraction and a unit suffix, such as "300s", "1.5m". The value cannot be greater than "2m".
   *
   * @schema ClusterSpecInitProviderNodeConfigKubeletConfig#imageMinimumGcAge
   */
  readonly imageMinimumGcAge?: string;

  /**
   * only port is enabled for newly created node pools in the cluster. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
   *
   * @schema ClusterSpecInitProviderNodeConfigKubeletConfig#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;

  /**
   * Controls the maximum number of processes allowed to run in a pod. The value must be greater than or equal to 1024 and less than 4194304.
   *
   * @schema ClusterSpecInitProviderNodeConfigKubeletConfig#podPidsLimit
   */
  readonly podPidsLimit?: number;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigKubeletConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigKubeletConfig(obj: ClusterSpecInitProviderNodeConfigKubeletConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedUnsafeSysctls': obj.allowedUnsafeSysctls?.map(y => y),
    'containerLogMaxFiles': obj.containerLogMaxFiles,
    'containerLogMaxSize': obj.containerLogMaxSize,
    'cpuCfsQuota': obj.cpuCfsQuota,
    'cpuCfsQuotaPeriod': obj.cpuCfsQuotaPeriod,
    'cpuManagerPolicy': obj.cpuManagerPolicy,
    'imageGcHighThresholdPercent': obj.imageGcHighThresholdPercent,
    'imageGcLowThresholdPercent': obj.imageGcLowThresholdPercent,
    'imageMaximumGcAge': obj.imageMaximumGcAge,
    'imageMinimumGcAge': obj.imageMinimumGcAge,
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
    'podPidsLimit': obj.podPidsLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigLinuxNodeConfig
 */
export interface ClusterSpecInitProviderNodeConfigLinuxNodeConfig {
  /**
   * Possible cgroup modes that can be used.
   * Accepted values are:
   *
   * @schema ClusterSpecInitProviderNodeConfigLinuxNodeConfig#cgroupMode
   */
  readonly cgroupMode?: string;

  /**
   * Amounts for 2M and 1G hugepages. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodeConfigLinuxNodeConfig#hugepagesConfig
   */
  readonly hugepagesConfig?: ClusterSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig[];

  /**
   * The Linux kernel parameters to be applied to the nodes
   * and all pods running on the nodes. Specified as a map from the key, such as
   * net.core.wmem_max, to a string value. Currently supported attributes can be found here.
   * Note that validations happen all server side. All attributes are optional.
   *
   * @schema ClusterSpecInitProviderNodeConfigLinuxNodeConfig#sysctls
   */
  readonly sysctls?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigLinuxNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigLinuxNodeConfig(obj: ClusterSpecInitProviderNodeConfigLinuxNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cgroupMode': obj.cgroupMode,
    'hugepagesConfig': obj.hugepagesConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig(y)),
    'sysctls': ((obj.sysctls) === undefined) ? undefined : (Object.entries(obj.sysctls).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig
 */
export interface ClusterSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig {
  /**
   * The amount of local SSD disks that will be
   * attached to each cluster node. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig(obj: ClusterSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigReservationAffinity
 */
export interface ClusterSpecInitProviderNodeConfigReservationAffinity {
  /**
   * The type of reservation consumption
   * Accepted values are:
   *
   * @schema ClusterSpecInitProviderNodeConfigReservationAffinity#consumeReservationType
   */
  readonly consumeReservationType?: string;

  /**
   * Key for taint.
   *
   * @schema ClusterSpecInitProviderNodeConfigReservationAffinity#key
   */
  readonly key?: string;

  /**
   * name"
   *
   * @schema ClusterSpecInitProviderNodeConfigReservationAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigReservationAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigReservationAffinity(obj: ClusterSpecInitProviderNodeConfigReservationAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumeReservationType': obj.consumeReservationType,
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigSecondaryBootDisks
 */
export interface ClusterSpecInitProviderNodeConfigSecondaryBootDisks {
  /**
   * Path to disk image to create the secondary boot disk from. After using the gke-disk-image-builder, this argument should be global/images/DISK_IMAGE_NAME.
   *
   * @schema ClusterSpecInitProviderNodeConfigSecondaryBootDisks#diskImage
   */
  readonly diskImage?: string;

  /**
   * How to expose the node metadata to the workload running on the node.
   * Accepted values are:
   *
   * @schema ClusterSpecInitProviderNodeConfigSecondaryBootDisks#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigSecondaryBootDisks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigSecondaryBootDisks(obj: ClusterSpecInitProviderNodeConfigSecondaryBootDisks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'diskImage': obj.diskImage,
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema ClusterSpecInitProviderNodeConfigServiceAccountRef
 */
export interface ClusterSpecInitProviderNodeConfigServiceAccountRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecInitProviderNodeConfigServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecInitProviderNodeConfigServiceAccountRef#policy
   */
  readonly policy?: ClusterSpecInitProviderNodeConfigServiceAccountRefPolicy;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigServiceAccountRef(obj: ClusterSpecInitProviderNodeConfigServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecInitProviderNodeConfigServiceAccountRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema ClusterSpecInitProviderNodeConfigServiceAccountSelector
 */
export interface ClusterSpecInitProviderNodeConfigServiceAccountSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterSpecInitProviderNodeConfigServiceAccountSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecInitProviderNodeConfigServiceAccountSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecInitProviderNodeConfigServiceAccountSelector#policy
   */
  readonly policy?: ClusterSpecInitProviderNodeConfigServiceAccountSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigServiceAccountSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigServiceAccountSelector(obj: ClusterSpecInitProviderNodeConfigServiceAccountSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecInitProviderNodeConfigServiceAccountSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigShieldedInstanceConfig
 */
export interface ClusterSpecInitProviderNodeConfigShieldedInstanceConfig {
  /**
   * Defines if the instance has integrity monitoring enabled.
   *
   * @schema ClusterSpecInitProviderNodeConfigShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * Defines if the instance has Secure Boot enabled.
   *
   * @schema ClusterSpecInitProviderNodeConfigShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigShieldedInstanceConfig(obj: ClusterSpecInitProviderNodeConfigShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigSoleTenantConfig
 */
export interface ClusterSpecInitProviderNodeConfigSoleTenantConfig {
  /**
   * @schema ClusterSpecInitProviderNodeConfigSoleTenantConfig#nodeAffinity
   */
  readonly nodeAffinity?: ClusterSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigSoleTenantConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigSoleTenantConfig(obj: ClusterSpecInitProviderNodeConfigSoleTenantConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': obj.nodeAffinity?.map(y => toJson_ClusterSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigTaint
 */
export interface ClusterSpecInitProviderNodeConfigTaint {
  /**
   * Effect for taint. Accepted values are NO_SCHEDULE, PREFER_NO_SCHEDULE, and NO_EXECUTE.
   *
   * @schema ClusterSpecInitProviderNodeConfigTaint#effect
   */
  readonly effect?: string;

  /**
   * Key for taint.
   *
   * @schema ClusterSpecInitProviderNodeConfigTaint#key
   */
  readonly key?: string;

  /**
   * Value for taint.
   *
   * @schema ClusterSpecInitProviderNodeConfigTaint#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigTaint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigTaint(obj: ClusterSpecInitProviderNodeConfigTaint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigWindowsNodeConfig
 */
export interface ClusterSpecInitProviderNodeConfigWindowsNodeConfig {
  /**
   * @schema ClusterSpecInitProviderNodeConfigWindowsNodeConfig#osversion
   */
  readonly osversion?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigWindowsNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigWindowsNodeConfig(obj: ClusterSpecInitProviderNodeConfigWindowsNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'osversion': obj.osversion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigWorkloadMetadataConfig
 */
export interface ClusterSpecInitProviderNodeConfigWorkloadMetadataConfig {
  /**
   * How to expose the node metadata to the workload running on the node.
   * Accepted values are:
   *
   * @schema ClusterSpecInitProviderNodeConfigWorkloadMetadataConfig#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigWorkloadMetadataConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigWorkloadMetadataConfig(obj: ClusterSpecInitProviderNodeConfigWorkloadMetadataConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodePoolAutoConfigLinuxNodeConfig
 */
export interface ClusterSpecInitProviderNodePoolAutoConfigLinuxNodeConfig {
  /**
   * Possible cgroup modes that can be used.
   * Accepted values are:
   *
   * @schema ClusterSpecInitProviderNodePoolAutoConfigLinuxNodeConfig#cgroupMode
   */
  readonly cgroupMode?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodePoolAutoConfigLinuxNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodePoolAutoConfigLinuxNodeConfig(obj: ClusterSpecInitProviderNodePoolAutoConfigLinuxNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cgroupMode': obj.cgroupMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodePoolAutoConfigNetworkTags
 */
export interface ClusterSpecInitProviderNodePoolAutoConfigNetworkTags {
  /**
   * List of network tags applied to auto-provisioned node pools.
   *
   * @schema ClusterSpecInitProviderNodePoolAutoConfigNetworkTags#tags
   */
  readonly tags?: string[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodePoolAutoConfigNetworkTags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodePoolAutoConfigNetworkTags(obj: ClusterSpecInitProviderNodePoolAutoConfigNetworkTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodePoolAutoConfigNodeKubeletConfig
 */
export interface ClusterSpecInitProviderNodePoolAutoConfigNodeKubeletConfig {
  /**
   * Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
   *
   * @schema ClusterSpecInitProviderNodePoolAutoConfigNodeKubeletConfig#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodePoolAutoConfigNodeKubeletConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodePoolAutoConfigNodeKubeletConfig(obj: ClusterSpecInitProviderNodePoolAutoConfigNodeKubeletConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaults
 */
export interface ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaults {
  /**
   * Parameters to customize containerd runtime. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaults#containerdConfig
   */
  readonly containerdConfig?: ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig[];

  /**
   * The default Google Container Filesystem (GCFS) configuration at the cluster level. e.g. enable image streaming across all the node pools within the cluster. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaults#gcfsConfig
   */
  readonly gcfsConfig?: ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig[];

  /**
   * only port is enabled for newly created node pools in the cluster. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
   *
   * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaults#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;

  /**
   * The type of logging agent that is deployed by default for newly created node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. See Increasing logging agent throughput for more information.
   *
   * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaults#loggingVariant
   */
  readonly loggingVariant?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaults' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaults(obj: ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerdConfig': obj.containerdConfig?.map(y => toJson_ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig(y)),
    'gcfsConfig': obj.gcfsConfig?.map(y => toJson_ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig(y)),
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
    'loggingVariant': obj.loggingVariant,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNotificationConfigPubsub
 */
export interface ClusterSpecInitProviderNotificationConfigPubsub {
  /**
   * Whether or not the notification config is enabled
   *
   * @schema ClusterSpecInitProviderNotificationConfigPubsub#enabled
   */
  readonly enabled?: boolean;

  /**
   * Choose what type of notifications you want to receive. If no filters are applied, you'll receive all notification types. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderNotificationConfigPubsub#filter
   */
  readonly filter?: ClusterSpecInitProviderNotificationConfigPubsubFilter[];

  /**
   * The pubsub topic to push upgrade notifications to. Must be in the same project as the cluster. Must be in the format: projects/{project}/topics/{topic}.
   *
   * @schema ClusterSpecInitProviderNotificationConfigPubsub#topic
   */
  readonly topic?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNotificationConfigPubsub' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNotificationConfigPubsub(obj: ClusterSpecInitProviderNotificationConfigPubsub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'filter': obj.filter?.map(y => toJson_ClusterSpecInitProviderNotificationConfigPubsubFilter(y)),
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig
 */
export interface ClusterSpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig {
  /**
   * Whether the cluster master is accessible globally or
   * not.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig(obj: ClusterSpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Subnetwork in compute to populate privateEndpointSubnetwork.
 *
 * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef
 */
export interface ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef#policy
   */
  readonly policy?: ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef(obj: ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Subnetwork in compute to populate privateEndpointSubnetwork.
 *
 * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector
 */
export interface ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector#policy
   */
  readonly policy?: ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector(obj: ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderResourceUsageExportConfigBigqueryDestination
 */
export interface ClusterSpecInitProviderResourceUsageExportConfigBigqueryDestination {
  /**
   * The ID of a BigQuery Dataset. For Example:
   *
   * @schema ClusterSpecInitProviderResourceUsageExportConfigBigqueryDestination#datasetId
   */
  readonly datasetId?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderResourceUsageExportConfigBigqueryDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderResourceUsageExportConfigBigqueryDestination(obj: ClusterSpecInitProviderResourceUsageExportConfigBigqueryDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecInitProviderSubnetworkRefPolicy
 */
export interface ClusterSpecInitProviderSubnetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecInitProviderSubnetworkRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecInitProviderSubnetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecInitProviderSubnetworkRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecInitProviderSubnetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderSubnetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderSubnetworkRefPolicy(obj: ClusterSpecInitProviderSubnetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecInitProviderSubnetworkSelectorPolicy
 */
export interface ClusterSpecInitProviderSubnetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecInitProviderSubnetworkSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecInitProviderSubnetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecInitProviderSubnetworkSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecInitProviderSubnetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderSubnetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderSubnetworkSelectorPolicy(obj: ClusterSpecInitProviderSubnetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig
 */
export interface ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig(obj: ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig
 */
export interface ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig(obj: ClusterSpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement
 */
export interface ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement {
  /**
   * Specifies whether the node auto-repair is enabled for the node pool. If enabled, the nodes in this node pool will be monitored and, if they fail health checks too many times, an automatic repair action will be triggered.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement#autoRepair
   */
  readonly autoRepair?: boolean;

  /**
   * Specifies whether node auto-upgrade is enabled for the node pool. If enabled, node auto-upgrade helps keep the nodes in your node pool up to date with the latest release version of Kubernetes.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement#autoUpgrade
   */
  readonly autoUpgrade?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement(obj: ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoRepair': obj.autoRepair,
    'autoUpgrade': obj.autoUpgrade,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig
 */
export interface ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig {
  /**
   * Defines if the instance has integrity monitoring enabled.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * Defines if the instance has Secure Boot enabled.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig(obj: ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings
 */
export interface ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings {
  /**
   * Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#blueGreenSettings
   */
  readonly blueGreenSettings?: ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings[];

  /**
   * The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
   *
   * @default 0.
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#maxSurge
   */
  readonly maxSurge?: number;

  /**
   * The maximum number of nodes that can be simultaneously unavailable during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
   *
   * @default 0.
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#maxUnavailable
   */
  readonly maxUnavailable?: number;

  /**
   * Strategy used for node pool update. Strategy can only be one of BLUE_GREEN or SURGE. The default is value is SURGE.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#strategy
   */
  readonly strategy?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings(obj: ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blueGreenSettings': obj.blueGreenSettings?.map(y => toJson_ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings(y)),
    'maxSurge': obj.maxSurge,
    'maxUnavailable': obj.maxUnavailable,
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions
 */
export interface ClusterSpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions {
  /**
   * The scope of automatic upgrades to restrict in the exclusion window. One of: NO_UPGRADES | NO_MINOR_UPGRADES | NO_MINOR_OR_NODE_UPGRADES
   *
   * @schema ClusterSpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions#scope
   */
  readonly scope?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions(obj: ClusterSpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scope': obj.scope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig
 */
export interface ClusterSpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig {
  /**
   * Whether or not to enable GKE Auto-Monitoring. Supported values include: ALL, NONE.
   *
   * @schema ClusterSpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig#scope
   */
  readonly scope?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig(obj: ClusterSpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scope': obj.scope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderNetworkRefPolicyResolution
 */
export enum ClusterSpecForProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecForProviderNetworkRefPolicyResolve
 */
export enum ClusterSpecForProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderNetworkSelectorPolicyResolution
 */
export enum ClusterSpecForProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecForProviderNetworkSelectorPolicyResolve
 */
export enum ClusterSpecForProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig
 */
export interface ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig {
  /**
   * List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See how to configure for private container registries for more detail. Example:
   *
   * @schema ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#certificateAuthorityDomainConfig
   */
  readonly certificateAuthorityDomainConfig?: ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig[];

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(obj: ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityDomainConfig': obj.certificateAuthorityDomainConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(y)),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig
 */
export interface ClusterSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
  /**
   * Mode for how the GPU driver is installed.
   * Accepted values are:
   *
   * @schema ClusterSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig#gpuDriverVersion
   */
  readonly gpuDriverVersion?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(obj: ClusterSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuDriverVersion': obj.gpuDriverVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig
 */
export interface ClusterSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig {
  /**
   * The type of GPU sharing strategy to enable on the GPU node.
   * Accepted values are:
   *
   * @schema ClusterSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig#gpuSharingStrategy
   */
  readonly gpuSharingStrategy?: string;

  /**
   * The maximum number of containers that can share a GPU.
   *
   * @schema ClusterSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig#maxSharedClientsPerGpu
   */
  readonly maxSharedClientsPerGpu?: number;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig(obj: ClusterSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuSharingStrategy': obj.gpuSharingStrategy,
    'maxSharedClientsPerGpu': obj.maxSharedClientsPerGpu,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig
 */
export interface ClusterSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig {
  /**
   * Amount of 1G hugepages.
   *
   * @schema ClusterSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize1G
   */
  readonly hugepageSize1G?: number;

  /**
   * Amount of 2M hugepages.
   *
   * @schema ClusterSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize2M
   */
  readonly hugepageSize2M?: number;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig(obj: ClusterSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hugepageSize1G': obj.hugepageSize1G,
    'hugepageSize2M': obj.hugepageSize2M,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderNodeConfigServiceAccountRefPolicy
 */
export interface ClusterSpecForProviderNodeConfigServiceAccountRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderNodeConfigServiceAccountRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderNodeConfigServiceAccountRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecForProviderNodeConfigServiceAccountRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderNodeConfigServiceAccountRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigServiceAccountRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigServiceAccountRefPolicy(obj: ClusterSpecForProviderNodeConfigServiceAccountRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderNodeConfigServiceAccountSelectorPolicy
 */
export interface ClusterSpecForProviderNodeConfigServiceAccountSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderNodeConfigServiceAccountSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderNodeConfigServiceAccountSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecForProviderNodeConfigServiceAccountSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderNodeConfigServiceAccountSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigServiceAccountSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigServiceAccountSelectorPolicy(obj: ClusterSpecForProviderNodeConfigServiceAccountSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigSoleTenantConfigNodeAffinity
 */
export interface ClusterSpecForProviderNodeConfigSoleTenantConfigNodeAffinity {
  /**
   * Key for taint.
   *
   * @schema ClusterSpecForProviderNodeConfigSoleTenantConfigNodeAffinity#key
   */
  readonly key?: string;

  /**
   * Specifies affinity or anti-affinity. Accepted values are "IN" or "NOT_IN"
   *
   * @schema ClusterSpecForProviderNodeConfigSoleTenantConfigNodeAffinity#operator
   */
  readonly operator?: string;

  /**
   * name"
   *
   * @schema ClusterSpecForProviderNodeConfigSoleTenantConfigNodeAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigSoleTenantConfigNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigSoleTenantConfigNodeAffinity(obj: ClusterSpecForProviderNodeConfigSoleTenantConfigNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig
 */
export interface ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig {
  /**
   * Configuration for private container registries. There are two fields in this config:
   *
   * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig#privateRegistryAccessConfig
   */
  readonly privateRegistryAccessConfig?: ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig(obj: ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateRegistryAccessConfig': obj.privateRegistryAccessConfig?.map(y => toJson_ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig
 */
export interface ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig(obj: ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNotificationConfigPubsubFilter
 */
export interface ClusterSpecForProviderNotificationConfigPubsubFilter {
  /**
   * Can be used to filter what notifications are sent. Accepted values are UPGRADE_AVAILABLE_EVENT, UPGRADE_EVENT and SECURITY_BULLETIN_EVENT. See Filtering notifications for more details.
   *
   * @schema ClusterSpecForProviderNotificationConfigPubsubFilter#eventType
   */
  readonly eventType?: string[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderNotificationConfigPubsubFilter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNotificationConfigPubsubFilter(obj: ClusterSpecForProviderNotificationConfigPubsubFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventType': obj.eventType?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy
 */
export interface ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy(obj: ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy
 */
export interface ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy(obj: ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderSubnetworkRefPolicyResolution
 */
export enum ClusterSpecForProviderSubnetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecForProviderSubnetworkRefPolicyResolve
 */
export enum ClusterSpecForProviderSubnetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderSubnetworkSelectorPolicyResolution
 */
export enum ClusterSpecForProviderSubnetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecForProviderSubnetworkSelectorPolicyResolve
 */
export enum ClusterSpecForProviderSubnetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig
 */
export interface ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig(obj: ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig
 */
export interface ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig(obj: ClusterSpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement
 */
export interface ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement {
  /**
   * Specifies whether the node auto-repair is enabled for the node pool. If enabled, the nodes in this node pool will be monitored and, if they fail health checks too many times, an automatic repair action will be triggered.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement#autoRepair
   */
  readonly autoRepair?: boolean;

  /**
   * Specifies whether node auto-upgrade is enabled for the node pool. If enabled, node auto-upgrade helps keep the nodes in your node pool up to date with the latest release version of Kubernetes.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement#autoUpgrade
   */
  readonly autoUpgrade?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement(obj: ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoRepair': obj.autoRepair,
    'autoUpgrade': obj.autoUpgrade,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig
 */
export interface ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig {
  /**
   * Defines if the instance has integrity monitoring enabled.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * Defines if the instance has Secure Boot enabled.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig(obj: ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings
 */
export interface ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings {
  /**
   * Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#blueGreenSettings
   */
  readonly blueGreenSettings?: ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings[];

  /**
   * The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
   *
   * @default 0.
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#maxSurge
   */
  readonly maxSurge?: number;

  /**
   * The maximum number of nodes that can be simultaneously unavailable during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
   *
   * @default 0.
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#maxUnavailable
   */
  readonly maxUnavailable?: number;

  /**
   * Strategy used for node pool update. Strategy can only be one of BLUE_GREEN or SURGE. The default is value is SURGE.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#strategy
   */
  readonly strategy?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings(obj: ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blueGreenSettings': obj.blueGreenSettings?.map(y => toJson_ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings(y)),
    'maxSurge': obj.maxSurge,
    'maxUnavailable': obj.maxUnavailable,
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions
 */
export interface ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions {
  /**
   * The scope of automatic upgrades to restrict in the exclusion window. One of: NO_UPGRADES | NO_MINOR_UPGRADES | NO_MINOR_OR_NODE_UPGRADES
   *
   * @schema ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions#scope
   */
  readonly scope?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions(obj: ClusterSpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scope': obj.scope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig
 */
export interface ClusterSpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig {
  /**
   * Whether or not to enable GKE Auto-Monitoring. Supported values include: ALL, NONE.
   *
   * @schema ClusterSpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig#scope
   */
  readonly scope?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig(obj: ClusterSpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scope': obj.scope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecInitProviderNetworkRefPolicyResolution
 */
export enum ClusterSpecInitProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecInitProviderNetworkRefPolicyResolve
 */
export enum ClusterSpecInitProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecInitProviderNetworkSelectorPolicyResolution
 */
export enum ClusterSpecInitProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecInitProviderNetworkSelectorPolicyResolve
 */
export enum ClusterSpecInitProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig
 */
export interface ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig {
  /**
   * List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See how to configure for private container registries for more detail. Example:
   *
   * @schema ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#certificateAuthorityDomainConfig
   */
  readonly certificateAuthorityDomainConfig?: ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig[];

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(obj: ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityDomainConfig': obj.certificateAuthorityDomainConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(y)),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig
 */
export interface ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
  /**
   * Mode for how the GPU driver is installed.
   * Accepted values are:
   *
   * @schema ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig#gpuDriverVersion
   */
  readonly gpuDriverVersion?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(obj: ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuDriverVersion': obj.gpuDriverVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig
 */
export interface ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig {
  /**
   * The type of GPU sharing strategy to enable on the GPU node.
   * Accepted values are:
   *
   * @schema ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig#gpuSharingStrategy
   */
  readonly gpuSharingStrategy?: string;

  /**
   * The maximum number of containers that can share a GPU.
   *
   * @schema ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig#maxSharedClientsPerGpu
   */
  readonly maxSharedClientsPerGpu?: number;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig(obj: ClusterSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuSharingStrategy': obj.gpuSharingStrategy,
    'maxSharedClientsPerGpu': obj.maxSharedClientsPerGpu,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig
 */
export interface ClusterSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig {
  /**
   * Amount of 1G hugepages.
   *
   * @schema ClusterSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize1G
   */
  readonly hugepageSize1G?: number;

  /**
   * Amount of 2M hugepages.
   *
   * @schema ClusterSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize2M
   */
  readonly hugepageSize2M?: number;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig(obj: ClusterSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hugepageSize1G': obj.hugepageSize1G,
    'hugepageSize2M': obj.hugepageSize2M,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecInitProviderNodeConfigServiceAccountRefPolicy
 */
export interface ClusterSpecInitProviderNodeConfigServiceAccountRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecInitProviderNodeConfigServiceAccountRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecInitProviderNodeConfigServiceAccountRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecInitProviderNodeConfigServiceAccountRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecInitProviderNodeConfigServiceAccountRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigServiceAccountRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigServiceAccountRefPolicy(obj: ClusterSpecInitProviderNodeConfigServiceAccountRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecInitProviderNodeConfigServiceAccountSelectorPolicy
 */
export interface ClusterSpecInitProviderNodeConfigServiceAccountSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecInitProviderNodeConfigServiceAccountSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecInitProviderNodeConfigServiceAccountSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecInitProviderNodeConfigServiceAccountSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecInitProviderNodeConfigServiceAccountSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigServiceAccountSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigServiceAccountSelectorPolicy(obj: ClusterSpecInitProviderNodeConfigServiceAccountSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity
 */
export interface ClusterSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity {
  /**
   * Key for taint.
   *
   * @schema ClusterSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity#key
   */
  readonly key?: string;

  /**
   * Specifies affinity or anti-affinity. Accepted values are "IN" or "NOT_IN"
   *
   * @schema ClusterSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity#operator
   */
  readonly operator?: string;

  /**
   * name"
   *
   * @schema ClusterSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity(obj: ClusterSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig
 */
export interface ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig {
  /**
   * Configuration for private container registries. There are two fields in this config:
   *
   * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig#privateRegistryAccessConfig
   */
  readonly privateRegistryAccessConfig?: ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig(obj: ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateRegistryAccessConfig': obj.privateRegistryAccessConfig?.map(y => toJson_ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig
 */
export interface ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig(obj: ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNotificationConfigPubsubFilter
 */
export interface ClusterSpecInitProviderNotificationConfigPubsubFilter {
  /**
   * Can be used to filter what notifications are sent. Accepted values are UPGRADE_AVAILABLE_EVENT, UPGRADE_EVENT and SECURITY_BULLETIN_EVENT. See Filtering notifications for more details.
   *
   * @schema ClusterSpecInitProviderNotificationConfigPubsubFilter#eventType
   */
  readonly eventType?: string[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNotificationConfigPubsubFilter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNotificationConfigPubsubFilter(obj: ClusterSpecInitProviderNotificationConfigPubsubFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventType': obj.eventType?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy
 */
export interface ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy(obj: ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy
 */
export interface ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy(obj: ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecInitProviderSubnetworkRefPolicyResolution
 */
export enum ClusterSpecInitProviderSubnetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecInitProviderSubnetworkRefPolicyResolve
 */
export enum ClusterSpecInitProviderSubnetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecInitProviderSubnetworkSelectorPolicyResolution
 */
export enum ClusterSpecInitProviderSubnetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecInitProviderSubnetworkSelectorPolicyResolve
 */
export enum ClusterSpecInitProviderSubnetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings
 */
export interface ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings {
  /**
   * Time needed after draining entire blue pool. After this period, blue pool will be cleaned up. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings#nodePoolSoakDuration
   */
  readonly nodePoolSoakDuration?: string;

  /**
   * green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings#standardRolloutPolicy
   */
  readonly standardRolloutPolicy?: ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings(obj: ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodePoolSoakDuration': obj.nodePoolSoakDuration,
    'standardRolloutPolicy': obj.standardRolloutPolicy?.map(y => toJson_ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig
 */
export interface ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
  /**
   * @schema ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#fqdns
   */
  readonly fqdns?: string[];

  /**
   * @schema ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#gcpSecretManagerCertificateConfig
   */
  readonly gcpSecretManagerCertificateConfig?: ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(obj: ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fqdns': obj.fqdns?.map(y => y),
    'gcpSecretManagerCertificateConfig': obj.gcpSecretManagerCertificateConfig?.map(y => toJson_ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderNodeConfigServiceAccountRefPolicyResolution
 */
export enum ClusterSpecForProviderNodeConfigServiceAccountRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecForProviderNodeConfigServiceAccountRefPolicyResolve
 */
export enum ClusterSpecForProviderNodeConfigServiceAccountRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderNodeConfigServiceAccountSelectorPolicyResolution
 */
export enum ClusterSpecForProviderNodeConfigServiceAccountSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecForProviderNodeConfigServiceAccountSelectorPolicyResolve
 */
export enum ClusterSpecForProviderNodeConfigServiceAccountSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig
 */
export interface ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig {
  /**
   * List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See how to configure for private container registries for more detail. Example:
   *
   * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig#certificateAuthorityDomainConfig
   */
  readonly certificateAuthorityDomainConfig?: ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig[];

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig(obj: ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityDomainConfig': obj.certificateAuthorityDomainConfig?.map(y => toJson_ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(y)),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution
 */
export enum ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve
 */
export enum ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution
 */
export enum ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve
 */
export enum ClusterSpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings
 */
export interface ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings {
  /**
   * Time needed after draining entire blue pool. After this period, blue pool will be cleaned up. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings#nodePoolSoakDuration
   */
  readonly nodePoolSoakDuration?: string;

  /**
   * green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings#standardRolloutPolicy
   */
  readonly standardRolloutPolicy?: ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings(obj: ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodePoolSoakDuration': obj.nodePoolSoakDuration,
    'standardRolloutPolicy': obj.standardRolloutPolicy?.map(y => toJson_ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig
 */
export interface ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
  /**
   * @schema ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#fqdns
   */
  readonly fqdns?: string[];

  /**
   * @schema ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#gcpSecretManagerCertificateConfig
   */
  readonly gcpSecretManagerCertificateConfig?: ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(obj: ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fqdns': obj.fqdns?.map(y => y),
    'gcpSecretManagerCertificateConfig': obj.gcpSecretManagerCertificateConfig?.map(y => toJson_ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecInitProviderNodeConfigServiceAccountRefPolicyResolution
 */
export enum ClusterSpecInitProviderNodeConfigServiceAccountRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecInitProviderNodeConfigServiceAccountRefPolicyResolve
 */
export enum ClusterSpecInitProviderNodeConfigServiceAccountRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecInitProviderNodeConfigServiceAccountSelectorPolicyResolution
 */
export enum ClusterSpecInitProviderNodeConfigServiceAccountSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecInitProviderNodeConfigServiceAccountSelectorPolicyResolve
 */
export enum ClusterSpecInitProviderNodeConfigServiceAccountSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig
 */
export interface ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig {
  /**
   * List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See how to configure for private container registries for more detail. Example:
   *
   * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig#certificateAuthorityDomainConfig
   */
  readonly certificateAuthorityDomainConfig?: ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig[];

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig(obj: ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityDomainConfig': obj.certificateAuthorityDomainConfig?.map(y => toJson_ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(y)),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution
 */
export enum ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve
 */
export enum ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution
 */
export enum ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve
 */
export enum ClusterSpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy
 */
export interface ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
  /**
   * Number of blue nodes to drain in a batch. Only one of the batch_percentage or batch_node_count can be specified.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchNodeCount
   */
  readonly batchNodeCount?: number;

  /**
   * :  Percentage of the bool pool nodes to drain in a batch. The range of this field should be (0.0, 1.0). Only one of the batch_percentage or batch_node_count can be specified.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchPercentage
   */
  readonly batchPercentage?: number;

  /**
   * Soak time after each batch gets drained. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".`.
   *
   * @schema ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchSoakDuration
   */
  readonly batchSoakDuration?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(obj: ClusterSpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchNodeCount': obj.batchNodeCount,
    'batchPercentage': obj.batchPercentage,
    'batchSoakDuration': obj.batchSoakDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig
 */
export interface ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
  /**
   * @schema ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig#secretUri
   */
  readonly secretUri?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj: ClusterSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretUri': obj.secretUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig
 */
export interface ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
  /**
   * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#fqdns
   */
  readonly fqdns?: string[];

  /**
   * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#gcpSecretManagerCertificateConfig
   */
  readonly gcpSecretManagerCertificateConfig?: ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig[];
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(obj: ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fqdns': obj.fqdns?.map(y => y),
    'gcpSecretManagerCertificateConfig': obj.gcpSecretManagerCertificateConfig?.map(y => toJson_ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy
 */
export interface ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
  /**
   * Number of blue nodes to drain in a batch. Only one of the batch_percentage or batch_node_count can be specified.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchNodeCount
   */
  readonly batchNodeCount?: number;

  /**
   * :  Percentage of the bool pool nodes to drain in a batch. The range of this field should be (0.0, 1.0). Only one of the batch_percentage or batch_node_count can be specified.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchPercentage
   */
  readonly batchPercentage?: number;

  /**
   * Soak time after each batch gets drained. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".`.
   *
   * @schema ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchSoakDuration
   */
  readonly batchSoakDuration?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(obj: ClusterSpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchNodeCount': obj.batchNodeCount,
    'batchPercentage': obj.batchPercentage,
    'batchSoakDuration': obj.batchSoakDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig
 */
export interface ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
  /**
   * @schema ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig#secretUri
   */
  readonly secretUri?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj: ClusterSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretUri': obj.secretUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig
 */
export interface ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
  /**
   * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#fqdns
   */
  readonly fqdns?: string[];

  /**
   * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#gcpSecretManagerCertificateConfig
   */
  readonly gcpSecretManagerCertificateConfig?: ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig[];
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(obj: ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fqdns': obj.fqdns?.map(y => y),
    'gcpSecretManagerCertificateConfig': obj.gcpSecretManagerCertificateConfig?.map(y => toJson_ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig
 */
export interface ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
  /**
   * @schema ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig#secretUri
   */
  readonly secretUri?: string;
}

/**
 * Converts an object of type 'ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj: ClusterSpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretUri': obj.secretUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig
 */
export interface ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
  /**
   * @schema ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig#secretUri
   */
  readonly secretUri?: string;
}

/**
 * Converts an object of type 'ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj: ClusterSpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretUri': obj.secretUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * Cluster is the Schema for the Clusters API. Creates a Google Kubernetes Engine (GKE) cluster.
 *
 * @schema ClusterV1Beta2
 */
export class ClusterV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'container.gcp.upbound.io/v1beta2',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterV1Beta2Props): any {
    return {
      ...ClusterV1Beta2.GVK,
      ...toJson_ClusterV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ClusterV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterV1Beta2Props) {
    super(scope, id, {
      ...ClusterV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterV1Beta2.GVK,
      ...toJson_ClusterV1Beta2Props(resolved),
    };
  }
}

/**
 * Cluster is the Schema for the Clusters API. Creates a Google Kubernetes Engine (GKE) cluster.
 *
 * @schema ClusterV1Beta2
 */
export interface ClusterV1Beta2Props {
  /**
   * @schema ClusterV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of Cluster
   *
   * @schema ClusterV1Beta2#spec
   */
  readonly spec: ClusterV1Beta2Spec;
}

/**
 * Converts an object of type 'ClusterV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2Props(obj: ClusterV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterSpec defines the desired state of Cluster
 *
 * @schema ClusterV1Beta2Spec
 */
export interface ClusterV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterV1Beta2SpecDeletionPolicy;

  /**
   * @schema ClusterV1Beta2Spec#forProvider
   */
  readonly forProvider: ClusterV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ClusterV1Beta2Spec#initProvider
   */
  readonly initProvider?: ClusterV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: ClusterV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ClusterV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterV1Beta2SpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ClusterV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterV1Beta2SpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ClusterV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2Spec(obj: ClusterV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_ClusterV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_ClusterV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterV1Beta2SpecDeletionPolicy
 */
export enum ClusterV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterV1Beta2SpecForProvider
 */
export interface ClusterV1Beta2SpecForProvider {
  /**
   * The configuration for addons supported by GKE.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#addonsConfig
   */
  readonly addonsConfig?: ClusterV1Beta2SpecForProviderAddonsConfig;

  /**
   * Enable NET_ADMIN for the cluster. Defaults to
   * false. This field should only be enabled for Autopilot clusters (enable_autopilot
   * set to true).
   *
   * @default false. This field should only be enabled for Autopilot clusters (enable_autopilot
   * @schema ClusterV1Beta2SpecForProvider#allowNetAdmin
   */
  readonly allowNetAdmin?: boolean;

  /**
   * Configuration for anonymous authentication restrictions. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#anonymousAuthenticationConfig
   */
  readonly anonymousAuthenticationConfig?: ClusterV1Beta2SpecForProviderAnonymousAuthenticationConfig;

  /**
   * Configuration for the
   * Google Groups for GKE feature.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#authenticatorGroupsConfig
   */
  readonly authenticatorGroupsConfig?: ClusterV1Beta2SpecForProviderAuthenticatorGroupsConfig;

  /**
   * Configuration options for the Binary
   * Authorization feature. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#binaryAuthorization
   */
  readonly binaryAuthorization?: ClusterV1Beta2SpecForProviderBinaryAuthorization;

  /**
   * Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to
   * automatically adjust the size of the cluster and create/delete node pools based
   * on the current needs of the cluster's workload. See the
   * guide to using Node Auto-Provisioning
   * for more details. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#clusterAutoscaling
   */
  readonly clusterAutoscaling?: ClusterV1Beta2SpecForProviderClusterAutoscaling;

  /**
   * The IP address range of the Kubernetes pods
   * in this cluster in CIDR notation (e.g. 10.96.0.0/14). Leave blank to have one
   * automatically chosen or specify a /14 block in 10.0.0.0/8. This field will
   * default a new cluster to routes-based, where ip_allocation_policy is not defined.
   *
   * @schema ClusterV1Beta2SpecForProvider#clusterIpv4Cidr
   */
  readonly clusterIpv4Cidr?: string;

  /**
   * Configuration for Confidential Nodes feature. Structure is documented below documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#confidentialNodes
   */
  readonly confidentialNodes?: ClusterV1Beta2SpecForProviderConfidentialNodes;

  /**
   * Configuration for all of the cluster's control plane endpoints.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#controlPlaneEndpointsConfig
   */
  readonly controlPlaneEndpointsConfig?: ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfig;

  /**
   * Configuration for the
   * Cost Allocation feature.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#costManagementConfig
   */
  readonly costManagementConfig?: ClusterV1Beta2SpecForProviderCostManagementConfig;

  /**
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#databaseEncryption
   */
  readonly databaseEncryption?: ClusterV1Beta2SpecForProviderDatabaseEncryption;

  /**
   * The desired datapath provider for this cluster. This is set to LEGACY_DATAPATH by default, which uses the IPTables-based kube-proxy implementation. Set to ADVANCED_DATAPATH to enable Dataplane v2.
   *
   * @schema ClusterV1Beta2SpecForProvider#datapathProvider
   */
  readonly datapathProvider?: string;

  /**
   * The default maximum number of pods
   * per node in this cluster. This doesn't work on "routes-based" clusters, clusters
   * that don't have IP Aliasing enabled. See the official documentation
   * for more information.
   *
   * @schema ClusterV1Beta2SpecForProvider#defaultMaxPodsPerNode
   */
  readonly defaultMaxPodsPerNode?: number;

  /**
   * GKE SNAT DefaultSnatStatus contains the desired state of whether default sNAT should be disabled on the cluster, API doc. Structure is documented below
   *
   * @schema ClusterV1Beta2SpecForProvider#defaultSnatStatus
   */
  readonly defaultSnatStatus?: ClusterV1Beta2SpecForProviderDefaultSnatStatus;

  /**
   * @schema ClusterV1Beta2SpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * Description of the cluster.
   *
   * @schema ClusterV1Beta2SpecForProvider#description
   */
  readonly description?: string;

  /**
   * Disable L4 load balancer VPC firewalls to enable firewall policies.
   *
   * @schema ClusterV1Beta2SpecForProvider#disableL4LbFirewallReconciliation
   */
  readonly disableL4LbFirewallReconciliation?: boolean;

  /**
   * Configuration for Using Cloud DNS for GKE. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#dnsConfig
   */
  readonly dnsConfig?: ClusterV1Beta2SpecForProviderDnsConfig;

  /**
   * Enable Autopilot for this cluster. Defaults to false.
   * Note that when this option is enabled, certain features of Standard GKE are not available.
   * See the official documentation
   * for available features.
   *
   * @default false.
   * @schema ClusterV1Beta2SpecForProvider#enableAutopilot
   */
  readonly enableAutopilot?: boolean;

  /**
   * Whether CiliumClusterWideNetworkPolicy is enabled on this cluster. Defaults to false.
   *
   * @default false.
   * @schema ClusterV1Beta2SpecForProvider#enableCiliumClusterwideNetworkPolicy
   */
  readonly enableCiliumClusterwideNetworkPolicy?: boolean;

  /**
   * Whether FQDN Network Policy is enabled on this cluster. Users who enable this feature for existing Standard clusters must restart the GKE Dataplane V2 anetd DaemonSet after enabling it. See the Enable FQDN Network Policy in an existing cluster for more information.
   *
   * @schema ClusterV1Beta2SpecForProvider#enableFqdnNetworkPolicy
   */
  readonly enableFqdnNetworkPolicy?: boolean;

  /**
   * Whether Intra-node visibility is enabled for this cluster. This makes same node pod to pod traffic visible for VPC network.
   *
   * @schema ClusterV1Beta2SpecForProvider#enableIntranodeVisibility
   */
  readonly enableIntranodeVisibility?: boolean;

  /**
   * Configuration for Kubernetes Beta APIs.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#enableK8SBetaApis
   */
  readonly enableK8SBetaApis?: ClusterV1Beta2SpecForProviderEnableK8SBetaApis;

  /**
   * Whether to enable Kubernetes Alpha features for
   * this cluster. Note that when this option is enabled, the cluster cannot be upgraded
   * and will be automatically deleted after 30 days.
   *
   * @schema ClusterV1Beta2SpecForProvider#enableKubernetesAlpha
   */
  readonly enableKubernetesAlpha?: boolean;

  /**
   * Whether L4ILB Subsetting is enabled for this cluster.
   *
   * @schema ClusterV1Beta2SpecForProvider#enableL4IlbSubsetting
   */
  readonly enableL4IlbSubsetting?: boolean;

  /**
   * Whether the ABAC authorizer is enabled for this cluster.
   * When enabled, identities in the system, including service accounts, nodes, and controllers,
   * will have statically granted permissions beyond those provided by the RBAC configuration or IAM.
   * Defaults to false
   *
   * @default false
   * @schema ClusterV1Beta2SpecForProvider#enableLegacyAbac
   */
  readonly enableLegacyAbac?: boolean;

  /**
   * Whether multi-networking is enabled for this cluster.
   *
   * @schema ClusterV1Beta2SpecForProvider#enableMultiNetworking
   */
  readonly enableMultiNetworking?: boolean;

  /**
   * Enable Shielded Nodes features on all nodes in this cluster.  Defaults to true.
   *
   * @default true.
   * @schema ClusterV1Beta2SpecForProvider#enableShieldedNodes
   */
  readonly enableShieldedNodes?: boolean;

  /**
   * Whether to enable Cloud TPU resources in this cluster.
   * See the official documentation.
   *
   * @schema ClusterV1Beta2SpecForProvider#enableTpu
   */
  readonly enableTpu?: boolean;

  /**
   * Configuration for [Enterprise edition].(https://cloud.google.com/kubernetes-engine/enterprise/docs/concepts/gke-editions). Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#enterpriseConfig
   */
  readonly enterpriseConfig?: ClusterV1Beta2SpecForProviderEnterpriseConfig;

  /**
   * Fleet configuration for the cluster. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#fleet
   */
  readonly fleet?: ClusterV1Beta2SpecForProviderFleet;

  /**
   * Configuration for GKE Gateway API controller. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#gatewayApiConfig
   */
  readonly gatewayApiConfig?: ClusterV1Beta2SpecForProviderGatewayApiConfig;

  /**
   * Configuration options for the auto-upgrade patch type feature, which provide more control over the speed of automatic upgrades of your GKE clusters.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#gkeAutoUpgradeConfig
   */
  readonly gkeAutoUpgradeConfig?: ClusterV1Beta2SpecForProviderGkeAutoUpgradeConfig;

  /**
   * . Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#identityServiceConfig
   */
  readonly identityServiceConfig?: ClusterV1Beta2SpecForProviderIdentityServiceConfig;

  /**
   * Defines the config of in-transit encryption. Valid values are IN_TRANSIT_ENCRYPTION_DISABLED and IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT.
   *
   * @schema ClusterV1Beta2SpecForProvider#inTransitEncryptionConfig
   */
  readonly inTransitEncryptionConfig?: string;

  /**
   * The number of nodes to create in this
   * cluster's default node pool. In regional or multi-zonal clusters, this is the
   * number of nodes per zone. Must be set if node_pool is not set. If you're using
   * google_container_node_pool objects with no default node pool, you'll need to
   * set this to a value of at least 1, alongside setting
   * remove_default_node_pool to true.
   *
   * @schema ClusterV1Beta2SpecForProvider#initialNodeCount
   */
  readonly initialNodeCount?: number;

  /**
   * Configuration of cluster IP allocation for
   * VPC-native clusters. If this block is unset during creation, it will be set by the GKE backend.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#ipAllocationPolicy
   */
  readonly ipAllocationPolicy?: ClusterV1Beta2SpecForProviderIpAllocationPolicy;

  /**
   * The location (region or zone) in which the cluster
   * master will be created, as well as the default node location. If you specify a
   * zone (such as us-central1-a), the cluster will be a zonal cluster with a
   * single cluster master. If you specify a region (such as us-west1), the
   * cluster will be a regional cluster with multiple masters spread across zones in
   * the region, and with default node locations in those zones as well
   *
   * @schema ClusterV1Beta2SpecForProvider#location
   */
  readonly location: string;

  /**
   * Logging configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#loggingConfig
   */
  readonly loggingConfig?: ClusterV1Beta2SpecForProviderLoggingConfig;

  /**
   * The logging service that the cluster should
   * write logs to. Available options include logging.googleapis.com(Legacy Stackdriver),
   * logging.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Logging), and none. Defaults to logging.googleapis.com/kubernetes
   *
   * @default logging.googleapis.com/kubernetes
   * @schema ClusterV1Beta2SpecForProvider#loggingService
   */
  readonly loggingService?: string;

  /**
   * The maintenance policy to use for the cluster. Structure is
   * documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#maintenancePolicy
   */
  readonly maintenancePolicy?: ClusterV1Beta2SpecForProviderMaintenancePolicy;

  /**
   * The authentication information for accessing the
   * Kubernetes master. Some values in this block are only returned by the API if
   * your service account has permission to get credentials for your GKE cluster. If
   * you see an unexpected diff unsetting your client cert, ensure you have the
   * container.clusters.getCredentials permission.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#masterAuth
   */
  readonly masterAuth?: ClusterV1Beta2SpecForProviderMasterAuth;

  /**
   * The desired
   * configuration options for master authorized networks. Omit the
   * nested cidr_blocks attribute to disallow external access (except
   * the cluster node IPs, which GKE automatically whitelists).
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#masterAuthorizedNetworksConfig
   */
  readonly masterAuthorizedNetworksConfig?: ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfig;

  /**
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#meshCertificates
   */
  readonly meshCertificates?: ClusterV1Beta2SpecForProviderMeshCertificates;

  /**
   * The minimum version of the master. GKE
   * will auto-update the master to new versions, so this does not guarantee the
   * current master version--use the read-only master_version field to obtain that.
   * If unset, the cluster's version will be set by GKE to the version of the most recent
   * official release (which is not necessarily the latest version). If you intend to specify versions manually,
   * the docs
   * describe the various acceptable formats for this field.
   *
   * @schema ClusterV1Beta2SpecForProvider#minMasterVersion
   */
  readonly minMasterVersion?: string;

  /**
   * Monitoring configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#monitoringConfig
   */
  readonly monitoringConfig?: ClusterV1Beta2SpecForProviderMonitoringConfig;

  /**
   * The monitoring service that the cluster
   * should write metrics to.
   * Automatically send metrics from pods in the cluster to the Google Cloud Monitoring API.
   * VM metrics will be collected by Google Compute Engine regardless of this setting
   * Available options include
   * monitoring.googleapis.com(Legacy Stackdriver), monitoring.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Monitoring), and none.
   * Defaults to monitoring.googleapis.com/kubernetes
   *
   * @default monitoring.googleapis.com/kubernetes
   * @schema ClusterV1Beta2SpecForProvider#monitoringService
   */
  readonly monitoringService?: string;

  /**
   * The name or self_link of the Google Compute Engine
   * network to which the cluster is connected. For Shared VPC, set this to the self link of the
   * shared network.
   *
   * @schema ClusterV1Beta2SpecForProvider#network
   */
  readonly network?: string;

  /**
   * Network bandwidth tier configuration. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#networkPerformanceConfig
   */
  readonly networkPerformanceConfig?: ClusterV1Beta2SpecForProviderNetworkPerformanceConfig;

  /**
   * Configuration options for the
   * NetworkPolicy
   * feature. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#networkPolicy
   */
  readonly networkPolicy?: ClusterV1Beta2SpecForProviderNetworkPolicy;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema ClusterV1Beta2SpecForProvider#networkRef
   */
  readonly networkRef?: ClusterV1Beta2SpecForProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema ClusterV1Beta2SpecForProvider#networkSelector
   */
  readonly networkSelector?: ClusterV1Beta2SpecForProviderNetworkSelector;

  /**
   * Determines whether alias IPs or routes will be used for pod IPs in the cluster.
   * Options are VPC_NATIVE or ROUTES. VPC_NATIVE enables IP aliasing. Newly created clusters will default to VPC_NATIVE.
   *
   * @schema ClusterV1Beta2SpecForProvider#networkingMode
   */
  readonly networkingMode?: string;

  /**
   * Parameters used in creating the default node pool. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#nodeConfig
   */
  readonly nodeConfig?: ClusterV1Beta2SpecForProviderNodeConfig;

  /**
   * The list of zones in which the cluster's nodes
   * are located. Nodes must be in the region of their regional cluster or in the
   * same region as their cluster's zone for zonal clusters. If this is specified for
   * a zonal cluster, omit the cluster's zone.
   *
   * @schema ClusterV1Beta2SpecForProvider#nodeLocations
   */
  readonly nodeLocations?: string[];

  /**
   * Node pool configs that apply to auto-provisioned node pools in
   * autopilot clusters and
   * node auto-provisioning-enabled clusters. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#nodePoolAutoConfig
   */
  readonly nodePoolAutoConfig?: ClusterV1Beta2SpecForProviderNodePoolAutoConfig;

  /**
   * Default NodePool settings for the entire cluster. These settings are overridden if specified on the specific NodePool object. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#nodePoolDefaults
   */
  readonly nodePoolDefaults?: ClusterV1Beta2SpecForProviderNodePoolDefaults;

  /**
   * The Kubernetes version on the nodes. Must either be unset
   * or set to the same value as min_master_version on create. Defaults to the default
   * version set by GKE which is not necessarily the latest version. This only affects
   * nodes in the default node pool.
   * To update nodes in other node pools, use the version attribute on the node pool.
   *
   * @default the default
   * @schema ClusterV1Beta2SpecForProvider#nodeVersion
   */
  readonly nodeVersion?: string;

  /**
   * Configuration for the cluster upgrade notifications feature. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#notificationConfig
   */
  readonly notificationConfig?: ClusterV1Beta2SpecForProviderNotificationConfig;

  /**
   * Configuration for the
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#podAutoscaling
   */
  readonly podAutoscaling?: ClusterV1Beta2SpecForProviderPodAutoscaling;

  /**
   * Configuration for private clusters,
   * clusters with private nodes. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#privateClusterConfig
   */
  readonly privateClusterConfig?: ClusterV1Beta2SpecForProviderPrivateClusterConfig;

  /**
   * The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4).
   *
   * @schema ClusterV1Beta2SpecForProvider#privateIpv6GoogleAccess
   */
  readonly privateIpv6GoogleAccess?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema ClusterV1Beta2SpecForProvider#project
   */
  readonly project?: string;

  /**
   * RBACBindingConfig allows user to restrict ClusterRoleBindings an RoleBindings that can be created. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#rbacBindingConfig
   */
  readonly rbacBindingConfig?: ClusterV1Beta2SpecForProviderRbacBindingConfig;

  /**
   * Configuration options for the Release channel
   * feature, which provide more control over automatic upgrades of your GKE clusters.
   * When updating this field, GKE imposes specific version requirements. See
   * Selecting a new release channel
   * for more details; the google_container_engine_versions datasource can provide
   * the default version for a channel. Instead, use the "UNSPECIFIED"
   * channel. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#releaseChannel
   */
  readonly releaseChannel?: ClusterV1Beta2SpecForProviderReleaseChannel;

  /**
   * If true, deletes the default node
   * pool upon cluster creation. If you're using google_container_node_pool
   * resources with no default node pool, this should be set to true, alongside
   * setting initial_node_count to at least 1.
   *
   * @schema ClusterV1Beta2SpecForProvider#removeDefaultNodePool
   */
  readonly removeDefaultNodePool?: boolean;

  /**
   * The GCE resource labels (a map of key/value pairs) to be applied to the cluster.
   *
   * @schema ClusterV1Beta2SpecForProvider#resourceLabels
   */
  readonly resourceLabels?: { [key: string]: string };

  /**
   * Configuration for the
   * ResourceUsageExportConfig feature.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#resourceUsageExportConfig
   */
  readonly resourceUsageExportConfig?: ClusterV1Beta2SpecForProviderResourceUsageExportConfig;

  /**
   * Configuration for the
   * SecretManagerConfig feature.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#secretManagerConfig
   */
  readonly secretManagerConfig?: ClusterV1Beta2SpecForProviderSecretManagerConfig;

  /**
   * Enable/Disable Security Posture API features for the cluster. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#securityPostureConfig
   */
  readonly securityPostureConfig?: ClusterV1Beta2SpecForProviderSecurityPostureConfig;

  /**
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#serviceExternalIpsConfig
   */
  readonly serviceExternalIpsConfig?: ClusterV1Beta2SpecForProviderServiceExternalIpsConfig;

  /**
   * The name or self_link of the Google Compute Engine
   * subnetwork in which the cluster's instances are launched.
   *
   * @schema ClusterV1Beta2SpecForProvider#subnetwork
   */
  readonly subnetwork?: string;

  /**
   * Reference to a Subnetwork in compute to populate subnetwork.
   *
   * @schema ClusterV1Beta2SpecForProvider#subnetworkRef
   */
  readonly subnetworkRef?: ClusterV1Beta2SpecForProviderSubnetworkRef;

  /**
   * Selector for a Subnetwork in compute to populate subnetwork.
   *
   * @schema ClusterV1Beta2SpecForProvider#subnetworkSelector
   */
  readonly subnetworkSelector?: ClusterV1Beta2SpecForProviderSubnetworkSelector;

  /**
   * The custom keys configuration of the cluster Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#userManagedKeysConfig
   */
  readonly userManagedKeysConfig?: ClusterV1Beta2SpecForProviderUserManagedKeysConfig;

  /**
   * Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#verticalPodAutoscaling
   */
  readonly verticalPodAutoscaling?: ClusterV1Beta2SpecForProviderVerticalPodAutoscaling;

  /**
   * Workload Identity allows Kubernetes service accounts to act as a user-managed
   * Google IAM Service Account.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProvider#workloadIdentityConfig
   */
  readonly workloadIdentityConfig?: ClusterV1Beta2SpecForProviderWorkloadIdentityConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProvider(obj: ClusterV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addonsConfig': toJson_ClusterV1Beta2SpecForProviderAddonsConfig(obj.addonsConfig),
    'allowNetAdmin': obj.allowNetAdmin,
    'anonymousAuthenticationConfig': toJson_ClusterV1Beta2SpecForProviderAnonymousAuthenticationConfig(obj.anonymousAuthenticationConfig),
    'authenticatorGroupsConfig': toJson_ClusterV1Beta2SpecForProviderAuthenticatorGroupsConfig(obj.authenticatorGroupsConfig),
    'binaryAuthorization': toJson_ClusterV1Beta2SpecForProviderBinaryAuthorization(obj.binaryAuthorization),
    'clusterAutoscaling': toJson_ClusterV1Beta2SpecForProviderClusterAutoscaling(obj.clusterAutoscaling),
    'clusterIpv4Cidr': obj.clusterIpv4Cidr,
    'confidentialNodes': toJson_ClusterV1Beta2SpecForProviderConfidentialNodes(obj.confidentialNodes),
    'controlPlaneEndpointsConfig': toJson_ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfig(obj.controlPlaneEndpointsConfig),
    'costManagementConfig': toJson_ClusterV1Beta2SpecForProviderCostManagementConfig(obj.costManagementConfig),
    'databaseEncryption': toJson_ClusterV1Beta2SpecForProviderDatabaseEncryption(obj.databaseEncryption),
    'datapathProvider': obj.datapathProvider,
    'defaultMaxPodsPerNode': obj.defaultMaxPodsPerNode,
    'defaultSnatStatus': toJson_ClusterV1Beta2SpecForProviderDefaultSnatStatus(obj.defaultSnatStatus),
    'deletionProtection': obj.deletionProtection,
    'description': obj.description,
    'disableL4LbFirewallReconciliation': obj.disableL4LbFirewallReconciliation,
    'dnsConfig': toJson_ClusterV1Beta2SpecForProviderDnsConfig(obj.dnsConfig),
    'enableAutopilot': obj.enableAutopilot,
    'enableCiliumClusterwideNetworkPolicy': obj.enableCiliumClusterwideNetworkPolicy,
    'enableFqdnNetworkPolicy': obj.enableFqdnNetworkPolicy,
    'enableIntranodeVisibility': obj.enableIntranodeVisibility,
    'enableK8SBetaApis': toJson_ClusterV1Beta2SpecForProviderEnableK8SBetaApis(obj.enableK8SBetaApis),
    'enableKubernetesAlpha': obj.enableKubernetesAlpha,
    'enableL4IlbSubsetting': obj.enableL4IlbSubsetting,
    'enableLegacyAbac': obj.enableLegacyAbac,
    'enableMultiNetworking': obj.enableMultiNetworking,
    'enableShieldedNodes': obj.enableShieldedNodes,
    'enableTpu': obj.enableTpu,
    'enterpriseConfig': toJson_ClusterV1Beta2SpecForProviderEnterpriseConfig(obj.enterpriseConfig),
    'fleet': toJson_ClusterV1Beta2SpecForProviderFleet(obj.fleet),
    'gatewayApiConfig': toJson_ClusterV1Beta2SpecForProviderGatewayApiConfig(obj.gatewayApiConfig),
    'gkeAutoUpgradeConfig': toJson_ClusterV1Beta2SpecForProviderGkeAutoUpgradeConfig(obj.gkeAutoUpgradeConfig),
    'identityServiceConfig': toJson_ClusterV1Beta2SpecForProviderIdentityServiceConfig(obj.identityServiceConfig),
    'inTransitEncryptionConfig': obj.inTransitEncryptionConfig,
    'initialNodeCount': obj.initialNodeCount,
    'ipAllocationPolicy': toJson_ClusterV1Beta2SpecForProviderIpAllocationPolicy(obj.ipAllocationPolicy),
    'location': obj.location,
    'loggingConfig': toJson_ClusterV1Beta2SpecForProviderLoggingConfig(obj.loggingConfig),
    'loggingService': obj.loggingService,
    'maintenancePolicy': toJson_ClusterV1Beta2SpecForProviderMaintenancePolicy(obj.maintenancePolicy),
    'masterAuth': toJson_ClusterV1Beta2SpecForProviderMasterAuth(obj.masterAuth),
    'masterAuthorizedNetworksConfig': toJson_ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfig(obj.masterAuthorizedNetworksConfig),
    'meshCertificates': toJson_ClusterV1Beta2SpecForProviderMeshCertificates(obj.meshCertificates),
    'minMasterVersion': obj.minMasterVersion,
    'monitoringConfig': toJson_ClusterV1Beta2SpecForProviderMonitoringConfig(obj.monitoringConfig),
    'monitoringService': obj.monitoringService,
    'network': obj.network,
    'networkPerformanceConfig': toJson_ClusterV1Beta2SpecForProviderNetworkPerformanceConfig(obj.networkPerformanceConfig),
    'networkPolicy': toJson_ClusterV1Beta2SpecForProviderNetworkPolicy(obj.networkPolicy),
    'networkRef': toJson_ClusterV1Beta2SpecForProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_ClusterV1Beta2SpecForProviderNetworkSelector(obj.networkSelector),
    'networkingMode': obj.networkingMode,
    'nodeConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfig(obj.nodeConfig),
    'nodeLocations': obj.nodeLocations?.map(y => y),
    'nodePoolAutoConfig': toJson_ClusterV1Beta2SpecForProviderNodePoolAutoConfig(obj.nodePoolAutoConfig),
    'nodePoolDefaults': toJson_ClusterV1Beta2SpecForProviderNodePoolDefaults(obj.nodePoolDefaults),
    'nodeVersion': obj.nodeVersion,
    'notificationConfig': toJson_ClusterV1Beta2SpecForProviderNotificationConfig(obj.notificationConfig),
    'podAutoscaling': toJson_ClusterV1Beta2SpecForProviderPodAutoscaling(obj.podAutoscaling),
    'privateClusterConfig': toJson_ClusterV1Beta2SpecForProviderPrivateClusterConfig(obj.privateClusterConfig),
    'privateIpv6GoogleAccess': obj.privateIpv6GoogleAccess,
    'project': obj.project,
    'rbacBindingConfig': toJson_ClusterV1Beta2SpecForProviderRbacBindingConfig(obj.rbacBindingConfig),
    'releaseChannel': toJson_ClusterV1Beta2SpecForProviderReleaseChannel(obj.releaseChannel),
    'removeDefaultNodePool': obj.removeDefaultNodePool,
    'resourceLabels': ((obj.resourceLabels) === undefined) ? undefined : (Object.entries(obj.resourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceUsageExportConfig': toJson_ClusterV1Beta2SpecForProviderResourceUsageExportConfig(obj.resourceUsageExportConfig),
    'secretManagerConfig': toJson_ClusterV1Beta2SpecForProviderSecretManagerConfig(obj.secretManagerConfig),
    'securityPostureConfig': toJson_ClusterV1Beta2SpecForProviderSecurityPostureConfig(obj.securityPostureConfig),
    'serviceExternalIpsConfig': toJson_ClusterV1Beta2SpecForProviderServiceExternalIpsConfig(obj.serviceExternalIpsConfig),
    'subnetwork': obj.subnetwork,
    'subnetworkRef': toJson_ClusterV1Beta2SpecForProviderSubnetworkRef(obj.subnetworkRef),
    'subnetworkSelector': toJson_ClusterV1Beta2SpecForProviderSubnetworkSelector(obj.subnetworkSelector),
    'userManagedKeysConfig': toJson_ClusterV1Beta2SpecForProviderUserManagedKeysConfig(obj.userManagedKeysConfig),
    'verticalPodAutoscaling': toJson_ClusterV1Beta2SpecForProviderVerticalPodAutoscaling(obj.verticalPodAutoscaling),
    'workloadIdentityConfig': toJson_ClusterV1Beta2SpecForProviderWorkloadIdentityConfig(obj.workloadIdentityConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ClusterV1Beta2SpecInitProvider
 */
export interface ClusterV1Beta2SpecInitProvider {
  /**
   * The configuration for addons supported by GKE.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#addonsConfig
   */
  readonly addonsConfig?: ClusterV1Beta2SpecInitProviderAddonsConfig;

  /**
   * Enable NET_ADMIN for the cluster. Defaults to
   * false. This field should only be enabled for Autopilot clusters (enable_autopilot
   * set to true).
   *
   * @default false. This field should only be enabled for Autopilot clusters (enable_autopilot
   * @schema ClusterV1Beta2SpecInitProvider#allowNetAdmin
   */
  readonly allowNetAdmin?: boolean;

  /**
   * Configuration for anonymous authentication restrictions. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#anonymousAuthenticationConfig
   */
  readonly anonymousAuthenticationConfig?: ClusterV1Beta2SpecInitProviderAnonymousAuthenticationConfig;

  /**
   * Configuration for the
   * Google Groups for GKE feature.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#authenticatorGroupsConfig
   */
  readonly authenticatorGroupsConfig?: ClusterV1Beta2SpecInitProviderAuthenticatorGroupsConfig;

  /**
   * Configuration options for the Binary
   * Authorization feature. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#binaryAuthorization
   */
  readonly binaryAuthorization?: ClusterV1Beta2SpecInitProviderBinaryAuthorization;

  /**
   * Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to
   * automatically adjust the size of the cluster and create/delete node pools based
   * on the current needs of the cluster's workload. See the
   * guide to using Node Auto-Provisioning
   * for more details. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#clusterAutoscaling
   */
  readonly clusterAutoscaling?: ClusterV1Beta2SpecInitProviderClusterAutoscaling;

  /**
   * The IP address range of the Kubernetes pods
   * in this cluster in CIDR notation (e.g. 10.96.0.0/14). Leave blank to have one
   * automatically chosen or specify a /14 block in 10.0.0.0/8. This field will
   * default a new cluster to routes-based, where ip_allocation_policy is not defined.
   *
   * @schema ClusterV1Beta2SpecInitProvider#clusterIpv4Cidr
   */
  readonly clusterIpv4Cidr?: string;

  /**
   * Configuration for Confidential Nodes feature. Structure is documented below documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#confidentialNodes
   */
  readonly confidentialNodes?: ClusterV1Beta2SpecInitProviderConfidentialNodes;

  /**
   * Configuration for all of the cluster's control plane endpoints.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#controlPlaneEndpointsConfig
   */
  readonly controlPlaneEndpointsConfig?: ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfig;

  /**
   * Configuration for the
   * Cost Allocation feature.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#costManagementConfig
   */
  readonly costManagementConfig?: ClusterV1Beta2SpecInitProviderCostManagementConfig;

  /**
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#databaseEncryption
   */
  readonly databaseEncryption?: ClusterV1Beta2SpecInitProviderDatabaseEncryption;

  /**
   * The desired datapath provider for this cluster. This is set to LEGACY_DATAPATH by default, which uses the IPTables-based kube-proxy implementation. Set to ADVANCED_DATAPATH to enable Dataplane v2.
   *
   * @schema ClusterV1Beta2SpecInitProvider#datapathProvider
   */
  readonly datapathProvider?: string;

  /**
   * The default maximum number of pods
   * per node in this cluster. This doesn't work on "routes-based" clusters, clusters
   * that don't have IP Aliasing enabled. See the official documentation
   * for more information.
   *
   * @schema ClusterV1Beta2SpecInitProvider#defaultMaxPodsPerNode
   */
  readonly defaultMaxPodsPerNode?: number;

  /**
   * GKE SNAT DefaultSnatStatus contains the desired state of whether default sNAT should be disabled on the cluster, API doc. Structure is documented below
   *
   * @schema ClusterV1Beta2SpecInitProvider#defaultSnatStatus
   */
  readonly defaultSnatStatus?: ClusterV1Beta2SpecInitProviderDefaultSnatStatus;

  /**
   * @schema ClusterV1Beta2SpecInitProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * Description of the cluster.
   *
   * @schema ClusterV1Beta2SpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Disable L4 load balancer VPC firewalls to enable firewall policies.
   *
   * @schema ClusterV1Beta2SpecInitProvider#disableL4LbFirewallReconciliation
   */
  readonly disableL4LbFirewallReconciliation?: boolean;

  /**
   * Configuration for Using Cloud DNS for GKE. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#dnsConfig
   */
  readonly dnsConfig?: ClusterV1Beta2SpecInitProviderDnsConfig;

  /**
   * Enable Autopilot for this cluster. Defaults to false.
   * Note that when this option is enabled, certain features of Standard GKE are not available.
   * See the official documentation
   * for available features.
   *
   * @default false.
   * @schema ClusterV1Beta2SpecInitProvider#enableAutopilot
   */
  readonly enableAutopilot?: boolean;

  /**
   * Whether CiliumClusterWideNetworkPolicy is enabled on this cluster. Defaults to false.
   *
   * @default false.
   * @schema ClusterV1Beta2SpecInitProvider#enableCiliumClusterwideNetworkPolicy
   */
  readonly enableCiliumClusterwideNetworkPolicy?: boolean;

  /**
   * Whether FQDN Network Policy is enabled on this cluster. Users who enable this feature for existing Standard clusters must restart the GKE Dataplane V2 anetd DaemonSet after enabling it. See the Enable FQDN Network Policy in an existing cluster for more information.
   *
   * @schema ClusterV1Beta2SpecInitProvider#enableFqdnNetworkPolicy
   */
  readonly enableFqdnNetworkPolicy?: boolean;

  /**
   * Whether Intra-node visibility is enabled for this cluster. This makes same node pod to pod traffic visible for VPC network.
   *
   * @schema ClusterV1Beta2SpecInitProvider#enableIntranodeVisibility
   */
  readonly enableIntranodeVisibility?: boolean;

  /**
   * Configuration for Kubernetes Beta APIs.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#enableK8SBetaApis
   */
  readonly enableK8SBetaApis?: ClusterV1Beta2SpecInitProviderEnableK8SBetaApis;

  /**
   * Whether to enable Kubernetes Alpha features for
   * this cluster. Note that when this option is enabled, the cluster cannot be upgraded
   * and will be automatically deleted after 30 days.
   *
   * @schema ClusterV1Beta2SpecInitProvider#enableKubernetesAlpha
   */
  readonly enableKubernetesAlpha?: boolean;

  /**
   * Whether L4ILB Subsetting is enabled for this cluster.
   *
   * @schema ClusterV1Beta2SpecInitProvider#enableL4IlbSubsetting
   */
  readonly enableL4IlbSubsetting?: boolean;

  /**
   * Whether the ABAC authorizer is enabled for this cluster.
   * When enabled, identities in the system, including service accounts, nodes, and controllers,
   * will have statically granted permissions beyond those provided by the RBAC configuration or IAM.
   * Defaults to false
   *
   * @default false
   * @schema ClusterV1Beta2SpecInitProvider#enableLegacyAbac
   */
  readonly enableLegacyAbac?: boolean;

  /**
   * Whether multi-networking is enabled for this cluster.
   *
   * @schema ClusterV1Beta2SpecInitProvider#enableMultiNetworking
   */
  readonly enableMultiNetworking?: boolean;

  /**
   * Enable Shielded Nodes features on all nodes in this cluster.  Defaults to true.
   *
   * @default true.
   * @schema ClusterV1Beta2SpecInitProvider#enableShieldedNodes
   */
  readonly enableShieldedNodes?: boolean;

  /**
   * Whether to enable Cloud TPU resources in this cluster.
   * See the official documentation.
   *
   * @schema ClusterV1Beta2SpecInitProvider#enableTpu
   */
  readonly enableTpu?: boolean;

  /**
   * Configuration for [Enterprise edition].(https://cloud.google.com/kubernetes-engine/enterprise/docs/concepts/gke-editions). Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#enterpriseConfig
   */
  readonly enterpriseConfig?: ClusterV1Beta2SpecInitProviderEnterpriseConfig;

  /**
   * Fleet configuration for the cluster. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#fleet
   */
  readonly fleet?: ClusterV1Beta2SpecInitProviderFleet;

  /**
   * Configuration for GKE Gateway API controller. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#gatewayApiConfig
   */
  readonly gatewayApiConfig?: ClusterV1Beta2SpecInitProviderGatewayApiConfig;

  /**
   * Configuration options for the auto-upgrade patch type feature, which provide more control over the speed of automatic upgrades of your GKE clusters.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#gkeAutoUpgradeConfig
   */
  readonly gkeAutoUpgradeConfig?: ClusterV1Beta2SpecInitProviderGkeAutoUpgradeConfig;

  /**
   * . Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#identityServiceConfig
   */
  readonly identityServiceConfig?: ClusterV1Beta2SpecInitProviderIdentityServiceConfig;

  /**
   * Defines the config of in-transit encryption. Valid values are IN_TRANSIT_ENCRYPTION_DISABLED and IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT.
   *
   * @schema ClusterV1Beta2SpecInitProvider#inTransitEncryptionConfig
   */
  readonly inTransitEncryptionConfig?: string;

  /**
   * The number of nodes to create in this
   * cluster's default node pool. In regional or multi-zonal clusters, this is the
   * number of nodes per zone. Must be set if node_pool is not set. If you're using
   * google_container_node_pool objects with no default node pool, you'll need to
   * set this to a value of at least 1, alongside setting
   * remove_default_node_pool to true.
   *
   * @schema ClusterV1Beta2SpecInitProvider#initialNodeCount
   */
  readonly initialNodeCount?: number;

  /**
   * Configuration of cluster IP allocation for
   * VPC-native clusters. If this block is unset during creation, it will be set by the GKE backend.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#ipAllocationPolicy
   */
  readonly ipAllocationPolicy?: ClusterV1Beta2SpecInitProviderIpAllocationPolicy;

  /**
   * Logging configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#loggingConfig
   */
  readonly loggingConfig?: ClusterV1Beta2SpecInitProviderLoggingConfig;

  /**
   * The logging service that the cluster should
   * write logs to. Available options include logging.googleapis.com(Legacy Stackdriver),
   * logging.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Logging), and none. Defaults to logging.googleapis.com/kubernetes
   *
   * @default logging.googleapis.com/kubernetes
   * @schema ClusterV1Beta2SpecInitProvider#loggingService
   */
  readonly loggingService?: string;

  /**
   * The maintenance policy to use for the cluster. Structure is
   * documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#maintenancePolicy
   */
  readonly maintenancePolicy?: ClusterV1Beta2SpecInitProviderMaintenancePolicy;

  /**
   * The authentication information for accessing the
   * Kubernetes master. Some values in this block are only returned by the API if
   * your service account has permission to get credentials for your GKE cluster. If
   * you see an unexpected diff unsetting your client cert, ensure you have the
   * container.clusters.getCredentials permission.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#masterAuth
   */
  readonly masterAuth?: ClusterV1Beta2SpecInitProviderMasterAuth;

  /**
   * The desired
   * configuration options for master authorized networks. Omit the
   * nested cidr_blocks attribute to disallow external access (except
   * the cluster node IPs, which GKE automatically whitelists).
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#masterAuthorizedNetworksConfig
   */
  readonly masterAuthorizedNetworksConfig?: ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfig;

  /**
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#meshCertificates
   */
  readonly meshCertificates?: ClusterV1Beta2SpecInitProviderMeshCertificates;

  /**
   * The minimum version of the master. GKE
   * will auto-update the master to new versions, so this does not guarantee the
   * current master version--use the read-only master_version field to obtain that.
   * If unset, the cluster's version will be set by GKE to the version of the most recent
   * official release (which is not necessarily the latest version). If you intend to specify versions manually,
   * the docs
   * describe the various acceptable formats for this field.
   *
   * @schema ClusterV1Beta2SpecInitProvider#minMasterVersion
   */
  readonly minMasterVersion?: string;

  /**
   * Monitoring configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#monitoringConfig
   */
  readonly monitoringConfig?: ClusterV1Beta2SpecInitProviderMonitoringConfig;

  /**
   * The monitoring service that the cluster
   * should write metrics to.
   * Automatically send metrics from pods in the cluster to the Google Cloud Monitoring API.
   * VM metrics will be collected by Google Compute Engine regardless of this setting
   * Available options include
   * monitoring.googleapis.com(Legacy Stackdriver), monitoring.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Monitoring), and none.
   * Defaults to monitoring.googleapis.com/kubernetes
   *
   * @default monitoring.googleapis.com/kubernetes
   * @schema ClusterV1Beta2SpecInitProvider#monitoringService
   */
  readonly monitoringService?: string;

  /**
   * The name or self_link of the Google Compute Engine
   * network to which the cluster is connected. For Shared VPC, set this to the self link of the
   * shared network.
   *
   * @schema ClusterV1Beta2SpecInitProvider#network
   */
  readonly network?: string;

  /**
   * Network bandwidth tier configuration. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#networkPerformanceConfig
   */
  readonly networkPerformanceConfig?: ClusterV1Beta2SpecInitProviderNetworkPerformanceConfig;

  /**
   * Configuration options for the
   * NetworkPolicy
   * feature. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#networkPolicy
   */
  readonly networkPolicy?: ClusterV1Beta2SpecInitProviderNetworkPolicy;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema ClusterV1Beta2SpecInitProvider#networkRef
   */
  readonly networkRef?: ClusterV1Beta2SpecInitProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema ClusterV1Beta2SpecInitProvider#networkSelector
   */
  readonly networkSelector?: ClusterV1Beta2SpecInitProviderNetworkSelector;

  /**
   * Determines whether alias IPs or routes will be used for pod IPs in the cluster.
   * Options are VPC_NATIVE or ROUTES. VPC_NATIVE enables IP aliasing. Newly created clusters will default to VPC_NATIVE.
   *
   * @schema ClusterV1Beta2SpecInitProvider#networkingMode
   */
  readonly networkingMode?: string;

  /**
   * Parameters used in creating the default node pool. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#nodeConfig
   */
  readonly nodeConfig?: ClusterV1Beta2SpecInitProviderNodeConfig;

  /**
   * The list of zones in which the cluster's nodes
   * are located. Nodes must be in the region of their regional cluster or in the
   * same region as their cluster's zone for zonal clusters. If this is specified for
   * a zonal cluster, omit the cluster's zone.
   *
   * @schema ClusterV1Beta2SpecInitProvider#nodeLocations
   */
  readonly nodeLocations?: string[];

  /**
   * Node pool configs that apply to auto-provisioned node pools in
   * autopilot clusters and
   * node auto-provisioning-enabled clusters. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#nodePoolAutoConfig
   */
  readonly nodePoolAutoConfig?: ClusterV1Beta2SpecInitProviderNodePoolAutoConfig;

  /**
   * Default NodePool settings for the entire cluster. These settings are overridden if specified on the specific NodePool object. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#nodePoolDefaults
   */
  readonly nodePoolDefaults?: ClusterV1Beta2SpecInitProviderNodePoolDefaults;

  /**
   * The Kubernetes version on the nodes. Must either be unset
   * or set to the same value as min_master_version on create. Defaults to the default
   * version set by GKE which is not necessarily the latest version. This only affects
   * nodes in the default node pool.
   * To update nodes in other node pools, use the version attribute on the node pool.
   *
   * @default the default
   * @schema ClusterV1Beta2SpecInitProvider#nodeVersion
   */
  readonly nodeVersion?: string;

  /**
   * Configuration for the cluster upgrade notifications feature. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#notificationConfig
   */
  readonly notificationConfig?: ClusterV1Beta2SpecInitProviderNotificationConfig;

  /**
   * Configuration for the
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#podAutoscaling
   */
  readonly podAutoscaling?: ClusterV1Beta2SpecInitProviderPodAutoscaling;

  /**
   * Configuration for private clusters,
   * clusters with private nodes. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#privateClusterConfig
   */
  readonly privateClusterConfig?: ClusterV1Beta2SpecInitProviderPrivateClusterConfig;

  /**
   * The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4).
   *
   * @schema ClusterV1Beta2SpecInitProvider#privateIpv6GoogleAccess
   */
  readonly privateIpv6GoogleAccess?: string;

  /**
   * The ID of the project in which the resource belongs. If it
   * is not provided, the provider project is used.
   *
   * @schema ClusterV1Beta2SpecInitProvider#project
   */
  readonly project?: string;

  /**
   * RBACBindingConfig allows user to restrict ClusterRoleBindings an RoleBindings that can be created. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#rbacBindingConfig
   */
  readonly rbacBindingConfig?: ClusterV1Beta2SpecInitProviderRbacBindingConfig;

  /**
   * Configuration options for the Release channel
   * feature, which provide more control over automatic upgrades of your GKE clusters.
   * When updating this field, GKE imposes specific version requirements. See
   * Selecting a new release channel
   * for more details; the google_container_engine_versions datasource can provide
   * the default version for a channel. Instead, use the "UNSPECIFIED"
   * channel. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#releaseChannel
   */
  readonly releaseChannel?: ClusterV1Beta2SpecInitProviderReleaseChannel;

  /**
   * If true, deletes the default node
   * pool upon cluster creation. If you're using google_container_node_pool
   * resources with no default node pool, this should be set to true, alongside
   * setting initial_node_count to at least 1.
   *
   * @schema ClusterV1Beta2SpecInitProvider#removeDefaultNodePool
   */
  readonly removeDefaultNodePool?: boolean;

  /**
   * The GCE resource labels (a map of key/value pairs) to be applied to the cluster.
   *
   * @schema ClusterV1Beta2SpecInitProvider#resourceLabels
   */
  readonly resourceLabels?: { [key: string]: string };

  /**
   * Configuration for the
   * ResourceUsageExportConfig feature.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#resourceUsageExportConfig
   */
  readonly resourceUsageExportConfig?: ClusterV1Beta2SpecInitProviderResourceUsageExportConfig;

  /**
   * Configuration for the
   * SecretManagerConfig feature.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#secretManagerConfig
   */
  readonly secretManagerConfig?: ClusterV1Beta2SpecInitProviderSecretManagerConfig;

  /**
   * Enable/Disable Security Posture API features for the cluster. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#securityPostureConfig
   */
  readonly securityPostureConfig?: ClusterV1Beta2SpecInitProviderSecurityPostureConfig;

  /**
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#serviceExternalIpsConfig
   */
  readonly serviceExternalIpsConfig?: ClusterV1Beta2SpecInitProviderServiceExternalIpsConfig;

  /**
   * The name or self_link of the Google Compute Engine
   * subnetwork in which the cluster's instances are launched.
   *
   * @schema ClusterV1Beta2SpecInitProvider#subnetwork
   */
  readonly subnetwork?: string;

  /**
   * Reference to a Subnetwork in compute to populate subnetwork.
   *
   * @schema ClusterV1Beta2SpecInitProvider#subnetworkRef
   */
  readonly subnetworkRef?: ClusterV1Beta2SpecInitProviderSubnetworkRef;

  /**
   * Selector for a Subnetwork in compute to populate subnetwork.
   *
   * @schema ClusterV1Beta2SpecInitProvider#subnetworkSelector
   */
  readonly subnetworkSelector?: ClusterV1Beta2SpecInitProviderSubnetworkSelector;

  /**
   * The custom keys configuration of the cluster Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#userManagedKeysConfig
   */
  readonly userManagedKeysConfig?: ClusterV1Beta2SpecInitProviderUserManagedKeysConfig;

  /**
   * Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#verticalPodAutoscaling
   */
  readonly verticalPodAutoscaling?: ClusterV1Beta2SpecInitProviderVerticalPodAutoscaling;

  /**
   * Workload Identity allows Kubernetes service accounts to act as a user-managed
   * Google IAM Service Account.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProvider#workloadIdentityConfig
   */
  readonly workloadIdentityConfig?: ClusterV1Beta2SpecInitProviderWorkloadIdentityConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProvider(obj: ClusterV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addonsConfig': toJson_ClusterV1Beta2SpecInitProviderAddonsConfig(obj.addonsConfig),
    'allowNetAdmin': obj.allowNetAdmin,
    'anonymousAuthenticationConfig': toJson_ClusterV1Beta2SpecInitProviderAnonymousAuthenticationConfig(obj.anonymousAuthenticationConfig),
    'authenticatorGroupsConfig': toJson_ClusterV1Beta2SpecInitProviderAuthenticatorGroupsConfig(obj.authenticatorGroupsConfig),
    'binaryAuthorization': toJson_ClusterV1Beta2SpecInitProviderBinaryAuthorization(obj.binaryAuthorization),
    'clusterAutoscaling': toJson_ClusterV1Beta2SpecInitProviderClusterAutoscaling(obj.clusterAutoscaling),
    'clusterIpv4Cidr': obj.clusterIpv4Cidr,
    'confidentialNodes': toJson_ClusterV1Beta2SpecInitProviderConfidentialNodes(obj.confidentialNodes),
    'controlPlaneEndpointsConfig': toJson_ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfig(obj.controlPlaneEndpointsConfig),
    'costManagementConfig': toJson_ClusterV1Beta2SpecInitProviderCostManagementConfig(obj.costManagementConfig),
    'databaseEncryption': toJson_ClusterV1Beta2SpecInitProviderDatabaseEncryption(obj.databaseEncryption),
    'datapathProvider': obj.datapathProvider,
    'defaultMaxPodsPerNode': obj.defaultMaxPodsPerNode,
    'defaultSnatStatus': toJson_ClusterV1Beta2SpecInitProviderDefaultSnatStatus(obj.defaultSnatStatus),
    'deletionProtection': obj.deletionProtection,
    'description': obj.description,
    'disableL4LbFirewallReconciliation': obj.disableL4LbFirewallReconciliation,
    'dnsConfig': toJson_ClusterV1Beta2SpecInitProviderDnsConfig(obj.dnsConfig),
    'enableAutopilot': obj.enableAutopilot,
    'enableCiliumClusterwideNetworkPolicy': obj.enableCiliumClusterwideNetworkPolicy,
    'enableFqdnNetworkPolicy': obj.enableFqdnNetworkPolicy,
    'enableIntranodeVisibility': obj.enableIntranodeVisibility,
    'enableK8SBetaApis': toJson_ClusterV1Beta2SpecInitProviderEnableK8SBetaApis(obj.enableK8SBetaApis),
    'enableKubernetesAlpha': obj.enableKubernetesAlpha,
    'enableL4IlbSubsetting': obj.enableL4IlbSubsetting,
    'enableLegacyAbac': obj.enableLegacyAbac,
    'enableMultiNetworking': obj.enableMultiNetworking,
    'enableShieldedNodes': obj.enableShieldedNodes,
    'enableTpu': obj.enableTpu,
    'enterpriseConfig': toJson_ClusterV1Beta2SpecInitProviderEnterpriseConfig(obj.enterpriseConfig),
    'fleet': toJson_ClusterV1Beta2SpecInitProviderFleet(obj.fleet),
    'gatewayApiConfig': toJson_ClusterV1Beta2SpecInitProviderGatewayApiConfig(obj.gatewayApiConfig),
    'gkeAutoUpgradeConfig': toJson_ClusterV1Beta2SpecInitProviderGkeAutoUpgradeConfig(obj.gkeAutoUpgradeConfig),
    'identityServiceConfig': toJson_ClusterV1Beta2SpecInitProviderIdentityServiceConfig(obj.identityServiceConfig),
    'inTransitEncryptionConfig': obj.inTransitEncryptionConfig,
    'initialNodeCount': obj.initialNodeCount,
    'ipAllocationPolicy': toJson_ClusterV1Beta2SpecInitProviderIpAllocationPolicy(obj.ipAllocationPolicy),
    'loggingConfig': toJson_ClusterV1Beta2SpecInitProviderLoggingConfig(obj.loggingConfig),
    'loggingService': obj.loggingService,
    'maintenancePolicy': toJson_ClusterV1Beta2SpecInitProviderMaintenancePolicy(obj.maintenancePolicy),
    'masterAuth': toJson_ClusterV1Beta2SpecInitProviderMasterAuth(obj.masterAuth),
    'masterAuthorizedNetworksConfig': toJson_ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfig(obj.masterAuthorizedNetworksConfig),
    'meshCertificates': toJson_ClusterV1Beta2SpecInitProviderMeshCertificates(obj.meshCertificates),
    'minMasterVersion': obj.minMasterVersion,
    'monitoringConfig': toJson_ClusterV1Beta2SpecInitProviderMonitoringConfig(obj.monitoringConfig),
    'monitoringService': obj.monitoringService,
    'network': obj.network,
    'networkPerformanceConfig': toJson_ClusterV1Beta2SpecInitProviderNetworkPerformanceConfig(obj.networkPerformanceConfig),
    'networkPolicy': toJson_ClusterV1Beta2SpecInitProviderNetworkPolicy(obj.networkPolicy),
    'networkRef': toJson_ClusterV1Beta2SpecInitProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_ClusterV1Beta2SpecInitProviderNetworkSelector(obj.networkSelector),
    'networkingMode': obj.networkingMode,
    'nodeConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfig(obj.nodeConfig),
    'nodeLocations': obj.nodeLocations?.map(y => y),
    'nodePoolAutoConfig': toJson_ClusterV1Beta2SpecInitProviderNodePoolAutoConfig(obj.nodePoolAutoConfig),
    'nodePoolDefaults': toJson_ClusterV1Beta2SpecInitProviderNodePoolDefaults(obj.nodePoolDefaults),
    'nodeVersion': obj.nodeVersion,
    'notificationConfig': toJson_ClusterV1Beta2SpecInitProviderNotificationConfig(obj.notificationConfig),
    'podAutoscaling': toJson_ClusterV1Beta2SpecInitProviderPodAutoscaling(obj.podAutoscaling),
    'privateClusterConfig': toJson_ClusterV1Beta2SpecInitProviderPrivateClusterConfig(obj.privateClusterConfig),
    'privateIpv6GoogleAccess': obj.privateIpv6GoogleAccess,
    'project': obj.project,
    'rbacBindingConfig': toJson_ClusterV1Beta2SpecInitProviderRbacBindingConfig(obj.rbacBindingConfig),
    'releaseChannel': toJson_ClusterV1Beta2SpecInitProviderReleaseChannel(obj.releaseChannel),
    'removeDefaultNodePool': obj.removeDefaultNodePool,
    'resourceLabels': ((obj.resourceLabels) === undefined) ? undefined : (Object.entries(obj.resourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceUsageExportConfig': toJson_ClusterV1Beta2SpecInitProviderResourceUsageExportConfig(obj.resourceUsageExportConfig),
    'secretManagerConfig': toJson_ClusterV1Beta2SpecInitProviderSecretManagerConfig(obj.secretManagerConfig),
    'securityPostureConfig': toJson_ClusterV1Beta2SpecInitProviderSecurityPostureConfig(obj.securityPostureConfig),
    'serviceExternalIpsConfig': toJson_ClusterV1Beta2SpecInitProviderServiceExternalIpsConfig(obj.serviceExternalIpsConfig),
    'subnetwork': obj.subnetwork,
    'subnetworkRef': toJson_ClusterV1Beta2SpecInitProviderSubnetworkRef(obj.subnetworkRef),
    'subnetworkSelector': toJson_ClusterV1Beta2SpecInitProviderSubnetworkSelector(obj.subnetworkSelector),
    'userManagedKeysConfig': toJson_ClusterV1Beta2SpecInitProviderUserManagedKeysConfig(obj.userManagedKeysConfig),
    'verticalPodAutoscaling': toJson_ClusterV1Beta2SpecInitProviderVerticalPodAutoscaling(obj.verticalPodAutoscaling),
    'workloadIdentityConfig': toJson_ClusterV1Beta2SpecInitProviderWorkloadIdentityConfig(obj.workloadIdentityConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ClusterV1Beta2SpecManagementPolicies
 */
export enum ClusterV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ClusterV1Beta2SpecProviderConfigRef
 */
export interface ClusterV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: ClusterV1Beta2SpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecProviderConfigRef(obj: ClusterV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ClusterV1Beta2SpecWriteConnectionSecretToRef
 */
export interface ClusterV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecWriteConnectionSecretToRef(obj: ClusterV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration for addons supported by GKE.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderAddonsConfig
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfig {
  /**
   * . Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfig#cloudrunConfig
   */
  readonly cloudrunConfig?: ClusterV1Beta2SpecForProviderAddonsConfigCloudrunConfig;

  /**
   * .
   * The status of the ConfigConnector addon. It is disabled by default; Set enabled = true to enable.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfig#configConnectorConfig
   */
  readonly configConnectorConfig?: ClusterV1Beta2SpecForProviderAddonsConfigConfigConnectorConfig;

  /**
   * .
   * The status of the NodeLocal DNSCache addon. It is disabled by default.
   * Set enabled = true to enable.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfig#dnsCacheConfig
   */
  readonly dnsCacheConfig?: ClusterV1Beta2SpecForProviderAddonsConfigDnsCacheConfig;

  /**
   * .
   * Whether this cluster should enable the Google Compute Engine Persistent Disk Container Storage Interface (CSI) Driver. Set enabled = true to enable.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfig#gcePersistentDiskCsiDriverConfig
   */
  readonly gcePersistentDiskCsiDriverConfig?: ClusterV1Beta2SpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig;

  /**
   * The status of the Filestore CSI driver addon,
   * which allows the usage of filestore instance as volumes.
   * It is disabled by default; set enabled = true to enable.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfig#gcpFilestoreCsiDriverConfig
   */
  readonly gcpFilestoreCsiDriverConfig?: ClusterV1Beta2SpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig;

  /**
   * The status of the GCSFuse CSI driver addon,
   * which allows the usage of a gcs bucket as volumes.
   * It is disabled by default for Standard clusters; set enabled = true to enable.
   * It is enabled by default for Autopilot clusters with version 1.24 or later; set enabled = true to enable it explicitly.
   * See Enable the Cloud Storage FUSE CSI driver for more information.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfig#gcsFuseCsiDriverConfig
   */
  readonly gcsFuseCsiDriverConfig?: ClusterV1Beta2SpecForProviderAddonsConfigGcsFuseCsiDriverConfig;

  /**
   * .
   * The status of the Backup for GKE agent addon. It is disabled by default; Set enabled = true to enable.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfig#gkeBackupAgentConfig
   */
  readonly gkeBackupAgentConfig?: ClusterV1Beta2SpecForProviderAddonsConfigGkeBackupAgentConfig;

  /**
   * The status of the Horizontal Pod Autoscaling
   * addon, which increases or decreases the number of replica pods a replication controller
   * has based on the resource usage of the existing pods.
   * It is enabled by default;
   * set disabled = true to disable.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfig#horizontalPodAutoscaling
   */
  readonly horizontalPodAutoscaling?: ClusterV1Beta2SpecForProviderAddonsConfigHorizontalPodAutoscaling;

  /**
   * The status of the HTTP (L7) load balancing
   * controller addon, which makes it easy to set up HTTP load balancers for services in a
   * cluster. It is enabled by default; set disabled = true to disable.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfig#httpLoadBalancing
   */
  readonly httpLoadBalancing?: ClusterV1Beta2SpecForProviderAddonsConfigHttpLoadBalancing;

  /**
   * The status of the Lustre CSI driver addon,
   * which allows the usage of a Lustre instances as volumes.
   * It is disabled by default for Standard clusters; set enabled = true to enable.
   * It is disabled by default for Autopilot clusters; set enabled = true to enable.
   * Lustre CSI Driver Config has optional subfield
   * enable_legacy_lustre_port which allows the Lustre CSI driver to initialize LNet (the virtual networklayer for Lustre kernel module) using port 6988.
   * This flag is required to workaround a port conflict with the gke-metadata-server on GKE nodes.
   * See Enable Lustre CSI driver for more information.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfig#lustreCsiDriverConfig
   */
  readonly lustreCsiDriverConfig?: ClusterV1Beta2SpecForProviderAddonsConfigLustreCsiDriverConfig;

  /**
   * Whether we should enable the network policy addon
   * for the master.  This must be enabled in order to enable network policy for the nodes.
   * To enable this, you must also define a network_policy block,
   * otherwise nothing will happen.
   * It can only be disabled if the nodes already do not have network policies enabled.
   * Defaults to disabled; set disabled = false to enable.
   *
   * @default disabled; set disabled = false to enable.
   * @schema ClusterV1Beta2SpecForProviderAddonsConfig#networkPolicyConfig
   */
  readonly networkPolicyConfig?: ClusterV1Beta2SpecForProviderAddonsConfigNetworkPolicyConfig;

  /**
   * The status of the Parallelstore CSI driver addon,
   * which allows the usage of a Parallelstore instances as volumes.
   * It is disabled by default for Standard clusters; set enabled = true to enable.
   * It is enabled by default for Autopilot clusters with version 1.29 or later; set enabled = true to enable it explicitly.
   * See Enable the Parallelstore CSI driver for more information.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfig#parallelstoreCsiDriverConfig
   */
  readonly parallelstoreCsiDriverConfig?: ClusterV1Beta2SpecForProviderAddonsConfigParallelstoreCsiDriverConfig;

  /**
   * . The status of the Ray Operator
   * addon.
   * It is disabled by default. Set enabled = true to enable. The minimum
   * cluster version to enable Ray is 1.30.0-gke.1747000.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfig#rayOperatorConfig
   */
  readonly rayOperatorConfig?: ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfig[];

  /**
   * .
   * The status of the Stateful HA addon, which provides automatic configurable failover for stateful applications.
   * It is disabled by default for Standard clusters. Set enabled = true to enable.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfig#statefulHaConfig
   */
  readonly statefulHaConfig?: ClusterV1Beta2SpecForProviderAddonsConfigStatefulHaConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfig(obj: ClusterV1Beta2SpecForProviderAddonsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudrunConfig': toJson_ClusterV1Beta2SpecForProviderAddonsConfigCloudrunConfig(obj.cloudrunConfig),
    'configConnectorConfig': toJson_ClusterV1Beta2SpecForProviderAddonsConfigConfigConnectorConfig(obj.configConnectorConfig),
    'dnsCacheConfig': toJson_ClusterV1Beta2SpecForProviderAddonsConfigDnsCacheConfig(obj.dnsCacheConfig),
    'gcePersistentDiskCsiDriverConfig': toJson_ClusterV1Beta2SpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig(obj.gcePersistentDiskCsiDriverConfig),
    'gcpFilestoreCsiDriverConfig': toJson_ClusterV1Beta2SpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig(obj.gcpFilestoreCsiDriverConfig),
    'gcsFuseCsiDriverConfig': toJson_ClusterV1Beta2SpecForProviderAddonsConfigGcsFuseCsiDriverConfig(obj.gcsFuseCsiDriverConfig),
    'gkeBackupAgentConfig': toJson_ClusterV1Beta2SpecForProviderAddonsConfigGkeBackupAgentConfig(obj.gkeBackupAgentConfig),
    'horizontalPodAutoscaling': toJson_ClusterV1Beta2SpecForProviderAddonsConfigHorizontalPodAutoscaling(obj.horizontalPodAutoscaling),
    'httpLoadBalancing': toJson_ClusterV1Beta2SpecForProviderAddonsConfigHttpLoadBalancing(obj.httpLoadBalancing),
    'lustreCsiDriverConfig': toJson_ClusterV1Beta2SpecForProviderAddonsConfigLustreCsiDriverConfig(obj.lustreCsiDriverConfig),
    'networkPolicyConfig': toJson_ClusterV1Beta2SpecForProviderAddonsConfigNetworkPolicyConfig(obj.networkPolicyConfig),
    'parallelstoreCsiDriverConfig': toJson_ClusterV1Beta2SpecForProviderAddonsConfigParallelstoreCsiDriverConfig(obj.parallelstoreCsiDriverConfig),
    'rayOperatorConfig': obj.rayOperatorConfig?.map(y => toJson_ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfig(y)),
    'statefulHaConfig': toJson_ClusterV1Beta2SpecForProviderAddonsConfigStatefulHaConfig(obj.statefulHaConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for anonymous authentication restrictions. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderAnonymousAuthenticationConfig
 */
export interface ClusterV1Beta2SpecForProviderAnonymousAuthenticationConfig {
  /**
   * Sets or removes authentication restrictions. Available options include LIMITED and ENABLED.
   *
   * @schema ClusterV1Beta2SpecForProviderAnonymousAuthenticationConfig#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAnonymousAuthenticationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAnonymousAuthenticationConfig(obj: ClusterV1Beta2SpecForProviderAnonymousAuthenticationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for the
 * Google Groups for GKE feature.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderAuthenticatorGroupsConfig
 */
export interface ClusterV1Beta2SpecForProviderAuthenticatorGroupsConfig {
  /**
   * The name of the RBAC security group for use with Google security groups in Kubernetes RBAC. Group name must be in format gke-security-groups@yourdomain.com.
   *
   * @schema ClusterV1Beta2SpecForProviderAuthenticatorGroupsConfig#securityGroup
   */
  readonly securityGroup?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAuthenticatorGroupsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAuthenticatorGroupsConfig(obj: ClusterV1Beta2SpecForProviderAuthenticatorGroupsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroup': obj.securityGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration options for the Binary
 * Authorization feature. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderBinaryAuthorization
 */
export interface ClusterV1Beta2SpecForProviderBinaryAuthorization {
  /**
   * (DEPRECATED) Enable Binary Authorization for this cluster. Deprecated in favor of evaluation_mode.
   *
   * @schema ClusterV1Beta2SpecForProviderBinaryAuthorization#enabled
   */
  readonly enabled?: boolean;

  /**
   * Mode of operation for Binary Authorization policy evaluation. Valid values are DISABLED
   * and PROJECT_SINGLETON_POLICY_ENFORCE.
   *
   * @schema ClusterV1Beta2SpecForProviderBinaryAuthorization#evaluationMode
   */
  readonly evaluationMode?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderBinaryAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderBinaryAuthorization(obj: ClusterV1Beta2SpecForProviderBinaryAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'evaluationMode': obj.evaluationMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to
 * automatically adjust the size of the cluster and create/delete node pools based
 * on the current needs of the cluster's workload. See the
 * guide to using Node Auto-Provisioning
 * for more details. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderClusterAutoscaling
 */
export interface ClusterV1Beta2SpecForProviderClusterAutoscaling {
  /**
   * Contains defaults for a node pool created by NAP. A subset of fields also apply to
   * GKE Autopilot clusters.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscaling#autoProvisioningDefaults
   */
  readonly autoProvisioningDefaults?: ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults;

  /**
   * The list of Google Compute Engine
   * zones in which the
   * NodePool's nodes can be created by NAP.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscaling#autoProvisioningLocations
   */
  readonly autoProvisioningLocations?: string[];

  /**
   * Configuration
   * options for the Autoscaling profile
   * feature, which lets you choose whether the cluster autoscaler should optimize for resource utilization or resource availability
   * when deciding to remove nodes from a cluster. Can be BALANCED or OPTIMIZE_UTILIZATION. Defaults to BALANCED.
   *
   * @default BALANCED.
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscaling#autoscalingProfile
   */
  readonly autoscalingProfile?: string;

  /**
   * Whether node auto-provisioning is enabled. Must be supplied for GKE Standard clusters, true is implied
   * for autopilot clusters. Resource limits for cpu and memory must be defined to enable node auto-provisioning for GKE Standard.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscaling#enabled
   */
  readonly enabled?: boolean;

  /**
   * Global constraints for machine resources in the
   * cluster. Configuring the cpu and memory types is required if node
   * auto-provisioning is enabled. These limits will apply to node pool autoscaling
   * in addition to node auto-provisioning. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscaling#resourceLimits
   */
  readonly resourceLimits?: ClusterV1Beta2SpecForProviderClusterAutoscalingResourceLimits[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderClusterAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderClusterAutoscaling(obj: ClusterV1Beta2SpecForProviderClusterAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoProvisioningDefaults': toJson_ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults(obj.autoProvisioningDefaults),
    'autoProvisioningLocations': obj.autoProvisioningLocations?.map(y => y),
    'autoscalingProfile': obj.autoscalingProfile,
    'enabled': obj.enabled,
    'resourceLimits': obj.resourceLimits?.map(y => toJson_ClusterV1Beta2SpecForProviderClusterAutoscalingResourceLimits(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for Confidential Nodes feature. Structure is documented below documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderConfidentialNodes
 */
export interface ClusterV1Beta2SpecForProviderConfidentialNodes {
  /**
   * Defines the type of technology used
   * by the confidential node.
   *
   * @schema ClusterV1Beta2SpecForProviderConfidentialNodes#confidentialInstanceType
   */
  readonly confidentialInstanceType?: string;

  /**
   * Enable Confidential GKE Nodes for this node pool, to
   * enforce encryption of data in-use.
   *
   * @schema ClusterV1Beta2SpecForProviderConfidentialNodes#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderConfidentialNodes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderConfidentialNodes(obj: ClusterV1Beta2SpecForProviderConfidentialNodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confidentialInstanceType': obj.confidentialInstanceType,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for all of the cluster's control plane endpoints.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfig
 */
export interface ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfig {
  /**
   * DNS endpoint configuration.
   *
   * @schema ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfig#dnsEndpointConfig
   */
  readonly dnsEndpointConfig?: ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig;

  /**
   * IP endpoint configuration.
   *
   * @schema ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfig#ipEndpointsConfig
   */
  readonly ipEndpointsConfig?: ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfig(obj: ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsEndpointConfig': toJson_ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig(obj.dnsEndpointConfig),
    'ipEndpointsConfig': toJson_ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig(obj.ipEndpointsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for the
 * Cost Allocation feature.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderCostManagementConfig
 */
export interface ClusterV1Beta2SpecForProviderCostManagementConfig {
  /**
   * Whether to enable the cost allocation feature.
   *
   * @schema ClusterV1Beta2SpecForProviderCostManagementConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderCostManagementConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderCostManagementConfig(obj: ClusterV1Beta2SpecForProviderCostManagementConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderDatabaseEncryption
 */
export interface ClusterV1Beta2SpecForProviderDatabaseEncryption {
  /**
   * the key to use to encrypt/decrypt secrets.  See the DatabaseEncryption definition for more information.
   *
   * @schema ClusterV1Beta2SpecForProviderDatabaseEncryption#keyName
   */
  readonly keyName?: string;

  /**
   * ENCRYPTED or DECRYPTED
   *
   * @schema ClusterV1Beta2SpecForProviderDatabaseEncryption#state
   */
  readonly state?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderDatabaseEncryption' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderDatabaseEncryption(obj: ClusterV1Beta2SpecForProviderDatabaseEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GKE SNAT DefaultSnatStatus contains the desired state of whether default sNAT should be disabled on the cluster, API doc. Structure is documented below
 *
 * @schema ClusterV1Beta2SpecForProviderDefaultSnatStatus
 */
export interface ClusterV1Beta2SpecForProviderDefaultSnatStatus {
  /**
   * Whether the cluster disables default in-node sNAT rules. In-node sNAT rules will be disabled when defaultSnatStatus is disabled.When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic
   *
   * @schema ClusterV1Beta2SpecForProviderDefaultSnatStatus#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderDefaultSnatStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderDefaultSnatStatus(obj: ClusterV1Beta2SpecForProviderDefaultSnatStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for Using Cloud DNS for GKE. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderDnsConfig
 */
export interface ClusterV1Beta2SpecForProviderDnsConfig {
  /**
   * This will enable Cloud DNS additive VPC scope. Must provide a domain name that is unique within the VPC. For this to work cluster_dns = "CLOUD_DNS" and cluster_dns_scope = "CLUSTER_SCOPE" must both be set as well.
   *
   * @schema ClusterV1Beta2SpecForProviderDnsConfig#additiveVpcScopeDnsDomain
   */
  readonly additiveVpcScopeDnsDomain?: string;

  /**
   * Which in-cluster DNS provider should be used. PROVIDER_UNSPECIFIED (default) or PLATFORM_DEFAULT or CLOUD_DNS.
   *
   * @schema ClusterV1Beta2SpecForProviderDnsConfig#clusterDns
   */
  readonly clusterDns?: string;

  /**
   * The suffix used for all cluster service records.
   *
   * @schema ClusterV1Beta2SpecForProviderDnsConfig#clusterDnsDomain
   */
  readonly clusterDnsDomain?: string;

  /**
   * The scope of access to cluster DNS records. DNS_SCOPE_UNSPECIFIED or CLUSTER_SCOPE or VPC_SCOPE. If the cluster_dns field is set to CLOUD_DNS, DNS_SCOPE_UNSPECIFIED and empty/null behave like CLUSTER_SCOPE.
   *
   * @schema ClusterV1Beta2SpecForProviderDnsConfig#clusterDnsScope
   */
  readonly clusterDnsScope?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderDnsConfig(obj: ClusterV1Beta2SpecForProviderDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additiveVpcScopeDnsDomain': obj.additiveVpcScopeDnsDomain,
    'clusterDns': obj.clusterDns,
    'clusterDnsDomain': obj.clusterDnsDomain,
    'clusterDnsScope': obj.clusterDnsScope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for Kubernetes Beta APIs.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderEnableK8SBetaApis
 */
export interface ClusterV1Beta2SpecForProviderEnableK8SBetaApis {
  /**
   * Enabled Kubernetes Beta APIs. To list a Beta API resource, use the representation {group}/{version}/{resource}. The version must be a Beta version. Note that you cannot disable beta APIs that are already enabled on a cluster without recreating it. See the Configure beta APIs for more information.
   *
   * @schema ClusterV1Beta2SpecForProviderEnableK8SBetaApis#enabledApis
   */
  readonly enabledApis?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderEnableK8SBetaApis' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderEnableK8SBetaApis(obj: ClusterV1Beta2SpecForProviderEnableK8SBetaApis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabledApis': obj.enabledApis?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for [Enterprise edition].(https://cloud.google.com/kubernetes-engine/enterprise/docs/concepts/gke-editions). Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderEnterpriseConfig
 */
export interface ClusterV1Beta2SpecForProviderEnterpriseConfig {
  /**
   * Sets the tier of the cluster. Available options include STANDARD and ENTERPRISE.
   *
   * @schema ClusterV1Beta2SpecForProviderEnterpriseConfig#desiredTier
   */
  readonly desiredTier?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderEnterpriseConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderEnterpriseConfig(obj: ClusterV1Beta2SpecForProviderEnterpriseConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'desiredTier': obj.desiredTier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fleet configuration for the cluster. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderFleet
 */
export interface ClusterV1Beta2SpecForProviderFleet {
  /**
   * The name of the Fleet host project where this cluster will be registered.
   *
   * @schema ClusterV1Beta2SpecForProviderFleet#project
   */
  readonly project?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderFleet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderFleet(obj: ClusterV1Beta2SpecForProviderFleet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for GKE Gateway API controller. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderGatewayApiConfig
 */
export interface ClusterV1Beta2SpecForProviderGatewayApiConfig {
  /**
   * Which Gateway Api channel should be used. CHANNEL_DISABLED, CHANNEL_EXPERIMENTAL or CHANNEL_STANDARD.
   *
   * @schema ClusterV1Beta2SpecForProviderGatewayApiConfig#channel
   */
  readonly channel?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderGatewayApiConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderGatewayApiConfig(obj: ClusterV1Beta2SpecForProviderGatewayApiConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'channel': obj.channel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration options for the auto-upgrade patch type feature, which provide more control over the speed of automatic upgrades of your GKE clusters.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderGkeAutoUpgradeConfig
 */
export interface ClusterV1Beta2SpecForProviderGkeAutoUpgradeConfig {
  /**
   * The selected patch mode.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecForProviderGkeAutoUpgradeConfig#patchMode
   */
  readonly patchMode?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderGkeAutoUpgradeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderGkeAutoUpgradeConfig(obj: ClusterV1Beta2SpecForProviderGkeAutoUpgradeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'patchMode': obj.patchMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * . Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderIdentityServiceConfig
 */
export interface ClusterV1Beta2SpecForProviderIdentityServiceConfig {
  /**
   * Whether to enable the Identity Service component. It is disabled by default. Set enabled=true to enable.
   *
   * @schema ClusterV1Beta2SpecForProviderIdentityServiceConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderIdentityServiceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderIdentityServiceConfig(obj: ClusterV1Beta2SpecForProviderIdentityServiceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of cluster IP allocation for
 * VPC-native clusters. If this block is unset during creation, it will be set by the GKE backend.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicy
 */
export interface ClusterV1Beta2SpecForProviderIpAllocationPolicy {
  /**
   * The configuration for individual additional subnetworks attached to the cluster.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicy#additionalIpRangesConfig
   */
  readonly additionalIpRangesConfig?: ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalIpRangesConfig[];

  /**
   * The configuration for additional pod secondary ranges at
   * the cluster level. Used for Autopilot clusters and Standard clusters with which control of the
   * secondary Pod IP address assignment to node pools isn't needed. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicy#additionalPodRangesConfig
   */
  readonly additionalPodRangesConfig?: ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalPodRangesConfig;

  /**
   * The IP address range for the cluster pod IPs.
   * Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
   * to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
   * from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
   * pick a specific range to use.
   *
   * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicy#clusterIpv4CidrBlock
   */
  readonly clusterIpv4CidrBlock?: string;

  /**
   * The name of the existing secondary
   * range in the cluster's subnetwork to use for pod IP addresses. Alternatively,
   * cluster_ipv4_cidr_block can be used to automatically create a GKE-managed one.
   *
   * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicy#clusterSecondaryRangeName
   */
  readonly clusterSecondaryRangeName?: string;

  /**
   * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicy#podCidrOverprovisionConfig
   */
  readonly podCidrOverprovisionConfig?: ClusterV1Beta2SpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig;

  /**
   * The IP address range of the services IPs in this cluster.
   * Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
   * to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
   * from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
   * pick a specific range to use.
   *
   * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicy#servicesIpv4CidrBlock
   */
  readonly servicesIpv4CidrBlock?: string;

  /**
   * The name of the existing
   * secondary range in the cluster's subnetwork to use for service ClusterIPs.
   * Alternatively, services_ipv4_cidr_block can be used to automatically create a
   * GKE-managed one.
   *
   * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicy#servicesSecondaryRangeName
   */
  readonly servicesSecondaryRangeName?: string;

  /**
   * The IP Stack Type of the cluster.
   * Default value is IPV4.
   * Possible values are IPV4 and IPV4_IPV6.
   *
   * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicy#stackType
   */
  readonly stackType?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderIpAllocationPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderIpAllocationPolicy(obj: ClusterV1Beta2SpecForProviderIpAllocationPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalIpRangesConfig': obj.additionalIpRangesConfig?.map(y => toJson_ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalIpRangesConfig(y)),
    'additionalPodRangesConfig': toJson_ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalPodRangesConfig(obj.additionalPodRangesConfig),
    'clusterIpv4CidrBlock': obj.clusterIpv4CidrBlock,
    'clusterSecondaryRangeName': obj.clusterSecondaryRangeName,
    'podCidrOverprovisionConfig': toJson_ClusterV1Beta2SpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig(obj.podCidrOverprovisionConfig),
    'servicesIpv4CidrBlock': obj.servicesIpv4CidrBlock,
    'servicesSecondaryRangeName': obj.servicesSecondaryRangeName,
    'stackType': obj.stackType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Logging configuration for the cluster.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderLoggingConfig
 */
export interface ClusterV1Beta2SpecForProviderLoggingConfig {
  /**
   * The GKE components exposing logs. Supported values include:
   * SYSTEM_COMPONENTS, APISERVER, CONTROLLER_MANAGER, SCHEDULER, and WORKLOADS.
   *
   * @schema ClusterV1Beta2SpecForProviderLoggingConfig#enableComponents
   */
  readonly enableComponents?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderLoggingConfig(obj: ClusterV1Beta2SpecForProviderLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableComponents': obj.enableComponents?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The maintenance policy to use for the cluster. Structure is
 * documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderMaintenancePolicy
 */
export interface ClusterV1Beta2SpecForProviderMaintenancePolicy {
  /**
   * structure documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderMaintenancePolicy#dailyMaintenanceWindow
   */
  readonly dailyMaintenanceWindow?: ClusterV1Beta2SpecForProviderMaintenancePolicyDailyMaintenanceWindow;

  /**
   * structure documented below
   *
   * @schema ClusterV1Beta2SpecForProviderMaintenancePolicy#maintenanceExclusion
   */
  readonly maintenanceExclusion?: ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusion[];

  /**
   * structure documented below
   *
   * @schema ClusterV1Beta2SpecForProviderMaintenancePolicy#recurringWindow
   */
  readonly recurringWindow?: ClusterV1Beta2SpecForProviderMaintenancePolicyRecurringWindow;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderMaintenancePolicy(obj: ClusterV1Beta2SpecForProviderMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dailyMaintenanceWindow': toJson_ClusterV1Beta2SpecForProviderMaintenancePolicyDailyMaintenanceWindow(obj.dailyMaintenanceWindow),
    'maintenanceExclusion': obj.maintenanceExclusion?.map(y => toJson_ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusion(y)),
    'recurringWindow': toJson_ClusterV1Beta2SpecForProviderMaintenancePolicyRecurringWindow(obj.recurringWindow),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The authentication information for accessing the
 * Kubernetes master. Some values in this block are only returned by the API if
 * your service account has permission to get credentials for your GKE cluster. If
 * you see an unexpected diff unsetting your client cert, ensure you have the
 * container.clusters.getCredentials permission.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderMasterAuth
 */
export interface ClusterV1Beta2SpecForProviderMasterAuth {
  /**
   * Whether client certificate authorization is enabled for this cluster.  For example:
   *
   * @schema ClusterV1Beta2SpecForProviderMasterAuth#clientCertificateConfig
   */
  readonly clientCertificateConfig?: ClusterV1Beta2SpecForProviderMasterAuthClientCertificateConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderMasterAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderMasterAuth(obj: ClusterV1Beta2SpecForProviderMasterAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertificateConfig': toJson_ClusterV1Beta2SpecForProviderMasterAuthClientCertificateConfig(obj.clientCertificateConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The desired
 * configuration options for master authorized networks. Omit the
 * nested cidr_blocks attribute to disallow external access (except
 * the cluster node IPs, which GKE automatically whitelists).
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfig
 */
export interface ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfig {
  /**
   * External networks that can access the
   * Kubernetes cluster master through HTTPS.
   *
   * @schema ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfig#cidrBlocks
   */
  readonly cidrBlocks?: ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfigCidrBlocks[];

  /**
   * Whether Kubernetes master is
   * accessible via Google Compute Engine Public IPs.
   *
   * @schema ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfig#gcpPublicCidrsAccessEnabled
   */
  readonly gcpPublicCidrsAccessEnabled?: boolean;

  /**
   * Whether authorized networks is enforced on the private endpoint or not.
   *
   * @schema ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfig#privateEndpointEnforcementEnabled
   */
  readonly privateEndpointEnforcementEnabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfig(obj: ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrBlocks': obj.cidrBlocks?.map(y => toJson_ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfigCidrBlocks(y)),
    'gcpPublicCidrsAccessEnabled': obj.gcpPublicCidrsAccessEnabled,
    'privateEndpointEnforcementEnabled': obj.privateEndpointEnforcementEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderMeshCertificates
 */
export interface ClusterV1Beta2SpecForProviderMeshCertificates {
  /**
   * Controls the issuance of workload mTLS certificates. It is enabled by default. Workload Identity is required, see workload_config.
   *
   * @schema ClusterV1Beta2SpecForProviderMeshCertificates#enableCertificates
   */
  readonly enableCertificates?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderMeshCertificates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderMeshCertificates(obj: ClusterV1Beta2SpecForProviderMeshCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableCertificates': obj.enableCertificates,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Monitoring configuration for the cluster.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderMonitoringConfig
 */
export interface ClusterV1Beta2SpecForProviderMonitoringConfig {
  /**
   * Configuration for Advanced Datapath Monitoring. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderMonitoringConfig#advancedDatapathObservabilityConfig
   */
  readonly advancedDatapathObservabilityConfig?: ClusterV1Beta2SpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig;

  /**
   * The GKE components exposing metrics. Supported values include: SYSTEM_COMPONENTS, APISERVER, SCHEDULER, CONTROLLER_MANAGER, STORAGE, HPA, POD, DAEMONSET, DEPLOYMENT, STATEFULSET, KUBELET, CADVISOR, DCGM and JOBSET. In beta provider, WORKLOADS is supported on top of those 12 values. (WORKLOADS is deprecated and removed in GKE 1.24.) KUBELET and CADVISOR are only supported in GKE 1.29.3-gke.1093000 and above. JOBSET is only supported in GKE 1.32.1-gke.1357001 and above.
   *
   * @schema ClusterV1Beta2SpecForProviderMonitoringConfig#enableComponents
   */
  readonly enableComponents?: string[];

  /**
   * Configuration for Managed Service for Prometheus. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderMonitoringConfig#managedPrometheus
   */
  readonly managedPrometheus?: ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheus;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderMonitoringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderMonitoringConfig(obj: ClusterV1Beta2SpecForProviderMonitoringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedDatapathObservabilityConfig': toJson_ClusterV1Beta2SpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig(obj.advancedDatapathObservabilityConfig),
    'enableComponents': obj.enableComponents?.map(y => y),
    'managedPrometheus': toJson_ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheus(obj.managedPrometheus),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Network bandwidth tier configuration. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNetworkPerformanceConfig
 */
export interface ClusterV1Beta2SpecForProviderNetworkPerformanceConfig {
  /**
   * Specifies the total network bandwidth tier for NodePools in the cluster.
   *
   * @schema ClusterV1Beta2SpecForProviderNetworkPerformanceConfig#totalEgressBandwidthTier
   */
  readonly totalEgressBandwidthTier?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNetworkPerformanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNetworkPerformanceConfig(obj: ClusterV1Beta2SpecForProviderNetworkPerformanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'totalEgressBandwidthTier': obj.totalEgressBandwidthTier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration options for the
 * NetworkPolicy
 * feature. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNetworkPolicy
 */
export interface ClusterV1Beta2SpecForProviderNetworkPolicy {
  /**
   * Whether network policy is enabled on the cluster.
   *
   * @schema ClusterV1Beta2SpecForProviderNetworkPolicy#enabled
   */
  readonly enabled?: boolean;

  /**
   * The selected network policy provider. Defaults to PROVIDER_UNSPECIFIED.
   *
   * @default PROVIDER_UNSPECIFIED.
   * @schema ClusterV1Beta2SpecForProviderNetworkPolicy#provider
   */
  readonly provider?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNetworkPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNetworkPolicy(obj: ClusterV1Beta2SpecForProviderNetworkPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'provider': obj.provider,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema ClusterV1Beta2SpecForProviderNetworkRef
 */
export interface ClusterV1Beta2SpecForProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterV1Beta2SpecForProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterV1Beta2SpecForProviderNetworkRef#policy
   */
  readonly policy?: ClusterV1Beta2SpecForProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNetworkRef(obj: ClusterV1Beta2SpecForProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterV1Beta2SpecForProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema ClusterV1Beta2SpecForProviderNetworkSelector
 */
export interface ClusterV1Beta2SpecForProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterV1Beta2SpecForProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterV1Beta2SpecForProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterV1Beta2SpecForProviderNetworkSelector#policy
   */
  readonly policy?: ClusterV1Beta2SpecForProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNetworkSelector(obj: ClusterV1Beta2SpecForProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterV1Beta2SpecForProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters used in creating the default node pool. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfig {
  /**
   * Specifies options for controlling
   * advanced machine features. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#advancedMachineFeatures
   */
  readonly advancedMachineFeatures?: ClusterV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures;

  /**
   * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#bootDiskKmsKey
   */
  readonly bootDiskKmsKey?: string;

  /**
   * Configuration for Confidential Nodes feature. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#confidentialNodes
   */
  readonly confidentialNodes?: ClusterV1Beta2SpecForProviderNodeConfigConfidentialNodes;

  /**
   * Parameters to customize containerd runtime. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#containerdConfig
   */
  readonly containerdConfig?: ClusterV1Beta2SpecForProviderNodeConfigContainerdConfig;

  /**
   * Size of the disk attached to each node, specified
   * in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
   *
   * @default 100GB.
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#diskSizeGb
   */
  readonly diskSizeGb?: number;

  /**
   * Type of the disk attached to each node
   * (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-balanced'
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#diskType
   */
  readonly diskType?: string;

  /**
   * Enabling Confidential Storage will create boot disk with confidential mode. It is disabled by default.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#enableConfidentialStorage
   */
  readonly enableConfidentialStorage?: boolean;

  /**
   * Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#ephemeralStorageLocalSsdConfig
   */
  readonly ephemeralStorageLocalSsdConfig?: ClusterV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig;

  /**
   * Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
   * Node Pool must enable gvnic.
   * GKE version 1.25.2-gke.1700 or later.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#fastSocket
   */
  readonly fastSocket?: ClusterV1Beta2SpecForProviderNodeConfigFastSocket;

  /**
   * Enables Flex Start provisioning model for the node pool.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#flexStart
   */
  readonly flexStart?: boolean;

  /**
   * Parameters for the Google Container Filesystem (GCFS).
   * If unspecified, GCFS will not be enabled on the node pool. When enabling this feature you must specify image_type = "COS_CONTAINERD" and node_version from GKE versions 1.19 or later to use it.
   * For GKE versions 1.19, 1.20, and 1.21, the recommended minimum node_version would be 1.19.15-gke.1300, 1.20.11-gke.1300, and 1.21.5-gke.1300 respectively.
   * A machine_type that has more than 16 GiB of memory is also recommended.
   * GCFS must be enabled in order to use image streaming.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#gcfsConfig
   */
  readonly gcfsConfig?: ClusterV1Beta2SpecForProviderNodeConfigGcfsConfig;

  /**
   * List of the type and count of accelerator cards attached to the instance.
   * Structure documented below.
   * Note: As of 6.0.0, argument syntax
   * is no longer supported for this field in favor of block syntax.
   * To dynamically set a list of guest accelerators, use dynamic blocks.
   * To set an empty list, use a single guest_accelerator block with count = 0.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#guestAccelerator
   */
  readonly guestAccelerator?: ClusterV1Beta2SpecForProviderNodeConfigGuestAccelerator[];

  /**
   * Google Virtual NIC (gVNIC) is a virtual network interface.
   * Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
   * gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
   * GKE node version 1.15.11-gke.15 or later
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#gvnic
   */
  readonly gvnic?: ClusterV1Beta2SpecForProviderNodeConfigGvnic;

  /**
   * The maintenance policy to use for the cluster. Structure is
   * documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#hostMaintenancePolicy
   */
  readonly hostMaintenancePolicy?: ClusterV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy;

  /**
   * The image type to use for this node. Note that changing the image type
   * will delete and recreate all nodes in the node pool.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#imageType
   */
  readonly imageType?: string;

  /**
   * Kubelet configuration, currently supported attributes can be found here.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#kubeletConfig
   */
  readonly kubeletConfig?: ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig;

  /**
   * The Kubernetes labels (key/value pairs) to be applied to each node. The kubernetes.io/ and k8s.io/ prefixes are
   * reserved by Kubernetes Core components and cannot be specified.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Parameters that can be configured on Linux nodes. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#linuxNodeConfig
   */
  readonly linuxNodeConfig?: ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfig;

  /**
   * Parameters for the local NVMe SSDs. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#localNvmeSsdBlockConfig
   */
  readonly localNvmeSsdBlockConfig?: ClusterV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig;

  /**
   * The amount of local SSD disks that will be
   * attached to each cluster node. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#localSsdCount
   */
  readonly localSsdCount?: number;

  /**
   * Possible Local SSD encryption modes:
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#localSsdEncryptionMode
   */
  readonly localSsdEncryptionMode?: string;

  /**
   * wide default value. Valid values include DEFAULT and MAX_THROUGHPUT. See Increasing logging agent throughput for more information.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#loggingVariant
   */
  readonly loggingVariant?: string;

  /**
   * The name of a Google Compute Engine machine type.
   * Defaults to e2-medium. To create a custom machine type, value should be set as specified
   * here.
   *
   * @default e2-medium. To create a custom machine type, value should be set as specified
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#machineType
   */
  readonly machineType?: string;

  /**
   * The runtime of each node in the node pool in seconds, terminated by 's'. Example: "3600s".
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#maxRunDuration
   */
  readonly maxRunDuration?: string;

  /**
   * The metadata key/value pairs assigned to instances in
   * the cluster. From GKE 1. To avoid this, set the
   * value in your config.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * Minimum CPU platform to be used by this instance.
   * The instance may be scheduled on the specified or newer CPU platform. Applicable
   * values are the friendly names of CPU platforms, such as Intel Haswell. See the
   * official documentation
   * for more information.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#minCpuPlatform
   */
  readonly minCpuPlatform?: string;

  /**
   * Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on sole tenant nodes.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#nodeGroup
   */
  readonly nodeGroup?: string;

  /**
   * The set of Google API scopes to be made available
   * on all of the node VMs under the "default" service account.
   * Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set service_account to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#oauthScopes
   */
  readonly oauthScopes?: string[];

  /**
   * A boolean that represents whether or not the underlying node VMs
   * are preemptible. See the official documentation
   * for more information. Defaults to false.
   *
   * @default false.
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#preemptible
   */
  readonly preemptible?: boolean;

  /**
   * The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#reservationAffinity
   */
  readonly reservationAffinity?: ClusterV1Beta2SpecForProviderNodeConfigReservationAffinity;

  /**
   * The GCP labels (key/value pairs) to be applied to each node. Refer here
   * for how these labels are applied to clusters, node pools and nodes.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#resourceLabels
   */
  readonly resourceLabels?: { [key: string]: string };

  /**
   * A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found here. A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. tagKeys/{tag_key_id}=tagValues/{tag_value_id} 2. {org_id}/{tag_key_name}={tag_value_name} 3. {project_id}/{tag_key_name}={tag_value_name}.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };

  /**
   * Parameters for secondary boot disks to preload container images and data on new nodes. Structure is documented below. gcfs_config must be enabled=true for this feature to work. min_master_version must also be set to use GKE 1.28.3-gke.106700 or later versions.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#secondaryBootDisks
   */
  readonly secondaryBootDisks?: ClusterV1Beta2SpecForProviderNodeConfigSecondaryBootDisks[];

  /**
   * The service account to be used by the Node VMs.
   * If not specified, the "default" service account is used.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#serviceAccountSelector
   */
  readonly serviceAccountSelector?: ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelector;

  /**
   * Shielded Instance options. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: ClusterV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig;

  /**
   * Allows specifying multiple node affinities useful for running workloads on sole tenant nodes. node_affinity structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#soleTenantConfig
   */
  readonly soleTenantConfig?: ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfig;

  /**
   * A boolean that represents whether the underlying node VMs are spot.
   * See the official documentation
   * for more information. Defaults to false.
   *
   * @default false.
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#spot
   */
  readonly spot?: boolean;

  /**
   * The list of Storage Pools where boot disks are provisioned.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#storagePools
   */
  readonly storagePools?: string[];

  /**
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#tags
   */
  readonly tags?: string[];

  /**
   * A list of
   * Kubernetes taints
   * to apply to nodes. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#taint
   */
  readonly taint?: ClusterV1Beta2SpecForProviderNodeConfigTaint[];

  /**
   * Windows node configuration, currently supporting OSVersion attribute. The value must be one of [OS_VERSION_UNSPECIFIED, OS_VERSION_LTSC2019, OS_VERSION_LTSC2022]. For example:
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#windowsNodeConfig
   */
  readonly windowsNodeConfig?: ClusterV1Beta2SpecForProviderNodeConfigWindowsNodeConfig;

  /**
   * Metadata configuration to expose to workloads on the node pool.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfig#workloadMetadataConfig
   */
  readonly workloadMetadataConfig?: ClusterV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfig(obj: ClusterV1Beta2SpecForProviderNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedMachineFeatures': toJson_ClusterV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures(obj.advancedMachineFeatures),
    'bootDiskKmsKey': obj.bootDiskKmsKey,
    'confidentialNodes': toJson_ClusterV1Beta2SpecForProviderNodeConfigConfidentialNodes(obj.confidentialNodes),
    'containerdConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfigContainerdConfig(obj.containerdConfig),
    'diskSizeGb': obj.diskSizeGb,
    'diskType': obj.diskType,
    'enableConfidentialStorage': obj.enableConfidentialStorage,
    'ephemeralStorageLocalSsdConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig(obj.ephemeralStorageLocalSsdConfig),
    'fastSocket': toJson_ClusterV1Beta2SpecForProviderNodeConfigFastSocket(obj.fastSocket),
    'flexStart': obj.flexStart,
    'gcfsConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfigGcfsConfig(obj.gcfsConfig),
    'guestAccelerator': obj.guestAccelerator?.map(y => toJson_ClusterV1Beta2SpecForProviderNodeConfigGuestAccelerator(y)),
    'gvnic': toJson_ClusterV1Beta2SpecForProviderNodeConfigGvnic(obj.gvnic),
    'hostMaintenancePolicy': toJson_ClusterV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy(obj.hostMaintenancePolicy),
    'imageType': obj.imageType,
    'kubeletConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig(obj.kubeletConfig),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'linuxNodeConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfig(obj.linuxNodeConfig),
    'localNvmeSsdBlockConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig(obj.localNvmeSsdBlockConfig),
    'localSsdCount': obj.localSsdCount,
    'localSsdEncryptionMode': obj.localSsdEncryptionMode,
    'loggingVariant': obj.loggingVariant,
    'machineType': obj.machineType,
    'maxRunDuration': obj.maxRunDuration,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'minCpuPlatform': obj.minCpuPlatform,
    'nodeGroup': obj.nodeGroup,
    'oauthScopes': obj.oauthScopes?.map(y => y),
    'preemptible': obj.preemptible,
    'reservationAffinity': toJson_ClusterV1Beta2SpecForProviderNodeConfigReservationAffinity(obj.reservationAffinity),
    'resourceLabels': ((obj.resourceLabels) === undefined) ? undefined : (Object.entries(obj.resourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'secondaryBootDisks': obj.secondaryBootDisks?.map(y => toJson_ClusterV1Beta2SpecForProviderNodeConfigSecondaryBootDisks(y)),
    'serviceAccount': obj.serviceAccount,
    'serviceAccountRef': toJson_ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRef(obj.serviceAccountRef),
    'serviceAccountSelector': toJson_ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelector(obj.serviceAccountSelector),
    'shieldedInstanceConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig(obj.shieldedInstanceConfig),
    'soleTenantConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfig(obj.soleTenantConfig),
    'spot': obj.spot,
    'storagePools': obj.storagePools?.map(y => y),
    'tags': obj.tags?.map(y => y),
    'taint': obj.taint?.map(y => toJson_ClusterV1Beta2SpecForProviderNodeConfigTaint(y)),
    'windowsNodeConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfigWindowsNodeConfig(obj.windowsNodeConfig),
    'workloadMetadataConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig(obj.workloadMetadataConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Node pool configs that apply to auto-provisioned node pools in
 * autopilot clusters and
 * node auto-provisioning-enabled clusters. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodePoolAutoConfig
 */
export interface ClusterV1Beta2SpecForProviderNodePoolAutoConfig {
  /**
   * Linux system configuration for the cluster's automatically provisioned node pools. Only cgroup_mode field is supported in node_pool_auto_config. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolAutoConfig#linuxNodeConfig
   */
  readonly linuxNodeConfig?: ClusterV1Beta2SpecForProviderNodePoolAutoConfigLinuxNodeConfig;

  /**
   * The network tag config for the cluster's automatically provisioned node pools. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolAutoConfig#networkTags
   */
  readonly networkTags?: ClusterV1Beta2SpecForProviderNodePoolAutoConfigNetworkTags;

  /**
   * Kubelet configuration for Autopilot clusters. Currently, only insecure_kubelet_readonly_port_enabled is supported here.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolAutoConfig#nodeKubeletConfig
   */
  readonly nodeKubeletConfig?: ClusterV1Beta2SpecForProviderNodePoolAutoConfigNodeKubeletConfig;

  /**
   * A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found here. A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. tagKeys/{tag_key_id}=tagValues/{tag_value_id} 2. {org_id}/{tag_key_name}={tag_value_name} 3. {project_id}/{tag_key_name}={tag_value_name}.
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolAutoConfig#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodePoolAutoConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodePoolAutoConfig(obj: ClusterV1Beta2SpecForProviderNodePoolAutoConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'linuxNodeConfig': toJson_ClusterV1Beta2SpecForProviderNodePoolAutoConfigLinuxNodeConfig(obj.linuxNodeConfig),
    'networkTags': toJson_ClusterV1Beta2SpecForProviderNodePoolAutoConfigNetworkTags(obj.networkTags),
    'nodeKubeletConfig': toJson_ClusterV1Beta2SpecForProviderNodePoolAutoConfigNodeKubeletConfig(obj.nodeKubeletConfig),
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Default NodePool settings for the entire cluster. These settings are overridden if specified on the specific NodePool object. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodePoolDefaults
 */
export interface ClusterV1Beta2SpecForProviderNodePoolDefaults {
  /**
   * Subset of NodeConfig message that has defaults.
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolDefaults#nodeConfigDefaults
   */
  readonly nodeConfigDefaults?: ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaults;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodePoolDefaults' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodePoolDefaults(obj: ClusterV1Beta2SpecForProviderNodePoolDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeConfigDefaults': toJson_ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaults(obj.nodeConfigDefaults),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for the cluster upgrade notifications feature. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNotificationConfig
 */
export interface ClusterV1Beta2SpecForProviderNotificationConfig {
  /**
   * The pubsub config for the cluster's upgrade notifications.
   *
   * @schema ClusterV1Beta2SpecForProviderNotificationConfig#pubsub
   */
  readonly pubsub?: ClusterV1Beta2SpecForProviderNotificationConfigPubsub;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNotificationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNotificationConfig(obj: ClusterV1Beta2SpecForProviderNotificationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pubsub': toJson_ClusterV1Beta2SpecForProviderNotificationConfigPubsub(obj.pubsub),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for the
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderPodAutoscaling
 */
export interface ClusterV1Beta2SpecForProviderPodAutoscaling {
  /**
   * Enable the Horizontal Pod Autoscaling profile for this cluster.
   * Acceptable values are:
   *
   * @schema ClusterV1Beta2SpecForProviderPodAutoscaling#hpaProfile
   */
  readonly hpaProfile?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderPodAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderPodAutoscaling(obj: ClusterV1Beta2SpecForProviderPodAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hpaProfile': obj.hpaProfile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for private clusters,
 * clusters with private nodes. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfig
 */
export interface ClusterV1Beta2SpecForProviderPrivateClusterConfig {
  /**
   * When true, the cluster's private
   * endpoint is used as the cluster endpoint and access through the public endpoint
   * is disabled. When false, either endpoint can be used. This field only applies
   * to private clusters, when enable_private_nodes is true.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfig#enablePrivateEndpoint
   */
  readonly enablePrivateEndpoint?: boolean;

  /**
   * Enables the private cluster feature,
   * creating a private endpoint on the cluster. In a private cluster, nodes only
   * have RFC 1918 private addresses and communicate with the master's private
   * endpoint via private networking.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfig#enablePrivateNodes
   */
  readonly enablePrivateNodes?: boolean;

  /**
   * Controls cluster master global
   * access settings. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfig#masterGlobalAccessConfig
   */
  readonly masterGlobalAccessConfig?: ClusterV1Beta2SpecForProviderPrivateClusterConfigMasterGlobalAccessConfig;

  /**
   * The IP range in CIDR notation to use for
   * the hosted master network. This range will be used for assigning private IP
   * addresses to the cluster master(s) and the ILB VIP. This range must not overlap
   * with any other ranges in use within the cluster's network, and it must be a /28
   * subnet. See Private Cluster Limitations
   * for more details. This field only applies to private clusters, when
   * enable_private_nodes is true.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfig#masterIpv4CidrBlock
   */
  readonly masterIpv4CidrBlock?: string;

  /**
   * Subnetwork in cluster's network where master's endpoint will be provisioned.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfig#privateEndpointSubnetwork
   */
  readonly privateEndpointSubnetwork?: string;

  /**
   * Reference to a Subnetwork in compute to populate privateEndpointSubnetwork.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfig#privateEndpointSubnetworkRef
   */
  readonly privateEndpointSubnetworkRef?: ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef;

  /**
   * Selector for a Subnetwork in compute to populate privateEndpointSubnetwork.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfig#privateEndpointSubnetworkSelector
   */
  readonly privateEndpointSubnetworkSelector?: ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderPrivateClusterConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderPrivateClusterConfig(obj: ClusterV1Beta2SpecForProviderPrivateClusterConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enablePrivateEndpoint': obj.enablePrivateEndpoint,
    'enablePrivateNodes': obj.enablePrivateNodes,
    'masterGlobalAccessConfig': toJson_ClusterV1Beta2SpecForProviderPrivateClusterConfigMasterGlobalAccessConfig(obj.masterGlobalAccessConfig),
    'masterIpv4CidrBlock': obj.masterIpv4CidrBlock,
    'privateEndpointSubnetwork': obj.privateEndpointSubnetwork,
    'privateEndpointSubnetworkRef': toJson_ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef(obj.privateEndpointSubnetworkRef),
    'privateEndpointSubnetworkSelector': toJson_ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector(obj.privateEndpointSubnetworkSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RBACBindingConfig allows user to restrict ClusterRoleBindings an RoleBindings that can be created. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderRbacBindingConfig
 */
export interface ClusterV1Beta2SpecForProviderRbacBindingConfig {
  /**
   * Setting this to true will allow any ClusterRoleBinding and RoleBinding with subjects system:authenticated.
   *
   * @schema ClusterV1Beta2SpecForProviderRbacBindingConfig#enableInsecureBindingSystemAuthenticated
   */
  readonly enableInsecureBindingSystemAuthenticated?: boolean;

  /**
   * Setting this to true will allow any ClusterRoleBinding and RoleBinding with subjects system:anonymous or system:unauthenticated.
   *
   * @schema ClusterV1Beta2SpecForProviderRbacBindingConfig#enableInsecureBindingSystemUnauthenticated
   */
  readonly enableInsecureBindingSystemUnauthenticated?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderRbacBindingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderRbacBindingConfig(obj: ClusterV1Beta2SpecForProviderRbacBindingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableInsecureBindingSystemAuthenticated': obj.enableInsecureBindingSystemAuthenticated,
    'enableInsecureBindingSystemUnauthenticated': obj.enableInsecureBindingSystemUnauthenticated,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration options for the Release channel
 * feature, which provide more control over automatic upgrades of your GKE clusters.
 * When updating this field, GKE imposes specific version requirements. See
 * Selecting a new release channel
 * for more details; the google_container_engine_versions datasource can provide
 * the default version for a channel. Instead, use the "UNSPECIFIED"
 * channel. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderReleaseChannel
 */
export interface ClusterV1Beta2SpecForProviderReleaseChannel {
  /**
   * The selected release channel.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecForProviderReleaseChannel#channel
   */
  readonly channel?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderReleaseChannel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderReleaseChannel(obj: ClusterV1Beta2SpecForProviderReleaseChannel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'channel': obj.channel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for the
 * ResourceUsageExportConfig feature.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderResourceUsageExportConfig
 */
export interface ClusterV1Beta2SpecForProviderResourceUsageExportConfig {
  /**
   * Parameters for using BigQuery as the destination of resource usage export.
   *
   * @schema ClusterV1Beta2SpecForProviderResourceUsageExportConfig#bigqueryDestination
   */
  readonly bigqueryDestination?: ClusterV1Beta2SpecForProviderResourceUsageExportConfigBigqueryDestination;

  /**
   * Whether to enable network egress metering for this cluster. If enabled, a daemonset will be created
   * in the cluster to meter network egress traffic.
   *
   * @schema ClusterV1Beta2SpecForProviderResourceUsageExportConfig#enableNetworkEgressMetering
   */
  readonly enableNetworkEgressMetering?: boolean;

  /**
   * Whether to enable resource
   * consumption metering on this cluster. When enabled, a table will be created in
   * the resource export BigQuery dataset to store resource consumption data. The
   * resulting table can be joined with the resource usage table or with BigQuery
   * billing export. Defaults to true.
   *
   * @default true.
   * @schema ClusterV1Beta2SpecForProviderResourceUsageExportConfig#enableResourceConsumptionMetering
   */
  readonly enableResourceConsumptionMetering?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderResourceUsageExportConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderResourceUsageExportConfig(obj: ClusterV1Beta2SpecForProviderResourceUsageExportConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigqueryDestination': toJson_ClusterV1Beta2SpecForProviderResourceUsageExportConfigBigqueryDestination(obj.bigqueryDestination),
    'enableNetworkEgressMetering': obj.enableNetworkEgressMetering,
    'enableResourceConsumptionMetering': obj.enableResourceConsumptionMetering,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for the
 * SecretManagerConfig feature.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderSecretManagerConfig
 */
export interface ClusterV1Beta2SpecForProviderSecretManagerConfig {
  /**
   * Enable the Secret Manager add-on for this cluster.
   *
   * @schema ClusterV1Beta2SpecForProviderSecretManagerConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderSecretManagerConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderSecretManagerConfig(obj: ClusterV1Beta2SpecForProviderSecretManagerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Enable/Disable Security Posture API features for the cluster. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderSecurityPostureConfig
 */
export interface ClusterV1Beta2SpecForProviderSecurityPostureConfig {
  /**
   * Sets the mode of the Kubernetes security posture API's off-cluster features. Available options include DISABLED, BASIC, and ENTERPRISE.
   *
   * @schema ClusterV1Beta2SpecForProviderSecurityPostureConfig#mode
   */
  readonly mode?: string;

  /**
   * Sets the mode of the Kubernetes security posture API's workload vulnerability scanning. Available options include VULNERABILITY_DISABLED, VULNERABILITY_BASIC and VULNERABILITY_ENTERPRISE.
   *
   * @schema ClusterV1Beta2SpecForProviderSecurityPostureConfig#vulnerabilityMode
   */
  readonly vulnerabilityMode?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderSecurityPostureConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderSecurityPostureConfig(obj: ClusterV1Beta2SpecForProviderSecurityPostureConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
    'vulnerabilityMode': obj.vulnerabilityMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderServiceExternalIpsConfig
 */
export interface ClusterV1Beta2SpecForProviderServiceExternalIpsConfig {
  /**
   * Controls whether external ips specified by a service will be allowed. It is enabled by default.
   *
   * @schema ClusterV1Beta2SpecForProviderServiceExternalIpsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderServiceExternalIpsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderServiceExternalIpsConfig(obj: ClusterV1Beta2SpecForProviderServiceExternalIpsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Subnetwork in compute to populate subnetwork.
 *
 * @schema ClusterV1Beta2SpecForProviderSubnetworkRef
 */
export interface ClusterV1Beta2SpecForProviderSubnetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterV1Beta2SpecForProviderSubnetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterV1Beta2SpecForProviderSubnetworkRef#policy
   */
  readonly policy?: ClusterV1Beta2SpecForProviderSubnetworkRefPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderSubnetworkRef(obj: ClusterV1Beta2SpecForProviderSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterV1Beta2SpecForProviderSubnetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Subnetwork in compute to populate subnetwork.
 *
 * @schema ClusterV1Beta2SpecForProviderSubnetworkSelector
 */
export interface ClusterV1Beta2SpecForProviderSubnetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterV1Beta2SpecForProviderSubnetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterV1Beta2SpecForProviderSubnetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterV1Beta2SpecForProviderSubnetworkSelector#policy
   */
  readonly policy?: ClusterV1Beta2SpecForProviderSubnetworkSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderSubnetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderSubnetworkSelector(obj: ClusterV1Beta2SpecForProviderSubnetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterV1Beta2SpecForProviderSubnetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The custom keys configuration of the cluster Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderUserManagedKeysConfig
 */
export interface ClusterV1Beta2SpecForProviderUserManagedKeysConfig {
  /**
   * The Certificate Authority Service caPool to use for the aggreation CA in this cluster.
   *
   * @schema ClusterV1Beta2SpecForProviderUserManagedKeysConfig#aggregationCa
   */
  readonly aggregationCa?: string;

  /**
   * The Certificate Authority Service caPool to use for the cluster CA in this cluster.
   *
   * @schema ClusterV1Beta2SpecForProviderUserManagedKeysConfig#clusterCa
   */
  readonly clusterCa?: string;

  /**
   * The Cloud KMS cryptoKey to use for Confidential Hyperdisk on the control plane nodes.
   *
   * @schema ClusterV1Beta2SpecForProviderUserManagedKeysConfig#controlPlaneDiskEncryptionKey
   */
  readonly controlPlaneDiskEncryptionKey?: string;

  /**
   * The Certificate Authority Service caPool to use for the etcd API CA in this cluster.
   *
   * @schema ClusterV1Beta2SpecForProviderUserManagedKeysConfig#etcdApiCa
   */
  readonly etcdApiCa?: string;

  /**
   * The Certificate Authority Service caPool to use for the etcd peer CA in this cluster.
   *
   * @schema ClusterV1Beta2SpecForProviderUserManagedKeysConfig#etcdPeerCa
   */
  readonly etcdPeerCa?: string;

  /**
   * Resource path of the Cloud KMS cryptoKey to use for encryption of internal etcd backups.
   *
   * @schema ClusterV1Beta2SpecForProviderUserManagedKeysConfig#gkeopsEtcdBackupEncryptionKey
   */
  readonly gkeopsEtcdBackupEncryptionKey?: string;

  /**
   * The Cloud KMS cryptoKeyVersions to use for signing service account JWTs issued by this cluster.
   *
   * @schema ClusterV1Beta2SpecForProviderUserManagedKeysConfig#serviceAccountSigningKeys
   */
  readonly serviceAccountSigningKeys?: string[];

  /**
   * The Cloud KMS cryptoKeyVersions to use for verifying service account JWTs issued by this cluster.
   *
   * @schema ClusterV1Beta2SpecForProviderUserManagedKeysConfig#serviceAccountVerificationKeys
   */
  readonly serviceAccountVerificationKeys?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderUserManagedKeysConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderUserManagedKeysConfig(obj: ClusterV1Beta2SpecForProviderUserManagedKeysConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationCa': obj.aggregationCa,
    'clusterCa': obj.clusterCa,
    'controlPlaneDiskEncryptionKey': obj.controlPlaneDiskEncryptionKey,
    'etcdApiCa': obj.etcdApiCa,
    'etcdPeerCa': obj.etcdPeerCa,
    'gkeopsEtcdBackupEncryptionKey': obj.gkeopsEtcdBackupEncryptionKey,
    'serviceAccountSigningKeys': obj.serviceAccountSigningKeys?.map(y => y),
    'serviceAccountVerificationKeys': obj.serviceAccountVerificationKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderVerticalPodAutoscaling
 */
export interface ClusterV1Beta2SpecForProviderVerticalPodAutoscaling {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderVerticalPodAutoscaling#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderVerticalPodAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderVerticalPodAutoscaling(obj: ClusterV1Beta2SpecForProviderVerticalPodAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Workload Identity allows Kubernetes service accounts to act as a user-managed
 * Google IAM Service Account.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderWorkloadIdentityConfig
 */
export interface ClusterV1Beta2SpecForProviderWorkloadIdentityConfig {
  /**
   * The workload pool to attach all Kubernetes service accounts to.
   *
   * @schema ClusterV1Beta2SpecForProviderWorkloadIdentityConfig#workloadPool
   */
  readonly workloadPool?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderWorkloadIdentityConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderWorkloadIdentityConfig(obj: ClusterV1Beta2SpecForProviderWorkloadIdentityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'workloadPool': obj.workloadPool,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration for addons supported by GKE.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfig
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfig {
  /**
   * . Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfig#cloudrunConfig
   */
  readonly cloudrunConfig?: ClusterV1Beta2SpecInitProviderAddonsConfigCloudrunConfig;

  /**
   * .
   * The status of the ConfigConnector addon. It is disabled by default; Set enabled = true to enable.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfig#configConnectorConfig
   */
  readonly configConnectorConfig?: ClusterV1Beta2SpecInitProviderAddonsConfigConfigConnectorConfig;

  /**
   * .
   * The status of the NodeLocal DNSCache addon. It is disabled by default.
   * Set enabled = true to enable.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfig#dnsCacheConfig
   */
  readonly dnsCacheConfig?: ClusterV1Beta2SpecInitProviderAddonsConfigDnsCacheConfig;

  /**
   * .
   * Whether this cluster should enable the Google Compute Engine Persistent Disk Container Storage Interface (CSI) Driver. Set enabled = true to enable.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfig#gcePersistentDiskCsiDriverConfig
   */
  readonly gcePersistentDiskCsiDriverConfig?: ClusterV1Beta2SpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig;

  /**
   * The status of the Filestore CSI driver addon,
   * which allows the usage of filestore instance as volumes.
   * It is disabled by default; set enabled = true to enable.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfig#gcpFilestoreCsiDriverConfig
   */
  readonly gcpFilestoreCsiDriverConfig?: ClusterV1Beta2SpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig;

  /**
   * The status of the GCSFuse CSI driver addon,
   * which allows the usage of a gcs bucket as volumes.
   * It is disabled by default for Standard clusters; set enabled = true to enable.
   * It is enabled by default for Autopilot clusters with version 1.24 or later; set enabled = true to enable it explicitly.
   * See Enable the Cloud Storage FUSE CSI driver for more information.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfig#gcsFuseCsiDriverConfig
   */
  readonly gcsFuseCsiDriverConfig?: ClusterV1Beta2SpecInitProviderAddonsConfigGcsFuseCsiDriverConfig;

  /**
   * .
   * The status of the Backup for GKE agent addon. It is disabled by default; Set enabled = true to enable.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfig#gkeBackupAgentConfig
   */
  readonly gkeBackupAgentConfig?: ClusterV1Beta2SpecInitProviderAddonsConfigGkeBackupAgentConfig;

  /**
   * The status of the Horizontal Pod Autoscaling
   * addon, which increases or decreases the number of replica pods a replication controller
   * has based on the resource usage of the existing pods.
   * It is enabled by default;
   * set disabled = true to disable.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfig#horizontalPodAutoscaling
   */
  readonly horizontalPodAutoscaling?: ClusterV1Beta2SpecInitProviderAddonsConfigHorizontalPodAutoscaling;

  /**
   * The status of the HTTP (L7) load balancing
   * controller addon, which makes it easy to set up HTTP load balancers for services in a
   * cluster. It is enabled by default; set disabled = true to disable.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfig#httpLoadBalancing
   */
  readonly httpLoadBalancing?: ClusterV1Beta2SpecInitProviderAddonsConfigHttpLoadBalancing;

  /**
   * The status of the Lustre CSI driver addon,
   * which allows the usage of a Lustre instances as volumes.
   * It is disabled by default for Standard clusters; set enabled = true to enable.
   * It is disabled by default for Autopilot clusters; set enabled = true to enable.
   * Lustre CSI Driver Config has optional subfield
   * enable_legacy_lustre_port which allows the Lustre CSI driver to initialize LNet (the virtual networklayer for Lustre kernel module) using port 6988.
   * This flag is required to workaround a port conflict with the gke-metadata-server on GKE nodes.
   * See Enable Lustre CSI driver for more information.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfig#lustreCsiDriverConfig
   */
  readonly lustreCsiDriverConfig?: ClusterV1Beta2SpecInitProviderAddonsConfigLustreCsiDriverConfig;

  /**
   * Whether we should enable the network policy addon
   * for the master.  This must be enabled in order to enable network policy for the nodes.
   * To enable this, you must also define a network_policy block,
   * otherwise nothing will happen.
   * It can only be disabled if the nodes already do not have network policies enabled.
   * Defaults to disabled; set disabled = false to enable.
   *
   * @default disabled; set disabled = false to enable.
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfig#networkPolicyConfig
   */
  readonly networkPolicyConfig?: ClusterV1Beta2SpecInitProviderAddonsConfigNetworkPolicyConfig;

  /**
   * The status of the Parallelstore CSI driver addon,
   * which allows the usage of a Parallelstore instances as volumes.
   * It is disabled by default for Standard clusters; set enabled = true to enable.
   * It is enabled by default for Autopilot clusters with version 1.29 or later; set enabled = true to enable it explicitly.
   * See Enable the Parallelstore CSI driver for more information.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfig#parallelstoreCsiDriverConfig
   */
  readonly parallelstoreCsiDriverConfig?: ClusterV1Beta2SpecInitProviderAddonsConfigParallelstoreCsiDriverConfig;

  /**
   * . The status of the Ray Operator
   * addon.
   * It is disabled by default. Set enabled = true to enable. The minimum
   * cluster version to enable Ray is 1.30.0-gke.1747000.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfig#rayOperatorConfig
   */
  readonly rayOperatorConfig?: ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfig[];

  /**
   * .
   * The status of the Stateful HA addon, which provides automatic configurable failover for stateful applications.
   * It is disabled by default for Standard clusters. Set enabled = true to enable.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfig#statefulHaConfig
   */
  readonly statefulHaConfig?: ClusterV1Beta2SpecInitProviderAddonsConfigStatefulHaConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfig(obj: ClusterV1Beta2SpecInitProviderAddonsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudrunConfig': toJson_ClusterV1Beta2SpecInitProviderAddonsConfigCloudrunConfig(obj.cloudrunConfig),
    'configConnectorConfig': toJson_ClusterV1Beta2SpecInitProviderAddonsConfigConfigConnectorConfig(obj.configConnectorConfig),
    'dnsCacheConfig': toJson_ClusterV1Beta2SpecInitProviderAddonsConfigDnsCacheConfig(obj.dnsCacheConfig),
    'gcePersistentDiskCsiDriverConfig': toJson_ClusterV1Beta2SpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig(obj.gcePersistentDiskCsiDriverConfig),
    'gcpFilestoreCsiDriverConfig': toJson_ClusterV1Beta2SpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig(obj.gcpFilestoreCsiDriverConfig),
    'gcsFuseCsiDriverConfig': toJson_ClusterV1Beta2SpecInitProviderAddonsConfigGcsFuseCsiDriverConfig(obj.gcsFuseCsiDriverConfig),
    'gkeBackupAgentConfig': toJson_ClusterV1Beta2SpecInitProviderAddonsConfigGkeBackupAgentConfig(obj.gkeBackupAgentConfig),
    'horizontalPodAutoscaling': toJson_ClusterV1Beta2SpecInitProviderAddonsConfigHorizontalPodAutoscaling(obj.horizontalPodAutoscaling),
    'httpLoadBalancing': toJson_ClusterV1Beta2SpecInitProviderAddonsConfigHttpLoadBalancing(obj.httpLoadBalancing),
    'lustreCsiDriverConfig': toJson_ClusterV1Beta2SpecInitProviderAddonsConfigLustreCsiDriverConfig(obj.lustreCsiDriverConfig),
    'networkPolicyConfig': toJson_ClusterV1Beta2SpecInitProviderAddonsConfigNetworkPolicyConfig(obj.networkPolicyConfig),
    'parallelstoreCsiDriverConfig': toJson_ClusterV1Beta2SpecInitProviderAddonsConfigParallelstoreCsiDriverConfig(obj.parallelstoreCsiDriverConfig),
    'rayOperatorConfig': obj.rayOperatorConfig?.map(y => toJson_ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfig(y)),
    'statefulHaConfig': toJson_ClusterV1Beta2SpecInitProviderAddonsConfigStatefulHaConfig(obj.statefulHaConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for anonymous authentication restrictions. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderAnonymousAuthenticationConfig
 */
export interface ClusterV1Beta2SpecInitProviderAnonymousAuthenticationConfig {
  /**
   * Sets or removes authentication restrictions. Available options include LIMITED and ENABLED.
   *
   * @schema ClusterV1Beta2SpecInitProviderAnonymousAuthenticationConfig#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAnonymousAuthenticationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAnonymousAuthenticationConfig(obj: ClusterV1Beta2SpecInitProviderAnonymousAuthenticationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for the
 * Google Groups for GKE feature.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderAuthenticatorGroupsConfig
 */
export interface ClusterV1Beta2SpecInitProviderAuthenticatorGroupsConfig {
  /**
   * The name of the RBAC security group for use with Google security groups in Kubernetes RBAC. Group name must be in format gke-security-groups@yourdomain.com.
   *
   * @schema ClusterV1Beta2SpecInitProviderAuthenticatorGroupsConfig#securityGroup
   */
  readonly securityGroup?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAuthenticatorGroupsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAuthenticatorGroupsConfig(obj: ClusterV1Beta2SpecInitProviderAuthenticatorGroupsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroup': obj.securityGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration options for the Binary
 * Authorization feature. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderBinaryAuthorization
 */
export interface ClusterV1Beta2SpecInitProviderBinaryAuthorization {
  /**
   * (DEPRECATED) Enable Binary Authorization for this cluster. Deprecated in favor of evaluation_mode.
   *
   * @schema ClusterV1Beta2SpecInitProviderBinaryAuthorization#enabled
   */
  readonly enabled?: boolean;

  /**
   * Mode of operation for Binary Authorization policy evaluation. Valid values are DISABLED
   * and PROJECT_SINGLETON_POLICY_ENFORCE.
   *
   * @schema ClusterV1Beta2SpecInitProviderBinaryAuthorization#evaluationMode
   */
  readonly evaluationMode?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderBinaryAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderBinaryAuthorization(obj: ClusterV1Beta2SpecInitProviderBinaryAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'evaluationMode': obj.evaluationMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to
 * automatically adjust the size of the cluster and create/delete node pools based
 * on the current needs of the cluster's workload. See the
 * guide to using Node Auto-Provisioning
 * for more details. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderClusterAutoscaling
 */
export interface ClusterV1Beta2SpecInitProviderClusterAutoscaling {
  /**
   * Contains defaults for a node pool created by NAP. A subset of fields also apply to
   * GKE Autopilot clusters.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscaling#autoProvisioningDefaults
   */
  readonly autoProvisioningDefaults?: ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults;

  /**
   * The list of Google Compute Engine
   * zones in which the
   * NodePool's nodes can be created by NAP.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscaling#autoProvisioningLocations
   */
  readonly autoProvisioningLocations?: string[];

  /**
   * Configuration
   * options for the Autoscaling profile
   * feature, which lets you choose whether the cluster autoscaler should optimize for resource utilization or resource availability
   * when deciding to remove nodes from a cluster. Can be BALANCED or OPTIMIZE_UTILIZATION. Defaults to BALANCED.
   *
   * @default BALANCED.
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscaling#autoscalingProfile
   */
  readonly autoscalingProfile?: string;

  /**
   * Whether node auto-provisioning is enabled. Must be supplied for GKE Standard clusters, true is implied
   * for autopilot clusters. Resource limits for cpu and memory must be defined to enable node auto-provisioning for GKE Standard.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscaling#enabled
   */
  readonly enabled?: boolean;

  /**
   * Global constraints for machine resources in the
   * cluster. Configuring the cpu and memory types is required if node
   * auto-provisioning is enabled. These limits will apply to node pool autoscaling
   * in addition to node auto-provisioning. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscaling#resourceLimits
   */
  readonly resourceLimits?: ClusterV1Beta2SpecInitProviderClusterAutoscalingResourceLimits[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderClusterAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderClusterAutoscaling(obj: ClusterV1Beta2SpecInitProviderClusterAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoProvisioningDefaults': toJson_ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults(obj.autoProvisioningDefaults),
    'autoProvisioningLocations': obj.autoProvisioningLocations?.map(y => y),
    'autoscalingProfile': obj.autoscalingProfile,
    'enabled': obj.enabled,
    'resourceLimits': obj.resourceLimits?.map(y => toJson_ClusterV1Beta2SpecInitProviderClusterAutoscalingResourceLimits(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for Confidential Nodes feature. Structure is documented below documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderConfidentialNodes
 */
export interface ClusterV1Beta2SpecInitProviderConfidentialNodes {
  /**
   * Defines the type of technology used
   * by the confidential node.
   *
   * @schema ClusterV1Beta2SpecInitProviderConfidentialNodes#confidentialInstanceType
   */
  readonly confidentialInstanceType?: string;

  /**
   * Enable Confidential GKE Nodes for this node pool, to
   * enforce encryption of data in-use.
   *
   * @schema ClusterV1Beta2SpecInitProviderConfidentialNodes#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderConfidentialNodes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderConfidentialNodes(obj: ClusterV1Beta2SpecInitProviderConfidentialNodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confidentialInstanceType': obj.confidentialInstanceType,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for all of the cluster's control plane endpoints.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfig
 */
export interface ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfig {
  /**
   * DNS endpoint configuration.
   *
   * @schema ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfig#dnsEndpointConfig
   */
  readonly dnsEndpointConfig?: ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig;

  /**
   * IP endpoint configuration.
   *
   * @schema ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfig#ipEndpointsConfig
   */
  readonly ipEndpointsConfig?: ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfig(obj: ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsEndpointConfig': toJson_ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig(obj.dnsEndpointConfig),
    'ipEndpointsConfig': toJson_ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig(obj.ipEndpointsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for the
 * Cost Allocation feature.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderCostManagementConfig
 */
export interface ClusterV1Beta2SpecInitProviderCostManagementConfig {
  /**
   * Whether to enable the cost allocation feature.
   *
   * @schema ClusterV1Beta2SpecInitProviderCostManagementConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderCostManagementConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderCostManagementConfig(obj: ClusterV1Beta2SpecInitProviderCostManagementConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderDatabaseEncryption
 */
export interface ClusterV1Beta2SpecInitProviderDatabaseEncryption {
  /**
   * the key to use to encrypt/decrypt secrets.  See the DatabaseEncryption definition for more information.
   *
   * @schema ClusterV1Beta2SpecInitProviderDatabaseEncryption#keyName
   */
  readonly keyName?: string;

  /**
   * ENCRYPTED or DECRYPTED
   *
   * @schema ClusterV1Beta2SpecInitProviderDatabaseEncryption#state
   */
  readonly state?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderDatabaseEncryption' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderDatabaseEncryption(obj: ClusterV1Beta2SpecInitProviderDatabaseEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GKE SNAT DefaultSnatStatus contains the desired state of whether default sNAT should be disabled on the cluster, API doc. Structure is documented below
 *
 * @schema ClusterV1Beta2SpecInitProviderDefaultSnatStatus
 */
export interface ClusterV1Beta2SpecInitProviderDefaultSnatStatus {
  /**
   * Whether the cluster disables default in-node sNAT rules. In-node sNAT rules will be disabled when defaultSnatStatus is disabled.When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic
   *
   * @schema ClusterV1Beta2SpecInitProviderDefaultSnatStatus#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderDefaultSnatStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderDefaultSnatStatus(obj: ClusterV1Beta2SpecInitProviderDefaultSnatStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for Using Cloud DNS for GKE. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderDnsConfig
 */
export interface ClusterV1Beta2SpecInitProviderDnsConfig {
  /**
   * This will enable Cloud DNS additive VPC scope. Must provide a domain name that is unique within the VPC. For this to work cluster_dns = "CLOUD_DNS" and cluster_dns_scope = "CLUSTER_SCOPE" must both be set as well.
   *
   * @schema ClusterV1Beta2SpecInitProviderDnsConfig#additiveVpcScopeDnsDomain
   */
  readonly additiveVpcScopeDnsDomain?: string;

  /**
   * Which in-cluster DNS provider should be used. PROVIDER_UNSPECIFIED (default) or PLATFORM_DEFAULT or CLOUD_DNS.
   *
   * @schema ClusterV1Beta2SpecInitProviderDnsConfig#clusterDns
   */
  readonly clusterDns?: string;

  /**
   * The suffix used for all cluster service records.
   *
   * @schema ClusterV1Beta2SpecInitProviderDnsConfig#clusterDnsDomain
   */
  readonly clusterDnsDomain?: string;

  /**
   * The scope of access to cluster DNS records. DNS_SCOPE_UNSPECIFIED or CLUSTER_SCOPE or VPC_SCOPE. If the cluster_dns field is set to CLOUD_DNS, DNS_SCOPE_UNSPECIFIED and empty/null behave like CLUSTER_SCOPE.
   *
   * @schema ClusterV1Beta2SpecInitProviderDnsConfig#clusterDnsScope
   */
  readonly clusterDnsScope?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderDnsConfig(obj: ClusterV1Beta2SpecInitProviderDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additiveVpcScopeDnsDomain': obj.additiveVpcScopeDnsDomain,
    'clusterDns': obj.clusterDns,
    'clusterDnsDomain': obj.clusterDnsDomain,
    'clusterDnsScope': obj.clusterDnsScope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for Kubernetes Beta APIs.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderEnableK8SBetaApis
 */
export interface ClusterV1Beta2SpecInitProviderEnableK8SBetaApis {
  /**
   * Enabled Kubernetes Beta APIs. To list a Beta API resource, use the representation {group}/{version}/{resource}. The version must be a Beta version. Note that you cannot disable beta APIs that are already enabled on a cluster without recreating it. See the Configure beta APIs for more information.
   *
   * @schema ClusterV1Beta2SpecInitProviderEnableK8SBetaApis#enabledApis
   */
  readonly enabledApis?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderEnableK8SBetaApis' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderEnableK8SBetaApis(obj: ClusterV1Beta2SpecInitProviderEnableK8SBetaApis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabledApis': obj.enabledApis?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for [Enterprise edition].(https://cloud.google.com/kubernetes-engine/enterprise/docs/concepts/gke-editions). Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderEnterpriseConfig
 */
export interface ClusterV1Beta2SpecInitProviderEnterpriseConfig {
  /**
   * Sets the tier of the cluster. Available options include STANDARD and ENTERPRISE.
   *
   * @schema ClusterV1Beta2SpecInitProviderEnterpriseConfig#desiredTier
   */
  readonly desiredTier?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderEnterpriseConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderEnterpriseConfig(obj: ClusterV1Beta2SpecInitProviderEnterpriseConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'desiredTier': obj.desiredTier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fleet configuration for the cluster. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderFleet
 */
export interface ClusterV1Beta2SpecInitProviderFleet {
  /**
   * The name of the Fleet host project where this cluster will be registered.
   *
   * @schema ClusterV1Beta2SpecInitProviderFleet#project
   */
  readonly project?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderFleet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderFleet(obj: ClusterV1Beta2SpecInitProviderFleet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for GKE Gateway API controller. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderGatewayApiConfig
 */
export interface ClusterV1Beta2SpecInitProviderGatewayApiConfig {
  /**
   * Which Gateway Api channel should be used. CHANNEL_DISABLED, CHANNEL_EXPERIMENTAL or CHANNEL_STANDARD.
   *
   * @schema ClusterV1Beta2SpecInitProviderGatewayApiConfig#channel
   */
  readonly channel?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderGatewayApiConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderGatewayApiConfig(obj: ClusterV1Beta2SpecInitProviderGatewayApiConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'channel': obj.channel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration options for the auto-upgrade patch type feature, which provide more control over the speed of automatic upgrades of your GKE clusters.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderGkeAutoUpgradeConfig
 */
export interface ClusterV1Beta2SpecInitProviderGkeAutoUpgradeConfig {
  /**
   * The selected patch mode.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecInitProviderGkeAutoUpgradeConfig#patchMode
   */
  readonly patchMode?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderGkeAutoUpgradeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderGkeAutoUpgradeConfig(obj: ClusterV1Beta2SpecInitProviderGkeAutoUpgradeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'patchMode': obj.patchMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * . Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderIdentityServiceConfig
 */
export interface ClusterV1Beta2SpecInitProviderIdentityServiceConfig {
  /**
   * Whether to enable the Identity Service component. It is disabled by default. Set enabled=true to enable.
   *
   * @schema ClusterV1Beta2SpecInitProviderIdentityServiceConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderIdentityServiceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderIdentityServiceConfig(obj: ClusterV1Beta2SpecInitProviderIdentityServiceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of cluster IP allocation for
 * VPC-native clusters. If this block is unset during creation, it will be set by the GKE backend.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicy
 */
export interface ClusterV1Beta2SpecInitProviderIpAllocationPolicy {
  /**
   * The configuration for individual additional subnetworks attached to the cluster.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicy#additionalIpRangesConfig
   */
  readonly additionalIpRangesConfig?: ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig[];

  /**
   * The configuration for additional pod secondary ranges at
   * the cluster level. Used for Autopilot clusters and Standard clusters with which control of the
   * secondary Pod IP address assignment to node pools isn't needed. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicy#additionalPodRangesConfig
   */
  readonly additionalPodRangesConfig?: ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig;

  /**
   * The IP address range for the cluster pod IPs.
   * Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
   * to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
   * from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
   * pick a specific range to use.
   *
   * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicy#clusterIpv4CidrBlock
   */
  readonly clusterIpv4CidrBlock?: string;

  /**
   * The name of the existing secondary
   * range in the cluster's subnetwork to use for pod IP addresses. Alternatively,
   * cluster_ipv4_cidr_block can be used to automatically create a GKE-managed one.
   *
   * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicy#clusterSecondaryRangeName
   */
  readonly clusterSecondaryRangeName?: string;

  /**
   * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicy#podCidrOverprovisionConfig
   */
  readonly podCidrOverprovisionConfig?: ClusterV1Beta2SpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig;

  /**
   * The IP address range of the services IPs in this cluster.
   * Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
   * to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
   * from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
   * pick a specific range to use.
   *
   * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicy#servicesIpv4CidrBlock
   */
  readonly servicesIpv4CidrBlock?: string;

  /**
   * The name of the existing
   * secondary range in the cluster's subnetwork to use for service ClusterIPs.
   * Alternatively, services_ipv4_cidr_block can be used to automatically create a
   * GKE-managed one.
   *
   * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicy#servicesSecondaryRangeName
   */
  readonly servicesSecondaryRangeName?: string;

  /**
   * The IP Stack Type of the cluster.
   * Default value is IPV4.
   * Possible values are IPV4 and IPV4_IPV6.
   *
   * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicy#stackType
   */
  readonly stackType?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderIpAllocationPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderIpAllocationPolicy(obj: ClusterV1Beta2SpecInitProviderIpAllocationPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalIpRangesConfig': obj.additionalIpRangesConfig?.map(y => toJson_ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig(y)),
    'additionalPodRangesConfig': toJson_ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig(obj.additionalPodRangesConfig),
    'clusterIpv4CidrBlock': obj.clusterIpv4CidrBlock,
    'clusterSecondaryRangeName': obj.clusterSecondaryRangeName,
    'podCidrOverprovisionConfig': toJson_ClusterV1Beta2SpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig(obj.podCidrOverprovisionConfig),
    'servicesIpv4CidrBlock': obj.servicesIpv4CidrBlock,
    'servicesSecondaryRangeName': obj.servicesSecondaryRangeName,
    'stackType': obj.stackType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Logging configuration for the cluster.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderLoggingConfig
 */
export interface ClusterV1Beta2SpecInitProviderLoggingConfig {
  /**
   * The GKE components exposing logs. Supported values include:
   * SYSTEM_COMPONENTS, APISERVER, CONTROLLER_MANAGER, SCHEDULER, and WORKLOADS.
   *
   * @schema ClusterV1Beta2SpecInitProviderLoggingConfig#enableComponents
   */
  readonly enableComponents?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderLoggingConfig(obj: ClusterV1Beta2SpecInitProviderLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableComponents': obj.enableComponents?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The maintenance policy to use for the cluster. Structure is
 * documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicy
 */
export interface ClusterV1Beta2SpecInitProviderMaintenancePolicy {
  /**
   * structure documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicy#dailyMaintenanceWindow
   */
  readonly dailyMaintenanceWindow?: ClusterV1Beta2SpecInitProviderMaintenancePolicyDailyMaintenanceWindow;

  /**
   * structure documented below
   *
   * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicy#maintenanceExclusion
   */
  readonly maintenanceExclusion?: ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusion[];

  /**
   * structure documented below
   *
   * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicy#recurringWindow
   */
  readonly recurringWindow?: ClusterV1Beta2SpecInitProviderMaintenancePolicyRecurringWindow;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderMaintenancePolicy(obj: ClusterV1Beta2SpecInitProviderMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dailyMaintenanceWindow': toJson_ClusterV1Beta2SpecInitProviderMaintenancePolicyDailyMaintenanceWindow(obj.dailyMaintenanceWindow),
    'maintenanceExclusion': obj.maintenanceExclusion?.map(y => toJson_ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusion(y)),
    'recurringWindow': toJson_ClusterV1Beta2SpecInitProviderMaintenancePolicyRecurringWindow(obj.recurringWindow),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The authentication information for accessing the
 * Kubernetes master. Some values in this block are only returned by the API if
 * your service account has permission to get credentials for your GKE cluster. If
 * you see an unexpected diff unsetting your client cert, ensure you have the
 * container.clusters.getCredentials permission.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderMasterAuth
 */
export interface ClusterV1Beta2SpecInitProviderMasterAuth {
  /**
   * Whether client certificate authorization is enabled for this cluster.  For example:
   *
   * @schema ClusterV1Beta2SpecInitProviderMasterAuth#clientCertificateConfig
   */
  readonly clientCertificateConfig?: ClusterV1Beta2SpecInitProviderMasterAuthClientCertificateConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderMasterAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderMasterAuth(obj: ClusterV1Beta2SpecInitProviderMasterAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertificateConfig': toJson_ClusterV1Beta2SpecInitProviderMasterAuthClientCertificateConfig(obj.clientCertificateConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The desired
 * configuration options for master authorized networks. Omit the
 * nested cidr_blocks attribute to disallow external access (except
 * the cluster node IPs, which GKE automatically whitelists).
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfig
 */
export interface ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfig {
  /**
   * External networks that can access the
   * Kubernetes cluster master through HTTPS.
   *
   * @schema ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfig#cidrBlocks
   */
  readonly cidrBlocks?: ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks[];

  /**
   * Whether Kubernetes master is
   * accessible via Google Compute Engine Public IPs.
   *
   * @schema ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfig#gcpPublicCidrsAccessEnabled
   */
  readonly gcpPublicCidrsAccessEnabled?: boolean;

  /**
   * Whether authorized networks is enforced on the private endpoint or not.
   *
   * @schema ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfig#privateEndpointEnforcementEnabled
   */
  readonly privateEndpointEnforcementEnabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfig(obj: ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrBlocks': obj.cidrBlocks?.map(y => toJson_ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks(y)),
    'gcpPublicCidrsAccessEnabled': obj.gcpPublicCidrsAccessEnabled,
    'privateEndpointEnforcementEnabled': obj.privateEndpointEnforcementEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderMeshCertificates
 */
export interface ClusterV1Beta2SpecInitProviderMeshCertificates {
  /**
   * Controls the issuance of workload mTLS certificates. It is enabled by default. Workload Identity is required, see workload_config.
   *
   * @schema ClusterV1Beta2SpecInitProviderMeshCertificates#enableCertificates
   */
  readonly enableCertificates?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderMeshCertificates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderMeshCertificates(obj: ClusterV1Beta2SpecInitProviderMeshCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableCertificates': obj.enableCertificates,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Monitoring configuration for the cluster.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderMonitoringConfig
 */
export interface ClusterV1Beta2SpecInitProviderMonitoringConfig {
  /**
   * Configuration for Advanced Datapath Monitoring. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderMonitoringConfig#advancedDatapathObservabilityConfig
   */
  readonly advancedDatapathObservabilityConfig?: ClusterV1Beta2SpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig;

  /**
   * The GKE components exposing metrics. Supported values include: SYSTEM_COMPONENTS, APISERVER, SCHEDULER, CONTROLLER_MANAGER, STORAGE, HPA, POD, DAEMONSET, DEPLOYMENT, STATEFULSET, KUBELET, CADVISOR, DCGM and JOBSET. In beta provider, WORKLOADS is supported on top of those 12 values. (WORKLOADS is deprecated and removed in GKE 1.24.) KUBELET and CADVISOR are only supported in GKE 1.29.3-gke.1093000 and above. JOBSET is only supported in GKE 1.32.1-gke.1357001 and above.
   *
   * @schema ClusterV1Beta2SpecInitProviderMonitoringConfig#enableComponents
   */
  readonly enableComponents?: string[];

  /**
   * Configuration for Managed Service for Prometheus. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderMonitoringConfig#managedPrometheus
   */
  readonly managedPrometheus?: ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheus;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderMonitoringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderMonitoringConfig(obj: ClusterV1Beta2SpecInitProviderMonitoringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedDatapathObservabilityConfig': toJson_ClusterV1Beta2SpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig(obj.advancedDatapathObservabilityConfig),
    'enableComponents': obj.enableComponents?.map(y => y),
    'managedPrometheus': toJson_ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheus(obj.managedPrometheus),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Network bandwidth tier configuration. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNetworkPerformanceConfig
 */
export interface ClusterV1Beta2SpecInitProviderNetworkPerformanceConfig {
  /**
   * Specifies the total network bandwidth tier for NodePools in the cluster.
   *
   * @schema ClusterV1Beta2SpecInitProviderNetworkPerformanceConfig#totalEgressBandwidthTier
   */
  readonly totalEgressBandwidthTier?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNetworkPerformanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNetworkPerformanceConfig(obj: ClusterV1Beta2SpecInitProviderNetworkPerformanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'totalEgressBandwidthTier': obj.totalEgressBandwidthTier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration options for the
 * NetworkPolicy
 * feature. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNetworkPolicy
 */
export interface ClusterV1Beta2SpecInitProviderNetworkPolicy {
  /**
   * Whether network policy is enabled on the cluster.
   *
   * @schema ClusterV1Beta2SpecInitProviderNetworkPolicy#enabled
   */
  readonly enabled?: boolean;

  /**
   * The selected network policy provider. Defaults to PROVIDER_UNSPECIFIED.
   *
   * @default PROVIDER_UNSPECIFIED.
   * @schema ClusterV1Beta2SpecInitProviderNetworkPolicy#provider
   */
  readonly provider?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNetworkPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNetworkPolicy(obj: ClusterV1Beta2SpecInitProviderNetworkPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'provider': obj.provider,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema ClusterV1Beta2SpecInitProviderNetworkRef
 */
export interface ClusterV1Beta2SpecInitProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterV1Beta2SpecInitProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterV1Beta2SpecInitProviderNetworkRef#policy
   */
  readonly policy?: ClusterV1Beta2SpecInitProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNetworkRef(obj: ClusterV1Beta2SpecInitProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterV1Beta2SpecInitProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema ClusterV1Beta2SpecInitProviderNetworkSelector
 */
export interface ClusterV1Beta2SpecInitProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterV1Beta2SpecInitProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterV1Beta2SpecInitProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterV1Beta2SpecInitProviderNetworkSelector#policy
   */
  readonly policy?: ClusterV1Beta2SpecInitProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNetworkSelector(obj: ClusterV1Beta2SpecInitProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterV1Beta2SpecInitProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters used in creating the default node pool. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfig {
  /**
   * Specifies options for controlling
   * advanced machine features. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#advancedMachineFeatures
   */
  readonly advancedMachineFeatures?: ClusterV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures;

  /**
   * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#bootDiskKmsKey
   */
  readonly bootDiskKmsKey?: string;

  /**
   * Configuration for Confidential Nodes feature. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#confidentialNodes
   */
  readonly confidentialNodes?: ClusterV1Beta2SpecInitProviderNodeConfigConfidentialNodes;

  /**
   * Parameters to customize containerd runtime. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#containerdConfig
   */
  readonly containerdConfig?: ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfig;

  /**
   * Size of the disk attached to each node, specified
   * in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
   *
   * @default 100GB.
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#diskSizeGb
   */
  readonly diskSizeGb?: number;

  /**
   * Type of the disk attached to each node
   * (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-balanced'
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#diskType
   */
  readonly diskType?: string;

  /**
   * Enabling Confidential Storage will create boot disk with confidential mode. It is disabled by default.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#enableConfidentialStorage
   */
  readonly enableConfidentialStorage?: boolean;

  /**
   * Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#ephemeralStorageLocalSsdConfig
   */
  readonly ephemeralStorageLocalSsdConfig?: ClusterV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig;

  /**
   * Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
   * Node Pool must enable gvnic.
   * GKE version 1.25.2-gke.1700 or later.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#fastSocket
   */
  readonly fastSocket?: ClusterV1Beta2SpecInitProviderNodeConfigFastSocket;

  /**
   * Enables Flex Start provisioning model for the node pool.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#flexStart
   */
  readonly flexStart?: boolean;

  /**
   * Parameters for the Google Container Filesystem (GCFS).
   * If unspecified, GCFS will not be enabled on the node pool. When enabling this feature you must specify image_type = "COS_CONTAINERD" and node_version from GKE versions 1.19 or later to use it.
   * For GKE versions 1.19, 1.20, and 1.21, the recommended minimum node_version would be 1.19.15-gke.1300, 1.20.11-gke.1300, and 1.21.5-gke.1300 respectively.
   * A machine_type that has more than 16 GiB of memory is also recommended.
   * GCFS must be enabled in order to use image streaming.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#gcfsConfig
   */
  readonly gcfsConfig?: ClusterV1Beta2SpecInitProviderNodeConfigGcfsConfig;

  /**
   * List of the type and count of accelerator cards attached to the instance.
   * Structure documented below.
   * Note: As of 6.0.0, argument syntax
   * is no longer supported for this field in favor of block syntax.
   * To dynamically set a list of guest accelerators, use dynamic blocks.
   * To set an empty list, use a single guest_accelerator block with count = 0.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#guestAccelerator
   */
  readonly guestAccelerator?: ClusterV1Beta2SpecInitProviderNodeConfigGuestAccelerator[];

  /**
   * Google Virtual NIC (gVNIC) is a virtual network interface.
   * Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
   * gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
   * GKE node version 1.15.11-gke.15 or later
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#gvnic
   */
  readonly gvnic?: ClusterV1Beta2SpecInitProviderNodeConfigGvnic;

  /**
   * The maintenance policy to use for the cluster. Structure is
   * documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#hostMaintenancePolicy
   */
  readonly hostMaintenancePolicy?: ClusterV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy;

  /**
   * The image type to use for this node. Note that changing the image type
   * will delete and recreate all nodes in the node pool.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#imageType
   */
  readonly imageType?: string;

  /**
   * Kubelet configuration, currently supported attributes can be found here.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#kubeletConfig
   */
  readonly kubeletConfig?: ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig;

  /**
   * The Kubernetes labels (key/value pairs) to be applied to each node. The kubernetes.io/ and k8s.io/ prefixes are
   * reserved by Kubernetes Core components and cannot be specified.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Parameters that can be configured on Linux nodes. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#linuxNodeConfig
   */
  readonly linuxNodeConfig?: ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig;

  /**
   * Parameters for the local NVMe SSDs. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#localNvmeSsdBlockConfig
   */
  readonly localNvmeSsdBlockConfig?: ClusterV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig;

  /**
   * The amount of local SSD disks that will be
   * attached to each cluster node. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#localSsdCount
   */
  readonly localSsdCount?: number;

  /**
   * Possible Local SSD encryption modes:
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#localSsdEncryptionMode
   */
  readonly localSsdEncryptionMode?: string;

  /**
   * wide default value. Valid values include DEFAULT and MAX_THROUGHPUT. See Increasing logging agent throughput for more information.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#loggingVariant
   */
  readonly loggingVariant?: string;

  /**
   * The name of a Google Compute Engine machine type.
   * Defaults to e2-medium. To create a custom machine type, value should be set as specified
   * here.
   *
   * @default e2-medium. To create a custom machine type, value should be set as specified
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#machineType
   */
  readonly machineType?: string;

  /**
   * The runtime of each node in the node pool in seconds, terminated by 's'. Example: "3600s".
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#maxRunDuration
   */
  readonly maxRunDuration?: string;

  /**
   * The metadata key/value pairs assigned to instances in
   * the cluster. From GKE 1. To avoid this, set the
   * value in your config.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * Minimum CPU platform to be used by this instance.
   * The instance may be scheduled on the specified or newer CPU platform. Applicable
   * values are the friendly names of CPU platforms, such as Intel Haswell. See the
   * official documentation
   * for more information.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#minCpuPlatform
   */
  readonly minCpuPlatform?: string;

  /**
   * Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on sole tenant nodes.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#nodeGroup
   */
  readonly nodeGroup?: string;

  /**
   * The set of Google API scopes to be made available
   * on all of the node VMs under the "default" service account.
   * Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set service_account to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#oauthScopes
   */
  readonly oauthScopes?: string[];

  /**
   * A boolean that represents whether or not the underlying node VMs
   * are preemptible. See the official documentation
   * for more information. Defaults to false.
   *
   * @default false.
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#preemptible
   */
  readonly preemptible?: boolean;

  /**
   * The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#reservationAffinity
   */
  readonly reservationAffinity?: ClusterV1Beta2SpecInitProviderNodeConfigReservationAffinity;

  /**
   * The GCP labels (key/value pairs) to be applied to each node. Refer here
   * for how these labels are applied to clusters, node pools and nodes.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#resourceLabels
   */
  readonly resourceLabels?: { [key: string]: string };

  /**
   * A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found here. A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. tagKeys/{tag_key_id}=tagValues/{tag_value_id} 2. {org_id}/{tag_key_name}={tag_value_name} 3. {project_id}/{tag_key_name}={tag_value_name}.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };

  /**
   * Parameters for secondary boot disks to preload container images and data on new nodes. Structure is documented below. gcfs_config must be enabled=true for this feature to work. min_master_version must also be set to use GKE 1.28.3-gke.106700 or later versions.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#secondaryBootDisks
   */
  readonly secondaryBootDisks?: ClusterV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks[];

  /**
   * The service account to be used by the Node VMs.
   * If not specified, the "default" service account is used.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#serviceAccountSelector
   */
  readonly serviceAccountSelector?: ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelector;

  /**
   * Shielded Instance options. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: ClusterV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig;

  /**
   * Allows specifying multiple node affinities useful for running workloads on sole tenant nodes. node_affinity structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#soleTenantConfig
   */
  readonly soleTenantConfig?: ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfig;

  /**
   * A boolean that represents whether the underlying node VMs are spot.
   * See the official documentation
   * for more information. Defaults to false.
   *
   * @default false.
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#spot
   */
  readonly spot?: boolean;

  /**
   * The list of Storage Pools where boot disks are provisioned.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#storagePools
   */
  readonly storagePools?: string[];

  /**
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#tags
   */
  readonly tags?: string[];

  /**
   * A list of
   * Kubernetes taints
   * to apply to nodes. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#taint
   */
  readonly taint?: ClusterV1Beta2SpecInitProviderNodeConfigTaint[];

  /**
   * Windows node configuration, currently supporting OSVersion attribute. The value must be one of [OS_VERSION_UNSPECIFIED, OS_VERSION_LTSC2019, OS_VERSION_LTSC2022]. For example:
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#windowsNodeConfig
   */
  readonly windowsNodeConfig?: ClusterV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig;

  /**
   * Metadata configuration to expose to workloads on the node pool.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfig#workloadMetadataConfig
   */
  readonly workloadMetadataConfig?: ClusterV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedMachineFeatures': toJson_ClusterV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures(obj.advancedMachineFeatures),
    'bootDiskKmsKey': obj.bootDiskKmsKey,
    'confidentialNodes': toJson_ClusterV1Beta2SpecInitProviderNodeConfigConfidentialNodes(obj.confidentialNodes),
    'containerdConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfig(obj.containerdConfig),
    'diskSizeGb': obj.diskSizeGb,
    'diskType': obj.diskType,
    'enableConfidentialStorage': obj.enableConfidentialStorage,
    'ephemeralStorageLocalSsdConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig(obj.ephemeralStorageLocalSsdConfig),
    'fastSocket': toJson_ClusterV1Beta2SpecInitProviderNodeConfigFastSocket(obj.fastSocket),
    'flexStart': obj.flexStart,
    'gcfsConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfigGcfsConfig(obj.gcfsConfig),
    'guestAccelerator': obj.guestAccelerator?.map(y => toJson_ClusterV1Beta2SpecInitProviderNodeConfigGuestAccelerator(y)),
    'gvnic': toJson_ClusterV1Beta2SpecInitProviderNodeConfigGvnic(obj.gvnic),
    'hostMaintenancePolicy': toJson_ClusterV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy(obj.hostMaintenancePolicy),
    'imageType': obj.imageType,
    'kubeletConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig(obj.kubeletConfig),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'linuxNodeConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig(obj.linuxNodeConfig),
    'localNvmeSsdBlockConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig(obj.localNvmeSsdBlockConfig),
    'localSsdCount': obj.localSsdCount,
    'localSsdEncryptionMode': obj.localSsdEncryptionMode,
    'loggingVariant': obj.loggingVariant,
    'machineType': obj.machineType,
    'maxRunDuration': obj.maxRunDuration,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'minCpuPlatform': obj.minCpuPlatform,
    'nodeGroup': obj.nodeGroup,
    'oauthScopes': obj.oauthScopes?.map(y => y),
    'preemptible': obj.preemptible,
    'reservationAffinity': toJson_ClusterV1Beta2SpecInitProviderNodeConfigReservationAffinity(obj.reservationAffinity),
    'resourceLabels': ((obj.resourceLabels) === undefined) ? undefined : (Object.entries(obj.resourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'secondaryBootDisks': obj.secondaryBootDisks?.map(y => toJson_ClusterV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks(y)),
    'serviceAccount': obj.serviceAccount,
    'serviceAccountRef': toJson_ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRef(obj.serviceAccountRef),
    'serviceAccountSelector': toJson_ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelector(obj.serviceAccountSelector),
    'shieldedInstanceConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig(obj.shieldedInstanceConfig),
    'soleTenantConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfig(obj.soleTenantConfig),
    'spot': obj.spot,
    'storagePools': obj.storagePools?.map(y => y),
    'tags': obj.tags?.map(y => y),
    'taint': obj.taint?.map(y => toJson_ClusterV1Beta2SpecInitProviderNodeConfigTaint(y)),
    'windowsNodeConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig(obj.windowsNodeConfig),
    'workloadMetadataConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig(obj.workloadMetadataConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Node pool configs that apply to auto-provisioned node pools in
 * autopilot clusters and
 * node auto-provisioning-enabled clusters. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodePoolAutoConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodePoolAutoConfig {
  /**
   * Linux system configuration for the cluster's automatically provisioned node pools. Only cgroup_mode field is supported in node_pool_auto_config. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolAutoConfig#linuxNodeConfig
   */
  readonly linuxNodeConfig?: ClusterV1Beta2SpecInitProviderNodePoolAutoConfigLinuxNodeConfig;

  /**
   * The network tag config for the cluster's automatically provisioned node pools. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolAutoConfig#networkTags
   */
  readonly networkTags?: ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNetworkTags;

  /**
   * Kubelet configuration for Autopilot clusters. Currently, only insecure_kubelet_readonly_port_enabled is supported here.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolAutoConfig#nodeKubeletConfig
   */
  readonly nodeKubeletConfig?: ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNodeKubeletConfig;

  /**
   * A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found here. A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. tagKeys/{tag_key_id}=tagValues/{tag_value_id} 2. {org_id}/{tag_key_name}={tag_value_name} 3. {project_id}/{tag_key_name}={tag_value_name}.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolAutoConfig#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodePoolAutoConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodePoolAutoConfig(obj: ClusterV1Beta2SpecInitProviderNodePoolAutoConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'linuxNodeConfig': toJson_ClusterV1Beta2SpecInitProviderNodePoolAutoConfigLinuxNodeConfig(obj.linuxNodeConfig),
    'networkTags': toJson_ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNetworkTags(obj.networkTags),
    'nodeKubeletConfig': toJson_ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNodeKubeletConfig(obj.nodeKubeletConfig),
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Default NodePool settings for the entire cluster. These settings are overridden if specified on the specific NodePool object. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaults
 */
export interface ClusterV1Beta2SpecInitProviderNodePoolDefaults {
  /**
   * Subset of NodeConfig message that has defaults.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaults#nodeConfigDefaults
   */
  readonly nodeConfigDefaults?: ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaults;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodePoolDefaults' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodePoolDefaults(obj: ClusterV1Beta2SpecInitProviderNodePoolDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeConfigDefaults': toJson_ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaults(obj.nodeConfigDefaults),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for the cluster upgrade notifications feature. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNotificationConfig
 */
export interface ClusterV1Beta2SpecInitProviderNotificationConfig {
  /**
   * The pubsub config for the cluster's upgrade notifications.
   *
   * @schema ClusterV1Beta2SpecInitProviderNotificationConfig#pubsub
   */
  readonly pubsub?: ClusterV1Beta2SpecInitProviderNotificationConfigPubsub;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNotificationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNotificationConfig(obj: ClusterV1Beta2SpecInitProviderNotificationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pubsub': toJson_ClusterV1Beta2SpecInitProviderNotificationConfigPubsub(obj.pubsub),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for the
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderPodAutoscaling
 */
export interface ClusterV1Beta2SpecInitProviderPodAutoscaling {
  /**
   * Enable the Horizontal Pod Autoscaling profile for this cluster.
   * Acceptable values are:
   *
   * @schema ClusterV1Beta2SpecInitProviderPodAutoscaling#hpaProfile
   */
  readonly hpaProfile?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderPodAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderPodAutoscaling(obj: ClusterV1Beta2SpecInitProviderPodAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hpaProfile': obj.hpaProfile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for private clusters,
 * clusters with private nodes. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfig
 */
export interface ClusterV1Beta2SpecInitProviderPrivateClusterConfig {
  /**
   * When true, the cluster's private
   * endpoint is used as the cluster endpoint and access through the public endpoint
   * is disabled. When false, either endpoint can be used. This field only applies
   * to private clusters, when enable_private_nodes is true.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfig#enablePrivateEndpoint
   */
  readonly enablePrivateEndpoint?: boolean;

  /**
   * Enables the private cluster feature,
   * creating a private endpoint on the cluster. In a private cluster, nodes only
   * have RFC 1918 private addresses and communicate with the master's private
   * endpoint via private networking.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfig#enablePrivateNodes
   */
  readonly enablePrivateNodes?: boolean;

  /**
   * Controls cluster master global
   * access settings. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfig#masterGlobalAccessConfig
   */
  readonly masterGlobalAccessConfig?: ClusterV1Beta2SpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig;

  /**
   * The IP range in CIDR notation to use for
   * the hosted master network. This range will be used for assigning private IP
   * addresses to the cluster master(s) and the ILB VIP. This range must not overlap
   * with any other ranges in use within the cluster's network, and it must be a /28
   * subnet. See Private Cluster Limitations
   * for more details. This field only applies to private clusters, when
   * enable_private_nodes is true.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfig#masterIpv4CidrBlock
   */
  readonly masterIpv4CidrBlock?: string;

  /**
   * Subnetwork in cluster's network where master's endpoint will be provisioned.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfig#privateEndpointSubnetwork
   */
  readonly privateEndpointSubnetwork?: string;

  /**
   * Reference to a Subnetwork in compute to populate privateEndpointSubnetwork.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfig#privateEndpointSubnetworkRef
   */
  readonly privateEndpointSubnetworkRef?: ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef;

  /**
   * Selector for a Subnetwork in compute to populate privateEndpointSubnetwork.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfig#privateEndpointSubnetworkSelector
   */
  readonly privateEndpointSubnetworkSelector?: ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderPrivateClusterConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderPrivateClusterConfig(obj: ClusterV1Beta2SpecInitProviderPrivateClusterConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enablePrivateEndpoint': obj.enablePrivateEndpoint,
    'enablePrivateNodes': obj.enablePrivateNodes,
    'masterGlobalAccessConfig': toJson_ClusterV1Beta2SpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig(obj.masterGlobalAccessConfig),
    'masterIpv4CidrBlock': obj.masterIpv4CidrBlock,
    'privateEndpointSubnetwork': obj.privateEndpointSubnetwork,
    'privateEndpointSubnetworkRef': toJson_ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef(obj.privateEndpointSubnetworkRef),
    'privateEndpointSubnetworkSelector': toJson_ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector(obj.privateEndpointSubnetworkSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RBACBindingConfig allows user to restrict ClusterRoleBindings an RoleBindings that can be created. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderRbacBindingConfig
 */
export interface ClusterV1Beta2SpecInitProviderRbacBindingConfig {
  /**
   * Setting this to true will allow any ClusterRoleBinding and RoleBinding with subjects system:authenticated.
   *
   * @schema ClusterV1Beta2SpecInitProviderRbacBindingConfig#enableInsecureBindingSystemAuthenticated
   */
  readonly enableInsecureBindingSystemAuthenticated?: boolean;

  /**
   * Setting this to true will allow any ClusterRoleBinding and RoleBinding with subjects system:anonymous or system:unauthenticated.
   *
   * @schema ClusterV1Beta2SpecInitProviderRbacBindingConfig#enableInsecureBindingSystemUnauthenticated
   */
  readonly enableInsecureBindingSystemUnauthenticated?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderRbacBindingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderRbacBindingConfig(obj: ClusterV1Beta2SpecInitProviderRbacBindingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableInsecureBindingSystemAuthenticated': obj.enableInsecureBindingSystemAuthenticated,
    'enableInsecureBindingSystemUnauthenticated': obj.enableInsecureBindingSystemUnauthenticated,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration options for the Release channel
 * feature, which provide more control over automatic upgrades of your GKE clusters.
 * When updating this field, GKE imposes specific version requirements. See
 * Selecting a new release channel
 * for more details; the google_container_engine_versions datasource can provide
 * the default version for a channel. Instead, use the "UNSPECIFIED"
 * channel. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderReleaseChannel
 */
export interface ClusterV1Beta2SpecInitProviderReleaseChannel {
  /**
   * The selected release channel.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecInitProviderReleaseChannel#channel
   */
  readonly channel?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderReleaseChannel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderReleaseChannel(obj: ClusterV1Beta2SpecInitProviderReleaseChannel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'channel': obj.channel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for the
 * ResourceUsageExportConfig feature.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderResourceUsageExportConfig
 */
export interface ClusterV1Beta2SpecInitProviderResourceUsageExportConfig {
  /**
   * Parameters for using BigQuery as the destination of resource usage export.
   *
   * @schema ClusterV1Beta2SpecInitProviderResourceUsageExportConfig#bigqueryDestination
   */
  readonly bigqueryDestination?: ClusterV1Beta2SpecInitProviderResourceUsageExportConfigBigqueryDestination;

  /**
   * Whether to enable network egress metering for this cluster. If enabled, a daemonset will be created
   * in the cluster to meter network egress traffic.
   *
   * @schema ClusterV1Beta2SpecInitProviderResourceUsageExportConfig#enableNetworkEgressMetering
   */
  readonly enableNetworkEgressMetering?: boolean;

  /**
   * Whether to enable resource
   * consumption metering on this cluster. When enabled, a table will be created in
   * the resource export BigQuery dataset to store resource consumption data. The
   * resulting table can be joined with the resource usage table or with BigQuery
   * billing export. Defaults to true.
   *
   * @default true.
   * @schema ClusterV1Beta2SpecInitProviderResourceUsageExportConfig#enableResourceConsumptionMetering
   */
  readonly enableResourceConsumptionMetering?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderResourceUsageExportConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderResourceUsageExportConfig(obj: ClusterV1Beta2SpecInitProviderResourceUsageExportConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigqueryDestination': toJson_ClusterV1Beta2SpecInitProviderResourceUsageExportConfigBigqueryDestination(obj.bigqueryDestination),
    'enableNetworkEgressMetering': obj.enableNetworkEgressMetering,
    'enableResourceConsumptionMetering': obj.enableResourceConsumptionMetering,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for the
 * SecretManagerConfig feature.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderSecretManagerConfig
 */
export interface ClusterV1Beta2SpecInitProviderSecretManagerConfig {
  /**
   * Enable the Secret Manager add-on for this cluster.
   *
   * @schema ClusterV1Beta2SpecInitProviderSecretManagerConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderSecretManagerConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderSecretManagerConfig(obj: ClusterV1Beta2SpecInitProviderSecretManagerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Enable/Disable Security Posture API features for the cluster. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderSecurityPostureConfig
 */
export interface ClusterV1Beta2SpecInitProviderSecurityPostureConfig {
  /**
   * Sets the mode of the Kubernetes security posture API's off-cluster features. Available options include DISABLED, BASIC, and ENTERPRISE.
   *
   * @schema ClusterV1Beta2SpecInitProviderSecurityPostureConfig#mode
   */
  readonly mode?: string;

  /**
   * Sets the mode of the Kubernetes security posture API's workload vulnerability scanning. Available options include VULNERABILITY_DISABLED, VULNERABILITY_BASIC and VULNERABILITY_ENTERPRISE.
   *
   * @schema ClusterV1Beta2SpecInitProviderSecurityPostureConfig#vulnerabilityMode
   */
  readonly vulnerabilityMode?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderSecurityPostureConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderSecurityPostureConfig(obj: ClusterV1Beta2SpecInitProviderSecurityPostureConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
    'vulnerabilityMode': obj.vulnerabilityMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderServiceExternalIpsConfig
 */
export interface ClusterV1Beta2SpecInitProviderServiceExternalIpsConfig {
  /**
   * Controls whether external ips specified by a service will be allowed. It is enabled by default.
   *
   * @schema ClusterV1Beta2SpecInitProviderServiceExternalIpsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderServiceExternalIpsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderServiceExternalIpsConfig(obj: ClusterV1Beta2SpecInitProviderServiceExternalIpsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Subnetwork in compute to populate subnetwork.
 *
 * @schema ClusterV1Beta2SpecInitProviderSubnetworkRef
 */
export interface ClusterV1Beta2SpecInitProviderSubnetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterV1Beta2SpecInitProviderSubnetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterV1Beta2SpecInitProviderSubnetworkRef#policy
   */
  readonly policy?: ClusterV1Beta2SpecInitProviderSubnetworkRefPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderSubnetworkRef(obj: ClusterV1Beta2SpecInitProviderSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterV1Beta2SpecInitProviderSubnetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Subnetwork in compute to populate subnetwork.
 *
 * @schema ClusterV1Beta2SpecInitProviderSubnetworkSelector
 */
export interface ClusterV1Beta2SpecInitProviderSubnetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterV1Beta2SpecInitProviderSubnetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterV1Beta2SpecInitProviderSubnetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterV1Beta2SpecInitProviderSubnetworkSelector#policy
   */
  readonly policy?: ClusterV1Beta2SpecInitProviderSubnetworkSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderSubnetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderSubnetworkSelector(obj: ClusterV1Beta2SpecInitProviderSubnetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterV1Beta2SpecInitProviderSubnetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The custom keys configuration of the cluster Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderUserManagedKeysConfig
 */
export interface ClusterV1Beta2SpecInitProviderUserManagedKeysConfig {
  /**
   * The Certificate Authority Service caPool to use for the aggreation CA in this cluster.
   *
   * @schema ClusterV1Beta2SpecInitProviderUserManagedKeysConfig#aggregationCa
   */
  readonly aggregationCa?: string;

  /**
   * The Certificate Authority Service caPool to use for the cluster CA in this cluster.
   *
   * @schema ClusterV1Beta2SpecInitProviderUserManagedKeysConfig#clusterCa
   */
  readonly clusterCa?: string;

  /**
   * The Cloud KMS cryptoKey to use for Confidential Hyperdisk on the control plane nodes.
   *
   * @schema ClusterV1Beta2SpecInitProviderUserManagedKeysConfig#controlPlaneDiskEncryptionKey
   */
  readonly controlPlaneDiskEncryptionKey?: string;

  /**
   * The Certificate Authority Service caPool to use for the etcd API CA in this cluster.
   *
   * @schema ClusterV1Beta2SpecInitProviderUserManagedKeysConfig#etcdApiCa
   */
  readonly etcdApiCa?: string;

  /**
   * The Certificate Authority Service caPool to use for the etcd peer CA in this cluster.
   *
   * @schema ClusterV1Beta2SpecInitProviderUserManagedKeysConfig#etcdPeerCa
   */
  readonly etcdPeerCa?: string;

  /**
   * Resource path of the Cloud KMS cryptoKey to use for encryption of internal etcd backups.
   *
   * @schema ClusterV1Beta2SpecInitProviderUserManagedKeysConfig#gkeopsEtcdBackupEncryptionKey
   */
  readonly gkeopsEtcdBackupEncryptionKey?: string;

  /**
   * The Cloud KMS cryptoKeyVersions to use for signing service account JWTs issued by this cluster.
   *
   * @schema ClusterV1Beta2SpecInitProviderUserManagedKeysConfig#serviceAccountSigningKeys
   */
  readonly serviceAccountSigningKeys?: string[];

  /**
   * The Cloud KMS cryptoKeyVersions to use for verifying service account JWTs issued by this cluster.
   *
   * @schema ClusterV1Beta2SpecInitProviderUserManagedKeysConfig#serviceAccountVerificationKeys
   */
  readonly serviceAccountVerificationKeys?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderUserManagedKeysConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderUserManagedKeysConfig(obj: ClusterV1Beta2SpecInitProviderUserManagedKeysConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationCa': obj.aggregationCa,
    'clusterCa': obj.clusterCa,
    'controlPlaneDiskEncryptionKey': obj.controlPlaneDiskEncryptionKey,
    'etcdApiCa': obj.etcdApiCa,
    'etcdPeerCa': obj.etcdPeerCa,
    'gkeopsEtcdBackupEncryptionKey': obj.gkeopsEtcdBackupEncryptionKey,
    'serviceAccountSigningKeys': obj.serviceAccountSigningKeys?.map(y => y),
    'serviceAccountVerificationKeys': obj.serviceAccountVerificationKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderVerticalPodAutoscaling
 */
export interface ClusterV1Beta2SpecInitProviderVerticalPodAutoscaling {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderVerticalPodAutoscaling#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderVerticalPodAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderVerticalPodAutoscaling(obj: ClusterV1Beta2SpecInitProviderVerticalPodAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Workload Identity allows Kubernetes service accounts to act as a user-managed
 * Google IAM Service Account.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderWorkloadIdentityConfig
 */
export interface ClusterV1Beta2SpecInitProviderWorkloadIdentityConfig {
  /**
   * The workload pool to attach all Kubernetes service accounts to.
   *
   * @schema ClusterV1Beta2SpecInitProviderWorkloadIdentityConfig#workloadPool
   */
  readonly workloadPool?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderWorkloadIdentityConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderWorkloadIdentityConfig(obj: ClusterV1Beta2SpecInitProviderWorkloadIdentityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'workloadPool': obj.workloadPool,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterV1Beta2SpecProviderConfigRefPolicy
 */
export interface ClusterV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecProviderConfigRefPolicy(obj: ClusterV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * . Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigCloudrunConfig
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigCloudrunConfig {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigCloudrunConfig#disabled
   */
  readonly disabled?: boolean;

  /**
   * The load balancer type of CloudRun ingress service. It is external load balancer by default.
   * Set load_balancer_type=LOAD_BALANCER_TYPE_INTERNAL to configure it as internal load balancer.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigCloudrunConfig#loadBalancerType
   */
  readonly loadBalancerType?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigCloudrunConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigCloudrunConfig(obj: ClusterV1Beta2SpecForProviderAddonsConfigCloudrunConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
    'loadBalancerType': obj.loadBalancerType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * .
 * The status of the ConfigConnector addon. It is disabled by default; Set enabled = true to enable.
 *
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigConfigConnectorConfig
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigConfigConnectorConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigConfigConnectorConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigConfigConnectorConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigConfigConnectorConfig(obj: ClusterV1Beta2SpecForProviderAddonsConfigConfigConnectorConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * .
 * The status of the NodeLocal DNSCache addon. It is disabled by default.
 * Set enabled = true to enable.
 *
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigDnsCacheConfig
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigDnsCacheConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigDnsCacheConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigDnsCacheConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigDnsCacheConfig(obj: ClusterV1Beta2SpecForProviderAddonsConfigDnsCacheConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * .
 * Whether this cluster should enable the Google Compute Engine Persistent Disk Container Storage Interface (CSI) Driver. Set enabled = true to enable.
 *
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig(obj: ClusterV1Beta2SpecForProviderAddonsConfigGcePersistentDiskCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The status of the Filestore CSI driver addon,
 * which allows the usage of filestore instance as volumes.
 * It is disabled by default; set enabled = true to enable.
 *
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig(obj: ClusterV1Beta2SpecForProviderAddonsConfigGcpFilestoreCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The status of the GCSFuse CSI driver addon,
 * which allows the usage of a gcs bucket as volumes.
 * It is disabled by default for Standard clusters; set enabled = true to enable.
 * It is enabled by default for Autopilot clusters with version 1.24 or later; set enabled = true to enable it explicitly.
 * See Enable the Cloud Storage FUSE CSI driver for more information.
 *
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigGcsFuseCsiDriverConfig
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigGcsFuseCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigGcsFuseCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigGcsFuseCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigGcsFuseCsiDriverConfig(obj: ClusterV1Beta2SpecForProviderAddonsConfigGcsFuseCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * .
 * The status of the Backup for GKE agent addon. It is disabled by default; Set enabled = true to enable.
 *
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigGkeBackupAgentConfig
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigGkeBackupAgentConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigGkeBackupAgentConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigGkeBackupAgentConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigGkeBackupAgentConfig(obj: ClusterV1Beta2SpecForProviderAddonsConfigGkeBackupAgentConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The status of the Horizontal Pod Autoscaling
 * addon, which increases or decreases the number of replica pods a replication controller
 * has based on the resource usage of the existing pods.
 * It is enabled by default;
 * set disabled = true to disable.
 *
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigHorizontalPodAutoscaling
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigHorizontalPodAutoscaling {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigHorizontalPodAutoscaling#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigHorizontalPodAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigHorizontalPodAutoscaling(obj: ClusterV1Beta2SpecForProviderAddonsConfigHorizontalPodAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The status of the HTTP (L7) load balancing
 * controller addon, which makes it easy to set up HTTP load balancers for services in a
 * cluster. It is enabled by default; set disabled = true to disable.
 *
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigHttpLoadBalancing
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigHttpLoadBalancing {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigHttpLoadBalancing#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigHttpLoadBalancing' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigHttpLoadBalancing(obj: ClusterV1Beta2SpecForProviderAddonsConfigHttpLoadBalancing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The status of the Lustre CSI driver addon,
 * which allows the usage of a Lustre instances as volumes.
 * It is disabled by default for Standard clusters; set enabled = true to enable.
 * It is disabled by default for Autopilot clusters; set enabled = true to enable.
 * Lustre CSI Driver Config has optional subfield
 * enable_legacy_lustre_port which allows the Lustre CSI driver to initialize LNet (the virtual networklayer for Lustre kernel module) using port 6988.
 * This flag is required to workaround a port conflict with the gke-metadata-server on GKE nodes.
 * See Enable Lustre CSI driver for more information.
 *
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigLustreCsiDriverConfig
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigLustreCsiDriverConfig {
  /**
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigLustreCsiDriverConfig#enableLegacyLustrePort
   */
  readonly enableLegacyLustrePort?: boolean;

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigLustreCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigLustreCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigLustreCsiDriverConfig(obj: ClusterV1Beta2SpecForProviderAddonsConfigLustreCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableLegacyLustrePort': obj.enableLegacyLustrePort,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Whether we should enable the network policy addon
 * for the master.  This must be enabled in order to enable network policy for the nodes.
 * To enable this, you must also define a network_policy block,
 * otherwise nothing will happen.
 * It can only be disabled if the nodes already do not have network policies enabled.
 * Defaults to disabled; set disabled = false to enable.
 *
 * @default disabled; set disabled = false to enable.
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigNetworkPolicyConfig
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigNetworkPolicyConfig {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigNetworkPolicyConfig#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigNetworkPolicyConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigNetworkPolicyConfig(obj: ClusterV1Beta2SpecForProviderAddonsConfigNetworkPolicyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The status of the Parallelstore CSI driver addon,
 * which allows the usage of a Parallelstore instances as volumes.
 * It is disabled by default for Standard clusters; set enabled = true to enable.
 * It is enabled by default for Autopilot clusters with version 1.29 or later; set enabled = true to enable it explicitly.
 * See Enable the Parallelstore CSI driver for more information.
 *
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigParallelstoreCsiDriverConfig
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigParallelstoreCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigParallelstoreCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigParallelstoreCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigParallelstoreCsiDriverConfig(obj: ClusterV1Beta2SpecForProviderAddonsConfigParallelstoreCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfig
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfig#enabled
   */
  readonly enabled?: boolean;

  /**
   * Logging configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfig#rayClusterLoggingConfig
   */
  readonly rayClusterLoggingConfig?: ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig;

  /**
   * Monitoring configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfig#rayClusterMonitoringConfig
   */
  readonly rayClusterMonitoringConfig?: ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfig(obj: ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'rayClusterLoggingConfig': toJson_ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig(obj.rayClusterLoggingConfig),
    'rayClusterMonitoringConfig': toJson_ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig(obj.rayClusterMonitoringConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * .
 * The status of the Stateful HA addon, which provides automatic configurable failover for stateful applications.
 * It is disabled by default for Standard clusters. Set enabled = true to enable.
 *
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigStatefulHaConfig
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigStatefulHaConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigStatefulHaConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigStatefulHaConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigStatefulHaConfig(obj: ClusterV1Beta2SpecForProviderAddonsConfigStatefulHaConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Contains defaults for a node pool created by NAP. A subset of fields also apply to
 * GKE Autopilot clusters.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults
 */
export interface ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults {
  /**
   * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults#bootDiskKmsKey
   */
  readonly bootDiskKmsKey?: string;

  /**
   * Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Defaults to 100
   *
   * @default 100
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults#diskSize
   */
  readonly diskSize?: number;

  /**
   * Type of the disk attached to each node
   * (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-balanced'
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults#diskType
   */
  readonly diskType?: string;

  /**
   * The image type to use for this node. Note that changing the image type
   * will delete and recreate all nodes in the node pool.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults#imageType
   */
  readonly imageType?: string;

  /**
   * NodeManagement configuration for this NodePool. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults#management
   */
  readonly management?: ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement;

  /**
   * Minimum CPU platform to be used by this instance.
   * The instance may be scheduled on the specified or newer CPU platform. Applicable
   * values are the friendly names of CPU platforms, such as Intel Haswell. See the
   * official documentation
   * for more information.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults#minCpuPlatform
   */
  readonly minCpuPlatform?: string;

  /**
   * The set of Google API scopes to be made available
   * on all of the node VMs under the "default" service account.
   * Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set service_account to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults#oauthScopes
   */
  readonly oauthScopes?: string[];

  /**
   * The service account to be used by the Node VMs.
   * If not specified, the "default" service account is used.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Shielded Instance options. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig;

  /**
   * Specifies the upgrade settings for NAP created node pools. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults#upgradeSettings
   */
  readonly upgradeSettings?: ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults(obj: ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bootDiskKmsKey': obj.bootDiskKmsKey,
    'diskSize': obj.diskSize,
    'diskType': obj.diskType,
    'imageType': obj.imageType,
    'management': toJson_ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement(obj.management),
    'minCpuPlatform': obj.minCpuPlatform,
    'oauthScopes': obj.oauthScopes?.map(y => y),
    'serviceAccount': obj.serviceAccount,
    'shieldedInstanceConfig': toJson_ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig(obj.shieldedInstanceConfig),
    'upgradeSettings': toJson_ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings(obj.upgradeSettings),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingResourceLimits
 */
export interface ClusterV1Beta2SpecForProviderClusterAutoscalingResourceLimits {
  /**
   * Maximum amount of the resource in the cluster.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingResourceLimits#maximum
   */
  readonly maximum?: number;

  /**
   * Minimum amount of the resource in the cluster.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingResourceLimits#minimum
   */
  readonly minimum?: number;

  /**
   * The type of the resource. For example, cpu and
   * memory.  See the guide to using Node Auto-Provisioning
   * for a list of types.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingResourceLimits#resourceType
   */
  readonly resourceType?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderClusterAutoscalingResourceLimits' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderClusterAutoscalingResourceLimits(obj: ClusterV1Beta2SpecForProviderClusterAutoscalingResourceLimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximum': obj.maximum,
    'minimum': obj.minimum,
    'resourceType': obj.resourceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DNS endpoint configuration.
 *
 * @schema ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig
 */
export interface ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig {
  /**
   * Controls whether user traffic is allowed over this endpoint. Note that GCP-managed services may still use the endpoint even if this is false.
   *
   * @schema ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig#allowExternalTraffic
   */
  readonly allowExternalTraffic?: boolean;

  /**
   * (Output) The cluster's DNS endpoint.
   *
   * @schema ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig#endpoint
   */
  readonly endpoint?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig(obj: ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigDnsEndpointConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowExternalTraffic': obj.allowExternalTraffic,
    'endpoint': obj.endpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IP endpoint configuration.
 *
 * @schema ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig
 */
export interface ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig {
  /**
   * Controls whether to allow direct IP access. Defaults to true.
   *
   * @default true.
   * @schema ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig(obj: ClusterV1Beta2SpecForProviderControlPlaneEndpointsConfigIpEndpointsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalIpRangesConfig
 */
export interface ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalIpRangesConfig {
  /**
   * List of secondary ranges names within this subnetwork that can be used for pod IPs.
   *
   * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalIpRangesConfig#podIpv4RangeNames
   */
  readonly podIpv4RangeNames?: string[];

  /**
   * The name or self_link of the Google Compute Engine
   * subnetwork in which the cluster's instances are launched.
   *
   * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalIpRangesConfig#subnetwork
   */
  readonly subnetwork?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalIpRangesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalIpRangesConfig(obj: ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalIpRangesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podIpv4RangeNames': obj.podIpv4RangeNames?.map(y => y),
    'subnetwork': obj.subnetwork,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration for additional pod secondary ranges at
 * the cluster level. Used for Autopilot clusters and Standard clusters with which control of the
 * secondary Pod IP address assignment to node pools isn't needed. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalPodRangesConfig
 */
export interface ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalPodRangesConfig {
  /**
   * The names of the Pod ranges to add to the cluster.
   *
   * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalPodRangesConfig#podRangeNames
   */
  readonly podRangeNames?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalPodRangesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalPodRangesConfig(obj: ClusterV1Beta2SpecForProviderIpAllocationPolicyAdditionalPodRangesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podRangeNames': obj.podRangeNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig
 */
export interface ClusterV1Beta2SpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterV1Beta2SpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig(obj: ClusterV1Beta2SpecForProviderIpAllocationPolicyPodCidrOverprovisionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * structure documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderMaintenancePolicyDailyMaintenanceWindow
 */
export interface ClusterV1Beta2SpecForProviderMaintenancePolicyDailyMaintenanceWindow {
  /**
   * @schema ClusterV1Beta2SpecForProviderMaintenancePolicyDailyMaintenanceWindow#startTime
   */
  readonly startTime?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderMaintenancePolicyDailyMaintenanceWindow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderMaintenancePolicyDailyMaintenanceWindow(obj: ClusterV1Beta2SpecForProviderMaintenancePolicyDailyMaintenanceWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusion
 */
export interface ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusion {
  /**
   * @schema ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusion#endTime
   */
  readonly endTime?: string;

  /**
   * The name of the cluster, unique within the project and
   * location.
   *
   * @schema ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusion#exclusionName
   */
  readonly exclusionName?: string;

  /**
   * MaintenanceExclusionOptions provides maintenance exclusion related options.
   *
   * @schema ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusion#exclusionOptions
   */
  readonly exclusionOptions?: ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions;

  /**
   * @schema ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusion#startTime
   */
  readonly startTime?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusion' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusion(obj: ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'exclusionName': obj.exclusionName,
    'exclusionOptions': toJson_ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions(obj.exclusionOptions),
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * structure documented below
 *
 * @schema ClusterV1Beta2SpecForProviderMaintenancePolicyRecurringWindow
 */
export interface ClusterV1Beta2SpecForProviderMaintenancePolicyRecurringWindow {
  /**
   * @schema ClusterV1Beta2SpecForProviderMaintenancePolicyRecurringWindow#endTime
   */
  readonly endTime?: string;

  /**
   * @schema ClusterV1Beta2SpecForProviderMaintenancePolicyRecurringWindow#recurrence
   */
  readonly recurrence?: string;

  /**
   * @schema ClusterV1Beta2SpecForProviderMaintenancePolicyRecurringWindow#startTime
   */
  readonly startTime?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderMaintenancePolicyRecurringWindow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderMaintenancePolicyRecurringWindow(obj: ClusterV1Beta2SpecForProviderMaintenancePolicyRecurringWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'recurrence': obj.recurrence,
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Whether client certificate authorization is enabled for this cluster.  For example:
 *
 * @schema ClusterV1Beta2SpecForProviderMasterAuthClientCertificateConfig
 */
export interface ClusterV1Beta2SpecForProviderMasterAuthClientCertificateConfig {
  /**
   * @schema ClusterV1Beta2SpecForProviderMasterAuthClientCertificateConfig#issueClientCertificate
   */
  readonly issueClientCertificate?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderMasterAuthClientCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderMasterAuthClientCertificateConfig(obj: ClusterV1Beta2SpecForProviderMasterAuthClientCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'issueClientCertificate': obj.issueClientCertificate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfigCidrBlocks
 */
export interface ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfigCidrBlocks {
  /**
   * External network that can access Kubernetes master through HTTPS.
   * Must be specified in CIDR notation.
   *
   * @schema ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfigCidrBlocks#cidrBlock
   */
  readonly cidrBlock?: string;

  /**
   * Field for users to identify CIDR blocks.
   *
   * @schema ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfigCidrBlocks#displayName
   */
  readonly displayName?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfigCidrBlocks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfigCidrBlocks(obj: ClusterV1Beta2SpecForProviderMasterAuthorizedNetworksConfigCidrBlocks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrBlock': obj.cidrBlock,
    'displayName': obj.displayName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for Advanced Datapath Monitoring. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig
 */
export interface ClusterV1Beta2SpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig {
  /**
   * Whether or not to enable advanced datapath metrics.
   *
   * @schema ClusterV1Beta2SpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig#enableMetrics
   */
  readonly enableMetrics?: boolean;

  /**
   * Whether or not Relay is enabled.
   *
   * @schema ClusterV1Beta2SpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig#enableRelay
   */
  readonly enableRelay?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig(obj: ClusterV1Beta2SpecForProviderMonitoringConfigAdvancedDatapathObservabilityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableMetrics': obj.enableMetrics,
    'enableRelay': obj.enableRelay,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for Managed Service for Prometheus. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheus
 */
export interface ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheus {
  /**
   * Configuration options for GKE Auto-Monitoring.
   *
   * @schema ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheus#autoMonitoringConfig
   */
  readonly autoMonitoringConfig?: ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig;

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheus#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheus(obj: ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoMonitoringConfig': toJson_ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig(obj.autoMonitoringConfig),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterV1Beta2SpecForProviderNetworkRefPolicy
 */
export interface ClusterV1Beta2SpecForProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecForProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecForProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecForProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecForProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNetworkRefPolicy(obj: ClusterV1Beta2SpecForProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterV1Beta2SpecForProviderNetworkSelectorPolicy
 */
export interface ClusterV1Beta2SpecForProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecForProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecForProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecForProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecForProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNetworkSelectorPolicy(obj: ClusterV1Beta2SpecForProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies options for controlling
 * advanced machine features. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures {
  /**
   * Defines whether the instance should have nested virtualization enabled. Defaults to false.
   *
   * @default false.
   * @schema ClusterV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures#enableNestedVirtualization
   */
  readonly enableNestedVirtualization?: boolean;

  /**
   * Defines the performance monitoring unit PMU level. Valid values are ARCHITECTURAL, STANDARD, or ENHANCED. Defaults to off.
   *
   * @default off.
   * @schema ClusterV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures#performanceMonitoringUnit
   */
  readonly performanceMonitoringUnit?: string;

  /**
   * The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures#threadsPerCore
   */
  readonly threadsPerCore?: number;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures(obj: ClusterV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableNestedVirtualization': obj.enableNestedVirtualization,
    'performanceMonitoringUnit': obj.performanceMonitoringUnit,
    'threadsPerCore': obj.threadsPerCore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for Confidential Nodes feature. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigConfidentialNodes
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigConfidentialNodes {
  /**
   * Defines the type of technology used
   * by the confidential node.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigConfidentialNodes#confidentialInstanceType
   */
  readonly confidentialInstanceType?: string;

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigConfidentialNodes#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigConfidentialNodes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigConfidentialNodes(obj: ClusterV1Beta2SpecForProviderNodeConfigConfidentialNodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confidentialInstanceType': obj.confidentialInstanceType,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters to customize containerd runtime. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigContainerdConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigContainerdConfig {
  /**
   * Configuration for private container registries. There are two fields in this config:
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigContainerdConfig#privateRegistryAccessConfig
   */
  readonly privateRegistryAccessConfig?: ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigContainerdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigContainerdConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigContainerdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateRegistryAccessConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(obj.privateRegistryAccessConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig {
  /**
   * Number of raw-block local NVMe SSD disks to be attached to the node utilized for GKE Data Cache. If zero, then GKE Data Cache will not be enabled in the nodes.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig#dataCacheCount
   */
  readonly dataCacheCount?: number;

  /**
   * The amount of local SSD disks that will be
   * attached to each cluster node. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataCacheCount': obj.dataCacheCount,
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
 * Node Pool must enable gvnic.
 * GKE version 1.25.2-gke.1700 or later.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigFastSocket
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigFastSocket {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigFastSocket#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigFastSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigFastSocket(obj: ClusterV1Beta2SpecForProviderNodeConfigFastSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters for the Google Container Filesystem (GCFS).
 * If unspecified, GCFS will not be enabled on the node pool. When enabling this feature you must specify image_type = "COS_CONTAINERD" and node_version from GKE versions 1.19 or later to use it.
 * For GKE versions 1.19, 1.20, and 1.21, the recommended minimum node_version would be 1.19.15-gke.1300, 1.20.11-gke.1300, and 1.21.5-gke.1300 respectively.
 * A machine_type that has more than 16 GiB of memory is also recommended.
 * GCFS must be enabled in order to use image streaming.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigGcfsConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigGcfsConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigGcfsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigGcfsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigGcfsConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigGcfsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecForProviderNodeConfigGuestAccelerator
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigGuestAccelerator {
  /**
   * The number of the guest accelerator cards exposed to this instance.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigGuestAccelerator#count
   */
  readonly count?: number;

  /**
   * Configuration for auto installation of GPU driver. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigGuestAccelerator#gpuDriverInstallationConfig
   */
  readonly gpuDriverInstallationConfig?: ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig;

  /**
   * Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig user guide.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigGuestAccelerator#gpuPartitionSize
   */
  readonly gpuPartitionSize?: string;

  /**
   * Configuration for GPU sharing. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigGuestAccelerator#gpuSharingConfig
   */
  readonly gpuSharingConfig?: ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig;

  /**
   * The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigGuestAccelerator#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigGuestAccelerator' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigGuestAccelerator(obj: ClusterV1Beta2SpecForProviderNodeConfigGuestAccelerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'gpuDriverInstallationConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(obj.gpuDriverInstallationConfig),
    'gpuPartitionSize': obj.gpuPartitionSize,
    'gpuSharingConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig(obj.gpuSharingConfig),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Google Virtual NIC (gVNIC) is a virtual network interface.
 * Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
 * gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
 * GKE node version 1.15.11-gke.15 or later
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigGvnic
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigGvnic {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigGvnic#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigGvnic' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigGvnic(obj: ClusterV1Beta2SpecForProviderNodeConfigGvnic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The maintenance policy to use for the cluster. Structure is
 * documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy {
  /**
   * @schema ClusterV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy#maintenanceInterval
   */
  readonly maintenanceInterval?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy(obj: ClusterV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maintenanceInterval': obj.maintenanceInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubelet configuration, currently supported attributes can be found here.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig {
  /**
   * Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods. The allowed sysctl groups are kernel.shm*, kernel.msg*, kernel.sem, fs.mqueue.*, and net.*.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig#allowedUnsafeSysctls
   */
  readonly allowedUnsafeSysctls?: string[];

  /**
   * Defines the maximum number of container log files that can be present for a container. The integer must be between 2 and 10, inclusive.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig#containerLogMaxFiles
   */
  readonly containerLogMaxFiles?: number;

  /**
   * Defines the maximum size of the
   * container log file before it is rotated. Specified as a positive number and a
   * unit suffix, such as "100Ki", "10Mi". Valid units are "Ki", "Mi", "Gi".
   * The value must be between "10Mi" and "500Mi", inclusive. And the total container log size
   * (container_log_max_size * container_log_max_files) cannot exceed 1% of the total storage of the node.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig#containerLogMaxSize
   */
  readonly containerLogMaxSize?: string;

  /**
   * If true, enables CPU CFS quota enforcement for
   * containers that specify CPU limits.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig#cpuCfsQuota
   */
  readonly cpuCfsQuota?: boolean;

  /**
   * The CPU CFS quota period value. Specified
   * as a sequence of decimal numbers, each with optional fraction and a unit suffix,
   * such as "300ms". Valid time units are "ns", "us" (or "s"), "ms", "s", "m",
   * "h". The value must be a positive duration.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig#cpuCfsQuotaPeriod
   */
  readonly cpuCfsQuotaPeriod?: string;

  /**
   * The CPU management policy on the node. See
   * K8S CPU Management Policies.
   * One of "none" or "static". If unset (or set to the empty string ""), the API will treat the field as if set to "none".
   * Prior to the 6.4.0 this field was marked as required. The workaround for the required field
   * is setting the empty string "", which will function identically to not setting this field.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig#cpuManagerPolicy
   */
  readonly cpuManagerPolicy?: string;

  /**
   * Defines the percent of disk usage after which image garbage collection is always run. The integer must be between 10 and 85, inclusive.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig#imageGcHighThresholdPercent
   */
  readonly imageGcHighThresholdPercent?: number;

  /**
   * Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to. The integer must be between 10 and 85, inclusive.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig#imageGcLowThresholdPercent
   */
  readonly imageGcLowThresholdPercent?: number;

  /**
   * Defines the maximum age an image can be unused before it is garbage collected. Specified as a sequence of decimal numbers, each with optional fraction and a unit suffix, such as "300s", "1.5m", and "2h45m". Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h". The value must be a positive duration.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig#imageMaximumGcAge
   */
  readonly imageMaximumGcAge?: string;

  /**
   * Defines the minimum age for an unused image before it is garbage collected. Specified as a sequence of decimal numbers, each with optional fraction and a unit suffix, such as "300s", "1.5m". The value cannot be greater than "2m".
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig#imageMinimumGcAge
   */
  readonly imageMinimumGcAge?: string;

  /**
   * only port is enabled for newly created node pools in the cluster. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;

  /**
   * Controls the maximum number of processes allowed to run in a pod. The value must be greater than or equal to 1024 and less than 4194304.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig#podPidsLimit
   */
  readonly podPidsLimit?: number;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigKubeletConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedUnsafeSysctls': obj.allowedUnsafeSysctls?.map(y => y),
    'containerLogMaxFiles': obj.containerLogMaxFiles,
    'containerLogMaxSize': obj.containerLogMaxSize,
    'cpuCfsQuota': obj.cpuCfsQuota,
    'cpuCfsQuotaPeriod': obj.cpuCfsQuotaPeriod,
    'cpuManagerPolicy': obj.cpuManagerPolicy,
    'imageGcHighThresholdPercent': obj.imageGcHighThresholdPercent,
    'imageGcLowThresholdPercent': obj.imageGcLowThresholdPercent,
    'imageMaximumGcAge': obj.imageMaximumGcAge,
    'imageMinimumGcAge': obj.imageMinimumGcAge,
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
    'podPidsLimit': obj.podPidsLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters that can be configured on Linux nodes. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfig {
  /**
   * Possible cgroup modes that can be used.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfig#cgroupMode
   */
  readonly cgroupMode?: string;

  /**
   * Amounts for 2M and 1G hugepages. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfig#hugepagesConfig
   */
  readonly hugepagesConfig?: ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig;

  /**
   * The Linux kernel parameters to be applied to the nodes
   * and all pods running on the nodes. Specified as a map from the key, such as
   * net.core.wmem_max, to a string value. Currently supported attributes can be found here.
   * Note that validations happen all server side. All attributes are optional.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfig#sysctls
   */
  readonly sysctls?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cgroupMode': obj.cgroupMode,
    'hugepagesConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig(obj.hugepagesConfig),
    'sysctls': ((obj.sysctls) === undefined) ? undefined : (Object.entries(obj.sysctls).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters for the local NVMe SSDs. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig {
  /**
   * The amount of local SSD disks that will be
   * attached to each cluster node. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigReservationAffinity
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigReservationAffinity {
  /**
   * The type of reservation consumption
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigReservationAffinity#consumeReservationType
   */
  readonly consumeReservationType?: string;

  /**
   * Key for taint.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigReservationAffinity#key
   */
  readonly key?: string;

  /**
   * name"
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigReservationAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigReservationAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigReservationAffinity(obj: ClusterV1Beta2SpecForProviderNodeConfigReservationAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumeReservationType': obj.consumeReservationType,
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecForProviderNodeConfigSecondaryBootDisks
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigSecondaryBootDisks {
  /**
   * Path to disk image to create the secondary boot disk from. After using the gke-disk-image-builder, this argument should be global/images/DISK_IMAGE_NAME.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigSecondaryBootDisks#diskImage
   */
  readonly diskImage?: string;

  /**
   * How to expose the node metadata to the workload running on the node.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigSecondaryBootDisks#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigSecondaryBootDisks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigSecondaryBootDisks(obj: ClusterV1Beta2SpecForProviderNodeConfigSecondaryBootDisks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'diskImage': obj.diskImage,
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRef
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRef#policy
   */
  readonly policy?: ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRef(obj: ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelector
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelector#policy
   */
  readonly policy?: ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelector(obj: ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Shielded Instance options. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig {
  /**
   * Defines if the instance has integrity monitoring enabled.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * Defines if the instance has Secure Boot enabled.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Allows specifying multiple node affinities useful for running workloads on sole tenant nodes. node_affinity structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfig {
  /**
   * @schema ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfig#nodeAffinity
   */
  readonly nodeAffinity?: ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': obj.nodeAffinity?.map(y => toJson_ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecForProviderNodeConfigTaint
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigTaint {
  /**
   * Effect for taint. Accepted values are NO_SCHEDULE, PREFER_NO_SCHEDULE, and NO_EXECUTE.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigTaint#effect
   */
  readonly effect?: string;

  /**
   * Key for taint.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigTaint#key
   */
  readonly key?: string;

  /**
   * Value for taint.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigTaint#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigTaint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigTaint(obj: ClusterV1Beta2SpecForProviderNodeConfigTaint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Windows node configuration, currently supporting OSVersion attribute. The value must be one of [OS_VERSION_UNSPECIFIED, OS_VERSION_LTSC2019, OS_VERSION_LTSC2022]. For example:
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigWindowsNodeConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigWindowsNodeConfig {
  /**
   * @schema ClusterV1Beta2SpecForProviderNodeConfigWindowsNodeConfig#osversion
   */
  readonly osversion?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigWindowsNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigWindowsNodeConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigWindowsNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'osversion': obj.osversion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata configuration to expose to workloads on the node pool.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig {
  /**
   * How to expose the node metadata to the workload running on the node.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Linux system configuration for the cluster's automatically provisioned node pools. Only cgroup_mode field is supported in node_pool_auto_config. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodePoolAutoConfigLinuxNodeConfig
 */
export interface ClusterV1Beta2SpecForProviderNodePoolAutoConfigLinuxNodeConfig {
  /**
   * Possible cgroup modes that can be used.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolAutoConfigLinuxNodeConfig#cgroupMode
   */
  readonly cgroupMode?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodePoolAutoConfigLinuxNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodePoolAutoConfigLinuxNodeConfig(obj: ClusterV1Beta2SpecForProviderNodePoolAutoConfigLinuxNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cgroupMode': obj.cgroupMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The network tag config for the cluster's automatically provisioned node pools. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodePoolAutoConfigNetworkTags
 */
export interface ClusterV1Beta2SpecForProviderNodePoolAutoConfigNetworkTags {
  /**
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls.
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolAutoConfigNetworkTags#tags
   */
  readonly tags?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodePoolAutoConfigNetworkTags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodePoolAutoConfigNetworkTags(obj: ClusterV1Beta2SpecForProviderNodePoolAutoConfigNetworkTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubelet configuration for Autopilot clusters. Currently, only insecure_kubelet_readonly_port_enabled is supported here.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodePoolAutoConfigNodeKubeletConfig
 */
export interface ClusterV1Beta2SpecForProviderNodePoolAutoConfigNodeKubeletConfig {
  /**
   * only port is enabled for newly created node pools in the cluster. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolAutoConfigNodeKubeletConfig#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodePoolAutoConfigNodeKubeletConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodePoolAutoConfigNodeKubeletConfig(obj: ClusterV1Beta2SpecForProviderNodePoolAutoConfigNodeKubeletConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Subset of NodeConfig message that has defaults.
 *
 * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaults
 */
export interface ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaults {
  /**
   * Parameters to customize containerd runtime. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaults#containerdConfig
   */
  readonly containerdConfig?: ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig;

  /**
   * The default Google Container Filesystem (GCFS) configuration at the cluster level. e.g. enable image streaming across all the node pools within the cluster. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaults#gcfsConfig
   */
  readonly gcfsConfig?: ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig;

  /**
   * only port is enabled for newly created node pools in the cluster. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaults#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;

  /**
   * The type of logging agent that is deployed by default for newly created node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. See Increasing logging agent throughput for more information.
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaults#loggingVariant
   */
  readonly loggingVariant?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaults' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaults(obj: ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerdConfig': toJson_ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig(obj.containerdConfig),
    'gcfsConfig': toJson_ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig(obj.gcfsConfig),
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
    'loggingVariant': obj.loggingVariant,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pubsub config for the cluster's upgrade notifications.
 *
 * @schema ClusterV1Beta2SpecForProviderNotificationConfigPubsub
 */
export interface ClusterV1Beta2SpecForProviderNotificationConfigPubsub {
  /**
   * Whether or not the notification config is enabled
   *
   * @schema ClusterV1Beta2SpecForProviderNotificationConfigPubsub#enabled
   */
  readonly enabled?: boolean;

  /**
   * Choose what type of notifications you want to receive. If no filters are applied, you'll receive all notification types. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderNotificationConfigPubsub#filter
   */
  readonly filter?: ClusterV1Beta2SpecForProviderNotificationConfigPubsubFilter;

  /**
   * The pubsub topic to push upgrade notifications to. Must be in the same project as the cluster. Must be in the format: projects/{project}/topics/{topic}.
   *
   * @schema ClusterV1Beta2SpecForProviderNotificationConfigPubsub#topic
   */
  readonly topic?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNotificationConfigPubsub' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNotificationConfigPubsub(obj: ClusterV1Beta2SpecForProviderNotificationConfigPubsub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'filter': toJson_ClusterV1Beta2SpecForProviderNotificationConfigPubsubFilter(obj.filter),
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Controls cluster master global
 * access settings. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigMasterGlobalAccessConfig
 */
export interface ClusterV1Beta2SpecForProviderPrivateClusterConfigMasterGlobalAccessConfig {
  /**
   * Whether the cluster master is accessible globally or
   * not.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigMasterGlobalAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderPrivateClusterConfigMasterGlobalAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderPrivateClusterConfigMasterGlobalAccessConfig(obj: ClusterV1Beta2SpecForProviderPrivateClusterConfigMasterGlobalAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Subnetwork in compute to populate privateEndpointSubnetwork.
 *
 * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef
 */
export interface ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef#policy
   */
  readonly policy?: ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef(obj: ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Subnetwork in compute to populate privateEndpointSubnetwork.
 *
 * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector
 */
export interface ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector#policy
   */
  readonly policy?: ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector(obj: ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters for using BigQuery as the destination of resource usage export.
 *
 * @schema ClusterV1Beta2SpecForProviderResourceUsageExportConfigBigqueryDestination
 */
export interface ClusterV1Beta2SpecForProviderResourceUsageExportConfigBigqueryDestination {
  /**
   * The ID of a BigQuery Dataset. For Example:
   *
   * @schema ClusterV1Beta2SpecForProviderResourceUsageExportConfigBigqueryDestination#datasetId
   */
  readonly datasetId?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderResourceUsageExportConfigBigqueryDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderResourceUsageExportConfigBigqueryDestination(obj: ClusterV1Beta2SpecForProviderResourceUsageExportConfigBigqueryDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterV1Beta2SpecForProviderSubnetworkRefPolicy
 */
export interface ClusterV1Beta2SpecForProviderSubnetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecForProviderSubnetworkRefPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecForProviderSubnetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecForProviderSubnetworkRefPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecForProviderSubnetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderSubnetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderSubnetworkRefPolicy(obj: ClusterV1Beta2SpecForProviderSubnetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterV1Beta2SpecForProviderSubnetworkSelectorPolicy
 */
export interface ClusterV1Beta2SpecForProviderSubnetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecForProviderSubnetworkSelectorPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecForProviderSubnetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecForProviderSubnetworkSelectorPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecForProviderSubnetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderSubnetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderSubnetworkSelectorPolicy(obj: ClusterV1Beta2SpecForProviderSubnetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * . Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigCloudrunConfig
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigCloudrunConfig {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigCloudrunConfig#disabled
   */
  readonly disabled?: boolean;

  /**
   * The load balancer type of CloudRun ingress service. It is external load balancer by default.
   * Set load_balancer_type=LOAD_BALANCER_TYPE_INTERNAL to configure it as internal load balancer.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigCloudrunConfig#loadBalancerType
   */
  readonly loadBalancerType?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigCloudrunConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigCloudrunConfig(obj: ClusterV1Beta2SpecInitProviderAddonsConfigCloudrunConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
    'loadBalancerType': obj.loadBalancerType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * .
 * The status of the ConfigConnector addon. It is disabled by default; Set enabled = true to enable.
 *
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigConfigConnectorConfig
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigConfigConnectorConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigConfigConnectorConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigConfigConnectorConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigConfigConnectorConfig(obj: ClusterV1Beta2SpecInitProviderAddonsConfigConfigConnectorConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * .
 * The status of the NodeLocal DNSCache addon. It is disabled by default.
 * Set enabled = true to enable.
 *
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigDnsCacheConfig
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigDnsCacheConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigDnsCacheConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigDnsCacheConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigDnsCacheConfig(obj: ClusterV1Beta2SpecInitProviderAddonsConfigDnsCacheConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * .
 * Whether this cluster should enable the Google Compute Engine Persistent Disk Container Storage Interface (CSI) Driver. Set enabled = true to enable.
 *
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig(obj: ClusterV1Beta2SpecInitProviderAddonsConfigGcePersistentDiskCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The status of the Filestore CSI driver addon,
 * which allows the usage of filestore instance as volumes.
 * It is disabled by default; set enabled = true to enable.
 *
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig(obj: ClusterV1Beta2SpecInitProviderAddonsConfigGcpFilestoreCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The status of the GCSFuse CSI driver addon,
 * which allows the usage of a gcs bucket as volumes.
 * It is disabled by default for Standard clusters; set enabled = true to enable.
 * It is enabled by default for Autopilot clusters with version 1.24 or later; set enabled = true to enable it explicitly.
 * See Enable the Cloud Storage FUSE CSI driver for more information.
 *
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigGcsFuseCsiDriverConfig
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigGcsFuseCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigGcsFuseCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigGcsFuseCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigGcsFuseCsiDriverConfig(obj: ClusterV1Beta2SpecInitProviderAddonsConfigGcsFuseCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * .
 * The status of the Backup for GKE agent addon. It is disabled by default; Set enabled = true to enable.
 *
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigGkeBackupAgentConfig
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigGkeBackupAgentConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigGkeBackupAgentConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigGkeBackupAgentConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigGkeBackupAgentConfig(obj: ClusterV1Beta2SpecInitProviderAddonsConfigGkeBackupAgentConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The status of the Horizontal Pod Autoscaling
 * addon, which increases or decreases the number of replica pods a replication controller
 * has based on the resource usage of the existing pods.
 * It is enabled by default;
 * set disabled = true to disable.
 *
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigHorizontalPodAutoscaling
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigHorizontalPodAutoscaling {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigHorizontalPodAutoscaling#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigHorizontalPodAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigHorizontalPodAutoscaling(obj: ClusterV1Beta2SpecInitProviderAddonsConfigHorizontalPodAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The status of the HTTP (L7) load balancing
 * controller addon, which makes it easy to set up HTTP load balancers for services in a
 * cluster. It is enabled by default; set disabled = true to disable.
 *
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigHttpLoadBalancing
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigHttpLoadBalancing {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigHttpLoadBalancing#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigHttpLoadBalancing' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigHttpLoadBalancing(obj: ClusterV1Beta2SpecInitProviderAddonsConfigHttpLoadBalancing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The status of the Lustre CSI driver addon,
 * which allows the usage of a Lustre instances as volumes.
 * It is disabled by default for Standard clusters; set enabled = true to enable.
 * It is disabled by default for Autopilot clusters; set enabled = true to enable.
 * Lustre CSI Driver Config has optional subfield
 * enable_legacy_lustre_port which allows the Lustre CSI driver to initialize LNet (the virtual networklayer for Lustre kernel module) using port 6988.
 * This flag is required to workaround a port conflict with the gke-metadata-server on GKE nodes.
 * See Enable Lustre CSI driver for more information.
 *
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigLustreCsiDriverConfig
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigLustreCsiDriverConfig {
  /**
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigLustreCsiDriverConfig#enableLegacyLustrePort
   */
  readonly enableLegacyLustrePort?: boolean;

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigLustreCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigLustreCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigLustreCsiDriverConfig(obj: ClusterV1Beta2SpecInitProviderAddonsConfigLustreCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableLegacyLustrePort': obj.enableLegacyLustrePort,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Whether we should enable the network policy addon
 * for the master.  This must be enabled in order to enable network policy for the nodes.
 * To enable this, you must also define a network_policy block,
 * otherwise nothing will happen.
 * It can only be disabled if the nodes already do not have network policies enabled.
 * Defaults to disabled; set disabled = false to enable.
 *
 * @default disabled; set disabled = false to enable.
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigNetworkPolicyConfig
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigNetworkPolicyConfig {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigNetworkPolicyConfig#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigNetworkPolicyConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigNetworkPolicyConfig(obj: ClusterV1Beta2SpecInitProviderAddonsConfigNetworkPolicyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The status of the Parallelstore CSI driver addon,
 * which allows the usage of a Parallelstore instances as volumes.
 * It is disabled by default for Standard clusters; set enabled = true to enable.
 * It is enabled by default for Autopilot clusters with version 1.29 or later; set enabled = true to enable it explicitly.
 * See Enable the Parallelstore CSI driver for more information.
 *
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigParallelstoreCsiDriverConfig
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigParallelstoreCsiDriverConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigParallelstoreCsiDriverConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigParallelstoreCsiDriverConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigParallelstoreCsiDriverConfig(obj: ClusterV1Beta2SpecInitProviderAddonsConfigParallelstoreCsiDriverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfig
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfig#enabled
   */
  readonly enabled?: boolean;

  /**
   * Logging configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfig#rayClusterLoggingConfig
   */
  readonly rayClusterLoggingConfig?: ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig;

  /**
   * Monitoring configuration for the cluster.
   * Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfig#rayClusterMonitoringConfig
   */
  readonly rayClusterMonitoringConfig?: ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfig(obj: ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'rayClusterLoggingConfig': toJson_ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig(obj.rayClusterLoggingConfig),
    'rayClusterMonitoringConfig': toJson_ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig(obj.rayClusterMonitoringConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * .
 * The status of the Stateful HA addon, which provides automatic configurable failover for stateful applications.
 * It is disabled by default for Standard clusters. Set enabled = true to enable.
 *
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigStatefulHaConfig
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigStatefulHaConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigStatefulHaConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigStatefulHaConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigStatefulHaConfig(obj: ClusterV1Beta2SpecInitProviderAddonsConfigStatefulHaConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Contains defaults for a node pool created by NAP. A subset of fields also apply to
 * GKE Autopilot clusters.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults
 */
export interface ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults {
  /**
   * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults#bootDiskKmsKey
   */
  readonly bootDiskKmsKey?: string;

  /**
   * Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Defaults to 100
   *
   * @default 100
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults#diskSize
   */
  readonly diskSize?: number;

  /**
   * Type of the disk attached to each node
   * (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-balanced'
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults#diskType
   */
  readonly diskType?: string;

  /**
   * The image type to use for this node. Note that changing the image type
   * will delete and recreate all nodes in the node pool.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults#imageType
   */
  readonly imageType?: string;

  /**
   * NodeManagement configuration for this NodePool. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults#management
   */
  readonly management?: ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement;

  /**
   * Minimum CPU platform to be used by this instance.
   * The instance may be scheduled on the specified or newer CPU platform. Applicable
   * values are the friendly names of CPU platforms, such as Intel Haswell. See the
   * official documentation
   * for more information.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults#minCpuPlatform
   */
  readonly minCpuPlatform?: string;

  /**
   * The set of Google API scopes to be made available
   * on all of the node VMs under the "default" service account.
   * Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set service_account to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults#oauthScopes
   */
  readonly oauthScopes?: string[];

  /**
   * The service account to be used by the Node VMs.
   * If not specified, the "default" service account is used.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Shielded Instance options. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig;

  /**
   * Specifies the upgrade settings for NAP created node pools. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults#upgradeSettings
   */
  readonly upgradeSettings?: ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults(obj: ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bootDiskKmsKey': obj.bootDiskKmsKey,
    'diskSize': obj.diskSize,
    'diskType': obj.diskType,
    'imageType': obj.imageType,
    'management': toJson_ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement(obj.management),
    'minCpuPlatform': obj.minCpuPlatform,
    'oauthScopes': obj.oauthScopes?.map(y => y),
    'serviceAccount': obj.serviceAccount,
    'shieldedInstanceConfig': toJson_ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig(obj.shieldedInstanceConfig),
    'upgradeSettings': toJson_ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings(obj.upgradeSettings),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingResourceLimits
 */
export interface ClusterV1Beta2SpecInitProviderClusterAutoscalingResourceLimits {
  /**
   * Maximum amount of the resource in the cluster.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingResourceLimits#maximum
   */
  readonly maximum?: number;

  /**
   * Minimum amount of the resource in the cluster.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingResourceLimits#minimum
   */
  readonly minimum?: number;

  /**
   * The type of the resource. For example, cpu and
   * memory.  See the guide to using Node Auto-Provisioning
   * for a list of types.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingResourceLimits#resourceType
   */
  readonly resourceType?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderClusterAutoscalingResourceLimits' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderClusterAutoscalingResourceLimits(obj: ClusterV1Beta2SpecInitProviderClusterAutoscalingResourceLimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximum': obj.maximum,
    'minimum': obj.minimum,
    'resourceType': obj.resourceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DNS endpoint configuration.
 *
 * @schema ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig
 */
export interface ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig {
  /**
   * Controls whether user traffic is allowed over this endpoint. Note that GCP-managed services may still use the endpoint even if this is false.
   *
   * @schema ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig#allowExternalTraffic
   */
  readonly allowExternalTraffic?: boolean;

  /**
   * (Output) The cluster's DNS endpoint.
   *
   * @schema ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig#endpoint
   */
  readonly endpoint?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig(obj: ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigDnsEndpointConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowExternalTraffic': obj.allowExternalTraffic,
    'endpoint': obj.endpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IP endpoint configuration.
 *
 * @schema ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig
 */
export interface ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig {
  /**
   * Controls whether to allow direct IP access. Defaults to true.
   *
   * @default true.
   * @schema ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig(obj: ClusterV1Beta2SpecInitProviderControlPlaneEndpointsConfigIpEndpointsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig
 */
export interface ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig {
  /**
   * List of secondary ranges names within this subnetwork that can be used for pod IPs.
   *
   * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig#podIpv4RangeNames
   */
  readonly podIpv4RangeNames?: string[];

  /**
   * The name or self_link of the Google Compute Engine
   * subnetwork in which the cluster's instances are launched.
   *
   * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig#subnetwork
   */
  readonly subnetwork?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig(obj: ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalIpRangesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podIpv4RangeNames': obj.podIpv4RangeNames?.map(y => y),
    'subnetwork': obj.subnetwork,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration for additional pod secondary ranges at
 * the cluster level. Used for Autopilot clusters and Standard clusters with which control of the
 * secondary Pod IP address assignment to node pools isn't needed. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig
 */
export interface ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig {
  /**
   * The names of the Pod ranges to add to the cluster.
   *
   * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig#podRangeNames
   */
  readonly podRangeNames?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig(obj: ClusterV1Beta2SpecInitProviderIpAllocationPolicyAdditionalPodRangesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podRangeNames': obj.podRangeNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig
 */
export interface ClusterV1Beta2SpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig {
  /**
   * The status of the Istio addon, which makes it easy to set up Istio for services in a
   * cluster. It is disabled by default. Set disabled = false to enable.
   *
   * @schema ClusterV1Beta2SpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig(obj: ClusterV1Beta2SpecInitProviderIpAllocationPolicyPodCidrOverprovisionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * structure documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicyDailyMaintenanceWindow
 */
export interface ClusterV1Beta2SpecInitProviderMaintenancePolicyDailyMaintenanceWindow {
  /**
   * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicyDailyMaintenanceWindow#startTime
   */
  readonly startTime?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderMaintenancePolicyDailyMaintenanceWindow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderMaintenancePolicyDailyMaintenanceWindow(obj: ClusterV1Beta2SpecInitProviderMaintenancePolicyDailyMaintenanceWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusion
 */
export interface ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusion {
  /**
   * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusion#endTime
   */
  readonly endTime?: string;

  /**
   * The name of the cluster, unique within the project and
   * location.
   *
   * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusion#exclusionName
   */
  readonly exclusionName?: string;

  /**
   * MaintenanceExclusionOptions provides maintenance exclusion related options.
   *
   * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusion#exclusionOptions
   */
  readonly exclusionOptions?: ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions;

  /**
   * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusion#startTime
   */
  readonly startTime?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusion' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusion(obj: ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'exclusionName': obj.exclusionName,
    'exclusionOptions': toJson_ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions(obj.exclusionOptions),
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * structure documented below
 *
 * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicyRecurringWindow
 */
export interface ClusterV1Beta2SpecInitProviderMaintenancePolicyRecurringWindow {
  /**
   * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicyRecurringWindow#endTime
   */
  readonly endTime?: string;

  /**
   * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicyRecurringWindow#recurrence
   */
  readonly recurrence?: string;

  /**
   * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicyRecurringWindow#startTime
   */
  readonly startTime?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderMaintenancePolicyRecurringWindow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderMaintenancePolicyRecurringWindow(obj: ClusterV1Beta2SpecInitProviderMaintenancePolicyRecurringWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'recurrence': obj.recurrence,
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Whether client certificate authorization is enabled for this cluster.  For example:
 *
 * @schema ClusterV1Beta2SpecInitProviderMasterAuthClientCertificateConfig
 */
export interface ClusterV1Beta2SpecInitProviderMasterAuthClientCertificateConfig {
  /**
   * @schema ClusterV1Beta2SpecInitProviderMasterAuthClientCertificateConfig#issueClientCertificate
   */
  readonly issueClientCertificate?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderMasterAuthClientCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderMasterAuthClientCertificateConfig(obj: ClusterV1Beta2SpecInitProviderMasterAuthClientCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'issueClientCertificate': obj.issueClientCertificate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks
 */
export interface ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks {
  /**
   * External network that can access Kubernetes master through HTTPS.
   * Must be specified in CIDR notation.
   *
   * @schema ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks#cidrBlock
   */
  readonly cidrBlock?: string;

  /**
   * Field for users to identify CIDR blocks.
   *
   * @schema ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks#displayName
   */
  readonly displayName?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks(obj: ClusterV1Beta2SpecInitProviderMasterAuthorizedNetworksConfigCidrBlocks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrBlock': obj.cidrBlock,
    'displayName': obj.displayName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for Advanced Datapath Monitoring. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig
 */
export interface ClusterV1Beta2SpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig {
  /**
   * Whether or not to enable advanced datapath metrics.
   *
   * @schema ClusterV1Beta2SpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig#enableMetrics
   */
  readonly enableMetrics?: boolean;

  /**
   * Whether or not Relay is enabled.
   *
   * @schema ClusterV1Beta2SpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig#enableRelay
   */
  readonly enableRelay?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig(obj: ClusterV1Beta2SpecInitProviderMonitoringConfigAdvancedDatapathObservabilityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableMetrics': obj.enableMetrics,
    'enableRelay': obj.enableRelay,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for Managed Service for Prometheus. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheus
 */
export interface ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheus {
  /**
   * Configuration options for GKE Auto-Monitoring.
   *
   * @schema ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheus#autoMonitoringConfig
   */
  readonly autoMonitoringConfig?: ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig;

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheus#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheus(obj: ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoMonitoringConfig': toJson_ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig(obj.autoMonitoringConfig),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterV1Beta2SpecInitProviderNetworkRefPolicy
 */
export interface ClusterV1Beta2SpecInitProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecInitProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecInitProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecInitProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecInitProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNetworkRefPolicy(obj: ClusterV1Beta2SpecInitProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterV1Beta2SpecInitProviderNetworkSelectorPolicy
 */
export interface ClusterV1Beta2SpecInitProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecInitProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecInitProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecInitProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecInitProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNetworkSelectorPolicy(obj: ClusterV1Beta2SpecInitProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies options for controlling
 * advanced machine features. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures {
  /**
   * Defines whether the instance should have nested virtualization enabled. Defaults to false.
   *
   * @default false.
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures#enableNestedVirtualization
   */
  readonly enableNestedVirtualization?: boolean;

  /**
   * Defines the performance monitoring unit PMU level. Valid values are ARCHITECTURAL, STANDARD, or ENHANCED. Defaults to off.
   *
   * @default off.
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures#performanceMonitoringUnit
   */
  readonly performanceMonitoringUnit?: string;

  /**
   * The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures#threadsPerCore
   */
  readonly threadsPerCore?: number;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures(obj: ClusterV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableNestedVirtualization': obj.enableNestedVirtualization,
    'performanceMonitoringUnit': obj.performanceMonitoringUnit,
    'threadsPerCore': obj.threadsPerCore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for Confidential Nodes feature. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigConfidentialNodes
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigConfidentialNodes {
  /**
   * Defines the type of technology used
   * by the confidential node.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigConfidentialNodes#confidentialInstanceType
   */
  readonly confidentialInstanceType?: string;

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigConfidentialNodes#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigConfidentialNodes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigConfidentialNodes(obj: ClusterV1Beta2SpecInitProviderNodeConfigConfidentialNodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confidentialInstanceType': obj.confidentialInstanceType,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters to customize containerd runtime. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfig {
  /**
   * Configuration for private container registries. There are two fields in this config:
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfig#privateRegistryAccessConfig
   */
  readonly privateRegistryAccessConfig?: ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateRegistryAccessConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(obj.privateRegistryAccessConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig {
  /**
   * Number of raw-block local NVMe SSD disks to be attached to the node utilized for GKE Data Cache. If zero, then GKE Data Cache will not be enabled in the nodes.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig#dataCacheCount
   */
  readonly dataCacheCount?: number;

  /**
   * The amount of local SSD disks that will be
   * attached to each cluster node. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataCacheCount': obj.dataCacheCount,
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
 * Node Pool must enable gvnic.
 * GKE version 1.25.2-gke.1700 or later.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigFastSocket
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigFastSocket {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigFastSocket#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigFastSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigFastSocket(obj: ClusterV1Beta2SpecInitProviderNodeConfigFastSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters for the Google Container Filesystem (GCFS).
 * If unspecified, GCFS will not be enabled on the node pool. When enabling this feature you must specify image_type = "COS_CONTAINERD" and node_version from GKE versions 1.19 or later to use it.
 * For GKE versions 1.19, 1.20, and 1.21, the recommended minimum node_version would be 1.19.15-gke.1300, 1.20.11-gke.1300, and 1.21.5-gke.1300 respectively.
 * A machine_type that has more than 16 GiB of memory is also recommended.
 * GCFS must be enabled in order to use image streaming.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigGcfsConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigGcfsConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigGcfsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigGcfsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigGcfsConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigGcfsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigGuestAccelerator
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigGuestAccelerator {
  /**
   * The number of the guest accelerator cards exposed to this instance.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigGuestAccelerator#count
   */
  readonly count?: number;

  /**
   * Configuration for auto installation of GPU driver. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigGuestAccelerator#gpuDriverInstallationConfig
   */
  readonly gpuDriverInstallationConfig?: ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig;

  /**
   * Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig user guide.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigGuestAccelerator#gpuPartitionSize
   */
  readonly gpuPartitionSize?: string;

  /**
   * Configuration for GPU sharing. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigGuestAccelerator#gpuSharingConfig
   */
  readonly gpuSharingConfig?: ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig;

  /**
   * The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigGuestAccelerator#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigGuestAccelerator' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigGuestAccelerator(obj: ClusterV1Beta2SpecInitProviderNodeConfigGuestAccelerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'gpuDriverInstallationConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(obj.gpuDriverInstallationConfig),
    'gpuPartitionSize': obj.gpuPartitionSize,
    'gpuSharingConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig(obj.gpuSharingConfig),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Google Virtual NIC (gVNIC) is a virtual network interface.
 * Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
 * gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
 * GKE node version 1.15.11-gke.15 or later
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigGvnic
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigGvnic {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigGvnic#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigGvnic' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigGvnic(obj: ClusterV1Beta2SpecInitProviderNodeConfigGvnic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The maintenance policy to use for the cluster. Structure is
 * documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy {
  /**
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy#maintenanceInterval
   */
  readonly maintenanceInterval?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy(obj: ClusterV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maintenanceInterval': obj.maintenanceInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubelet configuration, currently supported attributes can be found here.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig {
  /**
   * Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods. The allowed sysctl groups are kernel.shm*, kernel.msg*, kernel.sem, fs.mqueue.*, and net.*.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig#allowedUnsafeSysctls
   */
  readonly allowedUnsafeSysctls?: string[];

  /**
   * Defines the maximum number of container log files that can be present for a container. The integer must be between 2 and 10, inclusive.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig#containerLogMaxFiles
   */
  readonly containerLogMaxFiles?: number;

  /**
   * Defines the maximum size of the
   * container log file before it is rotated. Specified as a positive number and a
   * unit suffix, such as "100Ki", "10Mi". Valid units are "Ki", "Mi", "Gi".
   * The value must be between "10Mi" and "500Mi", inclusive. And the total container log size
   * (container_log_max_size * container_log_max_files) cannot exceed 1% of the total storage of the node.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig#containerLogMaxSize
   */
  readonly containerLogMaxSize?: string;

  /**
   * If true, enables CPU CFS quota enforcement for
   * containers that specify CPU limits.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig#cpuCfsQuota
   */
  readonly cpuCfsQuota?: boolean;

  /**
   * The CPU CFS quota period value. Specified
   * as a sequence of decimal numbers, each with optional fraction and a unit suffix,
   * such as "300ms". Valid time units are "ns", "us" (or "s"), "ms", "s", "m",
   * "h". The value must be a positive duration.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig#cpuCfsQuotaPeriod
   */
  readonly cpuCfsQuotaPeriod?: string;

  /**
   * The CPU management policy on the node. See
   * K8S CPU Management Policies.
   * One of "none" or "static". If unset (or set to the empty string ""), the API will treat the field as if set to "none".
   * Prior to the 6.4.0 this field was marked as required. The workaround for the required field
   * is setting the empty string "", which will function identically to not setting this field.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig#cpuManagerPolicy
   */
  readonly cpuManagerPolicy?: string;

  /**
   * Defines the percent of disk usage after which image garbage collection is always run. The integer must be between 10 and 85, inclusive.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig#imageGcHighThresholdPercent
   */
  readonly imageGcHighThresholdPercent?: number;

  /**
   * Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to. The integer must be between 10 and 85, inclusive.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig#imageGcLowThresholdPercent
   */
  readonly imageGcLowThresholdPercent?: number;

  /**
   * Defines the maximum age an image can be unused before it is garbage collected. Specified as a sequence of decimal numbers, each with optional fraction and a unit suffix, such as "300s", "1.5m", and "2h45m". Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h". The value must be a positive duration.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig#imageMaximumGcAge
   */
  readonly imageMaximumGcAge?: string;

  /**
   * Defines the minimum age for an unused image before it is garbage collected. Specified as a sequence of decimal numbers, each with optional fraction and a unit suffix, such as "300s", "1.5m". The value cannot be greater than "2m".
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig#imageMinimumGcAge
   */
  readonly imageMinimumGcAge?: string;

  /**
   * only port is enabled for newly created node pools in the cluster. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;

  /**
   * Controls the maximum number of processes allowed to run in a pod. The value must be greater than or equal to 1024 and less than 4194304.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig#podPidsLimit
   */
  readonly podPidsLimit?: number;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigKubeletConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedUnsafeSysctls': obj.allowedUnsafeSysctls?.map(y => y),
    'containerLogMaxFiles': obj.containerLogMaxFiles,
    'containerLogMaxSize': obj.containerLogMaxSize,
    'cpuCfsQuota': obj.cpuCfsQuota,
    'cpuCfsQuotaPeriod': obj.cpuCfsQuotaPeriod,
    'cpuManagerPolicy': obj.cpuManagerPolicy,
    'imageGcHighThresholdPercent': obj.imageGcHighThresholdPercent,
    'imageGcLowThresholdPercent': obj.imageGcLowThresholdPercent,
    'imageMaximumGcAge': obj.imageMaximumGcAge,
    'imageMinimumGcAge': obj.imageMinimumGcAge,
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
    'podPidsLimit': obj.podPidsLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters that can be configured on Linux nodes. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig {
  /**
   * Possible cgroup modes that can be used.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig#cgroupMode
   */
  readonly cgroupMode?: string;

  /**
   * Amounts for 2M and 1G hugepages. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig#hugepagesConfig
   */
  readonly hugepagesConfig?: ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig;

  /**
   * The Linux kernel parameters to be applied to the nodes
   * and all pods running on the nodes. Specified as a map from the key, such as
   * net.core.wmem_max, to a string value. Currently supported attributes can be found here.
   * Note that validations happen all server side. All attributes are optional.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig#sysctls
   */
  readonly sysctls?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cgroupMode': obj.cgroupMode,
    'hugepagesConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig(obj.hugepagesConfig),
    'sysctls': ((obj.sysctls) === undefined) ? undefined : (Object.entries(obj.sysctls).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters for the local NVMe SSDs. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig {
  /**
   * The amount of local SSD disks that will be
   * attached to each cluster node. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigReservationAffinity
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigReservationAffinity {
  /**
   * The type of reservation consumption
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigReservationAffinity#consumeReservationType
   */
  readonly consumeReservationType?: string;

  /**
   * Key for taint.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigReservationAffinity#key
   */
  readonly key?: string;

  /**
   * name"
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigReservationAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigReservationAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigReservationAffinity(obj: ClusterV1Beta2SpecInitProviderNodeConfigReservationAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumeReservationType': obj.consumeReservationType,
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks {
  /**
   * Path to disk image to create the secondary boot disk from. After using the gke-disk-image-builder, this argument should be global/images/DISK_IMAGE_NAME.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks#diskImage
   */
  readonly diskImage?: string;

  /**
   * How to expose the node metadata to the workload running on the node.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks(obj: ClusterV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'diskImage': obj.diskImage,
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRef
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRef#policy
   */
  readonly policy?: ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRef(obj: ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelector
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelector#policy
   */
  readonly policy?: ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelector(obj: ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Shielded Instance options. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig {
  /**
   * Defines if the instance has integrity monitoring enabled.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * Defines if the instance has Secure Boot enabled.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Allows specifying multiple node affinities useful for running workloads on sole tenant nodes. node_affinity structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfig {
  /**
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfig#nodeAffinity
   */
  readonly nodeAffinity?: ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': obj.nodeAffinity?.map(y => toJson_ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigTaint
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigTaint {
  /**
   * Effect for taint. Accepted values are NO_SCHEDULE, PREFER_NO_SCHEDULE, and NO_EXECUTE.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigTaint#effect
   */
  readonly effect?: string;

  /**
   * Key for taint.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigTaint#key
   */
  readonly key?: string;

  /**
   * Value for taint.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigTaint#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigTaint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigTaint(obj: ClusterV1Beta2SpecInitProviderNodeConfigTaint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Windows node configuration, currently supporting OSVersion attribute. The value must be one of [OS_VERSION_UNSPECIFIED, OS_VERSION_LTSC2019, OS_VERSION_LTSC2022]. For example:
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig {
  /**
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig#osversion
   */
  readonly osversion?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'osversion': obj.osversion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata configuration to expose to workloads on the node pool.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig {
  /**
   * How to expose the node metadata to the workload running on the node.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Linux system configuration for the cluster's automatically provisioned node pools. Only cgroup_mode field is supported in node_pool_auto_config. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodePoolAutoConfigLinuxNodeConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodePoolAutoConfigLinuxNodeConfig {
  /**
   * Possible cgroup modes that can be used.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolAutoConfigLinuxNodeConfig#cgroupMode
   */
  readonly cgroupMode?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodePoolAutoConfigLinuxNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodePoolAutoConfigLinuxNodeConfig(obj: ClusterV1Beta2SpecInitProviderNodePoolAutoConfigLinuxNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cgroupMode': obj.cgroupMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The network tag config for the cluster's automatically provisioned node pools. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNetworkTags
 */
export interface ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNetworkTags {
  /**
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNetworkTags#tags
   */
  readonly tags?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNetworkTags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNetworkTags(obj: ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNetworkTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubelet configuration for Autopilot clusters. Currently, only insecure_kubelet_readonly_port_enabled is supported here.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNodeKubeletConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNodeKubeletConfig {
  /**
   * only port is enabled for newly created node pools in the cluster. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNodeKubeletConfig#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNodeKubeletConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNodeKubeletConfig(obj: ClusterV1Beta2SpecInitProviderNodePoolAutoConfigNodeKubeletConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Subset of NodeConfig message that has defaults.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaults
 */
export interface ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaults {
  /**
   * Parameters to customize containerd runtime. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaults#containerdConfig
   */
  readonly containerdConfig?: ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig;

  /**
   * The default Google Container Filesystem (GCFS) configuration at the cluster level. e.g. enable image streaming across all the node pools within the cluster. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaults#gcfsConfig
   */
  readonly gcfsConfig?: ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig;

  /**
   * only port is enabled for newly created node pools in the cluster. It is strongly recommended to set this to FALSE. Possible values: TRUE, FALSE.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaults#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;

  /**
   * The type of logging agent that is deployed by default for newly created node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. See Increasing logging agent throughput for more information.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaults#loggingVariant
   */
  readonly loggingVariant?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaults' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaults(obj: ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerdConfig': toJson_ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig(obj.containerdConfig),
    'gcfsConfig': toJson_ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig(obj.gcfsConfig),
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
    'loggingVariant': obj.loggingVariant,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pubsub config for the cluster's upgrade notifications.
 *
 * @schema ClusterV1Beta2SpecInitProviderNotificationConfigPubsub
 */
export interface ClusterV1Beta2SpecInitProviderNotificationConfigPubsub {
  /**
   * Whether or not the notification config is enabled
   *
   * @schema ClusterV1Beta2SpecInitProviderNotificationConfigPubsub#enabled
   */
  readonly enabled?: boolean;

  /**
   * Choose what type of notifications you want to receive. If no filters are applied, you'll receive all notification types. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderNotificationConfigPubsub#filter
   */
  readonly filter?: ClusterV1Beta2SpecInitProviderNotificationConfigPubsubFilter;

  /**
   * The pubsub topic to push upgrade notifications to. Must be in the same project as the cluster. Must be in the format: projects/{project}/topics/{topic}.
   *
   * @schema ClusterV1Beta2SpecInitProviderNotificationConfigPubsub#topic
   */
  readonly topic?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNotificationConfigPubsub' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNotificationConfigPubsub(obj: ClusterV1Beta2SpecInitProviderNotificationConfigPubsub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'filter': toJson_ClusterV1Beta2SpecInitProviderNotificationConfigPubsubFilter(obj.filter),
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Controls cluster master global
 * access settings. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig
 */
export interface ClusterV1Beta2SpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig {
  /**
   * Whether the cluster master is accessible globally or
   * not.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig(obj: ClusterV1Beta2SpecInitProviderPrivateClusterConfigMasterGlobalAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Subnetwork in compute to populate privateEndpointSubnetwork.
 *
 * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef
 */
export interface ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef#policy
   */
  readonly policy?: ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef(obj: ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Subnetwork in compute to populate privateEndpointSubnetwork.
 *
 * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector
 */
export interface ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector#policy
   */
  readonly policy?: ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector(obj: ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters for using BigQuery as the destination of resource usage export.
 *
 * @schema ClusterV1Beta2SpecInitProviderResourceUsageExportConfigBigqueryDestination
 */
export interface ClusterV1Beta2SpecInitProviderResourceUsageExportConfigBigqueryDestination {
  /**
   * The ID of a BigQuery Dataset. For Example:
   *
   * @schema ClusterV1Beta2SpecInitProviderResourceUsageExportConfigBigqueryDestination#datasetId
   */
  readonly datasetId?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderResourceUsageExportConfigBigqueryDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderResourceUsageExportConfigBigqueryDestination(obj: ClusterV1Beta2SpecInitProviderResourceUsageExportConfigBigqueryDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetId': obj.datasetId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterV1Beta2SpecInitProviderSubnetworkRefPolicy
 */
export interface ClusterV1Beta2SpecInitProviderSubnetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecInitProviderSubnetworkRefPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecInitProviderSubnetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecInitProviderSubnetworkRefPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecInitProviderSubnetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderSubnetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderSubnetworkRefPolicy(obj: ClusterV1Beta2SpecInitProviderSubnetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterV1Beta2SpecInitProviderSubnetworkSelectorPolicy
 */
export interface ClusterV1Beta2SpecInitProviderSubnetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecInitProviderSubnetworkSelectorPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecInitProviderSubnetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecInitProviderSubnetworkSelectorPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecInitProviderSubnetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderSubnetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderSubnetworkSelectorPolicy(obj: ClusterV1Beta2SpecInitProviderSubnetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum ClusterV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum ClusterV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Logging configuration for the cluster.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig(obj: ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Monitoring configuration for the cluster.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig
 */
export interface ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig(obj: ClusterV1Beta2SpecForProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodeManagement configuration for this NodePool. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement
 */
export interface ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement {
  /**
   * Specifies whether the node auto-repair is enabled for the node pool. If enabled, the nodes in this node pool will be monitored and, if they fail health checks too many times, an automatic repair action will be triggered.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement#autoRepair
   */
  readonly autoRepair?: boolean;

  /**
   * Specifies whether node auto-upgrade is enabled for the node pool. If enabled, node auto-upgrade helps keep the nodes in your node pool up to date with the latest release version of Kubernetes.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement#autoUpgrade
   */
  readonly autoUpgrade?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement(obj: ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsManagement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoRepair': obj.autoRepair,
    'autoUpgrade': obj.autoUpgrade,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Shielded Instance options. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig
 */
export interface ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig {
  /**
   * Defines if the instance has integrity monitoring enabled.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * Defines if the instance has Secure Boot enabled.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig(obj: ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the upgrade settings for NAP created node pools. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings
 */
export interface ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings {
  /**
   * Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#blueGreenSettings
   */
  readonly blueGreenSettings?: ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings;

  /**
   * The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
   *
   * @default 0.
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#maxSurge
   */
  readonly maxSurge?: number;

  /**
   * The maximum number of nodes that can be simultaneously unavailable during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
   *
   * @default 0.
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#maxUnavailable
   */
  readonly maxUnavailable?: number;

  /**
   * Strategy used for node pool update. Strategy can only be one of BLUE_GREEN or SURGE. The default is value is SURGE.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#strategy
   */
  readonly strategy?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings(obj: ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blueGreenSettings': toJson_ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings(obj.blueGreenSettings),
    'maxSurge': obj.maxSurge,
    'maxUnavailable': obj.maxUnavailable,
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MaintenanceExclusionOptions provides maintenance exclusion related options.
 *
 * @schema ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions
 */
export interface ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions {
  /**
   * Whether or not to enable GKE Auto-Monitoring. Supported values include: ALL, NONE.
   *
   * @schema ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions#scope
   */
  readonly scope?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions(obj: ClusterV1Beta2SpecForProviderMaintenancePolicyMaintenanceExclusionExclusionOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scope': obj.scope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration options for GKE Auto-Monitoring.
 *
 * @schema ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig
 */
export interface ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig {
  /**
   * Whether or not to enable GKE Auto-Monitoring. Supported values include: ALL, NONE.
   *
   * @schema ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig#scope
   */
  readonly scope?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig(obj: ClusterV1Beta2SpecForProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scope': obj.scope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecForProviderNetworkRefPolicyResolution
 */
export enum ClusterV1Beta2SpecForProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecForProviderNetworkRefPolicyResolve
 */
export enum ClusterV1Beta2SpecForProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecForProviderNetworkSelectorPolicyResolution
 */
export enum ClusterV1Beta2SpecForProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecForProviderNetworkSelectorPolicyResolve
 */
export enum ClusterV1Beta2SpecForProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Configuration for private container registries. There are two fields in this config:
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig {
  /**
   * List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See how to configure for private container registries for more detail. Example:
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#certificateAuthorityDomainConfig
   */
  readonly certificateAuthorityDomainConfig?: ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig[];

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityDomainConfig': obj.certificateAuthorityDomainConfig?.map(y => toJson_ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(y)),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for auto installation of GPU driver. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
  /**
   * Mode for how the GPU driver is installed.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig#gpuDriverVersion
   */
  readonly gpuDriverVersion?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuDriverVersion': obj.gpuDriverVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for GPU sharing. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig {
  /**
   * The type of GPU sharing strategy to enable on the GPU node.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig#gpuSharingStrategy
   */
  readonly gpuSharingStrategy?: string;

  /**
   * The maximum number of containers that can share a GPU.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig#maxSharedClientsPerGpu
   */
  readonly maxSharedClientsPerGpu?: number;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuSharingStrategy': obj.gpuSharingStrategy,
    'maxSharedClientsPerGpu': obj.maxSharedClientsPerGpu,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Amounts for 2M and 1G hugepages. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig {
  /**
   * Amount of 1G hugepages.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize1G
   */
  readonly hugepageSize1G?: number;

  /**
   * Amount of 2M hugepages.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize2M
   */
  readonly hugepageSize2M?: number;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hugepageSize1G': obj.hugepageSize1G,
    'hugepageSize2M': obj.hugepageSize2M,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy(obj: ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy(obj: ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity {
  /**
   * Key for taint.
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity#key
   */
  readonly key?: string;

  /**
   * Specifies affinity or anti-affinity. Accepted values are "IN" or "NOT_IN"
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity#operator
   */
  readonly operator?: string;

  /**
   * name"
   *
   * @schema ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity(obj: ClusterV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters to customize containerd runtime. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig
 */
export interface ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig {
  /**
   * Configuration for private container registries. There are two fields in this config:
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig#privateRegistryAccessConfig
   */
  readonly privateRegistryAccessConfig?: ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig(obj: ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateRegistryAccessConfig': toJson_ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig(obj.privateRegistryAccessConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The default Google Container Filesystem (GCFS) configuration at the cluster level. e.g. enable image streaming across all the node pools within the cluster. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig
 */
export interface ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig(obj: ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Choose what type of notifications you want to receive. If no filters are applied, you'll receive all notification types. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderNotificationConfigPubsubFilter
 */
export interface ClusterV1Beta2SpecForProviderNotificationConfigPubsubFilter {
  /**
   * Can be used to filter what notifications are sent. Accepted values are UPGRADE_AVAILABLE_EVENT, UPGRADE_EVENT, SECURITY_BULLETIN_EVENT and UPGRADE_INFO_EVENT. See Filtering notifications for more details.
   *
   * @schema ClusterV1Beta2SpecForProviderNotificationConfigPubsubFilter#eventType
   */
  readonly eventType?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNotificationConfigPubsubFilter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNotificationConfigPubsubFilter(obj: ClusterV1Beta2SpecForProviderNotificationConfigPubsubFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventType': obj.eventType?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy
 */
export interface ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy(obj: ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy
 */
export interface ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy(obj: ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecForProviderSubnetworkRefPolicyResolution
 */
export enum ClusterV1Beta2SpecForProviderSubnetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecForProviderSubnetworkRefPolicyResolve
 */
export enum ClusterV1Beta2SpecForProviderSubnetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecForProviderSubnetworkSelectorPolicyResolution
 */
export enum ClusterV1Beta2SpecForProviderSubnetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecForProviderSubnetworkSelectorPolicyResolve
 */
export enum ClusterV1Beta2SpecForProviderSubnetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Logging configuration for the cluster.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig(obj: ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Monitoring configuration for the cluster.
 * Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig
 */
export interface ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig(obj: ClusterV1Beta2SpecInitProviderAddonsConfigRayOperatorConfigRayClusterMonitoringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodeManagement configuration for this NodePool. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement
 */
export interface ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement {
  /**
   * Specifies whether the node auto-repair is enabled for the node pool. If enabled, the nodes in this node pool will be monitored and, if they fail health checks too many times, an automatic repair action will be triggered.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement#autoRepair
   */
  readonly autoRepair?: boolean;

  /**
   * Specifies whether node auto-upgrade is enabled for the node pool. If enabled, node auto-upgrade helps keep the nodes in your node pool up to date with the latest release version of Kubernetes.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement#autoUpgrade
   */
  readonly autoUpgrade?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement(obj: ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsManagement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoRepair': obj.autoRepair,
    'autoUpgrade': obj.autoUpgrade,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Shielded Instance options. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig
 */
export interface ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig {
  /**
   * Defines if the instance has integrity monitoring enabled.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * Defines if the instance has Secure Boot enabled.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig(obj: ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the upgrade settings for NAP created node pools. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings
 */
export interface ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings {
  /**
   * Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#blueGreenSettings
   */
  readonly blueGreenSettings?: ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings;

  /**
   * The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
   *
   * @default 0.
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#maxSurge
   */
  readonly maxSurge?: number;

  /**
   * The maximum number of nodes that can be simultaneously unavailable during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
   *
   * @default 0.
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#maxUnavailable
   */
  readonly maxUnavailable?: number;

  /**
   * Strategy used for node pool update. Strategy can only be one of BLUE_GREEN or SURGE. The default is value is SURGE.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings#strategy
   */
  readonly strategy?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings(obj: ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blueGreenSettings': toJson_ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings(obj.blueGreenSettings),
    'maxSurge': obj.maxSurge,
    'maxUnavailable': obj.maxUnavailable,
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MaintenanceExclusionOptions provides maintenance exclusion related options.
 *
 * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions
 */
export interface ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions {
  /**
   * Whether or not to enable GKE Auto-Monitoring. Supported values include: ALL, NONE.
   *
   * @schema ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions#scope
   */
  readonly scope?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions(obj: ClusterV1Beta2SpecInitProviderMaintenancePolicyMaintenanceExclusionExclusionOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scope': obj.scope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration options for GKE Auto-Monitoring.
 *
 * @schema ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig
 */
export interface ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig {
  /**
   * Whether or not to enable GKE Auto-Monitoring. Supported values include: ALL, NONE.
   *
   * @schema ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig#scope
   */
  readonly scope?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig(obj: ClusterV1Beta2SpecInitProviderMonitoringConfigManagedPrometheusAutoMonitoringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scope': obj.scope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecInitProviderNetworkRefPolicyResolution
 */
export enum ClusterV1Beta2SpecInitProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecInitProviderNetworkRefPolicyResolve
 */
export enum ClusterV1Beta2SpecInitProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecInitProviderNetworkSelectorPolicyResolution
 */
export enum ClusterV1Beta2SpecInitProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecInitProviderNetworkSelectorPolicyResolve
 */
export enum ClusterV1Beta2SpecInitProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Configuration for private container registries. There are two fields in this config:
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig {
  /**
   * List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See how to configure for private container registries for more detail. Example:
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#certificateAuthorityDomainConfig
   */
  readonly certificateAuthorityDomainConfig?: ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig[];

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityDomainConfig': obj.certificateAuthorityDomainConfig?.map(y => toJson_ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(y)),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for auto installation of GPU driver. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
  /**
   * Mode for how the GPU driver is installed.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig#gpuDriverVersion
   */
  readonly gpuDriverVersion?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuDriverVersion': obj.gpuDriverVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for GPU sharing. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig {
  /**
   * The type of GPU sharing strategy to enable on the GPU node.
   * Accepted values are:
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig#gpuSharingStrategy
   */
  readonly gpuSharingStrategy?: string;

  /**
   * The maximum number of containers that can share a GPU.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig#maxSharedClientsPerGpu
   */
  readonly maxSharedClientsPerGpu?: number;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuSharingStrategy': obj.gpuSharingStrategy,
    'maxSharedClientsPerGpu': obj.maxSharedClientsPerGpu,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Amounts for 2M and 1G hugepages. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig {
  /**
   * Amount of 1G hugepages.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize1G
   */
  readonly hugepageSize1G?: number;

  /**
   * Amount of 2M hugepages.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize2M
   */
  readonly hugepageSize2M?: number;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hugepageSize1G': obj.hugepageSize1G,
    'hugepageSize2M': obj.hugepageSize2M,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy(obj: ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy(obj: ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity {
  /**
   * Key for taint.
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity#key
   */
  readonly key?: string;

  /**
   * Specifies affinity or anti-affinity. Accepted values are "IN" or "NOT_IN"
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity#operator
   */
  readonly operator?: string;

  /**
   * name"
   *
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity(obj: ClusterV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters to customize containerd runtime. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig {
  /**
   * Configuration for private container registries. There are two fields in this config:
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig#privateRegistryAccessConfig
   */
  readonly privateRegistryAccessConfig?: ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig(obj: ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateRegistryAccessConfig': toJson_ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig(obj.privateRegistryAccessConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The default Google Container Filesystem (GCFS) configuration at the cluster level. e.g. enable image streaming across all the node pools within the cluster. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig {
  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig(obj: ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsGcfsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Choose what type of notifications you want to receive. If no filters are applied, you'll receive all notification types. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderNotificationConfigPubsubFilter
 */
export interface ClusterV1Beta2SpecInitProviderNotificationConfigPubsubFilter {
  /**
   * Can be used to filter what notifications are sent. Accepted values are UPGRADE_AVAILABLE_EVENT, UPGRADE_EVENT, SECURITY_BULLETIN_EVENT and UPGRADE_INFO_EVENT. See Filtering notifications for more details.
   *
   * @schema ClusterV1Beta2SpecInitProviderNotificationConfigPubsubFilter#eventType
   */
  readonly eventType?: string[];
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNotificationConfigPubsubFilter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNotificationConfigPubsubFilter(obj: ClusterV1Beta2SpecInitProviderNotificationConfigPubsubFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventType': obj.eventType?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy
 */
export interface ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy(obj: ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy
 */
export interface ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy#resolution
   */
  readonly resolution?: ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy#resolve
   */
  readonly resolve?: ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy(obj: ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecInitProviderSubnetworkRefPolicyResolution
 */
export enum ClusterV1Beta2SpecInitProviderSubnetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecInitProviderSubnetworkRefPolicyResolve
 */
export enum ClusterV1Beta2SpecInitProviderSubnetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecInitProviderSubnetworkSelectorPolicyResolution
 */
export enum ClusterV1Beta2SpecInitProviderSubnetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecInitProviderSubnetworkSelectorPolicyResolve
 */
export enum ClusterV1Beta2SpecInitProviderSubnetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings
 */
export interface ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings {
  /**
   * Time needed after draining entire blue pool. After this period, blue pool will be cleaned up. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings#nodePoolSoakDuration
   */
  readonly nodePoolSoakDuration?: string;

  /**
   * green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings#standardRolloutPolicy
   */
  readonly standardRolloutPolicy?: ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings(obj: ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodePoolSoakDuration': obj.nodePoolSoakDuration,
    'standardRolloutPolicy': toJson_ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(obj.standardRolloutPolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
  /**
   * @schema ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#fqdns
   */
  readonly fqdns?: string[];

  /**
   * @schema ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#gcpSecretManagerCertificateConfig
   */
  readonly gcpSecretManagerCertificateConfig?: ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fqdns': obj.fqdns?.map(y => y),
    'gcpSecretManagerCertificateConfig': toJson_ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj.gcpSecretManagerCertificateConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicyResolution
 */
export enum ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicyResolve
 */
export enum ClusterV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicyResolution
 */
export enum ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicyResolve
 */
export enum ClusterV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Configuration for private container registries. There are two fields in this config:
 *
 * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig
 */
export interface ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig {
  /**
   * List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See how to configure for private container registries for more detail. Example:
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig#certificateAuthorityDomainConfig
   */
  readonly certificateAuthorityDomainConfig?: ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig[];

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig(obj: ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityDomainConfig': obj.certificateAuthorityDomainConfig?.map(y => toJson_ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(y)),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution
 */
export enum ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve
 */
export enum ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution
 */
export enum ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve
 */
export enum ClusterV1Beta2SpecForProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings
 */
export interface ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings {
  /**
   * Time needed after draining entire blue pool. After this period, blue pool will be cleaned up. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings#nodePoolSoakDuration
   */
  readonly nodePoolSoakDuration?: string;

  /**
   * green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings#standardRolloutPolicy
   */
  readonly standardRolloutPolicy?: ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings(obj: ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodePoolSoakDuration': obj.nodePoolSoakDuration,
    'standardRolloutPolicy': toJson_ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(obj.standardRolloutPolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
  /**
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#fqdns
   */
  readonly fqdns?: string[];

  /**
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#gcpSecretManagerCertificateConfig
   */
  readonly gcpSecretManagerCertificateConfig?: ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fqdns': obj.fqdns?.map(y => y),
    'gcpSecretManagerCertificateConfig': toJson_ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj.gcpSecretManagerCertificateConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicyResolution
 */
export enum ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicyResolve
 */
export enum ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicyResolution
 */
export enum ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicyResolve
 */
export enum ClusterV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Configuration for private container registries. There are two fields in this config:
 *
 * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig {
  /**
   * List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See how to configure for private container registries for more detail. Example:
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig#certificateAuthorityDomainConfig
   */
  readonly certificateAuthorityDomainConfig?: ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig[];

  /**
   * Enables vertical pod autoscaling
   *
   * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig(obj: ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityDomainConfig': obj.certificateAuthorityDomainConfig?.map(y => toJson_ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(y)),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution
 */
export enum ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve
 */
export enum ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution
 */
export enum ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve
 */
export enum ClusterV1Beta2SpecInitProviderPrivateClusterConfigPrivateEndpointSubnetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy
 */
export interface ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
  /**
   * Number of blue nodes to drain in a batch. Only one of the batch_percentage or batch_node_count can be specified.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchNodeCount
   */
  readonly batchNodeCount?: number;

  /**
   * :  Percentage of the bool pool nodes to drain in a batch. The range of this field should be (0.0, 1.0). Only one of the batch_percentage or batch_node_count can be specified.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchPercentage
   */
  readonly batchPercentage?: number;

  /**
   * Soak time after each batch gets drained. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".`.
   *
   * @schema ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchSoakDuration
   */
  readonly batchSoakDuration?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(obj: ClusterV1Beta2SpecForProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchNodeCount': obj.batchNodeCount,
    'batchPercentage': obj.batchPercentage,
    'batchSoakDuration': obj.batchSoakDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig
 */
export interface ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
  /**
   * @schema ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig#secretUri
   */
  readonly secretUri?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj: ClusterV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretUri': obj.secretUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig
 */
export interface ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
  /**
   * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#fqdns
   */
  readonly fqdns?: string[];

  /**
   * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#gcpSecretManagerCertificateConfig
   */
  readonly gcpSecretManagerCertificateConfig?: ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(obj: ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fqdns': obj.fqdns?.map(y => y),
    'gcpSecretManagerCertificateConfig': toJson_ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj.gcpSecretManagerCertificateConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
 *
 * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy
 */
export interface ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
  /**
   * Number of blue nodes to drain in a batch. Only one of the batch_percentage or batch_node_count can be specified.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchNodeCount
   */
  readonly batchNodeCount?: number;

  /**
   * :  Percentage of the bool pool nodes to drain in a batch. The range of this field should be (0.0, 1.0). Only one of the batch_percentage or batch_node_count can be specified.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchPercentage
   */
  readonly batchPercentage?: number;

  /**
   * Soak time after each batch gets drained. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".`.
   *
   * @schema ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchSoakDuration
   */
  readonly batchSoakDuration?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(obj: ClusterV1Beta2SpecInitProviderClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchNodeCount': obj.batchNodeCount,
    'batchPercentage': obj.batchPercentage,
    'batchSoakDuration': obj.batchSoakDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
  /**
   * @schema ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig#secretUri
   */
  readonly secretUri?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj: ClusterV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretUri': obj.secretUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
  /**
   * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#fqdns
   */
  readonly fqdns?: string[];

  /**
   * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#gcpSecretManagerCertificateConfig
   */
  readonly gcpSecretManagerCertificateConfig?: ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(obj: ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fqdns': obj.fqdns?.map(y => y),
    'gcpSecretManagerCertificateConfig': toJson_ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj.gcpSecretManagerCertificateConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig
 */
export interface ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
  /**
   * @schema ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig#secretUri
   */
  readonly secretUri?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj: ClusterV1Beta2SpecForProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretUri': obj.secretUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig
 */
export interface ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
  /**
   * @schema ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig#secretUri
   */
  readonly secretUri?: string;
}

/**
 * Converts an object of type 'ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj: ClusterV1Beta2SpecInitProviderNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretUri': obj.secretUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * NodePool is the Schema for the NodePools API. Manages a GKE NodePool resource.
 *
 * @schema NodePool
 */
export class NodePool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NodePool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'container.gcp.upbound.io/v1beta1',
    kind: 'NodePool',
  }

  /**
   * Renders a Kubernetes manifest for "NodePool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NodePoolProps): any {
    return {
      ...NodePool.GVK,
      ...toJson_NodePoolProps(props),
    };
  }

  /**
   * Defines a "NodePool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NodePoolProps) {
    super(scope, id, {
      ...NodePool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...NodePool.GVK,
      ...toJson_NodePoolProps(resolved),
    };
  }
}

/**
 * NodePool is the Schema for the NodePools API. Manages a GKE NodePool resource.
 *
 * @schema NodePool
 */
export interface NodePoolProps {
  /**
   * @schema NodePool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NodePoolSpec defines the desired state of NodePool
   *
   * @schema NodePool#spec
   */
  readonly spec: NodePoolSpec;
}

/**
 * Converts an object of type 'NodePoolProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolProps(obj: NodePoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NodePoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodePoolSpec defines the desired state of NodePool
 *
 * @schema NodePoolSpec
 */
export interface NodePoolSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NodePoolSpec#deletionPolicy
   */
  readonly deletionPolicy?: NodePoolSpecDeletionPolicy;

  /**
   * @schema NodePoolSpec#forProvider
   */
  readonly forProvider: NodePoolSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema NodePoolSpec#initProvider
   */
  readonly initProvider?: NodePoolSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema NodePoolSpec#managementPolicies
   */
  readonly managementPolicies?: NodePoolSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema NodePoolSpec#providerConfigRef
   */
  readonly providerConfigRef?: NodePoolSpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema NodePoolSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NodePoolSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'NodePoolSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpec(obj: NodePoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NodePoolSpecForProvider(obj.forProvider),
    'initProvider': toJson_NodePoolSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_NodePoolSpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_NodePoolSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NodePoolSpecDeletionPolicy
 */
export enum NodePoolSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NodePoolSpecForProvider
 */
export interface NodePoolSpecForProvider {
  /**
   * Configuration required by cluster autoscaler to adjust
   * the size of the node pool to the current cluster usage. Structure is documented below.
   *
   * @schema NodePoolSpecForProvider#autoscaling
   */
  readonly autoscaling?: NodePoolSpecForProviderAutoscaling[];

  /**
   * The cluster to create the node pool for. Cluster must be present in location provided for clusters. May be specified in the format projects/{{project}}/locations/{{location}}/clusters/{{cluster}} or as just the name of the cluster.
   *
   * @schema NodePoolSpecForProvider#cluster
   */
  readonly cluster?: string;

  /**
   * Reference to a Cluster in container to populate cluster.
   *
   * @schema NodePoolSpecForProvider#clusterRef
   */
  readonly clusterRef?: NodePoolSpecForProviderClusterRef;

  /**
   * Selector for a Cluster in container to populate cluster.
   *
   * @schema NodePoolSpecForProvider#clusterSelector
   */
  readonly clusterSelector?: NodePoolSpecForProviderClusterSelector;

  /**
   * The initial number of nodes for the pool. In
   * regional or multi-zonal clusters, this is the number of nodes per zone. Changing
   * this will force recreation of the resource.  If you don't
   * need this value, don't set it.  If you do need it, you can use a lifecycle block to
   * ignore subsequent changes to this field.
   *
   * @schema NodePoolSpecForProvider#initialNodeCount
   */
  readonly initialNodeCount?: number;

  /**
   * The location (region or zone) of the cluster.
   *
   * @schema NodePoolSpecForProvider#location
   */
  readonly location?: string;

  /**
   * Node management configuration, wherein auto-repair and
   * auto-upgrade is configured. Structure is documented below.
   *
   * @schema NodePoolSpecForProvider#management
   */
  readonly management?: NodePoolSpecForProviderManagement[];

  /**
   * The maximum number of pods per node in this node pool.
   * Note that this does not work on node pools which are "route-based" - that is, node
   * pools belonging to clusters that do not have IP Aliasing enabled.
   * See the official documentation
   * for more information.
   *
   * @schema NodePoolSpecForProvider#maxPodsPerNode
   */
  readonly maxPodsPerNode?: number;

  /**
   * The network configuration of the pool. Such as
   * configuration for Adding Pod IP address ranges) to the node pool. Or enabling private nodes. Structure is
   * documented below
   *
   * @schema NodePoolSpecForProvider#networkConfig
   */
  readonly networkConfig?: NodePoolSpecForProviderNetworkConfig[];

  /**
   * Parameters used in creating the node pool. See
   * google_container_cluster for schema.
   *
   * @schema NodePoolSpecForProvider#nodeConfig
   */
  readonly nodeConfig?: NodePoolSpecForProviderNodeConfig[];

  /**
   * The number of nodes per instance group. This field can be used to
   * update the number of nodes per instance group but should not be used alongside autoscaling.
   *
   * @schema NodePoolSpecForProvider#nodeCount
   */
  readonly nodeCount?: number;

  /**
   * The list of zones in which the node pool's nodes should be located. Nodes must
   * be in the region of their regional cluster or in the same region as their
   * cluster's zone for zonal clusters. If unspecified, the cluster-level
   * node_locations will be used.
   *
   * @schema NodePoolSpecForProvider#nodeLocations
   */
  readonly nodeLocations?: string[];

  /**
   * Specifies a custom placement policy for the
   * nodes.
   *
   * @schema NodePoolSpecForProvider#placementPolicy
   */
  readonly placementPolicy?: NodePoolSpecForProviderPlacementPolicy[];

  /**
   * The ID of the project in which to create the node pool. If blank,
   * the provider-configured project will be used.
   *
   * @schema NodePoolSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Specifies node pool-level settings of queued provisioning.
   * Structure is documented below.
   *
   * @schema NodePoolSpecForProvider#queuedProvisioning
   */
  readonly queuedProvisioning?: NodePoolSpecForProviderQueuedProvisioning[];

  /**
   * Specify node upgrade settings to change how GKE upgrades nodes.
   * The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
   *
   * @schema NodePoolSpecForProvider#upgradeSettings
   */
  readonly upgradeSettings?: NodePoolSpecForProviderUpgradeSettings[];

  /**
   * The Kubernetes version for the nodes in this pool. Note that if this field
   * and auto_upgrade are both specified, they will fight each other for what the node version should
   * be, so setting both is highly discouraged.
   *
   * @schema NodePoolSpecForProvider#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProvider(obj: NodePoolSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoscaling': obj.autoscaling?.map(y => toJson_NodePoolSpecForProviderAutoscaling(y)),
    'cluster': obj.cluster,
    'clusterRef': toJson_NodePoolSpecForProviderClusterRef(obj.clusterRef),
    'clusterSelector': toJson_NodePoolSpecForProviderClusterSelector(obj.clusterSelector),
    'initialNodeCount': obj.initialNodeCount,
    'location': obj.location,
    'management': obj.management?.map(y => toJson_NodePoolSpecForProviderManagement(y)),
    'maxPodsPerNode': obj.maxPodsPerNode,
    'networkConfig': obj.networkConfig?.map(y => toJson_NodePoolSpecForProviderNetworkConfig(y)),
    'nodeConfig': obj.nodeConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfig(y)),
    'nodeCount': obj.nodeCount,
    'nodeLocations': obj.nodeLocations?.map(y => y),
    'placementPolicy': obj.placementPolicy?.map(y => toJson_NodePoolSpecForProviderPlacementPolicy(y)),
    'project': obj.project,
    'queuedProvisioning': obj.queuedProvisioning?.map(y => toJson_NodePoolSpecForProviderQueuedProvisioning(y)),
    'upgradeSettings': obj.upgradeSettings?.map(y => toJson_NodePoolSpecForProviderUpgradeSettings(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema NodePoolSpecInitProvider
 */
export interface NodePoolSpecInitProvider {
  /**
   * Configuration required by cluster autoscaler to adjust
   * the size of the node pool to the current cluster usage. Structure is documented below.
   *
   * @schema NodePoolSpecInitProvider#autoscaling
   */
  readonly autoscaling?: NodePoolSpecInitProviderAutoscaling[];

  /**
   * The initial number of nodes for the pool. In
   * regional or multi-zonal clusters, this is the number of nodes per zone. Changing
   * this will force recreation of the resource.  If you don't
   * need this value, don't set it.  If you do need it, you can use a lifecycle block to
   * ignore subsequent changes to this field.
   *
   * @schema NodePoolSpecInitProvider#initialNodeCount
   */
  readonly initialNodeCount?: number;

  /**
   * Node management configuration, wherein auto-repair and
   * auto-upgrade is configured. Structure is documented below.
   *
   * @schema NodePoolSpecInitProvider#management
   */
  readonly management?: NodePoolSpecInitProviderManagement[];

  /**
   * The maximum number of pods per node in this node pool.
   * Note that this does not work on node pools which are "route-based" - that is, node
   * pools belonging to clusters that do not have IP Aliasing enabled.
   * See the official documentation
   * for more information.
   *
   * @schema NodePoolSpecInitProvider#maxPodsPerNode
   */
  readonly maxPodsPerNode?: number;

  /**
   * The network configuration of the pool. Such as
   * configuration for Adding Pod IP address ranges) to the node pool. Or enabling private nodes. Structure is
   * documented below
   *
   * @schema NodePoolSpecInitProvider#networkConfig
   */
  readonly networkConfig?: NodePoolSpecInitProviderNetworkConfig[];

  /**
   * Parameters used in creating the node pool. See
   * google_container_cluster for schema.
   *
   * @schema NodePoolSpecInitProvider#nodeConfig
   */
  readonly nodeConfig?: NodePoolSpecInitProviderNodeConfig[];

  /**
   * The number of nodes per instance group. This field can be used to
   * update the number of nodes per instance group but should not be used alongside autoscaling.
   *
   * @schema NodePoolSpecInitProvider#nodeCount
   */
  readonly nodeCount?: number;

  /**
   * The list of zones in which the node pool's nodes should be located. Nodes must
   * be in the region of their regional cluster or in the same region as their
   * cluster's zone for zonal clusters. If unspecified, the cluster-level
   * node_locations will be used.
   *
   * @schema NodePoolSpecInitProvider#nodeLocations
   */
  readonly nodeLocations?: string[];

  /**
   * Specifies a custom placement policy for the
   * nodes.
   *
   * @schema NodePoolSpecInitProvider#placementPolicy
   */
  readonly placementPolicy?: NodePoolSpecInitProviderPlacementPolicy[];

  /**
   * The ID of the project in which to create the node pool. If blank,
   * the provider-configured project will be used.
   *
   * @schema NodePoolSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Specifies node pool-level settings of queued provisioning.
   * Structure is documented below.
   *
   * @schema NodePoolSpecInitProvider#queuedProvisioning
   */
  readonly queuedProvisioning?: NodePoolSpecInitProviderQueuedProvisioning[];

  /**
   * Specify node upgrade settings to change how GKE upgrades nodes.
   * The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
   *
   * @schema NodePoolSpecInitProvider#upgradeSettings
   */
  readonly upgradeSettings?: NodePoolSpecInitProviderUpgradeSettings[];

  /**
   * The Kubernetes version for the nodes in this pool. Note that if this field
   * and auto_upgrade are both specified, they will fight each other for what the node version should
   * be, so setting both is highly discouraged.
   *
   * @schema NodePoolSpecInitProvider#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProvider(obj: NodePoolSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoscaling': obj.autoscaling?.map(y => toJson_NodePoolSpecInitProviderAutoscaling(y)),
    'initialNodeCount': obj.initialNodeCount,
    'management': obj.management?.map(y => toJson_NodePoolSpecInitProviderManagement(y)),
    'maxPodsPerNode': obj.maxPodsPerNode,
    'networkConfig': obj.networkConfig?.map(y => toJson_NodePoolSpecInitProviderNetworkConfig(y)),
    'nodeConfig': obj.nodeConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfig(y)),
    'nodeCount': obj.nodeCount,
    'nodeLocations': obj.nodeLocations?.map(y => y),
    'placementPolicy': obj.placementPolicy?.map(y => toJson_NodePoolSpecInitProviderPlacementPolicy(y)),
    'project': obj.project,
    'queuedProvisioning': obj.queuedProvisioning?.map(y => toJson_NodePoolSpecInitProviderQueuedProvisioning(y)),
    'upgradeSettings': obj.upgradeSettings?.map(y => toJson_NodePoolSpecInitProviderUpgradeSettings(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema NodePoolSpecManagementPolicies
 */
export enum NodePoolSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema NodePoolSpecProviderConfigRef
 */
export interface NodePoolSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodePoolSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodePoolSpecProviderConfigRef#policy
   */
  readonly policy?: NodePoolSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'NodePoolSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecProviderConfigRef(obj: NodePoolSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodePoolSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema NodePoolSpecWriteConnectionSecretToRef
 */
export interface NodePoolSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NodePoolSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NodePoolSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'NodePoolSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecWriteConnectionSecretToRef(obj: NodePoolSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderAutoscaling
 */
export interface NodePoolSpecForProviderAutoscaling {
  /**
   * Location policy specifies the algorithm used when
   * scaling-up the node pool. Location policy is supported only in 1.24.1+ clusters.
   *
   * @schema NodePoolSpecForProviderAutoscaling#locationPolicy
   */
  readonly locationPolicy?: string;

  /**
   * Maximum number of nodes per zone in the NodePool.
   * Must be >= min_node_count. Cannot be used with total limits.
   *
   * @schema NodePoolSpecForProviderAutoscaling#maxNodeCount
   */
  readonly maxNodeCount?: number;

  /**
   * Minimum number of nodes per zone in the NodePool.
   * Must be >=0 and <= max_node_count. Cannot be used with total limits.
   *
   * @schema NodePoolSpecForProviderAutoscaling#minNodeCount
   */
  readonly minNodeCount?: number;

  /**
   * Total maximum number of nodes in the NodePool.
   * Must be >= total_min_node_count. Cannot be used with per zone limits.
   * Total size limits are supported only in 1.24.1+ clusters.
   *
   * @schema NodePoolSpecForProviderAutoscaling#totalMaxNodeCount
   */
  readonly totalMaxNodeCount?: number;

  /**
   * Total minimum number of nodes in the NodePool.
   * Must be >=0 and <= total_max_node_count. Cannot be used with per zone limits.
   * Total size limits are supported only in 1.24.1+ clusters.
   *
   * @schema NodePoolSpecForProviderAutoscaling#totalMinNodeCount
   */
  readonly totalMinNodeCount?: number;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderAutoscaling(obj: NodePoolSpecForProviderAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'locationPolicy': obj.locationPolicy,
    'maxNodeCount': obj.maxNodeCount,
    'minNodeCount': obj.minNodeCount,
    'totalMaxNodeCount': obj.totalMaxNodeCount,
    'totalMinNodeCount': obj.totalMinNodeCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Cluster in container to populate cluster.
 *
 * @schema NodePoolSpecForProviderClusterRef
 */
export interface NodePoolSpecForProviderClusterRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodePoolSpecForProviderClusterRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodePoolSpecForProviderClusterRef#policy
   */
  readonly policy?: NodePoolSpecForProviderClusterRefPolicy;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderClusterRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderClusterRef(obj: NodePoolSpecForProviderClusterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodePoolSpecForProviderClusterRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Cluster in container to populate cluster.
 *
 * @schema NodePoolSpecForProviderClusterSelector
 */
export interface NodePoolSpecForProviderClusterSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema NodePoolSpecForProviderClusterSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodePoolSpecForProviderClusterSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodePoolSpecForProviderClusterSelector#policy
   */
  readonly policy?: NodePoolSpecForProviderClusterSelectorPolicy;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderClusterSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderClusterSelector(obj: NodePoolSpecForProviderClusterSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodePoolSpecForProviderClusterSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderManagement
 */
export interface NodePoolSpecForProviderManagement {
  /**
   * Whether the nodes will be automatically repaired. Enabled by default.
   *
   * @schema NodePoolSpecForProviderManagement#autoRepair
   */
  readonly autoRepair?: boolean;

  /**
   * Whether the nodes will be automatically upgraded. Enabled by default.
   *
   * @schema NodePoolSpecForProviderManagement#autoUpgrade
   */
  readonly autoUpgrade?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderManagement' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderManagement(obj: NodePoolSpecForProviderManagement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoRepair': obj.autoRepair,
    'autoUpgrade': obj.autoUpgrade,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNetworkConfig
 */
export interface NodePoolSpecForProviderNetworkConfig {
  /**
   * We specify the additional node networks for this node pool using this list. Each node network corresponds to an additional interface.
   * Structure is documented below
   *
   * @schema NodePoolSpecForProviderNetworkConfig#additionalNodeNetworkConfigs
   */
  readonly additionalNodeNetworkConfigs?: NodePoolSpecForProviderNetworkConfigAdditionalNodeNetworkConfigs[];

  /**
   * We specify the additional pod networks for this node pool using this list. Each pod network corresponds to an additional alias IP range for the node.
   * Structure is documented below
   *
   * @schema NodePoolSpecForProviderNetworkConfig#additionalPodNetworkConfigs
   */
  readonly additionalPodNetworkConfigs?: NodePoolSpecForProviderNetworkConfigAdditionalPodNetworkConfigs[];

  /**
   * Whether to create a new range for pod IPs in this node pool. Defaults are provided for pod_range and pod_ipv4_cidr_block if they are not specified.
   *
   * @schema NodePoolSpecForProviderNetworkConfig#createPodRange
   */
  readonly createPodRange?: boolean;

  /**
   * Whether nodes have internal IP addresses only.
   *
   * @schema NodePoolSpecForProviderNetworkConfig#enablePrivateNodes
   */
  readonly enablePrivateNodes?: boolean;

  /**
   * @schema NodePoolSpecForProviderNetworkConfig#networkPerformanceConfig
   */
  readonly networkPerformanceConfig?: NodePoolSpecForProviderNetworkConfigNetworkPerformanceConfig[];

  /**
   * @schema NodePoolSpecForProviderNetworkConfig#podCidrOverprovisionConfig
   */
  readonly podCidrOverprovisionConfig?: NodePoolSpecForProviderNetworkConfigPodCidrOverprovisionConfig[];

  /**
   * The IP address range for pod IPs in this node pool. Only applicable if createPodRange is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) to pick a specific range to use.
   *
   * @schema NodePoolSpecForProviderNetworkConfig#podIpv4CidrBlock
   */
  readonly podIpv4CidrBlock?: string;

  /**
   * The ID of the secondary range for pod IPs. If create_pod_range is true, this ID is used for the new range. If create_pod_range is false, uses an existing secondary range with this ID.
   *
   * @schema NodePoolSpecForProviderNetworkConfig#podRange
   */
  readonly podRange?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNetworkConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNetworkConfig(obj: NodePoolSpecForProviderNetworkConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalNodeNetworkConfigs': obj.additionalNodeNetworkConfigs?.map(y => toJson_NodePoolSpecForProviderNetworkConfigAdditionalNodeNetworkConfigs(y)),
    'additionalPodNetworkConfigs': obj.additionalPodNetworkConfigs?.map(y => toJson_NodePoolSpecForProviderNetworkConfigAdditionalPodNetworkConfigs(y)),
    'createPodRange': obj.createPodRange,
    'enablePrivateNodes': obj.enablePrivateNodes,
    'networkPerformanceConfig': obj.networkPerformanceConfig?.map(y => toJson_NodePoolSpecForProviderNetworkConfigNetworkPerformanceConfig(y)),
    'podCidrOverprovisionConfig': obj.podCidrOverprovisionConfig?.map(y => toJson_NodePoolSpecForProviderNetworkConfigPodCidrOverprovisionConfig(y)),
    'podIpv4CidrBlock': obj.podIpv4CidrBlock,
    'podRange': obj.podRange,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfig
 */
export interface NodePoolSpecForProviderNodeConfig {
  /**
   * @schema NodePoolSpecForProviderNodeConfig#advancedMachineFeatures
   */
  readonly advancedMachineFeatures?: NodePoolSpecForProviderNodeConfigAdvancedMachineFeatures[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#bootDiskKmsKey
   */
  readonly bootDiskKmsKey?: string;

  /**
   * Configuration for Confidential Nodes feature. Structure is documented below.
   *
   * @schema NodePoolSpecForProviderNodeConfig#confidentialNodes
   */
  readonly confidentialNodes?: NodePoolSpecForProviderNodeConfigConfidentialNodes[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#containerdConfig
   */
  readonly containerdConfig?: NodePoolSpecForProviderNodeConfigContainerdConfig[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#diskSizeGb
   */
  readonly diskSizeGb?: number;

  /**
   * @schema NodePoolSpecForProviderNodeConfig#diskType
   */
  readonly diskType?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfig#enableConfidentialStorage
   */
  readonly enableConfidentialStorage?: boolean;

  /**
   * @schema NodePoolSpecForProviderNodeConfig#ephemeralStorageLocalSsdConfig
   */
  readonly ephemeralStorageLocalSsdConfig?: NodePoolSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#fastSocket
   */
  readonly fastSocket?: NodePoolSpecForProviderNodeConfigFastSocket[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#flexStart
   */
  readonly flexStart?: boolean;

  /**
   * @schema NodePoolSpecForProviderNodeConfig#gcfsConfig
   */
  readonly gcfsConfig?: NodePoolSpecForProviderNodeConfigGcfsConfig[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#guestAccelerator
   */
  readonly guestAccelerator?: NodePoolSpecForProviderNodeConfigGuestAccelerator[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#gvnic
   */
  readonly gvnic?: NodePoolSpecForProviderNodeConfigGvnic[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#hostMaintenancePolicy
   */
  readonly hostMaintenancePolicy?: NodePoolSpecForProviderNodeConfigHostMaintenancePolicy[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#imageType
   */
  readonly imageType?: string;

  /**
   * This is an injected field with a default value for being able to merge items of the parent object list.
   *
   * @schema NodePoolSpecForProviderNodeConfig#index
   */
  readonly index?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfig#kubeletConfig
   */
  readonly kubeletConfig?: NodePoolSpecForProviderNodeConfigKubeletConfig[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Parameters used in creating the node pool. See
   * google_container_cluster for schema.
   *
   * @schema NodePoolSpecForProviderNodeConfig#linuxNodeConfig
   */
  readonly linuxNodeConfig?: NodePoolSpecForProviderNodeConfigLinuxNodeConfig[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#localNvmeSsdBlockConfig
   */
  readonly localNvmeSsdBlockConfig?: NodePoolSpecForProviderNodeConfigLocalNvmeSsdBlockConfig[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#localSsdCount
   */
  readonly localSsdCount?: number;

  /**
   * Possible Local SSD encryption modes:
   * Accepted values are:
   *
   * @schema NodePoolSpecForProviderNodeConfig#localSsdEncryptionMode
   */
  readonly localSsdEncryptionMode?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfig#loggingVariant
   */
  readonly loggingVariant?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfig#machineType
   */
  readonly machineType?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfig#maxRunDuration
   */
  readonly maxRunDuration?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfig#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * @schema NodePoolSpecForProviderNodeConfig#minCpuPlatform
   */
  readonly minCpuPlatform?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfig#nodeGroup
   */
  readonly nodeGroup?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfig#oauthScopes
   */
  readonly oauthScopes?: string[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#preemptible
   */
  readonly preemptible?: boolean;

  /**
   * @schema NodePoolSpecForProviderNodeConfig#reservationAffinity
   */
  readonly reservationAffinity?: NodePoolSpecForProviderNodeConfigReservationAffinity[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#resourceLabels
   */
  readonly resourceLabels?: { [key: string]: string };

  /**
   * @schema NodePoolSpecForProviderNodeConfig#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };

  /**
   * @schema NodePoolSpecForProviderNodeConfig#secondaryBootDisks
   */
  readonly secondaryBootDisks?: NodePoolSpecForProviderNodeConfigSecondaryBootDisks[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema NodePoolSpecForProviderNodeConfig#serviceAccountRef
   */
  readonly serviceAccountRef?: NodePoolSpecForProviderNodeConfigServiceAccountRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema NodePoolSpecForProviderNodeConfig#serviceAccountSelector
   */
  readonly serviceAccountSelector?: NodePoolSpecForProviderNodeConfigServiceAccountSelector;

  /**
   * @schema NodePoolSpecForProviderNodeConfig#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: NodePoolSpecForProviderNodeConfigShieldedInstanceConfig[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#soleTenantConfig
   */
  readonly soleTenantConfig?: NodePoolSpecForProviderNodeConfigSoleTenantConfig[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#spot
   */
  readonly spot?: boolean;

  /**
   * @schema NodePoolSpecForProviderNodeConfig#storagePools
   */
  readonly storagePools?: string[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#tags
   */
  readonly tags?: string[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#taint
   */
  readonly taint?: NodePoolSpecForProviderNodeConfigTaint[];

  /**
   * Parameters used in creating the node pool. See
   * google_container_cluster for schema.
   *
   * @schema NodePoolSpecForProviderNodeConfig#windowsNodeConfig
   */
  readonly windowsNodeConfig?: NodePoolSpecForProviderNodeConfigWindowsNodeConfig[];

  /**
   * @schema NodePoolSpecForProviderNodeConfig#workloadMetadataConfig
   */
  readonly workloadMetadataConfig?: NodePoolSpecForProviderNodeConfigWorkloadMetadataConfig[];
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfig(obj: NodePoolSpecForProviderNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedMachineFeatures': obj.advancedMachineFeatures?.map(y => toJson_NodePoolSpecForProviderNodeConfigAdvancedMachineFeatures(y)),
    'bootDiskKmsKey': obj.bootDiskKmsKey,
    'confidentialNodes': obj.confidentialNodes?.map(y => toJson_NodePoolSpecForProviderNodeConfigConfidentialNodes(y)),
    'containerdConfig': obj.containerdConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigContainerdConfig(y)),
    'diskSizeGb': obj.diskSizeGb,
    'diskType': obj.diskType,
    'enableConfidentialStorage': obj.enableConfidentialStorage,
    'ephemeralStorageLocalSsdConfig': obj.ephemeralStorageLocalSsdConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig(y)),
    'fastSocket': obj.fastSocket?.map(y => toJson_NodePoolSpecForProviderNodeConfigFastSocket(y)),
    'flexStart': obj.flexStart,
    'gcfsConfig': obj.gcfsConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigGcfsConfig(y)),
    'guestAccelerator': obj.guestAccelerator?.map(y => toJson_NodePoolSpecForProviderNodeConfigGuestAccelerator(y)),
    'gvnic': obj.gvnic?.map(y => toJson_NodePoolSpecForProviderNodeConfigGvnic(y)),
    'hostMaintenancePolicy': obj.hostMaintenancePolicy?.map(y => toJson_NodePoolSpecForProviderNodeConfigHostMaintenancePolicy(y)),
    'imageType': obj.imageType,
    'index': obj.index,
    'kubeletConfig': obj.kubeletConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigKubeletConfig(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'linuxNodeConfig': obj.linuxNodeConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigLinuxNodeConfig(y)),
    'localNvmeSsdBlockConfig': obj.localNvmeSsdBlockConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigLocalNvmeSsdBlockConfig(y)),
    'localSsdCount': obj.localSsdCount,
    'localSsdEncryptionMode': obj.localSsdEncryptionMode,
    'loggingVariant': obj.loggingVariant,
    'machineType': obj.machineType,
    'maxRunDuration': obj.maxRunDuration,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'minCpuPlatform': obj.minCpuPlatform,
    'nodeGroup': obj.nodeGroup,
    'oauthScopes': obj.oauthScopes?.map(y => y),
    'preemptible': obj.preemptible,
    'reservationAffinity': obj.reservationAffinity?.map(y => toJson_NodePoolSpecForProviderNodeConfigReservationAffinity(y)),
    'resourceLabels': ((obj.resourceLabels) === undefined) ? undefined : (Object.entries(obj.resourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'secondaryBootDisks': obj.secondaryBootDisks?.map(y => toJson_NodePoolSpecForProviderNodeConfigSecondaryBootDisks(y)),
    'serviceAccount': obj.serviceAccount,
    'serviceAccountRef': toJson_NodePoolSpecForProviderNodeConfigServiceAccountRef(obj.serviceAccountRef),
    'serviceAccountSelector': toJson_NodePoolSpecForProviderNodeConfigServiceAccountSelector(obj.serviceAccountSelector),
    'shieldedInstanceConfig': obj.shieldedInstanceConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigShieldedInstanceConfig(y)),
    'soleTenantConfig': obj.soleTenantConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigSoleTenantConfig(y)),
    'spot': obj.spot,
    'storagePools': obj.storagePools?.map(y => y),
    'tags': obj.tags?.map(y => y),
    'taint': obj.taint?.map(y => toJson_NodePoolSpecForProviderNodeConfigTaint(y)),
    'windowsNodeConfig': obj.windowsNodeConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigWindowsNodeConfig(y)),
    'workloadMetadataConfig': obj.workloadMetadataConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigWorkloadMetadataConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderPlacementPolicy
 */
export interface NodePoolSpecForProviderPlacementPolicy {
  /**
   * If set, refers to the name of a custom resource policy supplied by the user.
   * The resource policy must be in the same project and region as the node pool.
   * If not found, InvalidArgument error is returned.
   *
   * @schema NodePoolSpecForProviderPlacementPolicy#policyName
   */
  readonly policyName?: string;

  /**
   * The TPU placement topology for pod slice node pool.
   *
   * @schema NodePoolSpecForProviderPlacementPolicy#tpuTopology
   */
  readonly tpuTopology?: string;

  /**
   * The type of the policy. Supports a single value: COMPACT.
   * Specifying COMPACT placement policy type places node pool's nodes in a closer
   * physical proximity in order to reduce network latency between nodes.
   *
   * @schema NodePoolSpecForProviderPlacementPolicy#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderPlacementPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderPlacementPolicy(obj: NodePoolSpecForProviderPlacementPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policyName': obj.policyName,
    'tpuTopology': obj.tpuTopology,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderQueuedProvisioning
 */
export interface NodePoolSpecForProviderQueuedProvisioning {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolSpecForProviderQueuedProvisioning#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderQueuedProvisioning' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderQueuedProvisioning(obj: NodePoolSpecForProviderQueuedProvisioning | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderUpgradeSettings
 */
export interface NodePoolSpecForProviderUpgradeSettings {
  /**
   * The settings to adjust blue green upgrades.
   * Structure is documented below
   *
   * @schema NodePoolSpecForProviderUpgradeSettings#blueGreenSettings
   */
  readonly blueGreenSettings?: NodePoolSpecForProviderUpgradeSettingsBlueGreenSettings[];

  /**
   * The number of additional nodes that can be added to the node pool during
   * an upgrade. Increasing max_surge raises the number of nodes that can be upgraded simultaneously.
   * Can be set to 0 or greater.
   *
   * @schema NodePoolSpecForProviderUpgradeSettings#maxSurge
   */
  readonly maxSurge?: number;

  /**
   * The number of nodes that can be simultaneously unavailable during
   * an upgrade. Increasing max_unavailable raises the number of nodes that can be upgraded in
   * parallel. Can be set to 0 or greater.
   *
   * @schema NodePoolSpecForProviderUpgradeSettings#maxUnavailable
   */
  readonly maxUnavailable?: number;

  /**
   * (Default SURGE) The upgrade stragey to be used for upgrading the nodes.
   *
   * @schema NodePoolSpecForProviderUpgradeSettings#strategy
   */
  readonly strategy?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderUpgradeSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderUpgradeSettings(obj: NodePoolSpecForProviderUpgradeSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blueGreenSettings': obj.blueGreenSettings?.map(y => toJson_NodePoolSpecForProviderUpgradeSettingsBlueGreenSettings(y)),
    'maxSurge': obj.maxSurge,
    'maxUnavailable': obj.maxUnavailable,
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderAutoscaling
 */
export interface NodePoolSpecInitProviderAutoscaling {
  /**
   * Location policy specifies the algorithm used when
   * scaling-up the node pool. Location policy is supported only in 1.24.1+ clusters.
   *
   * @schema NodePoolSpecInitProviderAutoscaling#locationPolicy
   */
  readonly locationPolicy?: string;

  /**
   * Maximum number of nodes per zone in the NodePool.
   * Must be >= min_node_count. Cannot be used with total limits.
   *
   * @schema NodePoolSpecInitProviderAutoscaling#maxNodeCount
   */
  readonly maxNodeCount?: number;

  /**
   * Minimum number of nodes per zone in the NodePool.
   * Must be >=0 and <= max_node_count. Cannot be used with total limits.
   *
   * @schema NodePoolSpecInitProviderAutoscaling#minNodeCount
   */
  readonly minNodeCount?: number;

  /**
   * Total maximum number of nodes in the NodePool.
   * Must be >= total_min_node_count. Cannot be used with per zone limits.
   * Total size limits are supported only in 1.24.1+ clusters.
   *
   * @schema NodePoolSpecInitProviderAutoscaling#totalMaxNodeCount
   */
  readonly totalMaxNodeCount?: number;

  /**
   * Total minimum number of nodes in the NodePool.
   * Must be >=0 and <= total_max_node_count. Cannot be used with per zone limits.
   * Total size limits are supported only in 1.24.1+ clusters.
   *
   * @schema NodePoolSpecInitProviderAutoscaling#totalMinNodeCount
   */
  readonly totalMinNodeCount?: number;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderAutoscaling(obj: NodePoolSpecInitProviderAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'locationPolicy': obj.locationPolicy,
    'maxNodeCount': obj.maxNodeCount,
    'minNodeCount': obj.minNodeCount,
    'totalMaxNodeCount': obj.totalMaxNodeCount,
    'totalMinNodeCount': obj.totalMinNodeCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderManagement
 */
export interface NodePoolSpecInitProviderManagement {
  /**
   * Whether the nodes will be automatically repaired. Enabled by default.
   *
   * @schema NodePoolSpecInitProviderManagement#autoRepair
   */
  readonly autoRepair?: boolean;

  /**
   * Whether the nodes will be automatically upgraded. Enabled by default.
   *
   * @schema NodePoolSpecInitProviderManagement#autoUpgrade
   */
  readonly autoUpgrade?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderManagement' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderManagement(obj: NodePoolSpecInitProviderManagement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoRepair': obj.autoRepair,
    'autoUpgrade': obj.autoUpgrade,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNetworkConfig
 */
export interface NodePoolSpecInitProviderNetworkConfig {
  /**
   * We specify the additional node networks for this node pool using this list. Each node network corresponds to an additional interface.
   * Structure is documented below
   *
   * @schema NodePoolSpecInitProviderNetworkConfig#additionalNodeNetworkConfigs
   */
  readonly additionalNodeNetworkConfigs?: NodePoolSpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs[];

  /**
   * We specify the additional pod networks for this node pool using this list. Each pod network corresponds to an additional alias IP range for the node.
   * Structure is documented below
   *
   * @schema NodePoolSpecInitProviderNetworkConfig#additionalPodNetworkConfigs
   */
  readonly additionalPodNetworkConfigs?: NodePoolSpecInitProviderNetworkConfigAdditionalPodNetworkConfigs[];

  /**
   * Whether to create a new range for pod IPs in this node pool. Defaults are provided for pod_range and pod_ipv4_cidr_block if they are not specified.
   *
   * @schema NodePoolSpecInitProviderNetworkConfig#createPodRange
   */
  readonly createPodRange?: boolean;

  /**
   * Whether nodes have internal IP addresses only.
   *
   * @schema NodePoolSpecInitProviderNetworkConfig#enablePrivateNodes
   */
  readonly enablePrivateNodes?: boolean;

  /**
   * @schema NodePoolSpecInitProviderNetworkConfig#networkPerformanceConfig
   */
  readonly networkPerformanceConfig?: NodePoolSpecInitProviderNetworkConfigNetworkPerformanceConfig[];

  /**
   * @schema NodePoolSpecInitProviderNetworkConfig#podCidrOverprovisionConfig
   */
  readonly podCidrOverprovisionConfig?: NodePoolSpecInitProviderNetworkConfigPodCidrOverprovisionConfig[];

  /**
   * The IP address range for pod IPs in this node pool. Only applicable if createPodRange is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) to pick a specific range to use.
   *
   * @schema NodePoolSpecInitProviderNetworkConfig#podIpv4CidrBlock
   */
  readonly podIpv4CidrBlock?: string;

  /**
   * The ID of the secondary range for pod IPs. If create_pod_range is true, this ID is used for the new range. If create_pod_range is false, uses an existing secondary range with this ID.
   *
   * @schema NodePoolSpecInitProviderNetworkConfig#podRange
   */
  readonly podRange?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNetworkConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNetworkConfig(obj: NodePoolSpecInitProviderNetworkConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalNodeNetworkConfigs': obj.additionalNodeNetworkConfigs?.map(y => toJson_NodePoolSpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs(y)),
    'additionalPodNetworkConfigs': obj.additionalPodNetworkConfigs?.map(y => toJson_NodePoolSpecInitProviderNetworkConfigAdditionalPodNetworkConfigs(y)),
    'createPodRange': obj.createPodRange,
    'enablePrivateNodes': obj.enablePrivateNodes,
    'networkPerformanceConfig': obj.networkPerformanceConfig?.map(y => toJson_NodePoolSpecInitProviderNetworkConfigNetworkPerformanceConfig(y)),
    'podCidrOverprovisionConfig': obj.podCidrOverprovisionConfig?.map(y => toJson_NodePoolSpecInitProviderNetworkConfigPodCidrOverprovisionConfig(y)),
    'podIpv4CidrBlock': obj.podIpv4CidrBlock,
    'podRange': obj.podRange,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfig
 */
export interface NodePoolSpecInitProviderNodeConfig {
  /**
   * @schema NodePoolSpecInitProviderNodeConfig#advancedMachineFeatures
   */
  readonly advancedMachineFeatures?: NodePoolSpecInitProviderNodeConfigAdvancedMachineFeatures[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#bootDiskKmsKey
   */
  readonly bootDiskKmsKey?: string;

  /**
   * Configuration for Confidential Nodes feature. Structure is documented below.
   *
   * @schema NodePoolSpecInitProviderNodeConfig#confidentialNodes
   */
  readonly confidentialNodes?: NodePoolSpecInitProviderNodeConfigConfidentialNodes[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#containerdConfig
   */
  readonly containerdConfig?: NodePoolSpecInitProviderNodeConfigContainerdConfig[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#diskSizeGb
   */
  readonly diskSizeGb?: number;

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#diskType
   */
  readonly diskType?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#enableConfidentialStorage
   */
  readonly enableConfidentialStorage?: boolean;

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#ephemeralStorageLocalSsdConfig
   */
  readonly ephemeralStorageLocalSsdConfig?: NodePoolSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#fastSocket
   */
  readonly fastSocket?: NodePoolSpecInitProviderNodeConfigFastSocket[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#flexStart
   */
  readonly flexStart?: boolean;

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#gcfsConfig
   */
  readonly gcfsConfig?: NodePoolSpecInitProviderNodeConfigGcfsConfig[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#guestAccelerator
   */
  readonly guestAccelerator?: NodePoolSpecInitProviderNodeConfigGuestAccelerator[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#gvnic
   */
  readonly gvnic?: NodePoolSpecInitProviderNodeConfigGvnic[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#hostMaintenancePolicy
   */
  readonly hostMaintenancePolicy?: NodePoolSpecInitProviderNodeConfigHostMaintenancePolicy[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#imageType
   */
  readonly imageType?: string;

  /**
   * This is an injected field with a default value for being able to merge items of the parent object list.
   *
   * @schema NodePoolSpecInitProviderNodeConfig#index
   */
  readonly index?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#kubeletConfig
   */
  readonly kubeletConfig?: NodePoolSpecInitProviderNodeConfigKubeletConfig[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Parameters used in creating the node pool. See
   * google_container_cluster for schema.
   *
   * @schema NodePoolSpecInitProviderNodeConfig#linuxNodeConfig
   */
  readonly linuxNodeConfig?: NodePoolSpecInitProviderNodeConfigLinuxNodeConfig[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#localNvmeSsdBlockConfig
   */
  readonly localNvmeSsdBlockConfig?: NodePoolSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#localSsdCount
   */
  readonly localSsdCount?: number;

  /**
   * Possible Local SSD encryption modes:
   * Accepted values are:
   *
   * @schema NodePoolSpecInitProviderNodeConfig#localSsdEncryptionMode
   */
  readonly localSsdEncryptionMode?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#loggingVariant
   */
  readonly loggingVariant?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#machineType
   */
  readonly machineType?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#maxRunDuration
   */
  readonly maxRunDuration?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#minCpuPlatform
   */
  readonly minCpuPlatform?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#nodeGroup
   */
  readonly nodeGroup?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#oauthScopes
   */
  readonly oauthScopes?: string[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#preemptible
   */
  readonly preemptible?: boolean;

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#reservationAffinity
   */
  readonly reservationAffinity?: NodePoolSpecInitProviderNodeConfigReservationAffinity[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#resourceLabels
   */
  readonly resourceLabels?: { [key: string]: string };

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#secondaryBootDisks
   */
  readonly secondaryBootDisks?: NodePoolSpecInitProviderNodeConfigSecondaryBootDisks[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema NodePoolSpecInitProviderNodeConfig#serviceAccountRef
   */
  readonly serviceAccountRef?: NodePoolSpecInitProviderNodeConfigServiceAccountRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema NodePoolSpecInitProviderNodeConfig#serviceAccountSelector
   */
  readonly serviceAccountSelector?: NodePoolSpecInitProviderNodeConfigServiceAccountSelector;

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: NodePoolSpecInitProviderNodeConfigShieldedInstanceConfig[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#soleTenantConfig
   */
  readonly soleTenantConfig?: NodePoolSpecInitProviderNodeConfigSoleTenantConfig[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#spot
   */
  readonly spot?: boolean;

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#storagePools
   */
  readonly storagePools?: string[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#tags
   */
  readonly tags?: string[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#taint
   */
  readonly taint?: NodePoolSpecInitProviderNodeConfigTaint[];

  /**
   * Parameters used in creating the node pool. See
   * google_container_cluster for schema.
   *
   * @schema NodePoolSpecInitProviderNodeConfig#windowsNodeConfig
   */
  readonly windowsNodeConfig?: NodePoolSpecInitProviderNodeConfigWindowsNodeConfig[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfig#workloadMetadataConfig
   */
  readonly workloadMetadataConfig?: NodePoolSpecInitProviderNodeConfigWorkloadMetadataConfig[];
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfig(obj: NodePoolSpecInitProviderNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedMachineFeatures': obj.advancedMachineFeatures?.map(y => toJson_NodePoolSpecInitProviderNodeConfigAdvancedMachineFeatures(y)),
    'bootDiskKmsKey': obj.bootDiskKmsKey,
    'confidentialNodes': obj.confidentialNodes?.map(y => toJson_NodePoolSpecInitProviderNodeConfigConfidentialNodes(y)),
    'containerdConfig': obj.containerdConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigContainerdConfig(y)),
    'diskSizeGb': obj.diskSizeGb,
    'diskType': obj.diskType,
    'enableConfidentialStorage': obj.enableConfidentialStorage,
    'ephemeralStorageLocalSsdConfig': obj.ephemeralStorageLocalSsdConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig(y)),
    'fastSocket': obj.fastSocket?.map(y => toJson_NodePoolSpecInitProviderNodeConfigFastSocket(y)),
    'flexStart': obj.flexStart,
    'gcfsConfig': obj.gcfsConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigGcfsConfig(y)),
    'guestAccelerator': obj.guestAccelerator?.map(y => toJson_NodePoolSpecInitProviderNodeConfigGuestAccelerator(y)),
    'gvnic': obj.gvnic?.map(y => toJson_NodePoolSpecInitProviderNodeConfigGvnic(y)),
    'hostMaintenancePolicy': obj.hostMaintenancePolicy?.map(y => toJson_NodePoolSpecInitProviderNodeConfigHostMaintenancePolicy(y)),
    'imageType': obj.imageType,
    'index': obj.index,
    'kubeletConfig': obj.kubeletConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigKubeletConfig(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'linuxNodeConfig': obj.linuxNodeConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigLinuxNodeConfig(y)),
    'localNvmeSsdBlockConfig': obj.localNvmeSsdBlockConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig(y)),
    'localSsdCount': obj.localSsdCount,
    'localSsdEncryptionMode': obj.localSsdEncryptionMode,
    'loggingVariant': obj.loggingVariant,
    'machineType': obj.machineType,
    'maxRunDuration': obj.maxRunDuration,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'minCpuPlatform': obj.minCpuPlatform,
    'nodeGroup': obj.nodeGroup,
    'oauthScopes': obj.oauthScopes?.map(y => y),
    'preemptible': obj.preemptible,
    'reservationAffinity': obj.reservationAffinity?.map(y => toJson_NodePoolSpecInitProviderNodeConfigReservationAffinity(y)),
    'resourceLabels': ((obj.resourceLabels) === undefined) ? undefined : (Object.entries(obj.resourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'secondaryBootDisks': obj.secondaryBootDisks?.map(y => toJson_NodePoolSpecInitProviderNodeConfigSecondaryBootDisks(y)),
    'serviceAccount': obj.serviceAccount,
    'serviceAccountRef': toJson_NodePoolSpecInitProviderNodeConfigServiceAccountRef(obj.serviceAccountRef),
    'serviceAccountSelector': toJson_NodePoolSpecInitProviderNodeConfigServiceAccountSelector(obj.serviceAccountSelector),
    'shieldedInstanceConfig': obj.shieldedInstanceConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigShieldedInstanceConfig(y)),
    'soleTenantConfig': obj.soleTenantConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigSoleTenantConfig(y)),
    'spot': obj.spot,
    'storagePools': obj.storagePools?.map(y => y),
    'tags': obj.tags?.map(y => y),
    'taint': obj.taint?.map(y => toJson_NodePoolSpecInitProviderNodeConfigTaint(y)),
    'windowsNodeConfig': obj.windowsNodeConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigWindowsNodeConfig(y)),
    'workloadMetadataConfig': obj.workloadMetadataConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigWorkloadMetadataConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderPlacementPolicy
 */
export interface NodePoolSpecInitProviderPlacementPolicy {
  /**
   * If set, refers to the name of a custom resource policy supplied by the user.
   * The resource policy must be in the same project and region as the node pool.
   * If not found, InvalidArgument error is returned.
   *
   * @schema NodePoolSpecInitProviderPlacementPolicy#policyName
   */
  readonly policyName?: string;

  /**
   * The TPU placement topology for pod slice node pool.
   *
   * @schema NodePoolSpecInitProviderPlacementPolicy#tpuTopology
   */
  readonly tpuTopology?: string;

  /**
   * The type of the policy. Supports a single value: COMPACT.
   * Specifying COMPACT placement policy type places node pool's nodes in a closer
   * physical proximity in order to reduce network latency between nodes.
   *
   * @schema NodePoolSpecInitProviderPlacementPolicy#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderPlacementPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderPlacementPolicy(obj: NodePoolSpecInitProviderPlacementPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policyName': obj.policyName,
    'tpuTopology': obj.tpuTopology,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderQueuedProvisioning
 */
export interface NodePoolSpecInitProviderQueuedProvisioning {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolSpecInitProviderQueuedProvisioning#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderQueuedProvisioning' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderQueuedProvisioning(obj: NodePoolSpecInitProviderQueuedProvisioning | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderUpgradeSettings
 */
export interface NodePoolSpecInitProviderUpgradeSettings {
  /**
   * The settings to adjust blue green upgrades.
   * Structure is documented below
   *
   * @schema NodePoolSpecInitProviderUpgradeSettings#blueGreenSettings
   */
  readonly blueGreenSettings?: NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettings[];

  /**
   * The number of additional nodes that can be added to the node pool during
   * an upgrade. Increasing max_surge raises the number of nodes that can be upgraded simultaneously.
   * Can be set to 0 or greater.
   *
   * @schema NodePoolSpecInitProviderUpgradeSettings#maxSurge
   */
  readonly maxSurge?: number;

  /**
   * The number of nodes that can be simultaneously unavailable during
   * an upgrade. Increasing max_unavailable raises the number of nodes that can be upgraded in
   * parallel. Can be set to 0 or greater.
   *
   * @schema NodePoolSpecInitProviderUpgradeSettings#maxUnavailable
   */
  readonly maxUnavailable?: number;

  /**
   * (Default SURGE) The upgrade stragey to be used for upgrading the nodes.
   *
   * @schema NodePoolSpecInitProviderUpgradeSettings#strategy
   */
  readonly strategy?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderUpgradeSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderUpgradeSettings(obj: NodePoolSpecInitProviderUpgradeSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blueGreenSettings': obj.blueGreenSettings?.map(y => toJson_NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettings(y)),
    'maxSurge': obj.maxSurge,
    'maxUnavailable': obj.maxUnavailable,
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodePoolSpecProviderConfigRefPolicy
 */
export interface NodePoolSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema NodePoolSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NodePoolSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema NodePoolSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NodePoolSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'NodePoolSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecProviderConfigRefPolicy(obj: NodePoolSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodePoolSpecForProviderClusterRefPolicy
 */
export interface NodePoolSpecForProviderClusterRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema NodePoolSpecForProviderClusterRefPolicy#resolution
   */
  readonly resolution?: NodePoolSpecForProviderClusterRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema NodePoolSpecForProviderClusterRefPolicy#resolve
   */
  readonly resolve?: NodePoolSpecForProviderClusterRefPolicyResolve;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderClusterRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderClusterRefPolicy(obj: NodePoolSpecForProviderClusterRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema NodePoolSpecForProviderClusterSelectorPolicy
 */
export interface NodePoolSpecForProviderClusterSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema NodePoolSpecForProviderClusterSelectorPolicy#resolution
   */
  readonly resolution?: NodePoolSpecForProviderClusterSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema NodePoolSpecForProviderClusterSelectorPolicy#resolve
   */
  readonly resolve?: NodePoolSpecForProviderClusterSelectorPolicyResolve;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderClusterSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderClusterSelectorPolicy(obj: NodePoolSpecForProviderClusterSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNetworkConfigAdditionalNodeNetworkConfigs
 */
export interface NodePoolSpecForProviderNetworkConfigAdditionalNodeNetworkConfigs {
  /**
   * Name of the VPC where the additional interface belongs.
   *
   * @schema NodePoolSpecForProviderNetworkConfigAdditionalNodeNetworkConfigs#network
   */
  readonly network?: string;

  /**
   * The subnetwork path for the node pool. Format: projects/{project}/regions/{region}/subnetworks/{subnetwork}. If the cluster is associated with multiple subnetworks, the subnetwork for the node pool is picked based on the IP utilization during node pool creation and is immutable
   *
   * @schema NodePoolSpecForProviderNetworkConfigAdditionalNodeNetworkConfigs#subnetwork
   */
  readonly subnetwork?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNetworkConfigAdditionalNodeNetworkConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNetworkConfigAdditionalNodeNetworkConfigs(obj: NodePoolSpecForProviderNetworkConfigAdditionalNodeNetworkConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'network': obj.network,
    'subnetwork': obj.subnetwork,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNetworkConfigAdditionalPodNetworkConfigs
 */
export interface NodePoolSpecForProviderNetworkConfigAdditionalPodNetworkConfigs {
  /**
   * The maximum number of pods per node in this node pool.
   * Note that this does not work on node pools which are "route-based" - that is, node
   * pools belonging to clusters that do not have IP Aliasing enabled.
   * See the official documentation
   * for more information.
   *
   * @schema NodePoolSpecForProviderNetworkConfigAdditionalPodNetworkConfigs#maxPodsPerNode
   */
  readonly maxPodsPerNode?: number;

  /**
   * The name of the secondary range on the subnet which provides IP address for this pod range.
   *
   * @schema NodePoolSpecForProviderNetworkConfigAdditionalPodNetworkConfigs#secondaryPodRange
   */
  readonly secondaryPodRange?: string;

  /**
   * The subnetwork path for the node pool. Format: projects/{project}/regions/{region}/subnetworks/{subnetwork}. If the cluster is associated with multiple subnetworks, the subnetwork for the node pool is picked based on the IP utilization during node pool creation and is immutable
   *
   * @schema NodePoolSpecForProviderNetworkConfigAdditionalPodNetworkConfigs#subnetwork
   */
  readonly subnetwork?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNetworkConfigAdditionalPodNetworkConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNetworkConfigAdditionalPodNetworkConfigs(obj: NodePoolSpecForProviderNetworkConfigAdditionalPodNetworkConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxPodsPerNode': obj.maxPodsPerNode,
    'secondaryPodRange': obj.secondaryPodRange,
    'subnetwork': obj.subnetwork,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNetworkConfigNetworkPerformanceConfig
 */
export interface NodePoolSpecForProviderNetworkConfigNetworkPerformanceConfig {
  /**
   * Specifies the total network bandwidth tier for the NodePool. Valid values include: "TIER_1" and "TIER_UNSPECIFIED".
   *
   * @schema NodePoolSpecForProviderNetworkConfigNetworkPerformanceConfig#totalEgressBandwidthTier
   */
  readonly totalEgressBandwidthTier?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNetworkConfigNetworkPerformanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNetworkConfigNetworkPerformanceConfig(obj: NodePoolSpecForProviderNetworkConfigNetworkPerformanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'totalEgressBandwidthTier': obj.totalEgressBandwidthTier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNetworkConfigPodCidrOverprovisionConfig
 */
export interface NodePoolSpecForProviderNetworkConfigPodCidrOverprovisionConfig {
  /**
   * @schema NodePoolSpecForProviderNetworkConfigPodCidrOverprovisionConfig#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNetworkConfigPodCidrOverprovisionConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNetworkConfigPodCidrOverprovisionConfig(obj: NodePoolSpecForProviderNetworkConfigPodCidrOverprovisionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigAdvancedMachineFeatures
 */
export interface NodePoolSpecForProviderNodeConfigAdvancedMachineFeatures {
  /**
   * @schema NodePoolSpecForProviderNodeConfigAdvancedMachineFeatures#enableNestedVirtualization
   */
  readonly enableNestedVirtualization?: boolean;

  /**
   * @schema NodePoolSpecForProviderNodeConfigAdvancedMachineFeatures#performanceMonitoringUnit
   */
  readonly performanceMonitoringUnit?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigAdvancedMachineFeatures#threadsPerCore
   */
  readonly threadsPerCore?: number;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigAdvancedMachineFeatures' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigAdvancedMachineFeatures(obj: NodePoolSpecForProviderNodeConfigAdvancedMachineFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableNestedVirtualization': obj.enableNestedVirtualization,
    'performanceMonitoringUnit': obj.performanceMonitoringUnit,
    'threadsPerCore': obj.threadsPerCore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigConfidentialNodes
 */
export interface NodePoolSpecForProviderNodeConfigConfidentialNodes {
  /**
   * @schema NodePoolSpecForProviderNodeConfigConfidentialNodes#confidentialInstanceType
   */
  readonly confidentialInstanceType?: string;

  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolSpecForProviderNodeConfigConfidentialNodes#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigConfidentialNodes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigConfidentialNodes(obj: NodePoolSpecForProviderNodeConfigConfidentialNodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confidentialInstanceType': obj.confidentialInstanceType,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigContainerdConfig
 */
export interface NodePoolSpecForProviderNodeConfigContainerdConfig {
  /**
   * @schema NodePoolSpecForProviderNodeConfigContainerdConfig#privateRegistryAccessConfig
   */
  readonly privateRegistryAccessConfig?: NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig[];
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigContainerdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigContainerdConfig(obj: NodePoolSpecForProviderNodeConfigContainerdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateRegistryAccessConfig': obj.privateRegistryAccessConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig
 */
export interface NodePoolSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig {
  /**
   * @schema NodePoolSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig#dataCacheCount
   */
  readonly dataCacheCount?: number;

  /**
   * @schema NodePoolSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig(obj: NodePoolSpecForProviderNodeConfigEphemeralStorageLocalSsdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataCacheCount': obj.dataCacheCount,
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigFastSocket
 */
export interface NodePoolSpecForProviderNodeConfigFastSocket {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolSpecForProviderNodeConfigFastSocket#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigFastSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigFastSocket(obj: NodePoolSpecForProviderNodeConfigFastSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigGcfsConfig
 */
export interface NodePoolSpecForProviderNodeConfigGcfsConfig {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolSpecForProviderNodeConfigGcfsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigGcfsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigGcfsConfig(obj: NodePoolSpecForProviderNodeConfigGcfsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigGuestAccelerator
 */
export interface NodePoolSpecForProviderNodeConfigGuestAccelerator {
  /**
   * @schema NodePoolSpecForProviderNodeConfigGuestAccelerator#count
   */
  readonly count?: number;

  /**
   * @schema NodePoolSpecForProviderNodeConfigGuestAccelerator#gpuDriverInstallationConfig
   */
  readonly gpuDriverInstallationConfig?: NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig[];

  /**
   * @schema NodePoolSpecForProviderNodeConfigGuestAccelerator#gpuPartitionSize
   */
  readonly gpuPartitionSize?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigGuestAccelerator#gpuSharingConfig
   */
  readonly gpuSharingConfig?: NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig[];

  /**
   * The type of the policy. Supports a single value: COMPACT.
   * Specifying COMPACT placement policy type places node pool's nodes in a closer
   * physical proximity in order to reduce network latency between nodes.
   *
   * @schema NodePoolSpecForProviderNodeConfigGuestAccelerator#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigGuestAccelerator' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigGuestAccelerator(obj: NodePoolSpecForProviderNodeConfigGuestAccelerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'gpuDriverInstallationConfig': obj.gpuDriverInstallationConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(y)),
    'gpuPartitionSize': obj.gpuPartitionSize,
    'gpuSharingConfig': obj.gpuSharingConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigGvnic
 */
export interface NodePoolSpecForProviderNodeConfigGvnic {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolSpecForProviderNodeConfigGvnic#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigGvnic' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigGvnic(obj: NodePoolSpecForProviderNodeConfigGvnic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigHostMaintenancePolicy
 */
export interface NodePoolSpecForProviderNodeConfigHostMaintenancePolicy {
  /**
   * @schema NodePoolSpecForProviderNodeConfigHostMaintenancePolicy#maintenanceInterval
   */
  readonly maintenanceInterval?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigHostMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigHostMaintenancePolicy(obj: NodePoolSpecForProviderNodeConfigHostMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maintenanceInterval': obj.maintenanceInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigKubeletConfig
 */
export interface NodePoolSpecForProviderNodeConfigKubeletConfig {
  /**
   * @schema NodePoolSpecForProviderNodeConfigKubeletConfig#allowedUnsafeSysctls
   */
  readonly allowedUnsafeSysctls?: string[];

  /**
   * @schema NodePoolSpecForProviderNodeConfigKubeletConfig#containerLogMaxFiles
   */
  readonly containerLogMaxFiles?: number;

  /**
   * @schema NodePoolSpecForProviderNodeConfigKubeletConfig#containerLogMaxSize
   */
  readonly containerLogMaxSize?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigKubeletConfig#cpuCfsQuota
   */
  readonly cpuCfsQuota?: boolean;

  /**
   * @schema NodePoolSpecForProviderNodeConfigKubeletConfig#cpuCfsQuotaPeriod
   */
  readonly cpuCfsQuotaPeriod?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigKubeletConfig#cpuManagerPolicy
   */
  readonly cpuManagerPolicy?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigKubeletConfig#imageGcHighThresholdPercent
   */
  readonly imageGcHighThresholdPercent?: number;

  /**
   * @schema NodePoolSpecForProviderNodeConfigKubeletConfig#imageGcLowThresholdPercent
   */
  readonly imageGcLowThresholdPercent?: number;

  /**
   * @schema NodePoolSpecForProviderNodeConfigKubeletConfig#imageMaximumGcAge
   */
  readonly imageMaximumGcAge?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigKubeletConfig#imageMinimumGcAge
   */
  readonly imageMinimumGcAge?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigKubeletConfig#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigKubeletConfig#podPidsLimit
   */
  readonly podPidsLimit?: number;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigKubeletConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigKubeletConfig(obj: NodePoolSpecForProviderNodeConfigKubeletConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedUnsafeSysctls': obj.allowedUnsafeSysctls?.map(y => y),
    'containerLogMaxFiles': obj.containerLogMaxFiles,
    'containerLogMaxSize': obj.containerLogMaxSize,
    'cpuCfsQuota': obj.cpuCfsQuota,
    'cpuCfsQuotaPeriod': obj.cpuCfsQuotaPeriod,
    'cpuManagerPolicy': obj.cpuManagerPolicy,
    'imageGcHighThresholdPercent': obj.imageGcHighThresholdPercent,
    'imageGcLowThresholdPercent': obj.imageGcLowThresholdPercent,
    'imageMaximumGcAge': obj.imageMaximumGcAge,
    'imageMinimumGcAge': obj.imageMinimumGcAge,
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
    'podPidsLimit': obj.podPidsLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigLinuxNodeConfig
 */
export interface NodePoolSpecForProviderNodeConfigLinuxNodeConfig {
  /**
   * @schema NodePoolSpecForProviderNodeConfigLinuxNodeConfig#cgroupMode
   */
  readonly cgroupMode?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigLinuxNodeConfig#hugepagesConfig
   */
  readonly hugepagesConfig?: NodePoolSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig[];

  /**
   * @schema NodePoolSpecForProviderNodeConfigLinuxNodeConfig#sysctls
   */
  readonly sysctls?: { [key: string]: string };
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigLinuxNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigLinuxNodeConfig(obj: NodePoolSpecForProviderNodeConfigLinuxNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cgroupMode': obj.cgroupMode,
    'hugepagesConfig': obj.hugepagesConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig(y)),
    'sysctls': ((obj.sysctls) === undefined) ? undefined : (Object.entries(obj.sysctls).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigLocalNvmeSsdBlockConfig
 */
export interface NodePoolSpecForProviderNodeConfigLocalNvmeSsdBlockConfig {
  /**
   * @schema NodePoolSpecForProviderNodeConfigLocalNvmeSsdBlockConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigLocalNvmeSsdBlockConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigLocalNvmeSsdBlockConfig(obj: NodePoolSpecForProviderNodeConfigLocalNvmeSsdBlockConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigReservationAffinity
 */
export interface NodePoolSpecForProviderNodeConfigReservationAffinity {
  /**
   * @schema NodePoolSpecForProviderNodeConfigReservationAffinity#consumeReservationType
   */
  readonly consumeReservationType?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigReservationAffinity#key
   */
  readonly key?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigReservationAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigReservationAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigReservationAffinity(obj: NodePoolSpecForProviderNodeConfigReservationAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumeReservationType': obj.consumeReservationType,
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigSecondaryBootDisks
 */
export interface NodePoolSpecForProviderNodeConfigSecondaryBootDisks {
  /**
   * @schema NodePoolSpecForProviderNodeConfigSecondaryBootDisks#diskImage
   */
  readonly diskImage?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigSecondaryBootDisks#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigSecondaryBootDisks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigSecondaryBootDisks(obj: NodePoolSpecForProviderNodeConfigSecondaryBootDisks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'diskImage': obj.diskImage,
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema NodePoolSpecForProviderNodeConfigServiceAccountRef
 */
export interface NodePoolSpecForProviderNodeConfigServiceAccountRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodePoolSpecForProviderNodeConfigServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodePoolSpecForProviderNodeConfigServiceAccountRef#policy
   */
  readonly policy?: NodePoolSpecForProviderNodeConfigServiceAccountRefPolicy;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigServiceAccountRef(obj: NodePoolSpecForProviderNodeConfigServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodePoolSpecForProviderNodeConfigServiceAccountRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema NodePoolSpecForProviderNodeConfigServiceAccountSelector
 */
export interface NodePoolSpecForProviderNodeConfigServiceAccountSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema NodePoolSpecForProviderNodeConfigServiceAccountSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodePoolSpecForProviderNodeConfigServiceAccountSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodePoolSpecForProviderNodeConfigServiceAccountSelector#policy
   */
  readonly policy?: NodePoolSpecForProviderNodeConfigServiceAccountSelectorPolicy;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigServiceAccountSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigServiceAccountSelector(obj: NodePoolSpecForProviderNodeConfigServiceAccountSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodePoolSpecForProviderNodeConfigServiceAccountSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigShieldedInstanceConfig
 */
export interface NodePoolSpecForProviderNodeConfigShieldedInstanceConfig {
  /**
   * @schema NodePoolSpecForProviderNodeConfigShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * @schema NodePoolSpecForProviderNodeConfigShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigShieldedInstanceConfig(obj: NodePoolSpecForProviderNodeConfigShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigSoleTenantConfig
 */
export interface NodePoolSpecForProviderNodeConfigSoleTenantConfig {
  /**
   * @schema NodePoolSpecForProviderNodeConfigSoleTenantConfig#nodeAffinity
   */
  readonly nodeAffinity?: NodePoolSpecForProviderNodeConfigSoleTenantConfigNodeAffinity[];
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigSoleTenantConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigSoleTenantConfig(obj: NodePoolSpecForProviderNodeConfigSoleTenantConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': obj.nodeAffinity?.map(y => toJson_NodePoolSpecForProviderNodeConfigSoleTenantConfigNodeAffinity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigTaint
 */
export interface NodePoolSpecForProviderNodeConfigTaint {
  /**
   * @schema NodePoolSpecForProviderNodeConfigTaint#effect
   */
  readonly effect?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigTaint#key
   */
  readonly key?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigTaint#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigTaint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigTaint(obj: NodePoolSpecForProviderNodeConfigTaint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigWindowsNodeConfig
 */
export interface NodePoolSpecForProviderNodeConfigWindowsNodeConfig {
  /**
   * The Kubernetes version for the nodes in this pool. Note that if this field
   * and auto_upgrade are both specified, they will fight each other for what the node version should
   * be, so setting both is highly discouraged.
   *
   * @schema NodePoolSpecForProviderNodeConfigWindowsNodeConfig#osversion
   */
  readonly osversion?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigWindowsNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigWindowsNodeConfig(obj: NodePoolSpecForProviderNodeConfigWindowsNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'osversion': obj.osversion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigWorkloadMetadataConfig
 */
export interface NodePoolSpecForProviderNodeConfigWorkloadMetadataConfig {
  /**
   * @schema NodePoolSpecForProviderNodeConfigWorkloadMetadataConfig#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigWorkloadMetadataConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigWorkloadMetadataConfig(obj: NodePoolSpecForProviderNodeConfigWorkloadMetadataConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderUpgradeSettingsBlueGreenSettings
 */
export interface NodePoolSpecForProviderUpgradeSettingsBlueGreenSettings {
  /**
   * Time needed after draining the entire blue pool.
   * After this period, the blue pool will be cleaned up.
   *
   * @schema NodePoolSpecForProviderUpgradeSettingsBlueGreenSettings#nodePoolSoakDuration
   */
  readonly nodePoolSoakDuration?: string;

  /**
   * Specifies the standard policy settings for blue-green upgrades.
   *
   * @schema NodePoolSpecForProviderUpgradeSettingsBlueGreenSettings#standardRolloutPolicy
   */
  readonly standardRolloutPolicy?: NodePoolSpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy[];
}

/**
 * Converts an object of type 'NodePoolSpecForProviderUpgradeSettingsBlueGreenSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderUpgradeSettingsBlueGreenSettings(obj: NodePoolSpecForProviderUpgradeSettingsBlueGreenSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodePoolSoakDuration': obj.nodePoolSoakDuration,
    'standardRolloutPolicy': obj.standardRolloutPolicy?.map(y => toJson_NodePoolSpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs
 */
export interface NodePoolSpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs {
  /**
   * Name of the VPC where the additional interface belongs.
   *
   * @schema NodePoolSpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs#network
   */
  readonly network?: string;

  /**
   * The subnetwork path for the node pool. Format: projects/{project}/regions/{region}/subnetworks/{subnetwork}. If the cluster is associated with multiple subnetworks, the subnetwork for the node pool is picked based on the IP utilization during node pool creation and is immutable
   *
   * @schema NodePoolSpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs#subnetwork
   */
  readonly subnetwork?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs(obj: NodePoolSpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'network': obj.network,
    'subnetwork': obj.subnetwork,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNetworkConfigAdditionalPodNetworkConfigs
 */
export interface NodePoolSpecInitProviderNetworkConfigAdditionalPodNetworkConfigs {
  /**
   * The maximum number of pods per node in this node pool.
   * Note that this does not work on node pools which are "route-based" - that is, node
   * pools belonging to clusters that do not have IP Aliasing enabled.
   * See the official documentation
   * for more information.
   *
   * @schema NodePoolSpecInitProviderNetworkConfigAdditionalPodNetworkConfigs#maxPodsPerNode
   */
  readonly maxPodsPerNode?: number;

  /**
   * The name of the secondary range on the subnet which provides IP address for this pod range.
   *
   * @schema NodePoolSpecInitProviderNetworkConfigAdditionalPodNetworkConfigs#secondaryPodRange
   */
  readonly secondaryPodRange?: string;

  /**
   * The subnetwork path for the node pool. Format: projects/{project}/regions/{region}/subnetworks/{subnetwork}. If the cluster is associated with multiple subnetworks, the subnetwork for the node pool is picked based on the IP utilization during node pool creation and is immutable
   *
   * @schema NodePoolSpecInitProviderNetworkConfigAdditionalPodNetworkConfigs#subnetwork
   */
  readonly subnetwork?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNetworkConfigAdditionalPodNetworkConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNetworkConfigAdditionalPodNetworkConfigs(obj: NodePoolSpecInitProviderNetworkConfigAdditionalPodNetworkConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxPodsPerNode': obj.maxPodsPerNode,
    'secondaryPodRange': obj.secondaryPodRange,
    'subnetwork': obj.subnetwork,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNetworkConfigNetworkPerformanceConfig
 */
export interface NodePoolSpecInitProviderNetworkConfigNetworkPerformanceConfig {
  /**
   * Specifies the total network bandwidth tier for the NodePool. Valid values include: "TIER_1" and "TIER_UNSPECIFIED".
   *
   * @schema NodePoolSpecInitProviderNetworkConfigNetworkPerformanceConfig#totalEgressBandwidthTier
   */
  readonly totalEgressBandwidthTier?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNetworkConfigNetworkPerformanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNetworkConfigNetworkPerformanceConfig(obj: NodePoolSpecInitProviderNetworkConfigNetworkPerformanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'totalEgressBandwidthTier': obj.totalEgressBandwidthTier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNetworkConfigPodCidrOverprovisionConfig
 */
export interface NodePoolSpecInitProviderNetworkConfigPodCidrOverprovisionConfig {
  /**
   * @schema NodePoolSpecInitProviderNetworkConfigPodCidrOverprovisionConfig#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNetworkConfigPodCidrOverprovisionConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNetworkConfigPodCidrOverprovisionConfig(obj: NodePoolSpecInitProviderNetworkConfigPodCidrOverprovisionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigAdvancedMachineFeatures
 */
export interface NodePoolSpecInitProviderNodeConfigAdvancedMachineFeatures {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigAdvancedMachineFeatures#enableNestedVirtualization
   */
  readonly enableNestedVirtualization?: boolean;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigAdvancedMachineFeatures#performanceMonitoringUnit
   */
  readonly performanceMonitoringUnit?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigAdvancedMachineFeatures#threadsPerCore
   */
  readonly threadsPerCore?: number;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigAdvancedMachineFeatures' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigAdvancedMachineFeatures(obj: NodePoolSpecInitProviderNodeConfigAdvancedMachineFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableNestedVirtualization': obj.enableNestedVirtualization,
    'performanceMonitoringUnit': obj.performanceMonitoringUnit,
    'threadsPerCore': obj.threadsPerCore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigConfidentialNodes
 */
export interface NodePoolSpecInitProviderNodeConfigConfidentialNodes {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigConfidentialNodes#confidentialInstanceType
   */
  readonly confidentialInstanceType?: string;

  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolSpecInitProviderNodeConfigConfidentialNodes#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigConfidentialNodes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigConfidentialNodes(obj: NodePoolSpecInitProviderNodeConfigConfidentialNodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confidentialInstanceType': obj.confidentialInstanceType,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigContainerdConfig
 */
export interface NodePoolSpecInitProviderNodeConfigContainerdConfig {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigContainerdConfig#privateRegistryAccessConfig
   */
  readonly privateRegistryAccessConfig?: NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig[];
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigContainerdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigContainerdConfig(obj: NodePoolSpecInitProviderNodeConfigContainerdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateRegistryAccessConfig': obj.privateRegistryAccessConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig
 */
export interface NodePoolSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig#dataCacheCount
   */
  readonly dataCacheCount?: number;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig(obj: NodePoolSpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataCacheCount': obj.dataCacheCount,
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigFastSocket
 */
export interface NodePoolSpecInitProviderNodeConfigFastSocket {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolSpecInitProviderNodeConfigFastSocket#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigFastSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigFastSocket(obj: NodePoolSpecInitProviderNodeConfigFastSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigGcfsConfig
 */
export interface NodePoolSpecInitProviderNodeConfigGcfsConfig {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolSpecInitProviderNodeConfigGcfsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigGcfsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigGcfsConfig(obj: NodePoolSpecInitProviderNodeConfigGcfsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigGuestAccelerator
 */
export interface NodePoolSpecInitProviderNodeConfigGuestAccelerator {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigGuestAccelerator#count
   */
  readonly count?: number;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigGuestAccelerator#gpuDriverInstallationConfig
   */
  readonly gpuDriverInstallationConfig?: NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfigGuestAccelerator#gpuPartitionSize
   */
  readonly gpuPartitionSize?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigGuestAccelerator#gpuSharingConfig
   */
  readonly gpuSharingConfig?: NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig[];

  /**
   * The type of the policy. Supports a single value: COMPACT.
   * Specifying COMPACT placement policy type places node pool's nodes in a closer
   * physical proximity in order to reduce network latency between nodes.
   *
   * @schema NodePoolSpecInitProviderNodeConfigGuestAccelerator#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigGuestAccelerator' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigGuestAccelerator(obj: NodePoolSpecInitProviderNodeConfigGuestAccelerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'gpuDriverInstallationConfig': obj.gpuDriverInstallationConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(y)),
    'gpuPartitionSize': obj.gpuPartitionSize,
    'gpuSharingConfig': obj.gpuSharingConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigGvnic
 */
export interface NodePoolSpecInitProviderNodeConfigGvnic {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolSpecInitProviderNodeConfigGvnic#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigGvnic' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigGvnic(obj: NodePoolSpecInitProviderNodeConfigGvnic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigHostMaintenancePolicy
 */
export interface NodePoolSpecInitProviderNodeConfigHostMaintenancePolicy {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigHostMaintenancePolicy#maintenanceInterval
   */
  readonly maintenanceInterval?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigHostMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigHostMaintenancePolicy(obj: NodePoolSpecInitProviderNodeConfigHostMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maintenanceInterval': obj.maintenanceInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigKubeletConfig
 */
export interface NodePoolSpecInitProviderNodeConfigKubeletConfig {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigKubeletConfig#allowedUnsafeSysctls
   */
  readonly allowedUnsafeSysctls?: string[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfigKubeletConfig#containerLogMaxFiles
   */
  readonly containerLogMaxFiles?: number;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigKubeletConfig#containerLogMaxSize
   */
  readonly containerLogMaxSize?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigKubeletConfig#cpuCfsQuota
   */
  readonly cpuCfsQuota?: boolean;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigKubeletConfig#cpuCfsQuotaPeriod
   */
  readonly cpuCfsQuotaPeriod?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigKubeletConfig#cpuManagerPolicy
   */
  readonly cpuManagerPolicy?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigKubeletConfig#imageGcHighThresholdPercent
   */
  readonly imageGcHighThresholdPercent?: number;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigKubeletConfig#imageGcLowThresholdPercent
   */
  readonly imageGcLowThresholdPercent?: number;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigKubeletConfig#imageMaximumGcAge
   */
  readonly imageMaximumGcAge?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigKubeletConfig#imageMinimumGcAge
   */
  readonly imageMinimumGcAge?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigKubeletConfig#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigKubeletConfig#podPidsLimit
   */
  readonly podPidsLimit?: number;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigKubeletConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigKubeletConfig(obj: NodePoolSpecInitProviderNodeConfigKubeletConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedUnsafeSysctls': obj.allowedUnsafeSysctls?.map(y => y),
    'containerLogMaxFiles': obj.containerLogMaxFiles,
    'containerLogMaxSize': obj.containerLogMaxSize,
    'cpuCfsQuota': obj.cpuCfsQuota,
    'cpuCfsQuotaPeriod': obj.cpuCfsQuotaPeriod,
    'cpuManagerPolicy': obj.cpuManagerPolicy,
    'imageGcHighThresholdPercent': obj.imageGcHighThresholdPercent,
    'imageGcLowThresholdPercent': obj.imageGcLowThresholdPercent,
    'imageMaximumGcAge': obj.imageMaximumGcAge,
    'imageMinimumGcAge': obj.imageMinimumGcAge,
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
    'podPidsLimit': obj.podPidsLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigLinuxNodeConfig
 */
export interface NodePoolSpecInitProviderNodeConfigLinuxNodeConfig {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigLinuxNodeConfig#cgroupMode
   */
  readonly cgroupMode?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigLinuxNodeConfig#hugepagesConfig
   */
  readonly hugepagesConfig?: NodePoolSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfigLinuxNodeConfig#sysctls
   */
  readonly sysctls?: { [key: string]: string };
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigLinuxNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigLinuxNodeConfig(obj: NodePoolSpecInitProviderNodeConfigLinuxNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cgroupMode': obj.cgroupMode,
    'hugepagesConfig': obj.hugepagesConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig(y)),
    'sysctls': ((obj.sysctls) === undefined) ? undefined : (Object.entries(obj.sysctls).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig
 */
export interface NodePoolSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig(obj: NodePoolSpecInitProviderNodeConfigLocalNvmeSsdBlockConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigReservationAffinity
 */
export interface NodePoolSpecInitProviderNodeConfigReservationAffinity {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigReservationAffinity#consumeReservationType
   */
  readonly consumeReservationType?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigReservationAffinity#key
   */
  readonly key?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigReservationAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigReservationAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigReservationAffinity(obj: NodePoolSpecInitProviderNodeConfigReservationAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumeReservationType': obj.consumeReservationType,
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigSecondaryBootDisks
 */
export interface NodePoolSpecInitProviderNodeConfigSecondaryBootDisks {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigSecondaryBootDisks#diskImage
   */
  readonly diskImage?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigSecondaryBootDisks#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigSecondaryBootDisks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigSecondaryBootDisks(obj: NodePoolSpecInitProviderNodeConfigSecondaryBootDisks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'diskImage': obj.diskImage,
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema NodePoolSpecInitProviderNodeConfigServiceAccountRef
 */
export interface NodePoolSpecInitProviderNodeConfigServiceAccountRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodePoolSpecInitProviderNodeConfigServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodePoolSpecInitProviderNodeConfigServiceAccountRef#policy
   */
  readonly policy?: NodePoolSpecInitProviderNodeConfigServiceAccountRefPolicy;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigServiceAccountRef(obj: NodePoolSpecInitProviderNodeConfigServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodePoolSpecInitProviderNodeConfigServiceAccountRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema NodePoolSpecInitProviderNodeConfigServiceAccountSelector
 */
export interface NodePoolSpecInitProviderNodeConfigServiceAccountSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema NodePoolSpecInitProviderNodeConfigServiceAccountSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodePoolSpecInitProviderNodeConfigServiceAccountSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodePoolSpecInitProviderNodeConfigServiceAccountSelector#policy
   */
  readonly policy?: NodePoolSpecInitProviderNodeConfigServiceAccountSelectorPolicy;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigServiceAccountSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigServiceAccountSelector(obj: NodePoolSpecInitProviderNodeConfigServiceAccountSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodePoolSpecInitProviderNodeConfigServiceAccountSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigShieldedInstanceConfig
 */
export interface NodePoolSpecInitProviderNodeConfigShieldedInstanceConfig {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigShieldedInstanceConfig(obj: NodePoolSpecInitProviderNodeConfigShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigSoleTenantConfig
 */
export interface NodePoolSpecInitProviderNodeConfigSoleTenantConfig {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigSoleTenantConfig#nodeAffinity
   */
  readonly nodeAffinity?: NodePoolSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity[];
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigSoleTenantConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigSoleTenantConfig(obj: NodePoolSpecInitProviderNodeConfigSoleTenantConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': obj.nodeAffinity?.map(y => toJson_NodePoolSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigTaint
 */
export interface NodePoolSpecInitProviderNodeConfigTaint {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigTaint#effect
   */
  readonly effect?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigTaint#key
   */
  readonly key?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigTaint#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigTaint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigTaint(obj: NodePoolSpecInitProviderNodeConfigTaint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigWindowsNodeConfig
 */
export interface NodePoolSpecInitProviderNodeConfigWindowsNodeConfig {
  /**
   * The Kubernetes version for the nodes in this pool. Note that if this field
   * and auto_upgrade are both specified, they will fight each other for what the node version should
   * be, so setting both is highly discouraged.
   *
   * @schema NodePoolSpecInitProviderNodeConfigWindowsNodeConfig#osversion
   */
  readonly osversion?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigWindowsNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigWindowsNodeConfig(obj: NodePoolSpecInitProviderNodeConfigWindowsNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'osversion': obj.osversion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigWorkloadMetadataConfig
 */
export interface NodePoolSpecInitProviderNodeConfigWorkloadMetadataConfig {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigWorkloadMetadataConfig#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigWorkloadMetadataConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigWorkloadMetadataConfig(obj: NodePoolSpecInitProviderNodeConfigWorkloadMetadataConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettings
 */
export interface NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettings {
  /**
   * Time needed after draining the entire blue pool.
   * After this period, the blue pool will be cleaned up.
   *
   * @schema NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettings#nodePoolSoakDuration
   */
  readonly nodePoolSoakDuration?: string;

  /**
   * Specifies the standard policy settings for blue-green upgrades.
   *
   * @schema NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettings#standardRolloutPolicy
   */
  readonly standardRolloutPolicy?: NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy[];
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettings(obj: NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodePoolSoakDuration': obj.nodePoolSoakDuration,
    'standardRolloutPolicy': obj.standardRolloutPolicy?.map(y => toJson_NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema NodePoolSpecProviderConfigRefPolicyResolution
 */
export enum NodePoolSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema NodePoolSpecProviderConfigRefPolicyResolve
 */
export enum NodePoolSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema NodePoolSpecForProviderClusterRefPolicyResolution
 */
export enum NodePoolSpecForProviderClusterRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema NodePoolSpecForProviderClusterRefPolicyResolve
 */
export enum NodePoolSpecForProviderClusterRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema NodePoolSpecForProviderClusterSelectorPolicyResolution
 */
export enum NodePoolSpecForProviderClusterSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema NodePoolSpecForProviderClusterSelectorPolicyResolve
 */
export enum NodePoolSpecForProviderClusterSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig
 */
export interface NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig {
  /**
   * @schema NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#certificateAuthorityDomainConfig
   */
  readonly certificateAuthorityDomainConfig?: NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig[];

  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(obj: NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityDomainConfig': obj.certificateAuthorityDomainConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(y)),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig
 */
export interface NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
  /**
   * The Kubernetes version for the nodes in this pool. Note that if this field
   * and auto_upgrade are both specified, they will fight each other for what the node version should
   * be, so setting both is highly discouraged.
   *
   * @schema NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig#gpuDriverVersion
   */
  readonly gpuDriverVersion?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(obj: NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuDriverVersion': obj.gpuDriverVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig
 */
export interface NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig {
  /**
   * @schema NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig#gpuSharingStrategy
   */
  readonly gpuSharingStrategy?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig#maxSharedClientsPerGpu
   */
  readonly maxSharedClientsPerGpu?: number;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig(obj: NodePoolSpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuSharingStrategy': obj.gpuSharingStrategy,
    'maxSharedClientsPerGpu': obj.maxSharedClientsPerGpu,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig
 */
export interface NodePoolSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig {
  /**
   * @schema NodePoolSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize1G
   */
  readonly hugepageSize1G?: number;

  /**
   * @schema NodePoolSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize2M
   */
  readonly hugepageSize2M?: number;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig(obj: NodePoolSpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hugepageSize1G': obj.hugepageSize1G,
    'hugepageSize2M': obj.hugepageSize2M,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodePoolSpecForProviderNodeConfigServiceAccountRefPolicy
 */
export interface NodePoolSpecForProviderNodeConfigServiceAccountRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema NodePoolSpecForProviderNodeConfigServiceAccountRefPolicy#resolution
   */
  readonly resolution?: NodePoolSpecForProviderNodeConfigServiceAccountRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema NodePoolSpecForProviderNodeConfigServiceAccountRefPolicy#resolve
   */
  readonly resolve?: NodePoolSpecForProviderNodeConfigServiceAccountRefPolicyResolve;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigServiceAccountRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigServiceAccountRefPolicy(obj: NodePoolSpecForProviderNodeConfigServiceAccountRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema NodePoolSpecForProviderNodeConfigServiceAccountSelectorPolicy
 */
export interface NodePoolSpecForProviderNodeConfigServiceAccountSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema NodePoolSpecForProviderNodeConfigServiceAccountSelectorPolicy#resolution
   */
  readonly resolution?: NodePoolSpecForProviderNodeConfigServiceAccountSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema NodePoolSpecForProviderNodeConfigServiceAccountSelectorPolicy#resolve
   */
  readonly resolve?: NodePoolSpecForProviderNodeConfigServiceAccountSelectorPolicyResolve;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigServiceAccountSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigServiceAccountSelectorPolicy(obj: NodePoolSpecForProviderNodeConfigServiceAccountSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigSoleTenantConfigNodeAffinity
 */
export interface NodePoolSpecForProviderNodeConfigSoleTenantConfigNodeAffinity {
  /**
   * @schema NodePoolSpecForProviderNodeConfigSoleTenantConfigNodeAffinity#key
   */
  readonly key?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigSoleTenantConfigNodeAffinity#operator
   */
  readonly operator?: string;

  /**
   * @schema NodePoolSpecForProviderNodeConfigSoleTenantConfigNodeAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigSoleTenantConfigNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigSoleTenantConfigNodeAffinity(obj: NodePoolSpecForProviderNodeConfigSoleTenantConfigNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy
 */
export interface NodePoolSpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
  /**
   * Number of blue nodes to drain in a batch.
   *
   * @schema NodePoolSpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchNodeCount
   */
  readonly batchNodeCount?: number;

  /**
   * Percentage of the blue pool nodes to drain in a batch.
   *
   * @schema NodePoolSpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchPercentage
   */
  readonly batchPercentage?: number;

  /**
   * (Optionial) Soak time after each batch gets drained.
   *
   * @schema NodePoolSpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchSoakDuration
   */
  readonly batchSoakDuration?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(obj: NodePoolSpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchNodeCount': obj.batchNodeCount,
    'batchPercentage': obj.batchPercentage,
    'batchSoakDuration': obj.batchSoakDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig
 */
export interface NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#certificateAuthorityDomainConfig
   */
  readonly certificateAuthorityDomainConfig?: NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig[];

  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(obj: NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityDomainConfig': obj.certificateAuthorityDomainConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(y)),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig
 */
export interface NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
  /**
   * The Kubernetes version for the nodes in this pool. Note that if this field
   * and auto_upgrade are both specified, they will fight each other for what the node version should
   * be, so setting both is highly discouraged.
   *
   * @schema NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig#gpuDriverVersion
   */
  readonly gpuDriverVersion?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(obj: NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuDriverVersion': obj.gpuDriverVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig
 */
export interface NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig#gpuSharingStrategy
   */
  readonly gpuSharingStrategy?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig#maxSharedClientsPerGpu
   */
  readonly maxSharedClientsPerGpu?: number;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig(obj: NodePoolSpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuSharingStrategy': obj.gpuSharingStrategy,
    'maxSharedClientsPerGpu': obj.maxSharedClientsPerGpu,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig
 */
export interface NodePoolSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize1G
   */
  readonly hugepageSize1G?: number;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize2M
   */
  readonly hugepageSize2M?: number;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig(obj: NodePoolSpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hugepageSize1G': obj.hugepageSize1G,
    'hugepageSize2M': obj.hugepageSize2M,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodePoolSpecInitProviderNodeConfigServiceAccountRefPolicy
 */
export interface NodePoolSpecInitProviderNodeConfigServiceAccountRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema NodePoolSpecInitProviderNodeConfigServiceAccountRefPolicy#resolution
   */
  readonly resolution?: NodePoolSpecInitProviderNodeConfigServiceAccountRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema NodePoolSpecInitProviderNodeConfigServiceAccountRefPolicy#resolve
   */
  readonly resolve?: NodePoolSpecInitProviderNodeConfigServiceAccountRefPolicyResolve;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigServiceAccountRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigServiceAccountRefPolicy(obj: NodePoolSpecInitProviderNodeConfigServiceAccountRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema NodePoolSpecInitProviderNodeConfigServiceAccountSelectorPolicy
 */
export interface NodePoolSpecInitProviderNodeConfigServiceAccountSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema NodePoolSpecInitProviderNodeConfigServiceAccountSelectorPolicy#resolution
   */
  readonly resolution?: NodePoolSpecInitProviderNodeConfigServiceAccountSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema NodePoolSpecInitProviderNodeConfigServiceAccountSelectorPolicy#resolve
   */
  readonly resolve?: NodePoolSpecInitProviderNodeConfigServiceAccountSelectorPolicyResolve;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigServiceAccountSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigServiceAccountSelectorPolicy(obj: NodePoolSpecInitProviderNodeConfigServiceAccountSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity
 */
export interface NodePoolSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity#key
   */
  readonly key?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity#operator
   */
  readonly operator?: string;

  /**
   * @schema NodePoolSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity(obj: NodePoolSpecInitProviderNodeConfigSoleTenantConfigNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy
 */
export interface NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
  /**
   * Number of blue nodes to drain in a batch.
   *
   * @schema NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchNodeCount
   */
  readonly batchNodeCount?: number;

  /**
   * Percentage of the blue pool nodes to drain in a batch.
   *
   * @schema NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchPercentage
   */
  readonly batchPercentage?: number;

  /**
   * (Optionial) Soak time after each batch gets drained.
   *
   * @schema NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchSoakDuration
   */
  readonly batchSoakDuration?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(obj: NodePoolSpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchNodeCount': obj.batchNodeCount,
    'batchPercentage': obj.batchPercentage,
    'batchSoakDuration': obj.batchSoakDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig
 */
export interface NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
  /**
   * @schema NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#fqdns
   */
  readonly fqdns?: string[];

  /**
   * @schema NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#gcpSecretManagerCertificateConfig
   */
  readonly gcpSecretManagerCertificateConfig?: NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig[];
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(obj: NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fqdns': obj.fqdns?.map(y => y),
    'gcpSecretManagerCertificateConfig': obj.gcpSecretManagerCertificateConfig?.map(y => toJson_NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema NodePoolSpecForProviderNodeConfigServiceAccountRefPolicyResolution
 */
export enum NodePoolSpecForProviderNodeConfigServiceAccountRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema NodePoolSpecForProviderNodeConfigServiceAccountRefPolicyResolve
 */
export enum NodePoolSpecForProviderNodeConfigServiceAccountRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema NodePoolSpecForProviderNodeConfigServiceAccountSelectorPolicyResolution
 */
export enum NodePoolSpecForProviderNodeConfigServiceAccountSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema NodePoolSpecForProviderNodeConfigServiceAccountSelectorPolicyResolve
 */
export enum NodePoolSpecForProviderNodeConfigServiceAccountSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig
 */
export interface NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#fqdns
   */
  readonly fqdns?: string[];

  /**
   * @schema NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#gcpSecretManagerCertificateConfig
   */
  readonly gcpSecretManagerCertificateConfig?: NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig[];
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(obj: NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fqdns': obj.fqdns?.map(y => y),
    'gcpSecretManagerCertificateConfig': obj.gcpSecretManagerCertificateConfig?.map(y => toJson_NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema NodePoolSpecInitProviderNodeConfigServiceAccountRefPolicyResolution
 */
export enum NodePoolSpecInitProviderNodeConfigServiceAccountRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema NodePoolSpecInitProviderNodeConfigServiceAccountRefPolicyResolve
 */
export enum NodePoolSpecInitProviderNodeConfigServiceAccountRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema NodePoolSpecInitProviderNodeConfigServiceAccountSelectorPolicyResolution
 */
export enum NodePoolSpecInitProviderNodeConfigServiceAccountSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema NodePoolSpecInitProviderNodeConfigServiceAccountSelectorPolicyResolve
 */
export enum NodePoolSpecInitProviderNodeConfigServiceAccountSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig
 */
export interface NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
  /**
   * @schema NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig#secretUri
   */
  readonly secretUri?: string;
}

/**
 * Converts an object of type 'NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj: NodePoolSpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretUri': obj.secretUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig
 */
export interface NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
  /**
   * @schema NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig#secretUri
   */
  readonly secretUri?: string;
}

/**
 * Converts an object of type 'NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj: NodePoolSpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretUri': obj.secretUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * NodePool is the Schema for the NodePools API. Manages a GKE NodePool resource.
 *
 * @schema NodePoolV1Beta2
 */
export class NodePoolV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NodePoolV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'container.gcp.upbound.io/v1beta2',
    kind: 'NodePool',
  }

  /**
   * Renders a Kubernetes manifest for "NodePoolV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NodePoolV1Beta2Props): any {
    return {
      ...NodePoolV1Beta2.GVK,
      ...toJson_NodePoolV1Beta2Props(props),
    };
  }

  /**
   * Defines a "NodePoolV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NodePoolV1Beta2Props) {
    super(scope, id, {
      ...NodePoolV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...NodePoolV1Beta2.GVK,
      ...toJson_NodePoolV1Beta2Props(resolved),
    };
  }
}

/**
 * NodePool is the Schema for the NodePools API. Manages a GKE NodePool resource.
 *
 * @schema NodePoolV1Beta2
 */
export interface NodePoolV1Beta2Props {
  /**
   * @schema NodePoolV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NodePoolSpec defines the desired state of NodePool
   *
   * @schema NodePoolV1Beta2#spec
   */
  readonly spec: NodePoolV1Beta2Spec;
}

/**
 * Converts an object of type 'NodePoolV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2Props(obj: NodePoolV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NodePoolV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodePoolSpec defines the desired state of NodePool
 *
 * @schema NodePoolV1Beta2Spec
 */
export interface NodePoolV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NodePoolV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: NodePoolV1Beta2SpecDeletionPolicy;

  /**
   * @schema NodePoolV1Beta2Spec#forProvider
   */
  readonly forProvider: NodePoolV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema NodePoolV1Beta2Spec#initProvider
   */
  readonly initProvider?: NodePoolV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema NodePoolV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: NodePoolV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema NodePoolV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: NodePoolV1Beta2SpecProviderConfigRef;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema NodePoolV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NodePoolV1Beta2SpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'NodePoolV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2Spec(obj: NodePoolV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NodePoolV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_NodePoolV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_NodePoolV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'writeConnectionSecretToRef': toJson_NodePoolV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NodePoolV1Beta2SpecDeletionPolicy
 */
export enum NodePoolV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NodePoolV1Beta2SpecForProvider
 */
export interface NodePoolV1Beta2SpecForProvider {
  /**
   * Configuration required by cluster autoscaler to adjust
   * the size of the node pool to the current cluster usage. Structure is documented below.
   *
   * @schema NodePoolV1Beta2SpecForProvider#autoscaling
   */
  readonly autoscaling?: NodePoolV1Beta2SpecForProviderAutoscaling;

  /**
   * The cluster to create the node pool for. Cluster must be present in location provided for clusters. May be specified in the format projects/{{project}}/locations/{{location}}/clusters/{{cluster}} or as just the name of the cluster.
   *
   * @schema NodePoolV1Beta2SpecForProvider#cluster
   */
  readonly cluster?: string;

  /**
   * Reference to a Cluster in container to populate cluster.
   *
   * @schema NodePoolV1Beta2SpecForProvider#clusterRef
   */
  readonly clusterRef?: NodePoolV1Beta2SpecForProviderClusterRef;

  /**
   * Selector for a Cluster in container to populate cluster.
   *
   * @schema NodePoolV1Beta2SpecForProvider#clusterSelector
   */
  readonly clusterSelector?: NodePoolV1Beta2SpecForProviderClusterSelector;

  /**
   * The initial number of nodes for the pool. In
   * regional or multi-zonal clusters, this is the number of nodes per zone. Changing
   * this will force recreation of the resource.  If you don't
   * need this value, don't set it.  If you do need it, you can use a lifecycle block to
   * ignore subsequent changes to this field.
   *
   * @schema NodePoolV1Beta2SpecForProvider#initialNodeCount
   */
  readonly initialNodeCount?: number;

  /**
   * The location (region or zone) of the cluster.
   *
   * @schema NodePoolV1Beta2SpecForProvider#location
   */
  readonly location?: string;

  /**
   * Node management configuration, wherein auto-repair and
   * auto-upgrade is configured. Structure is documented below.
   *
   * @schema NodePoolV1Beta2SpecForProvider#management
   */
  readonly management?: NodePoolV1Beta2SpecForProviderManagement;

  /**
   * The maximum number of pods per node in this node pool.
   * Note that this does not work on node pools which are "route-based" - that is, node
   * pools belonging to clusters that do not have IP Aliasing enabled.
   * See the official documentation
   * for more information.
   *
   * @schema NodePoolV1Beta2SpecForProvider#maxPodsPerNode
   */
  readonly maxPodsPerNode?: number;

  /**
   * The network configuration of the pool. Such as
   * configuration for Adding Pod IP address ranges) to the node pool. Or enabling private nodes. Structure is
   * documented below
   *
   * @schema NodePoolV1Beta2SpecForProvider#networkConfig
   */
  readonly networkConfig?: NodePoolV1Beta2SpecForProviderNetworkConfig;

  /**
   * Parameters used in creating the node pool. See
   * google_container_cluster for schema.
   *
   * @schema NodePoolV1Beta2SpecForProvider#nodeConfig
   */
  readonly nodeConfig?: NodePoolV1Beta2SpecForProviderNodeConfig;

  /**
   * The number of nodes per instance group. This field can be used to
   * update the number of nodes per instance group but should not be used alongside autoscaling.
   *
   * @schema NodePoolV1Beta2SpecForProvider#nodeCount
   */
  readonly nodeCount?: number;

  /**
   * The list of zones in which the node pool's nodes should be located. Nodes must
   * be in the region of their regional cluster or in the same region as their
   * cluster's zone for zonal clusters. If unspecified, the cluster-level
   * node_locations will be used.
   *
   * @schema NodePoolV1Beta2SpecForProvider#nodeLocations
   */
  readonly nodeLocations?: string[];

  /**
   * Specifies a custom placement policy for the
   * nodes.
   *
   * @schema NodePoolV1Beta2SpecForProvider#placementPolicy
   */
  readonly placementPolicy?: NodePoolV1Beta2SpecForProviderPlacementPolicy;

  /**
   * The ID of the project in which to create the node pool. If blank,
   * the provider-configured project will be used.
   *
   * @schema NodePoolV1Beta2SpecForProvider#project
   */
  readonly project?: string;

  /**
   * Specifies node pool-level settings of queued provisioning.
   * Structure is documented below.
   *
   * @schema NodePoolV1Beta2SpecForProvider#queuedProvisioning
   */
  readonly queuedProvisioning?: NodePoolV1Beta2SpecForProviderQueuedProvisioning;

  /**
   * Specify node upgrade settings to change how GKE upgrades nodes.
   * The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
   *
   * @schema NodePoolV1Beta2SpecForProvider#upgradeSettings
   */
  readonly upgradeSettings?: NodePoolV1Beta2SpecForProviderUpgradeSettings;

  /**
   * The Kubernetes version for the nodes in this pool. Note that if this field
   * and auto_upgrade are both specified, they will fight each other for what the node version should
   * be, so setting both is highly discouraged.
   *
   * @schema NodePoolV1Beta2SpecForProvider#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProvider(obj: NodePoolV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoscaling': toJson_NodePoolV1Beta2SpecForProviderAutoscaling(obj.autoscaling),
    'cluster': obj.cluster,
    'clusterRef': toJson_NodePoolV1Beta2SpecForProviderClusterRef(obj.clusterRef),
    'clusterSelector': toJson_NodePoolV1Beta2SpecForProviderClusterSelector(obj.clusterSelector),
    'initialNodeCount': obj.initialNodeCount,
    'location': obj.location,
    'management': toJson_NodePoolV1Beta2SpecForProviderManagement(obj.management),
    'maxPodsPerNode': obj.maxPodsPerNode,
    'networkConfig': toJson_NodePoolV1Beta2SpecForProviderNetworkConfig(obj.networkConfig),
    'nodeConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfig(obj.nodeConfig),
    'nodeCount': obj.nodeCount,
    'nodeLocations': obj.nodeLocations?.map(y => y),
    'placementPolicy': toJson_NodePoolV1Beta2SpecForProviderPlacementPolicy(obj.placementPolicy),
    'project': obj.project,
    'queuedProvisioning': toJson_NodePoolV1Beta2SpecForProviderQueuedProvisioning(obj.queuedProvisioning),
    'upgradeSettings': toJson_NodePoolV1Beta2SpecForProviderUpgradeSettings(obj.upgradeSettings),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema NodePoolV1Beta2SpecInitProvider
 */
export interface NodePoolV1Beta2SpecInitProvider {
  /**
   * Configuration required by cluster autoscaler to adjust
   * the size of the node pool to the current cluster usage. Structure is documented below.
   *
   * @schema NodePoolV1Beta2SpecInitProvider#autoscaling
   */
  readonly autoscaling?: NodePoolV1Beta2SpecInitProviderAutoscaling;

  /**
   * The initial number of nodes for the pool. In
   * regional or multi-zonal clusters, this is the number of nodes per zone. Changing
   * this will force recreation of the resource.  If you don't
   * need this value, don't set it.  If you do need it, you can use a lifecycle block to
   * ignore subsequent changes to this field.
   *
   * @schema NodePoolV1Beta2SpecInitProvider#initialNodeCount
   */
  readonly initialNodeCount?: number;

  /**
   * Node management configuration, wherein auto-repair and
   * auto-upgrade is configured. Structure is documented below.
   *
   * @schema NodePoolV1Beta2SpecInitProvider#management
   */
  readonly management?: NodePoolV1Beta2SpecInitProviderManagement;

  /**
   * The maximum number of pods per node in this node pool.
   * Note that this does not work on node pools which are "route-based" - that is, node
   * pools belonging to clusters that do not have IP Aliasing enabled.
   * See the official documentation
   * for more information.
   *
   * @schema NodePoolV1Beta2SpecInitProvider#maxPodsPerNode
   */
  readonly maxPodsPerNode?: number;

  /**
   * The network configuration of the pool. Such as
   * configuration for Adding Pod IP address ranges) to the node pool. Or enabling private nodes. Structure is
   * documented below
   *
   * @schema NodePoolV1Beta2SpecInitProvider#networkConfig
   */
  readonly networkConfig?: NodePoolV1Beta2SpecInitProviderNetworkConfig;

  /**
   * Parameters used in creating the node pool. See
   * google_container_cluster for schema.
   *
   * @schema NodePoolV1Beta2SpecInitProvider#nodeConfig
   */
  readonly nodeConfig?: NodePoolV1Beta2SpecInitProviderNodeConfig;

  /**
   * The number of nodes per instance group. This field can be used to
   * update the number of nodes per instance group but should not be used alongside autoscaling.
   *
   * @schema NodePoolV1Beta2SpecInitProvider#nodeCount
   */
  readonly nodeCount?: number;

  /**
   * The list of zones in which the node pool's nodes should be located. Nodes must
   * be in the region of their regional cluster or in the same region as their
   * cluster's zone for zonal clusters. If unspecified, the cluster-level
   * node_locations will be used.
   *
   * @schema NodePoolV1Beta2SpecInitProvider#nodeLocations
   */
  readonly nodeLocations?: string[];

  /**
   * Specifies a custom placement policy for the
   * nodes.
   *
   * @schema NodePoolV1Beta2SpecInitProvider#placementPolicy
   */
  readonly placementPolicy?: NodePoolV1Beta2SpecInitProviderPlacementPolicy;

  /**
   * The ID of the project in which to create the node pool. If blank,
   * the provider-configured project will be used.
   *
   * @schema NodePoolV1Beta2SpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Specifies node pool-level settings of queued provisioning.
   * Structure is documented below.
   *
   * @schema NodePoolV1Beta2SpecInitProvider#queuedProvisioning
   */
  readonly queuedProvisioning?: NodePoolV1Beta2SpecInitProviderQueuedProvisioning;

  /**
   * Specify node upgrade settings to change how GKE upgrades nodes.
   * The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
   *
   * @schema NodePoolV1Beta2SpecInitProvider#upgradeSettings
   */
  readonly upgradeSettings?: NodePoolV1Beta2SpecInitProviderUpgradeSettings;

  /**
   * The Kubernetes version for the nodes in this pool. Note that if this field
   * and auto_upgrade are both specified, they will fight each other for what the node version should
   * be, so setting both is highly discouraged.
   *
   * @schema NodePoolV1Beta2SpecInitProvider#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProvider(obj: NodePoolV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoscaling': toJson_NodePoolV1Beta2SpecInitProviderAutoscaling(obj.autoscaling),
    'initialNodeCount': obj.initialNodeCount,
    'management': toJson_NodePoolV1Beta2SpecInitProviderManagement(obj.management),
    'maxPodsPerNode': obj.maxPodsPerNode,
    'networkConfig': toJson_NodePoolV1Beta2SpecInitProviderNetworkConfig(obj.networkConfig),
    'nodeConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfig(obj.nodeConfig),
    'nodeCount': obj.nodeCount,
    'nodeLocations': obj.nodeLocations?.map(y => y),
    'placementPolicy': toJson_NodePoolV1Beta2SpecInitProviderPlacementPolicy(obj.placementPolicy),
    'project': obj.project,
    'queuedProvisioning': toJson_NodePoolV1Beta2SpecInitProviderQueuedProvisioning(obj.queuedProvisioning),
    'upgradeSettings': toJson_NodePoolV1Beta2SpecInitProviderUpgradeSettings(obj.upgradeSettings),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema NodePoolV1Beta2SpecManagementPolicies
 */
export enum NodePoolV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema NodePoolV1Beta2SpecProviderConfigRef
 */
export interface NodePoolV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodePoolV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodePoolV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: NodePoolV1Beta2SpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecProviderConfigRef(obj: NodePoolV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodePoolV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema NodePoolV1Beta2SpecWriteConnectionSecretToRef
 */
export interface NodePoolV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NodePoolV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NodePoolV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecWriteConnectionSecretToRef(obj: NodePoolV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration required by cluster autoscaler to adjust
 * the size of the node pool to the current cluster usage. Structure is documented below.
 *
 * @schema NodePoolV1Beta2SpecForProviderAutoscaling
 */
export interface NodePoolV1Beta2SpecForProviderAutoscaling {
  /**
   * Location policy specifies the algorithm used when
   * scaling-up the node pool. Location policy is supported only in 1.24.1+ clusters.
   *
   * @schema NodePoolV1Beta2SpecForProviderAutoscaling#locationPolicy
   */
  readonly locationPolicy?: string;

  /**
   * Maximum number of nodes per zone in the NodePool.
   * Must be >= min_node_count. Cannot be used with total limits.
   *
   * @schema NodePoolV1Beta2SpecForProviderAutoscaling#maxNodeCount
   */
  readonly maxNodeCount?: number;

  /**
   * Minimum number of nodes per zone in the NodePool.
   * Must be >=0 and <= max_node_count. Cannot be used with total limits.
   *
   * @schema NodePoolV1Beta2SpecForProviderAutoscaling#minNodeCount
   */
  readonly minNodeCount?: number;

  /**
   * Total maximum number of nodes in the NodePool.
   * Must be >= total_min_node_count. Cannot be used with per zone limits.
   * Total size limits are supported only in 1.24.1+ clusters.
   *
   * @schema NodePoolV1Beta2SpecForProviderAutoscaling#totalMaxNodeCount
   */
  readonly totalMaxNodeCount?: number;

  /**
   * Total minimum number of nodes in the NodePool.
   * Must be >=0 and <= total_max_node_count. Cannot be used with per zone limits.
   * Total size limits are supported only in 1.24.1+ clusters.
   *
   * @schema NodePoolV1Beta2SpecForProviderAutoscaling#totalMinNodeCount
   */
  readonly totalMinNodeCount?: number;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderAutoscaling(obj: NodePoolV1Beta2SpecForProviderAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'locationPolicy': obj.locationPolicy,
    'maxNodeCount': obj.maxNodeCount,
    'minNodeCount': obj.minNodeCount,
    'totalMaxNodeCount': obj.totalMaxNodeCount,
    'totalMinNodeCount': obj.totalMinNodeCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Cluster in container to populate cluster.
 *
 * @schema NodePoolV1Beta2SpecForProviderClusterRef
 */
export interface NodePoolV1Beta2SpecForProviderClusterRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodePoolV1Beta2SpecForProviderClusterRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodePoolV1Beta2SpecForProviderClusterRef#policy
   */
  readonly policy?: NodePoolV1Beta2SpecForProviderClusterRefPolicy;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderClusterRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderClusterRef(obj: NodePoolV1Beta2SpecForProviderClusterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodePoolV1Beta2SpecForProviderClusterRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Cluster in container to populate cluster.
 *
 * @schema NodePoolV1Beta2SpecForProviderClusterSelector
 */
export interface NodePoolV1Beta2SpecForProviderClusterSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema NodePoolV1Beta2SpecForProviderClusterSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodePoolV1Beta2SpecForProviderClusterSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodePoolV1Beta2SpecForProviderClusterSelector#policy
   */
  readonly policy?: NodePoolV1Beta2SpecForProviderClusterSelectorPolicy;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderClusterSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderClusterSelector(obj: NodePoolV1Beta2SpecForProviderClusterSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodePoolV1Beta2SpecForProviderClusterSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Node management configuration, wherein auto-repair and
 * auto-upgrade is configured. Structure is documented below.
 *
 * @schema NodePoolV1Beta2SpecForProviderManagement
 */
export interface NodePoolV1Beta2SpecForProviderManagement {
  /**
   * Whether the nodes will be automatically repaired. Enabled by default.
   *
   * @schema NodePoolV1Beta2SpecForProviderManagement#autoRepair
   */
  readonly autoRepair?: boolean;

  /**
   * Whether the nodes will be automatically upgraded. Enabled by default.
   *
   * @schema NodePoolV1Beta2SpecForProviderManagement#autoUpgrade
   */
  readonly autoUpgrade?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderManagement' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderManagement(obj: NodePoolV1Beta2SpecForProviderManagement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoRepair': obj.autoRepair,
    'autoUpgrade': obj.autoUpgrade,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The network configuration of the pool. Such as
 * configuration for Adding Pod IP address ranges) to the node pool. Or enabling private nodes. Structure is
 * documented below
 *
 * @schema NodePoolV1Beta2SpecForProviderNetworkConfig
 */
export interface NodePoolV1Beta2SpecForProviderNetworkConfig {
  /**
   * We specify the additional node networks for this node pool using this list. Each node network corresponds to an additional interface.
   * Structure is documented below
   *
   * @schema NodePoolV1Beta2SpecForProviderNetworkConfig#additionalNodeNetworkConfigs
   */
  readonly additionalNodeNetworkConfigs?: NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalNodeNetworkConfigs[];

  /**
   * We specify the additional pod networks for this node pool using this list. Each pod network corresponds to an additional alias IP range for the node.
   * Structure is documented below
   *
   * @schema NodePoolV1Beta2SpecForProviderNetworkConfig#additionalPodNetworkConfigs
   */
  readonly additionalPodNetworkConfigs?: NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalPodNetworkConfigs[];

  /**
   * Whether to create a new range for pod IPs in this node pool. Defaults are provided for pod_range and pod_ipv4_cidr_block if they are not specified.
   *
   * @schema NodePoolV1Beta2SpecForProviderNetworkConfig#createPodRange
   */
  readonly createPodRange?: boolean;

  /**
   * Whether nodes have internal IP addresses only.
   *
   * @schema NodePoolV1Beta2SpecForProviderNetworkConfig#enablePrivateNodes
   */
  readonly enablePrivateNodes?: boolean;

  /**
   * Network bandwidth tier configuration. Structure is documented below.
   *
   * @schema NodePoolV1Beta2SpecForProviderNetworkConfig#networkPerformanceConfig
   */
  readonly networkPerformanceConfig?: NodePoolV1Beta2SpecForProviderNetworkConfigNetworkPerformanceConfig;

  /**
   * Configuration for node-pool level pod cidr overprovision. If not set, the cluster level setting will be inherited. Structure is documented below.
   *
   * @schema NodePoolV1Beta2SpecForProviderNetworkConfig#podCidrOverprovisionConfig
   */
  readonly podCidrOverprovisionConfig?: NodePoolV1Beta2SpecForProviderNetworkConfigPodCidrOverprovisionConfig;

  /**
   * The IP address range for pod IPs in this node pool. Only applicable if createPodRange is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) to pick a specific range to use.
   *
   * @schema NodePoolV1Beta2SpecForProviderNetworkConfig#podIpv4CidrBlock
   */
  readonly podIpv4CidrBlock?: string;

  /**
   * The ID of the secondary range for pod IPs. If create_pod_range is true, this ID is used for the new range. If create_pod_range is false, uses an existing secondary range with this ID.
   *
   * @schema NodePoolV1Beta2SpecForProviderNetworkConfig#podRange
   */
  readonly podRange?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNetworkConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNetworkConfig(obj: NodePoolV1Beta2SpecForProviderNetworkConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalNodeNetworkConfigs': obj.additionalNodeNetworkConfigs?.map(y => toJson_NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalNodeNetworkConfigs(y)),
    'additionalPodNetworkConfigs': obj.additionalPodNetworkConfigs?.map(y => toJson_NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalPodNetworkConfigs(y)),
    'createPodRange': obj.createPodRange,
    'enablePrivateNodes': obj.enablePrivateNodes,
    'networkPerformanceConfig': toJson_NodePoolV1Beta2SpecForProviderNetworkConfigNetworkPerformanceConfig(obj.networkPerformanceConfig),
    'podCidrOverprovisionConfig': toJson_NodePoolV1Beta2SpecForProviderNetworkConfigPodCidrOverprovisionConfig(obj.podCidrOverprovisionConfig),
    'podIpv4CidrBlock': obj.podIpv4CidrBlock,
    'podRange': obj.podRange,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters used in creating the node pool. See
 * google_container_cluster for schema.
 *
 * @schema NodePoolV1Beta2SpecForProviderNodeConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfig {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#advancedMachineFeatures
   */
  readonly advancedMachineFeatures?: NodePoolV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#bootDiskKmsKey
   */
  readonly bootDiskKmsKey?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#confidentialNodes
   */
  readonly confidentialNodes?: NodePoolV1Beta2SpecForProviderNodeConfigConfidentialNodes;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#containerdConfig
   */
  readonly containerdConfig?: NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfig;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#diskSizeGb
   */
  readonly diskSizeGb?: number;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#diskType
   */
  readonly diskType?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#enableConfidentialStorage
   */
  readonly enableConfidentialStorage?: boolean;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#ephemeralStorageLocalSsdConfig
   */
  readonly ephemeralStorageLocalSsdConfig?: NodePoolV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#fastSocket
   */
  readonly fastSocket?: NodePoolV1Beta2SpecForProviderNodeConfigFastSocket;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#flexStart
   */
  readonly flexStart?: boolean;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#gcfsConfig
   */
  readonly gcfsConfig?: NodePoolV1Beta2SpecForProviderNodeConfigGcfsConfig;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#guestAccelerator
   */
  readonly guestAccelerator?: NodePoolV1Beta2SpecForProviderNodeConfigGuestAccelerator[];

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#gvnic
   */
  readonly gvnic?: NodePoolV1Beta2SpecForProviderNodeConfigGvnic;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#hostMaintenancePolicy
   */
  readonly hostMaintenancePolicy?: NodePoolV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#imageType
   */
  readonly imageType?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#kubeletConfig
   */
  readonly kubeletConfig?: NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Parameters used in creating the node pool. See
   * google_container_cluster for schema.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#linuxNodeConfig
   */
  readonly linuxNodeConfig?: NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfig;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#localNvmeSsdBlockConfig
   */
  readonly localNvmeSsdBlockConfig?: NodePoolV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#localSsdCount
   */
  readonly localSsdCount?: number;

  /**
   * Possible Local SSD encryption modes:
   * Accepted values are:
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#localSsdEncryptionMode
   */
  readonly localSsdEncryptionMode?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#loggingVariant
   */
  readonly loggingVariant?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#machineType
   */
  readonly machineType?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#maxRunDuration
   */
  readonly maxRunDuration?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#minCpuPlatform
   */
  readonly minCpuPlatform?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#nodeGroup
   */
  readonly nodeGroup?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#oauthScopes
   */
  readonly oauthScopes?: string[];

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#preemptible
   */
  readonly preemptible?: boolean;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#reservationAffinity
   */
  readonly reservationAffinity?: NodePoolV1Beta2SpecForProviderNodeConfigReservationAffinity;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#resourceLabels
   */
  readonly resourceLabels?: { [key: string]: string };

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#secondaryBootDisks
   */
  readonly secondaryBootDisks?: NodePoolV1Beta2SpecForProviderNodeConfigSecondaryBootDisks[];

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#serviceAccountRef
   */
  readonly serviceAccountRef?: NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#serviceAccountSelector
   */
  readonly serviceAccountSelector?: NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelector;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: NodePoolV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#soleTenantConfig
   */
  readonly soleTenantConfig?: NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfig;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#spot
   */
  readonly spot?: boolean;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#storagePools
   */
  readonly storagePools?: string[];

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#tags
   */
  readonly tags?: string[];

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#taint
   */
  readonly taint?: NodePoolV1Beta2SpecForProviderNodeConfigTaint[];

  /**
   * Parameters used in creating the node pool. See
   * google_container_cluster for schema.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#windowsNodeConfig
   */
  readonly windowsNodeConfig?: NodePoolV1Beta2SpecForProviderNodeConfigWindowsNodeConfig;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfig#workloadMetadataConfig
   */
  readonly workloadMetadataConfig?: NodePoolV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedMachineFeatures': toJson_NodePoolV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures(obj.advancedMachineFeatures),
    'bootDiskKmsKey': obj.bootDiskKmsKey,
    'confidentialNodes': toJson_NodePoolV1Beta2SpecForProviderNodeConfigConfidentialNodes(obj.confidentialNodes),
    'containerdConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfig(obj.containerdConfig),
    'diskSizeGb': obj.diskSizeGb,
    'diskType': obj.diskType,
    'enableConfidentialStorage': obj.enableConfidentialStorage,
    'ephemeralStorageLocalSsdConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig(obj.ephemeralStorageLocalSsdConfig),
    'fastSocket': toJson_NodePoolV1Beta2SpecForProviderNodeConfigFastSocket(obj.fastSocket),
    'flexStart': obj.flexStart,
    'gcfsConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfigGcfsConfig(obj.gcfsConfig),
    'guestAccelerator': obj.guestAccelerator?.map(y => toJson_NodePoolV1Beta2SpecForProviderNodeConfigGuestAccelerator(y)),
    'gvnic': toJson_NodePoolV1Beta2SpecForProviderNodeConfigGvnic(obj.gvnic),
    'hostMaintenancePolicy': toJson_NodePoolV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy(obj.hostMaintenancePolicy),
    'imageType': obj.imageType,
    'kubeletConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig(obj.kubeletConfig),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'linuxNodeConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfig(obj.linuxNodeConfig),
    'localNvmeSsdBlockConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig(obj.localNvmeSsdBlockConfig),
    'localSsdCount': obj.localSsdCount,
    'localSsdEncryptionMode': obj.localSsdEncryptionMode,
    'loggingVariant': obj.loggingVariant,
    'machineType': obj.machineType,
    'maxRunDuration': obj.maxRunDuration,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'minCpuPlatform': obj.minCpuPlatform,
    'nodeGroup': obj.nodeGroup,
    'oauthScopes': obj.oauthScopes?.map(y => y),
    'preemptible': obj.preemptible,
    'reservationAffinity': toJson_NodePoolV1Beta2SpecForProviderNodeConfigReservationAffinity(obj.reservationAffinity),
    'resourceLabels': ((obj.resourceLabels) === undefined) ? undefined : (Object.entries(obj.resourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'secondaryBootDisks': obj.secondaryBootDisks?.map(y => toJson_NodePoolV1Beta2SpecForProviderNodeConfigSecondaryBootDisks(y)),
    'serviceAccount': obj.serviceAccount,
    'serviceAccountRef': toJson_NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRef(obj.serviceAccountRef),
    'serviceAccountSelector': toJson_NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelector(obj.serviceAccountSelector),
    'shieldedInstanceConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig(obj.shieldedInstanceConfig),
    'soleTenantConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfig(obj.soleTenantConfig),
    'spot': obj.spot,
    'storagePools': obj.storagePools?.map(y => y),
    'tags': obj.tags?.map(y => y),
    'taint': obj.taint?.map(y => toJson_NodePoolV1Beta2SpecForProviderNodeConfigTaint(y)),
    'windowsNodeConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfigWindowsNodeConfig(obj.windowsNodeConfig),
    'workloadMetadataConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig(obj.workloadMetadataConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies a custom placement policy for the
 * nodes.
 *
 * @schema NodePoolV1Beta2SpecForProviderPlacementPolicy
 */
export interface NodePoolV1Beta2SpecForProviderPlacementPolicy {
  /**
   * If set, refers to the name of a custom resource policy supplied by the user.
   * The resource policy must be in the same project and region as the node pool.
   * If not found, InvalidArgument error is returned.
   *
   * @schema NodePoolV1Beta2SpecForProviderPlacementPolicy#policyName
   */
  readonly policyName?: string;

  /**
   * The TPU topology like "2x4" or "2x2x2".
   *
   * @schema NodePoolV1Beta2SpecForProviderPlacementPolicy#tpuTopology
   */
  readonly tpuTopology?: string;

  /**
   * The type of the policy. Supports a single value: COMPACT.
   * Specifying COMPACT placement policy type places node pool's nodes in a closer
   * physical proximity in order to reduce network latency between nodes.
   *
   * @schema NodePoolV1Beta2SpecForProviderPlacementPolicy#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderPlacementPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderPlacementPolicy(obj: NodePoolV1Beta2SpecForProviderPlacementPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policyName': obj.policyName,
    'tpuTopology': obj.tpuTopology,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies node pool-level settings of queued provisioning.
 * Structure is documented below.
 *
 * @schema NodePoolV1Beta2SpecForProviderQueuedProvisioning
 */
export interface NodePoolV1Beta2SpecForProviderQueuedProvisioning {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolV1Beta2SpecForProviderQueuedProvisioning#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderQueuedProvisioning' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderQueuedProvisioning(obj: NodePoolV1Beta2SpecForProviderQueuedProvisioning | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify node upgrade settings to change how GKE upgrades nodes.
 * The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
 *
 * @schema NodePoolV1Beta2SpecForProviderUpgradeSettings
 */
export interface NodePoolV1Beta2SpecForProviderUpgradeSettings {
  /**
   * The settings to adjust blue green upgrades.
   * Structure is documented below
   *
   * @schema NodePoolV1Beta2SpecForProviderUpgradeSettings#blueGreenSettings
   */
  readonly blueGreenSettings?: NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettings;

  /**
   * The number of additional nodes that can be added to the node pool during
   * an upgrade. Increasing max_surge raises the number of nodes that can be upgraded simultaneously.
   * Can be set to 0 or greater.
   *
   * @schema NodePoolV1Beta2SpecForProviderUpgradeSettings#maxSurge
   */
  readonly maxSurge?: number;

  /**
   * The number of nodes that can be simultaneously unavailable during
   * an upgrade. Increasing max_unavailable raises the number of nodes that can be upgraded in
   * parallel. Can be set to 0 or greater.
   *
   * @schema NodePoolV1Beta2SpecForProviderUpgradeSettings#maxUnavailable
   */
  readonly maxUnavailable?: number;

  /**
   * (Default SURGE) The upgrade strategy to be used for upgrading the nodes.
   *
   * @schema NodePoolV1Beta2SpecForProviderUpgradeSettings#strategy
   */
  readonly strategy?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderUpgradeSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderUpgradeSettings(obj: NodePoolV1Beta2SpecForProviderUpgradeSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blueGreenSettings': toJson_NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettings(obj.blueGreenSettings),
    'maxSurge': obj.maxSurge,
    'maxUnavailable': obj.maxUnavailable,
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration required by cluster autoscaler to adjust
 * the size of the node pool to the current cluster usage. Structure is documented below.
 *
 * @schema NodePoolV1Beta2SpecInitProviderAutoscaling
 */
export interface NodePoolV1Beta2SpecInitProviderAutoscaling {
  /**
   * Location policy specifies the algorithm used when
   * scaling-up the node pool. Location policy is supported only in 1.24.1+ clusters.
   *
   * @schema NodePoolV1Beta2SpecInitProviderAutoscaling#locationPolicy
   */
  readonly locationPolicy?: string;

  /**
   * Maximum number of nodes per zone in the NodePool.
   * Must be >= min_node_count. Cannot be used with total limits.
   *
   * @schema NodePoolV1Beta2SpecInitProviderAutoscaling#maxNodeCount
   */
  readonly maxNodeCount?: number;

  /**
   * Minimum number of nodes per zone in the NodePool.
   * Must be >=0 and <= max_node_count. Cannot be used with total limits.
   *
   * @schema NodePoolV1Beta2SpecInitProviderAutoscaling#minNodeCount
   */
  readonly minNodeCount?: number;

  /**
   * Total maximum number of nodes in the NodePool.
   * Must be >= total_min_node_count. Cannot be used with per zone limits.
   * Total size limits are supported only in 1.24.1+ clusters.
   *
   * @schema NodePoolV1Beta2SpecInitProviderAutoscaling#totalMaxNodeCount
   */
  readonly totalMaxNodeCount?: number;

  /**
   * Total minimum number of nodes in the NodePool.
   * Must be >=0 and <= total_max_node_count. Cannot be used with per zone limits.
   * Total size limits are supported only in 1.24.1+ clusters.
   *
   * @schema NodePoolV1Beta2SpecInitProviderAutoscaling#totalMinNodeCount
   */
  readonly totalMinNodeCount?: number;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderAutoscaling(obj: NodePoolV1Beta2SpecInitProviderAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'locationPolicy': obj.locationPolicy,
    'maxNodeCount': obj.maxNodeCount,
    'minNodeCount': obj.minNodeCount,
    'totalMaxNodeCount': obj.totalMaxNodeCount,
    'totalMinNodeCount': obj.totalMinNodeCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Node management configuration, wherein auto-repair and
 * auto-upgrade is configured. Structure is documented below.
 *
 * @schema NodePoolV1Beta2SpecInitProviderManagement
 */
export interface NodePoolV1Beta2SpecInitProviderManagement {
  /**
   * Whether the nodes will be automatically repaired. Enabled by default.
   *
   * @schema NodePoolV1Beta2SpecInitProviderManagement#autoRepair
   */
  readonly autoRepair?: boolean;

  /**
   * Whether the nodes will be automatically upgraded. Enabled by default.
   *
   * @schema NodePoolV1Beta2SpecInitProviderManagement#autoUpgrade
   */
  readonly autoUpgrade?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderManagement' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderManagement(obj: NodePoolV1Beta2SpecInitProviderManagement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoRepair': obj.autoRepair,
    'autoUpgrade': obj.autoUpgrade,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The network configuration of the pool. Such as
 * configuration for Adding Pod IP address ranges) to the node pool. Or enabling private nodes. Structure is
 * documented below
 *
 * @schema NodePoolV1Beta2SpecInitProviderNetworkConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNetworkConfig {
  /**
   * We specify the additional node networks for this node pool using this list. Each node network corresponds to an additional interface.
   * Structure is documented below
   *
   * @schema NodePoolV1Beta2SpecInitProviderNetworkConfig#additionalNodeNetworkConfigs
   */
  readonly additionalNodeNetworkConfigs?: NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs[];

  /**
   * We specify the additional pod networks for this node pool using this list. Each pod network corresponds to an additional alias IP range for the node.
   * Structure is documented below
   *
   * @schema NodePoolV1Beta2SpecInitProviderNetworkConfig#additionalPodNetworkConfigs
   */
  readonly additionalPodNetworkConfigs?: NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalPodNetworkConfigs[];

  /**
   * Whether to create a new range for pod IPs in this node pool. Defaults are provided for pod_range and pod_ipv4_cidr_block if they are not specified.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNetworkConfig#createPodRange
   */
  readonly createPodRange?: boolean;

  /**
   * Whether nodes have internal IP addresses only.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNetworkConfig#enablePrivateNodes
   */
  readonly enablePrivateNodes?: boolean;

  /**
   * Network bandwidth tier configuration. Structure is documented below.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNetworkConfig#networkPerformanceConfig
   */
  readonly networkPerformanceConfig?: NodePoolV1Beta2SpecInitProviderNetworkConfigNetworkPerformanceConfig;

  /**
   * Configuration for node-pool level pod cidr overprovision. If not set, the cluster level setting will be inherited. Structure is documented below.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNetworkConfig#podCidrOverprovisionConfig
   */
  readonly podCidrOverprovisionConfig?: NodePoolV1Beta2SpecInitProviderNetworkConfigPodCidrOverprovisionConfig;

  /**
   * The IP address range for pod IPs in this node pool. Only applicable if createPodRange is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) to pick a specific range to use.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNetworkConfig#podIpv4CidrBlock
   */
  readonly podIpv4CidrBlock?: string;

  /**
   * The ID of the secondary range for pod IPs. If create_pod_range is true, this ID is used for the new range. If create_pod_range is false, uses an existing secondary range with this ID.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNetworkConfig#podRange
   */
  readonly podRange?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNetworkConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNetworkConfig(obj: NodePoolV1Beta2SpecInitProviderNetworkConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalNodeNetworkConfigs': obj.additionalNodeNetworkConfigs?.map(y => toJson_NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs(y)),
    'additionalPodNetworkConfigs': obj.additionalPodNetworkConfigs?.map(y => toJson_NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalPodNetworkConfigs(y)),
    'createPodRange': obj.createPodRange,
    'enablePrivateNodes': obj.enablePrivateNodes,
    'networkPerformanceConfig': toJson_NodePoolV1Beta2SpecInitProviderNetworkConfigNetworkPerformanceConfig(obj.networkPerformanceConfig),
    'podCidrOverprovisionConfig': toJson_NodePoolV1Beta2SpecInitProviderNetworkConfigPodCidrOverprovisionConfig(obj.podCidrOverprovisionConfig),
    'podIpv4CidrBlock': obj.podIpv4CidrBlock,
    'podRange': obj.podRange,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters used in creating the node pool. See
 * google_container_cluster for schema.
 *
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfig {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#advancedMachineFeatures
   */
  readonly advancedMachineFeatures?: NodePoolV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#bootDiskKmsKey
   */
  readonly bootDiskKmsKey?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#confidentialNodes
   */
  readonly confidentialNodes?: NodePoolV1Beta2SpecInitProviderNodeConfigConfidentialNodes;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#containerdConfig
   */
  readonly containerdConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfig;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#diskSizeGb
   */
  readonly diskSizeGb?: number;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#diskType
   */
  readonly diskType?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#enableConfidentialStorage
   */
  readonly enableConfidentialStorage?: boolean;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#ephemeralStorageLocalSsdConfig
   */
  readonly ephemeralStorageLocalSsdConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#fastSocket
   */
  readonly fastSocket?: NodePoolV1Beta2SpecInitProviderNodeConfigFastSocket;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#flexStart
   */
  readonly flexStart?: boolean;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#gcfsConfig
   */
  readonly gcfsConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigGcfsConfig;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#guestAccelerator
   */
  readonly guestAccelerator?: NodePoolV1Beta2SpecInitProviderNodeConfigGuestAccelerator[];

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#gvnic
   */
  readonly gvnic?: NodePoolV1Beta2SpecInitProviderNodeConfigGvnic;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#hostMaintenancePolicy
   */
  readonly hostMaintenancePolicy?: NodePoolV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#imageType
   */
  readonly imageType?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#kubeletConfig
   */
  readonly kubeletConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Parameters used in creating the node pool. See
   * google_container_cluster for schema.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#linuxNodeConfig
   */
  readonly linuxNodeConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#localNvmeSsdBlockConfig
   */
  readonly localNvmeSsdBlockConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#localSsdCount
   */
  readonly localSsdCount?: number;

  /**
   * Possible Local SSD encryption modes:
   * Accepted values are:
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#localSsdEncryptionMode
   */
  readonly localSsdEncryptionMode?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#loggingVariant
   */
  readonly loggingVariant?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#machineType
   */
  readonly machineType?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#maxRunDuration
   */
  readonly maxRunDuration?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#minCpuPlatform
   */
  readonly minCpuPlatform?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#nodeGroup
   */
  readonly nodeGroup?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#oauthScopes
   */
  readonly oauthScopes?: string[];

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#preemptible
   */
  readonly preemptible?: boolean;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#reservationAffinity
   */
  readonly reservationAffinity?: NodePoolV1Beta2SpecInitProviderNodeConfigReservationAffinity;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#resourceLabels
   */
  readonly resourceLabels?: { [key: string]: string };

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#resourceManagerTags
   */
  readonly resourceManagerTags?: { [key: string]: string };

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#secondaryBootDisks
   */
  readonly secondaryBootDisks?: NodePoolV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks[];

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#serviceAccountRef
   */
  readonly serviceAccountRef?: NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#serviceAccountSelector
   */
  readonly serviceAccountSelector?: NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelector;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#soleTenantConfig
   */
  readonly soleTenantConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfig;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#spot
   */
  readonly spot?: boolean;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#storagePools
   */
  readonly storagePools?: string[];

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#tags
   */
  readonly tags?: string[];

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#taint
   */
  readonly taint?: NodePoolV1Beta2SpecInitProviderNodeConfigTaint[];

  /**
   * Parameters used in creating the node pool. See
   * google_container_cluster for schema.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#windowsNodeConfig
   */
  readonly windowsNodeConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfig#workloadMetadataConfig
   */
  readonly workloadMetadataConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedMachineFeatures': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures(obj.advancedMachineFeatures),
    'bootDiskKmsKey': obj.bootDiskKmsKey,
    'confidentialNodes': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigConfidentialNodes(obj.confidentialNodes),
    'containerdConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfig(obj.containerdConfig),
    'diskSizeGb': obj.diskSizeGb,
    'diskType': obj.diskType,
    'enableConfidentialStorage': obj.enableConfidentialStorage,
    'ephemeralStorageLocalSsdConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig(obj.ephemeralStorageLocalSsdConfig),
    'fastSocket': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigFastSocket(obj.fastSocket),
    'flexStart': obj.flexStart,
    'gcfsConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigGcfsConfig(obj.gcfsConfig),
    'guestAccelerator': obj.guestAccelerator?.map(y => toJson_NodePoolV1Beta2SpecInitProviderNodeConfigGuestAccelerator(y)),
    'gvnic': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigGvnic(obj.gvnic),
    'hostMaintenancePolicy': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy(obj.hostMaintenancePolicy),
    'imageType': obj.imageType,
    'kubeletConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig(obj.kubeletConfig),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'linuxNodeConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig(obj.linuxNodeConfig),
    'localNvmeSsdBlockConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig(obj.localNvmeSsdBlockConfig),
    'localSsdCount': obj.localSsdCount,
    'localSsdEncryptionMode': obj.localSsdEncryptionMode,
    'loggingVariant': obj.loggingVariant,
    'machineType': obj.machineType,
    'maxRunDuration': obj.maxRunDuration,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'minCpuPlatform': obj.minCpuPlatform,
    'nodeGroup': obj.nodeGroup,
    'oauthScopes': obj.oauthScopes?.map(y => y),
    'preemptible': obj.preemptible,
    'reservationAffinity': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigReservationAffinity(obj.reservationAffinity),
    'resourceLabels': ((obj.resourceLabels) === undefined) ? undefined : (Object.entries(obj.resourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceManagerTags': ((obj.resourceManagerTags) === undefined) ? undefined : (Object.entries(obj.resourceManagerTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'secondaryBootDisks': obj.secondaryBootDisks?.map(y => toJson_NodePoolV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks(y)),
    'serviceAccount': obj.serviceAccount,
    'serviceAccountRef': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRef(obj.serviceAccountRef),
    'serviceAccountSelector': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelector(obj.serviceAccountSelector),
    'shieldedInstanceConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig(obj.shieldedInstanceConfig),
    'soleTenantConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfig(obj.soleTenantConfig),
    'spot': obj.spot,
    'storagePools': obj.storagePools?.map(y => y),
    'tags': obj.tags?.map(y => y),
    'taint': obj.taint?.map(y => toJson_NodePoolV1Beta2SpecInitProviderNodeConfigTaint(y)),
    'windowsNodeConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig(obj.windowsNodeConfig),
    'workloadMetadataConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig(obj.workloadMetadataConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies a custom placement policy for the
 * nodes.
 *
 * @schema NodePoolV1Beta2SpecInitProviderPlacementPolicy
 */
export interface NodePoolV1Beta2SpecInitProviderPlacementPolicy {
  /**
   * If set, refers to the name of a custom resource policy supplied by the user.
   * The resource policy must be in the same project and region as the node pool.
   * If not found, InvalidArgument error is returned.
   *
   * @schema NodePoolV1Beta2SpecInitProviderPlacementPolicy#policyName
   */
  readonly policyName?: string;

  /**
   * The TPU topology like "2x4" or "2x2x2".
   *
   * @schema NodePoolV1Beta2SpecInitProviderPlacementPolicy#tpuTopology
   */
  readonly tpuTopology?: string;

  /**
   * The type of the policy. Supports a single value: COMPACT.
   * Specifying COMPACT placement policy type places node pool's nodes in a closer
   * physical proximity in order to reduce network latency between nodes.
   *
   * @schema NodePoolV1Beta2SpecInitProviderPlacementPolicy#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderPlacementPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderPlacementPolicy(obj: NodePoolV1Beta2SpecInitProviderPlacementPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policyName': obj.policyName,
    'tpuTopology': obj.tpuTopology,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies node pool-level settings of queued provisioning.
 * Structure is documented below.
 *
 * @schema NodePoolV1Beta2SpecInitProviderQueuedProvisioning
 */
export interface NodePoolV1Beta2SpecInitProviderQueuedProvisioning {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolV1Beta2SpecInitProviderQueuedProvisioning#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderQueuedProvisioning' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderQueuedProvisioning(obj: NodePoolV1Beta2SpecInitProviderQueuedProvisioning | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify node upgrade settings to change how GKE upgrades nodes.
 * The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.
 *
 * @schema NodePoolV1Beta2SpecInitProviderUpgradeSettings
 */
export interface NodePoolV1Beta2SpecInitProviderUpgradeSettings {
  /**
   * The settings to adjust blue green upgrades.
   * Structure is documented below
   *
   * @schema NodePoolV1Beta2SpecInitProviderUpgradeSettings#blueGreenSettings
   */
  readonly blueGreenSettings?: NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettings;

  /**
   * The number of additional nodes that can be added to the node pool during
   * an upgrade. Increasing max_surge raises the number of nodes that can be upgraded simultaneously.
   * Can be set to 0 or greater.
   *
   * @schema NodePoolV1Beta2SpecInitProviderUpgradeSettings#maxSurge
   */
  readonly maxSurge?: number;

  /**
   * The number of nodes that can be simultaneously unavailable during
   * an upgrade. Increasing max_unavailable raises the number of nodes that can be upgraded in
   * parallel. Can be set to 0 or greater.
   *
   * @schema NodePoolV1Beta2SpecInitProviderUpgradeSettings#maxUnavailable
   */
  readonly maxUnavailable?: number;

  /**
   * (Default SURGE) The upgrade strategy to be used for upgrading the nodes.
   *
   * @schema NodePoolV1Beta2SpecInitProviderUpgradeSettings#strategy
   */
  readonly strategy?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderUpgradeSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderUpgradeSettings(obj: NodePoolV1Beta2SpecInitProviderUpgradeSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blueGreenSettings': toJson_NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettings(obj.blueGreenSettings),
    'maxSurge': obj.maxSurge,
    'maxUnavailable': obj.maxUnavailable,
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodePoolV1Beta2SpecProviderConfigRefPolicy
 */
export interface NodePoolV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema NodePoolV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NodePoolV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema NodePoolV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NodePoolV1Beta2SpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecProviderConfigRefPolicy(obj: NodePoolV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodePoolV1Beta2SpecForProviderClusterRefPolicy
 */
export interface NodePoolV1Beta2SpecForProviderClusterRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema NodePoolV1Beta2SpecForProviderClusterRefPolicy#resolution
   */
  readonly resolution?: NodePoolV1Beta2SpecForProviderClusterRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema NodePoolV1Beta2SpecForProviderClusterRefPolicy#resolve
   */
  readonly resolve?: NodePoolV1Beta2SpecForProviderClusterRefPolicyResolve;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderClusterRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderClusterRefPolicy(obj: NodePoolV1Beta2SpecForProviderClusterRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema NodePoolV1Beta2SpecForProviderClusterSelectorPolicy
 */
export interface NodePoolV1Beta2SpecForProviderClusterSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema NodePoolV1Beta2SpecForProviderClusterSelectorPolicy#resolution
   */
  readonly resolution?: NodePoolV1Beta2SpecForProviderClusterSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema NodePoolV1Beta2SpecForProviderClusterSelectorPolicy#resolve
   */
  readonly resolve?: NodePoolV1Beta2SpecForProviderClusterSelectorPolicyResolve;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderClusterSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderClusterSelectorPolicy(obj: NodePoolV1Beta2SpecForProviderClusterSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalNodeNetworkConfigs
 */
export interface NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalNodeNetworkConfigs {
  /**
   * Name of the VPC where the additional interface belongs.
   *
   * @schema NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalNodeNetworkConfigs#network
   */
  readonly network?: string;

  /**
   * The subnetwork path for the node pool. Format: projects/{project}/regions/{region}/subnetworks/{subnetwork}. If the cluster is associated with multiple subnetworks, the subnetwork for the node pool is picked based on the IP utilization during node pool creation and is immutable
   *
   * @schema NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalNodeNetworkConfigs#subnetwork
   */
  readonly subnetwork?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalNodeNetworkConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalNodeNetworkConfigs(obj: NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalNodeNetworkConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'network': obj.network,
    'subnetwork': obj.subnetwork,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalPodNetworkConfigs
 */
export interface NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalPodNetworkConfigs {
  /**
   * The maximum number of pods per node in this node pool.
   * Note that this does not work on node pools which are "route-based" - that is, node
   * pools belonging to clusters that do not have IP Aliasing enabled.
   * See the official documentation
   * for more information.
   *
   * @schema NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalPodNetworkConfigs#maxPodsPerNode
   */
  readonly maxPodsPerNode?: number;

  /**
   * The name of the secondary range on the subnet which provides IP address for this pod range.
   *
   * @schema NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalPodNetworkConfigs#secondaryPodRange
   */
  readonly secondaryPodRange?: string;

  /**
   * The subnetwork path for the node pool. Format: projects/{project}/regions/{region}/subnetworks/{subnetwork}. If the cluster is associated with multiple subnetworks, the subnetwork for the node pool is picked based on the IP utilization during node pool creation and is immutable
   *
   * @schema NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalPodNetworkConfigs#subnetwork
   */
  readonly subnetwork?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalPodNetworkConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalPodNetworkConfigs(obj: NodePoolV1Beta2SpecForProviderNetworkConfigAdditionalPodNetworkConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxPodsPerNode': obj.maxPodsPerNode,
    'secondaryPodRange': obj.secondaryPodRange,
    'subnetwork': obj.subnetwork,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Network bandwidth tier configuration. Structure is documented below.
 *
 * @schema NodePoolV1Beta2SpecForProviderNetworkConfigNetworkPerformanceConfig
 */
export interface NodePoolV1Beta2SpecForProviderNetworkConfigNetworkPerformanceConfig {
  /**
   * Specifies the total network bandwidth tier for the NodePool. Valid values include: "TIER_1" and "TIER_UNSPECIFIED".
   *
   * @schema NodePoolV1Beta2SpecForProviderNetworkConfigNetworkPerformanceConfig#totalEgressBandwidthTier
   */
  readonly totalEgressBandwidthTier?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNetworkConfigNetworkPerformanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNetworkConfigNetworkPerformanceConfig(obj: NodePoolV1Beta2SpecForProviderNetworkConfigNetworkPerformanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'totalEgressBandwidthTier': obj.totalEgressBandwidthTier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for node-pool level pod cidr overprovision. If not set, the cluster level setting will be inherited. Structure is documented below.
 *
 * @schema NodePoolV1Beta2SpecForProviderNetworkConfigPodCidrOverprovisionConfig
 */
export interface NodePoolV1Beta2SpecForProviderNetworkConfigPodCidrOverprovisionConfig {
  /**
   * Whether pod cidr overprovision is disabled.
   *
   * @schema NodePoolV1Beta2SpecForProviderNetworkConfigPodCidrOverprovisionConfig#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNetworkConfigPodCidrOverprovisionConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNetworkConfigPodCidrOverprovisionConfig(obj: NodePoolV1Beta2SpecForProviderNetworkConfigPodCidrOverprovisionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures#enableNestedVirtualization
   */
  readonly enableNestedVirtualization?: boolean;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures#performanceMonitoringUnit
   */
  readonly performanceMonitoringUnit?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures#threadsPerCore
   */
  readonly threadsPerCore?: number;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures(obj: NodePoolV1Beta2SpecForProviderNodeConfigAdvancedMachineFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableNestedVirtualization': obj.enableNestedVirtualization,
    'performanceMonitoringUnit': obj.performanceMonitoringUnit,
    'threadsPerCore': obj.threadsPerCore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigConfidentialNodes
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigConfidentialNodes {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigConfidentialNodes#confidentialInstanceType
   */
  readonly confidentialInstanceType?: string;

  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigConfidentialNodes#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigConfidentialNodes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigConfidentialNodes(obj: NodePoolV1Beta2SpecForProviderNodeConfigConfidentialNodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confidentialInstanceType': obj.confidentialInstanceType,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfig {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfig#privateRegistryAccessConfig
   */
  readonly privateRegistryAccessConfig?: NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateRegistryAccessConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(obj.privateRegistryAccessConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig#dataCacheCount
   */
  readonly dataCacheCount?: number;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigEphemeralStorageLocalSsdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataCacheCount': obj.dataCacheCount,
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigFastSocket
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigFastSocket {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigFastSocket#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigFastSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigFastSocket(obj: NodePoolV1Beta2SpecForProviderNodeConfigFastSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigGcfsConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigGcfsConfig {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigGcfsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigGcfsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigGcfsConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigGcfsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigGuestAccelerator
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigGuestAccelerator {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigGuestAccelerator#count
   */
  readonly count?: number;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigGuestAccelerator#gpuDriverInstallationConfig
   */
  readonly gpuDriverInstallationConfig?: NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigGuestAccelerator#gpuPartitionSize
   */
  readonly gpuPartitionSize?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigGuestAccelerator#gpuSharingConfig
   */
  readonly gpuSharingConfig?: NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig;

  /**
   * The type of the policy. Supports a single value: COMPACT.
   * Specifying COMPACT placement policy type places node pool's nodes in a closer
   * physical proximity in order to reduce network latency between nodes.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigGuestAccelerator#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigGuestAccelerator' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigGuestAccelerator(obj: NodePoolV1Beta2SpecForProviderNodeConfigGuestAccelerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'gpuDriverInstallationConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(obj.gpuDriverInstallationConfig),
    'gpuPartitionSize': obj.gpuPartitionSize,
    'gpuSharingConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig(obj.gpuSharingConfig),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigGvnic
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigGvnic {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigGvnic#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigGvnic' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigGvnic(obj: NodePoolV1Beta2SpecForProviderNodeConfigGvnic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy#maintenanceInterval
   */
  readonly maintenanceInterval?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy(obj: NodePoolV1Beta2SpecForProviderNodeConfigHostMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maintenanceInterval': obj.maintenanceInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig#allowedUnsafeSysctls
   */
  readonly allowedUnsafeSysctls?: string[];

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig#containerLogMaxFiles
   */
  readonly containerLogMaxFiles?: number;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig#containerLogMaxSize
   */
  readonly containerLogMaxSize?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig#cpuCfsQuota
   */
  readonly cpuCfsQuota?: boolean;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig#cpuCfsQuotaPeriod
   */
  readonly cpuCfsQuotaPeriod?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig#cpuManagerPolicy
   */
  readonly cpuManagerPolicy?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig#imageGcHighThresholdPercent
   */
  readonly imageGcHighThresholdPercent?: number;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig#imageGcLowThresholdPercent
   */
  readonly imageGcLowThresholdPercent?: number;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig#imageMaximumGcAge
   */
  readonly imageMaximumGcAge?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig#imageMinimumGcAge
   */
  readonly imageMinimumGcAge?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig#podPidsLimit
   */
  readonly podPidsLimit?: number;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigKubeletConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedUnsafeSysctls': obj.allowedUnsafeSysctls?.map(y => y),
    'containerLogMaxFiles': obj.containerLogMaxFiles,
    'containerLogMaxSize': obj.containerLogMaxSize,
    'cpuCfsQuota': obj.cpuCfsQuota,
    'cpuCfsQuotaPeriod': obj.cpuCfsQuotaPeriod,
    'cpuManagerPolicy': obj.cpuManagerPolicy,
    'imageGcHighThresholdPercent': obj.imageGcHighThresholdPercent,
    'imageGcLowThresholdPercent': obj.imageGcLowThresholdPercent,
    'imageMaximumGcAge': obj.imageMaximumGcAge,
    'imageMinimumGcAge': obj.imageMinimumGcAge,
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
    'podPidsLimit': obj.podPidsLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters used in creating the node pool. See
 * google_container_cluster for schema.
 *
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfig {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfig#cgroupMode
   */
  readonly cgroupMode?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfig#hugepagesConfig
   */
  readonly hugepagesConfig?: NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfig#sysctls
   */
  readonly sysctls?: { [key: string]: string };
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cgroupMode': obj.cgroupMode,
    'hugepagesConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig(obj.hugepagesConfig),
    'sysctls': ((obj.sysctls) === undefined) ? undefined : (Object.entries(obj.sysctls).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigLocalNvmeSsdBlockConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigReservationAffinity
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigReservationAffinity {
  /**
   * The type of reservation consumption
   * Accepted values are:
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigReservationAffinity#consumeReservationType
   */
  readonly consumeReservationType?: string;

  /**
   * name" as the key and specify the name of your reservation as its value.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigReservationAffinity#key
   */
  readonly key?: string;

  /**
   * name"
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigReservationAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigReservationAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigReservationAffinity(obj: NodePoolV1Beta2SpecForProviderNodeConfigReservationAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumeReservationType': obj.consumeReservationType,
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigSecondaryBootDisks
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigSecondaryBootDisks {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigSecondaryBootDisks#diskImage
   */
  readonly diskImage?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigSecondaryBootDisks#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigSecondaryBootDisks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigSecondaryBootDisks(obj: NodePoolV1Beta2SpecForProviderNodeConfigSecondaryBootDisks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'diskImage': obj.diskImage,
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRef
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRef#policy
   */
  readonly policy?: NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRef(obj: NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelector
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelector#policy
   */
  readonly policy?: NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelector(obj: NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfig {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfig#nodeAffinity
   */
  readonly nodeAffinity?: NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity[];
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': obj.nodeAffinity?.map(y => toJson_NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigTaint
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigTaint {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigTaint#effect
   */
  readonly effect?: string;

  /**
   * name" as the key and specify the name of your reservation as its value.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigTaint#key
   */
  readonly key?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigTaint#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigTaint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigTaint(obj: NodePoolV1Beta2SpecForProviderNodeConfigTaint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters used in creating the node pool. See
 * google_container_cluster for schema.
 *
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigWindowsNodeConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigWindowsNodeConfig {
  /**
   * The Kubernetes version for the nodes in this pool. Note that if this field
   * and auto_upgrade are both specified, they will fight each other for what the node version should
   * be, so setting both is highly discouraged.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigWindowsNodeConfig#osversion
   */
  readonly osversion?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigWindowsNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigWindowsNodeConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigWindowsNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'osversion': obj.osversion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigWorkloadMetadataConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The settings to adjust blue green upgrades.
 * Structure is documented below
 *
 * @schema NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettings
 */
export interface NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettings {
  /**
   * Time needed after draining the entire blue pool.
   * After this period, the blue pool will be cleaned up.
   *
   * @schema NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettings#nodePoolSoakDuration
   */
  readonly nodePoolSoakDuration?: string;

  /**
   * Specifies the standard policy settings for blue-green upgrades.
   *
   * @schema NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettings#standardRolloutPolicy
   */
  readonly standardRolloutPolicy?: NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettings(obj: NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodePoolSoakDuration': obj.nodePoolSoakDuration,
    'standardRolloutPolicy': toJson_NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(obj.standardRolloutPolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs
 */
export interface NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs {
  /**
   * Name of the VPC where the additional interface belongs.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs#network
   */
  readonly network?: string;

  /**
   * The subnetwork path for the node pool. Format: projects/{project}/regions/{region}/subnetworks/{subnetwork}. If the cluster is associated with multiple subnetworks, the subnetwork for the node pool is picked based on the IP utilization during node pool creation and is immutable
   *
   * @schema NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs#subnetwork
   */
  readonly subnetwork?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs(obj: NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalNodeNetworkConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'network': obj.network,
    'subnetwork': obj.subnetwork,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalPodNetworkConfigs
 */
export interface NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalPodNetworkConfigs {
  /**
   * The maximum number of pods per node in this node pool.
   * Note that this does not work on node pools which are "route-based" - that is, node
   * pools belonging to clusters that do not have IP Aliasing enabled.
   * See the official documentation
   * for more information.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalPodNetworkConfigs#maxPodsPerNode
   */
  readonly maxPodsPerNode?: number;

  /**
   * The name of the secondary range on the subnet which provides IP address for this pod range.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalPodNetworkConfigs#secondaryPodRange
   */
  readonly secondaryPodRange?: string;

  /**
   * The subnetwork path for the node pool. Format: projects/{project}/regions/{region}/subnetworks/{subnetwork}. If the cluster is associated with multiple subnetworks, the subnetwork for the node pool is picked based on the IP utilization during node pool creation and is immutable
   *
   * @schema NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalPodNetworkConfigs#subnetwork
   */
  readonly subnetwork?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalPodNetworkConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalPodNetworkConfigs(obj: NodePoolV1Beta2SpecInitProviderNetworkConfigAdditionalPodNetworkConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxPodsPerNode': obj.maxPodsPerNode,
    'secondaryPodRange': obj.secondaryPodRange,
    'subnetwork': obj.subnetwork,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Network bandwidth tier configuration. Structure is documented below.
 *
 * @schema NodePoolV1Beta2SpecInitProviderNetworkConfigNetworkPerformanceConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNetworkConfigNetworkPerformanceConfig {
  /**
   * Specifies the total network bandwidth tier for the NodePool. Valid values include: "TIER_1" and "TIER_UNSPECIFIED".
   *
   * @schema NodePoolV1Beta2SpecInitProviderNetworkConfigNetworkPerformanceConfig#totalEgressBandwidthTier
   */
  readonly totalEgressBandwidthTier?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNetworkConfigNetworkPerformanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNetworkConfigNetworkPerformanceConfig(obj: NodePoolV1Beta2SpecInitProviderNetworkConfigNetworkPerformanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'totalEgressBandwidthTier': obj.totalEgressBandwidthTier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration for node-pool level pod cidr overprovision. If not set, the cluster level setting will be inherited. Structure is documented below.
 *
 * @schema NodePoolV1Beta2SpecInitProviderNetworkConfigPodCidrOverprovisionConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNetworkConfigPodCidrOverprovisionConfig {
  /**
   * Whether pod cidr overprovision is disabled.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNetworkConfigPodCidrOverprovisionConfig#disabled
   */
  readonly disabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNetworkConfigPodCidrOverprovisionConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNetworkConfigPodCidrOverprovisionConfig(obj: NodePoolV1Beta2SpecInitProviderNetworkConfigPodCidrOverprovisionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures#enableNestedVirtualization
   */
  readonly enableNestedVirtualization?: boolean;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures#performanceMonitoringUnit
   */
  readonly performanceMonitoringUnit?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures#threadsPerCore
   */
  readonly threadsPerCore?: number;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures(obj: NodePoolV1Beta2SpecInitProviderNodeConfigAdvancedMachineFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableNestedVirtualization': obj.enableNestedVirtualization,
    'performanceMonitoringUnit': obj.performanceMonitoringUnit,
    'threadsPerCore': obj.threadsPerCore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigConfidentialNodes
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigConfidentialNodes {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigConfidentialNodes#confidentialInstanceType
   */
  readonly confidentialInstanceType?: string;

  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigConfidentialNodes#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigConfidentialNodes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigConfidentialNodes(obj: NodePoolV1Beta2SpecInitProviderNodeConfigConfidentialNodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confidentialInstanceType': obj.confidentialInstanceType,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfig {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfig#privateRegistryAccessConfig
   */
  readonly privateRegistryAccessConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'privateRegistryAccessConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(obj.privateRegistryAccessConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig#dataCacheCount
   */
  readonly dataCacheCount?: number;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigEphemeralStorageLocalSsdConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataCacheCount': obj.dataCacheCount,
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigFastSocket
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigFastSocket {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigFastSocket#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigFastSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigFastSocket(obj: NodePoolV1Beta2SpecInitProviderNodeConfigFastSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigGcfsConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigGcfsConfig {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigGcfsConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigGcfsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigGcfsConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigGcfsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigGuestAccelerator
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigGuestAccelerator {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigGuestAccelerator#count
   */
  readonly count?: number;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigGuestAccelerator#gpuDriverInstallationConfig
   */
  readonly gpuDriverInstallationConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigGuestAccelerator#gpuPartitionSize
   */
  readonly gpuPartitionSize?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigGuestAccelerator#gpuSharingConfig
   */
  readonly gpuSharingConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig;

  /**
   * The type of the policy. Supports a single value: COMPACT.
   * Specifying COMPACT placement policy type places node pool's nodes in a closer
   * physical proximity in order to reduce network latency between nodes.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigGuestAccelerator#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigGuestAccelerator' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigGuestAccelerator(obj: NodePoolV1Beta2SpecInitProviderNodeConfigGuestAccelerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'gpuDriverInstallationConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(obj.gpuDriverInstallationConfig),
    'gpuPartitionSize': obj.gpuPartitionSize,
    'gpuSharingConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig(obj.gpuSharingConfig),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigGvnic
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigGvnic {
  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigGvnic#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigGvnic' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigGvnic(obj: NodePoolV1Beta2SpecInitProviderNodeConfigGvnic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy#maintenanceInterval
   */
  readonly maintenanceInterval?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy(obj: NodePoolV1Beta2SpecInitProviderNodeConfigHostMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maintenanceInterval': obj.maintenanceInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig#allowedUnsafeSysctls
   */
  readonly allowedUnsafeSysctls?: string[];

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig#containerLogMaxFiles
   */
  readonly containerLogMaxFiles?: number;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig#containerLogMaxSize
   */
  readonly containerLogMaxSize?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig#cpuCfsQuota
   */
  readonly cpuCfsQuota?: boolean;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig#cpuCfsQuotaPeriod
   */
  readonly cpuCfsQuotaPeriod?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig#cpuManagerPolicy
   */
  readonly cpuManagerPolicy?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig#imageGcHighThresholdPercent
   */
  readonly imageGcHighThresholdPercent?: number;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig#imageGcLowThresholdPercent
   */
  readonly imageGcLowThresholdPercent?: number;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig#imageMaximumGcAge
   */
  readonly imageMaximumGcAge?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig#imageMinimumGcAge
   */
  readonly imageMinimumGcAge?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig#insecureKubeletReadonlyPortEnabled
   */
  readonly insecureKubeletReadonlyPortEnabled?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig#podPidsLimit
   */
  readonly podPidsLimit?: number;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigKubeletConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedUnsafeSysctls': obj.allowedUnsafeSysctls?.map(y => y),
    'containerLogMaxFiles': obj.containerLogMaxFiles,
    'containerLogMaxSize': obj.containerLogMaxSize,
    'cpuCfsQuota': obj.cpuCfsQuota,
    'cpuCfsQuotaPeriod': obj.cpuCfsQuotaPeriod,
    'cpuManagerPolicy': obj.cpuManagerPolicy,
    'imageGcHighThresholdPercent': obj.imageGcHighThresholdPercent,
    'imageGcLowThresholdPercent': obj.imageGcLowThresholdPercent,
    'imageMaximumGcAge': obj.imageMaximumGcAge,
    'imageMinimumGcAge': obj.imageMinimumGcAge,
    'insecureKubeletReadonlyPortEnabled': obj.insecureKubeletReadonlyPortEnabled,
    'podPidsLimit': obj.podPidsLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters used in creating the node pool. See
 * google_container_cluster for schema.
 *
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig#cgroupMode
   */
  readonly cgroupMode?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig#hugepagesConfig
   */
  readonly hugepagesConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig#sysctls
   */
  readonly sysctls?: { [key: string]: string };
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cgroupMode': obj.cgroupMode,
    'hugepagesConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig(obj.hugepagesConfig),
    'sysctls': ((obj.sysctls) === undefined) ? undefined : (Object.entries(obj.sysctls).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig#localSsdCount
   */
  readonly localSsdCount?: number;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigLocalNvmeSsdBlockConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localSsdCount': obj.localSsdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigReservationAffinity
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigReservationAffinity {
  /**
   * The type of reservation consumption
   * Accepted values are:
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigReservationAffinity#consumeReservationType
   */
  readonly consumeReservationType?: string;

  /**
   * name" as the key and specify the name of your reservation as its value.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigReservationAffinity#key
   */
  readonly key?: string;

  /**
   * name"
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigReservationAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigReservationAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigReservationAffinity(obj: NodePoolV1Beta2SpecInitProviderNodeConfigReservationAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumeReservationType': obj.consumeReservationType,
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks#diskImage
   */
  readonly diskImage?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks(obj: NodePoolV1Beta2SpecInitProviderNodeConfigSecondaryBootDisks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'diskImage': obj.diskImage,
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRef
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRef#policy
   */
  readonly policy?: NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRef(obj: NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelector
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelector#policy
   */
  readonly policy?: NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelector(obj: NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfig {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfig#nodeAffinity
   */
  readonly nodeAffinity?: NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity[];
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': obj.nodeAffinity?.map(y => toJson_NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigTaint
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigTaint {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigTaint#effect
   */
  readonly effect?: string;

  /**
   * name" as the key and specify the name of your reservation as its value.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigTaint#key
   */
  readonly key?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigTaint#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigTaint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigTaint(obj: NodePoolV1Beta2SpecInitProviderNodeConfigTaint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Parameters used in creating the node pool. See
 * google_container_cluster for schema.
 *
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig {
  /**
   * The Kubernetes version for the nodes in this pool. Note that if this field
   * and auto_upgrade are both specified, they will fight each other for what the node version should
   * be, so setting both is highly discouraged.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig#osversion
   */
  readonly osversion?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigWindowsNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'osversion': obj.osversion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig#mode
   */
  readonly mode?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigWorkloadMetadataConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The settings to adjust blue green upgrades.
 * Structure is documented below
 *
 * @schema NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettings
 */
export interface NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettings {
  /**
   * Time needed after draining the entire blue pool.
   * After this period, the blue pool will be cleaned up.
   *
   * @schema NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettings#nodePoolSoakDuration
   */
  readonly nodePoolSoakDuration?: string;

  /**
   * Specifies the standard policy settings for blue-green upgrades.
   *
   * @schema NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettings#standardRolloutPolicy
   */
  readonly standardRolloutPolicy?: NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettings(obj: NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodePoolSoakDuration': obj.nodePoolSoakDuration,
    'standardRolloutPolicy': toJson_NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(obj.standardRolloutPolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema NodePoolV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum NodePoolV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema NodePoolV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum NodePoolV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema NodePoolV1Beta2SpecForProviderClusterRefPolicyResolution
 */
export enum NodePoolV1Beta2SpecForProviderClusterRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema NodePoolV1Beta2SpecForProviderClusterRefPolicyResolve
 */
export enum NodePoolV1Beta2SpecForProviderClusterRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema NodePoolV1Beta2SpecForProviderClusterSelectorPolicyResolution
 */
export enum NodePoolV1Beta2SpecForProviderClusterSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema NodePoolV1Beta2SpecForProviderClusterSelectorPolicyResolve
 */
export enum NodePoolV1Beta2SpecForProviderClusterSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#certificateAuthorityDomainConfig
   */
  readonly certificateAuthorityDomainConfig?: NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig[];

  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityDomainConfig': obj.certificateAuthorityDomainConfig?.map(y => toJson_NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(y)),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
  /**
   * The Kubernetes version for the nodes in this pool. Note that if this field
   * and auto_upgrade are both specified, they will fight each other for what the node version should
   * be, so setting both is highly discouraged.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig#gpuDriverVersion
   */
  readonly gpuDriverVersion?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuDriverVersion': obj.gpuDriverVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig#gpuSharingStrategy
   */
  readonly gpuSharingStrategy?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig#maxSharedClientsPerGpu
   */
  readonly maxSharedClientsPerGpu?: number;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigGuestAcceleratorGpuSharingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuSharingStrategy': obj.gpuSharingStrategy,
    'maxSharedClientsPerGpu': obj.maxSharedClientsPerGpu,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize1G
   */
  readonly hugepageSize1G?: number;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize2M
   */
  readonly hugepageSize2M?: number;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigLinuxNodeConfigHugepagesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hugepageSize1G': obj.hugepageSize1G,
    'hugepageSize2M': obj.hugepageSize2M,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy#resolution
   */
  readonly resolution?: NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy#resolve
   */
  readonly resolve?: NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicyResolve;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy(obj: NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy#resolution
   */
  readonly resolution?: NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy#resolve
   */
  readonly resolve?: NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicyResolve;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy(obj: NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity {
  /**
   * name" as the key and specify the name of your reservation as its value.
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity#key
   */
  readonly key?: string;

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity#operator
   */
  readonly operator?: string;

  /**
   * name"
   *
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity(obj: NodePoolV1Beta2SpecForProviderNodeConfigSoleTenantConfigNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the standard policy settings for blue-green upgrades.
 *
 * @schema NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy
 */
export interface NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
  /**
   * Number of blue nodes to drain in a batch.
   *
   * @schema NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchNodeCount
   */
  readonly batchNodeCount?: number;

  /**
   * Percentage of the blue pool nodes to drain in a batch.
   *
   * @schema NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchPercentage
   */
  readonly batchPercentage?: number;

  /**
   * (Optionial) Soak time after each batch gets drained.
   *
   * @schema NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchSoakDuration
   */
  readonly batchSoakDuration?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(obj: NodePoolV1Beta2SpecForProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchNodeCount': obj.batchNodeCount,
    'batchPercentage': obj.batchPercentage,
    'batchSoakDuration': obj.batchSoakDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#certificateAuthorityDomainConfig
   */
  readonly certificateAuthorityDomainConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig[];

  /**
   * Makes nodes obtainable through the ProvisioningRequest API exclusively.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityDomainConfig': obj.certificateAuthorityDomainConfig?.map(y => toJson_NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(y)),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
  /**
   * The Kubernetes version for the nodes in this pool. Note that if this field
   * and auto_upgrade are both specified, they will fight each other for what the node version should
   * be, so setting both is highly discouraged.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig#gpuDriverVersion
   */
  readonly gpuDriverVersion?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuDriverInstallationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuDriverVersion': obj.gpuDriverVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig#gpuSharingStrategy
   */
  readonly gpuSharingStrategy?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig#maxSharedClientsPerGpu
   */
  readonly maxSharedClientsPerGpu?: number;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigGuestAcceleratorGpuSharingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gpuSharingStrategy': obj.gpuSharingStrategy,
    'maxSharedClientsPerGpu': obj.maxSharedClientsPerGpu,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize1G
   */
  readonly hugepageSize1G?: number;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig#hugepageSize2M
   */
  readonly hugepageSize2M?: number;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigLinuxNodeConfigHugepagesConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hugepageSize1G': obj.hugepageSize1G,
    'hugepageSize2M': obj.hugepageSize2M,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy#resolution
   */
  readonly resolution?: NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy#resolve
   */
  readonly resolve?: NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicyResolve;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy(obj: NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy#resolution
   */
  readonly resolution?: NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy#resolve
   */
  readonly resolve?: NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicyResolve;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy(obj: NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity {
  /**
   * name" as the key and specify the name of your reservation as its value.
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity#key
   */
  readonly key?: string;

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity#operator
   */
  readonly operator?: string;

  /**
   * name"
   *
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity(obj: NodePoolV1Beta2SpecInitProviderNodeConfigSoleTenantConfigNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the standard policy settings for blue-green upgrades.
 *
 * @schema NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy
 */
export interface NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
  /**
   * Number of blue nodes to drain in a batch.
   *
   * @schema NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchNodeCount
   */
  readonly batchNodeCount?: number;

  /**
   * Percentage of the blue pool nodes to drain in a batch.
   *
   * @schema NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchPercentage
   */
  readonly batchPercentage?: number;

  /**
   * (Optionial) Soak time after each batch gets drained.
   *
   * @schema NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy#batchSoakDuration
   */
  readonly batchSoakDuration?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy(obj: NodePoolV1Beta2SpecInitProviderUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchNodeCount': obj.batchNodeCount,
    'batchPercentage': obj.batchPercentage,
    'batchSoakDuration': obj.batchSoakDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#fqdns
   */
  readonly fqdns?: string[];

  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#gcpSecretManagerCertificateConfig
   */
  readonly gcpSecretManagerCertificateConfig?: NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fqdns': obj.fqdns?.map(y => y),
    'gcpSecretManagerCertificateConfig': toJson_NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj.gcpSecretManagerCertificateConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicyResolution
 */
export enum NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicyResolve
 */
export enum NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicyResolution
 */
export enum NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicyResolve
 */
export enum NodePoolV1Beta2SpecForProviderNodeConfigServiceAccountSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#fqdns
   */
  readonly fqdns?: string[];

  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig#gcpSecretManagerCertificateConfig
   */
  readonly gcpSecretManagerCertificateConfig?: NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fqdns': obj.fqdns?.map(y => y),
    'gcpSecretManagerCertificateConfig': toJson_NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj.gcpSecretManagerCertificateConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicyResolution
 */
export enum NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicyResolve
 */
export enum NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicyResolution
 */
export enum NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicyResolve
 */
export enum NodePoolV1Beta2SpecInitProviderNodeConfigServiceAccountSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig
 */
export interface NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
  /**
   * @schema NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig#secretUri
   */
  readonly secretUri?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj: NodePoolV1Beta2SpecForProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretUri': obj.secretUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig
 */
export interface NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
  /**
   * @schema NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig#secretUri
   */
  readonly secretUri?: string;
}

/**
 * Converts an object of type 'NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig(obj: NodePoolV1Beta2SpecInitProviderNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretUri': obj.secretUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

