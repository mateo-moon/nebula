// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from "cdk8s";
import { Construct } from "constructs";

// Preserve global Object reference before the local Object class shadows it
const _Object = globalThis.Object;

// Type alias to avoid collision with the Object class defined below
type JsonObject<K extends keyof any, T> = { [P in K]: T };

/**
 * A Object is an provider Kubernetes API type
Deprecated: v1alpha1.Object is deprecated in favor of v1alpha2.Object
 *
 * @schema Object
 */
export class Object extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Object"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "kubernetes.crossplane.io/v1alpha1",
    kind: "Object",
  };

  /**
   * Renders a Kubernetes manifest for "Object".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ObjectProps): any {
    return {
      ...Object.GVK,
      ...toJson_ObjectProps(props),
    };
  }

  /**
   * Defines a "Object" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ObjectProps) {
    super(scope, id, {
      ...Object.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Object.GVK,
      ...toJson_ObjectProps(resolved),
    };
  }
}

/**
 * A Object is an provider Kubernetes API type
 * Deprecated: v1alpha1.Object is deprecated in favor of v1alpha2.Object
 *
 * @schema Object
 */
export interface ObjectProps {
  /**
   * @schema Object#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A ObjectSpec defines the desired state of a Object.
   *
   * @schema Object#spec
   */
  readonly spec: ObjectSpec;
}

/**
 * Converts an object of type 'ObjectProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectProps(
  obj: ObjectProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_ObjectSpec(obj.spec),
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ObjectSpec defines the desired state of a Object.
 *
 * @schema ObjectSpec
 */
export interface ObjectSpec {
  /**
   * @schema ObjectSpec#connectionDetails
   */
  readonly connectionDetails?: ObjectSpecConnectionDetails[];

  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicy
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ObjectSpec#deletionPolicy
   */
  readonly deletionPolicy?: ObjectSpecDeletionPolicy;

  /**
   * ObjectParameters are the configurable fields of a Object.
   *
   * @schema ObjectSpec#forProvider
   */
  readonly forProvider: ObjectSpecForProvider;

  /**
   * A ManagementPolicy determines what should happen to the underlying external
   * resource when a managed resource is created, updated, deleted, or observed.
   *
   * @schema ObjectSpec#managementPolicy
   */
  readonly managementPolicy?: ObjectSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ObjectSpec#providerConfigRef
   */
  readonly providerConfigRef?: ObjectSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create,
   * observe, update, and delete this managed resource.
   * Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ObjectSpec#providerRef
   */
  readonly providerRef?: ObjectSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ObjectSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ObjectSpecPublishConnectionDetailsTo;

  /**
   * Readiness defines how the object's readiness condition should be computed,
   * if not specified it will be considered ready as soon as the underlying external
   * resource is considered up-to-date.
   *
   * @schema ObjectSpec#readiness
   */
  readonly readiness?: ObjectSpecReadiness;

  /**
   * @schema ObjectSpec#references
   */
  readonly references?: ObjectSpecReferences[];

  /**
   * Watch enables watching the referenced or managed kubernetes resources.
   *
   *
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
   * unless "watches" feature gate is enabled, and may be changed or removed
   * without notice.
   *
   * @schema ObjectSpec#watch
   */
  readonly watch?: boolean;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema ObjectSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ObjectSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ObjectSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpec(
  obj: ObjectSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    connectionDetails: obj.connectionDetails?.map((y) =>
      toJson_ObjectSpecConnectionDetails(y),
    ),
    deletionPolicy: obj.deletionPolicy,
    forProvider: toJson_ObjectSpecForProvider(obj.forProvider),
    managementPolicy: obj.managementPolicy,
    providerConfigRef: toJson_ObjectSpecProviderConfigRef(
      obj.providerConfigRef,
    ),
    providerRef: toJson_ObjectSpecProviderRef(obj.providerRef),
    publishConnectionDetailsTo: toJson_ObjectSpecPublishConnectionDetailsTo(
      obj.publishConnectionDetailsTo,
    ),
    readiness: toJson_ObjectSpecReadiness(obj.readiness),
    references: obj.references?.map((y) => toJson_ObjectSpecReferences(y)),
    watch: obj.watch,
    writeConnectionSecretToRef: toJson_ObjectSpecWriteConnectionSecretToRef(
      obj.writeConnectionSecretToRef,
    ),
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConnectionDetail represents an entry in the connection secret for an Object
 *
 * @schema ObjectSpecConnectionDetails
 */
export interface ObjectSpecConnectionDetails {
  /**
   * API version of the referent.
   *
   * @schema ObjectSpecConnectionDetails#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * If referring to a piece of an object instead of an entire object, this string
   * should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
   * For example, if the object reference is to a container within a pod, this would take on a value like:
   * "spec.containers{name}" (where "name" refers to the name of the container that triggered
   * the event) or if no container name is specified "spec.containers[2]" (container with
   * index 2 in this pod). This syntax is chosen only to have some well-defined way of
   * referencing a part of an object.
   * TODO: this design is not final and this field is subject to change in the future.
   *
   * @schema ObjectSpecConnectionDetails#fieldPath
   */
  readonly fieldPath?: string;

  /**
   * Kind of the referent.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema ObjectSpecConnectionDetails#kind
   */
  readonly kind?: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ObjectSpecConnectionDetails#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ObjectSpecConnectionDetails#namespace
   */
  readonly namespace?: string;

  /**
   * Specific resourceVersion to which this reference is made, if any.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   *
   * @schema ObjectSpecConnectionDetails#resourceVersion
   */
  readonly resourceVersion?: string;

  /**
   * @schema ObjectSpecConnectionDetails#toConnectionSecretKey
   */
  readonly toConnectionSecretKey?: string;

  /**
   * UID of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
   *
   * @schema ObjectSpecConnectionDetails#uid
   */
  readonly uid?: string;
}

/**
 * Converts an object of type 'ObjectSpecConnectionDetails' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpecConnectionDetails(
  obj: ObjectSpecConnectionDetails | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
    kind: obj.kind,
    name: obj.name,
    namespace: obj.namespace,
    resourceVersion: obj.resourceVersion,
    toConnectionSecretKey: obj.toConnectionSecretKey,
    uid: obj.uid,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicy
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ObjectSpecDeletionPolicy
 */
export enum ObjectSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ObjectParameters are the configurable fields of a Object.
 *
 * @schema ObjectSpecForProvider
 */
export interface ObjectSpecForProvider {
  /**
   * Raw JSON representation of the kubernetes object to be created.
   *
   * @schema ObjectSpecForProvider#manifest
   */
  readonly manifest: any;
}

/**
 * Converts an object of type 'ObjectSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpecForProvider(
  obj: ObjectSpecForProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    manifest: obj.manifest,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementPolicy determines what should happen to the underlying external
 * resource when a managed resource is created, updated, deleted, or observed.
 *
 * @schema ObjectSpecManagementPolicy
 */
export enum ObjectSpecManagementPolicy {
  /** Default */
  DEFAULT = "Default",
  /** ObserveCreateUpdate */
  OBSERVE_CREATE_UPDATE = "ObserveCreateUpdate",
  /** ObserveDelete */
  OBSERVE_DELETE = "ObserveDelete",
  /** Observe */
  OBSERVE = "Observe",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ObjectSpecProviderConfigRef
 */
export interface ObjectSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectSpecProviderConfigRef#policy
   */
  readonly policy?: ObjectSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ObjectSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpecProviderConfigRef(
  obj: ObjectSpecProviderConfigRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    policy: toJson_ObjectSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProviderReference specifies the provider that will be used to create,
 * observe, update, and delete this managed resource.
 * Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ObjectSpecProviderRef
 */
export interface ObjectSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectSpecProviderRef#policy
   */
  readonly policy?: ObjectSpecProviderRefPolicy;
}

/**
 * Converts an object of type 'ObjectSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpecProviderRef(
  obj: ObjectSpecProviderRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    policy: toJson_ObjectSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ObjectSpecPublishConnectionDetailsTo
 */
export interface ObjectSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema ObjectSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ObjectSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ObjectSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ObjectSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ObjectSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ObjectSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpecPublishConnectionDetailsTo(
  obj: ObjectSpecPublishConnectionDetailsTo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configRef: toJson_ObjectSpecPublishConnectionDetailsToConfigRef(
      obj.configRef,
    ),
    metadata: toJson_ObjectSpecPublishConnectionDetailsToMetadata(obj.metadata),
    name: obj.name,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Readiness defines how the object's readiness condition should be computed,
 * if not specified it will be considered ready as soon as the underlying external
 * resource is considered up-to-date.
 *
 * @schema ObjectSpecReadiness
 */
export interface ObjectSpecReadiness {
  /**
   * Policy defines how the Object's readiness condition should be computed.
   *
   * @schema ObjectSpecReadiness#policy
   */
  readonly policy?: ObjectSpecReadinessPolicy;
}

/**
 * Converts an object of type 'ObjectSpecReadiness' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpecReadiness(
  obj: ObjectSpecReadiness | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    policy: obj.policy,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference refers to an Object or arbitrary Kubernetes resource and optionally
 * patch values from that resource to the current Object.
 *
 * @schema ObjectSpecReferences
 */
export interface ObjectSpecReferences {
  /**
   * DependsOn is used to declare dependency on other Object or arbitrary
   * Kubernetes resource.
   *
   * @schema ObjectSpecReferences#dependsOn
   */
  readonly dependsOn?: ObjectSpecReferencesDependsOn;

  /**
   * PatchesFrom is used to declare dependency on other Object or arbitrary
   * Kubernetes resource, and also patch fields from this object.
   *
   * @schema ObjectSpecReferences#patchesFrom
   */
  readonly patchesFrom?: ObjectSpecReferencesPatchesFrom;

  /**
   * ToFieldPath is the path of the field on the resource whose value will
   * be changed with the result of transforms. Leave empty if you'd like to
   * propagate to the same path as patchesFrom.fieldPath.
   *
   * @schema ObjectSpecReferences#toFieldPath
   */
  readonly toFieldPath?: string;
}

/**
 * Converts an object of type 'ObjectSpecReferences' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpecReferences(
  obj: ObjectSpecReferences | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    dependsOn: toJson_ObjectSpecReferencesDependsOn(obj.dependsOn),
    patchesFrom: toJson_ObjectSpecReferencesPatchesFrom(obj.patchesFrom),
    toFieldPath: obj.toFieldPath,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema ObjectSpecWriteConnectionSecretToRef
 */
export interface ObjectSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ObjectSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ObjectSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ObjectSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpecWriteConnectionSecretToRef(
  obj: ObjectSpecWriteConnectionSecretToRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectSpecProviderConfigRefPolicy
 */
export interface ObjectSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ObjectSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ObjectSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ObjectSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpecProviderConfigRefPolicy(
  obj: ObjectSpecProviderConfigRefPolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resolution: obj.resolution,
    resolve: obj.resolve,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectSpecProviderRefPolicy
 */
export interface ObjectSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ObjectSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ObjectSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ObjectSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ObjectSpecProviderRefPolicyResolve;
}

/**
 * Converts an object of type 'ObjectSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpecProviderRefPolicy(
  obj: ObjectSpecProviderRefPolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resolution: obj.resolution,
    resolve: obj.resolve,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema ObjectSpecPublishConnectionDetailsToConfigRef
 */
export interface ObjectSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ObjectSpecPublishConnectionDetailsToConfigRefPolicy;
}

/**
 * Converts an object of type 'ObjectSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpecPublishConnectionDetailsToConfigRef(
  obj: ObjectSpecPublishConnectionDetailsToConfigRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    policy: toJson_ObjectSpecPublishConnectionDetailsToConfigRefPolicy(
      obj.policy,
    ),
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ObjectSpecPublishConnectionDetailsToMetadata
 */
export interface ObjectSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema ObjectSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ObjectSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpecPublishConnectionDetailsToMetadata(
  obj: ObjectSpecPublishConnectionDetailsToMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : _Object
            .entries(obj.annotations)
            .reduce(
              (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
              {},
            ),
    labels:
      obj.labels === undefined
        ? undefined
        : _Object
            .entries(obj.labels)
            .reduce(
              (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
              {},
            ),
    type: obj.type,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policy defines how the Object's readiness condition should be computed.
 *
 * @schema ObjectSpecReadinessPolicy
 */
export enum ObjectSpecReadinessPolicy {
  /** SuccessfulCreate */
  SUCCESSFUL_CREATE = "SuccessfulCreate",
  /** DeriveFromObject */
  DERIVE_FROM_OBJECT = "DeriveFromObject",
  /** AllTrue */
  ALL_TRUE = "AllTrue",
}

/**
 * DependsOn is used to declare dependency on other Object or arbitrary
 * Kubernetes resource.
 *
 * @schema ObjectSpecReferencesDependsOn
 */
export interface ObjectSpecReferencesDependsOn {
  /**
   * APIVersion of the referenced object.
   *
   * @schema ObjectSpecReferencesDependsOn#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referenced object.
   *
   * @schema ObjectSpecReferencesDependsOn#kind
   */
  readonly kind?: string;

  /**
   * Name of the referenced object.
   *
   * @schema ObjectSpecReferencesDependsOn#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.
   *
   * @schema ObjectSpecReferencesDependsOn#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ObjectSpecReferencesDependsOn' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpecReferencesDependsOn(
  obj: ObjectSpecReferencesDependsOn | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    kind: obj.kind,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PatchesFrom is used to declare dependency on other Object or arbitrary
 * Kubernetes resource, and also patch fields from this object.
 *
 * @schema ObjectSpecReferencesPatchesFrom
 */
export interface ObjectSpecReferencesPatchesFrom {
  /**
   * APIVersion of the referenced object.
   *
   * @schema ObjectSpecReferencesPatchesFrom#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * FieldPath is the path of the field on the resource whose value is to be
   * used as input.
   *
   * @schema ObjectSpecReferencesPatchesFrom#fieldPath
   */
  readonly fieldPath: string;

  /**
   * Kind of the referenced object.
   *
   * @schema ObjectSpecReferencesPatchesFrom#kind
   */
  readonly kind?: string;

  /**
   * Name of the referenced object.
   *
   * @schema ObjectSpecReferencesPatchesFrom#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.
   *
   * @schema ObjectSpecReferencesPatchesFrom#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ObjectSpecReferencesPatchesFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpecReferencesPatchesFrom(
  obj: ObjectSpecReferencesPatchesFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
    kind: obj.kind,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ObjectSpecProviderConfigRefPolicyResolution
 */
export enum ObjectSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ObjectSpecProviderConfigRefPolicyResolve
 */
export enum ObjectSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ObjectSpecProviderRefPolicyResolution
 */
export enum ObjectSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ObjectSpecProviderRefPolicyResolve
 */
export enum ObjectSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ObjectSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ObjectSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ObjectSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ObjectSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectSpecPublishConnectionDetailsToConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ObjectSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectSpecPublishConnectionDetailsToConfigRefPolicy(
  obj: ObjectSpecPublishConnectionDetailsToConfigRefPolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resolution: obj.resolution,
    resolve: obj.resolve,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ObjectSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ObjectSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ObjectSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ObjectSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * A Object is an provider Kubernetes API type
 *
 * @schema ObjectV1Alpha2
 */
export class ObjectV1Alpha2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ObjectV1Alpha2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "kubernetes.crossplane.io/v1alpha2",
    kind: "Object",
  };

  /**
   * Renders a Kubernetes manifest for "ObjectV1Alpha2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ObjectV1Alpha2Props): any {
    return {
      ...ObjectV1Alpha2.GVK,
      ...toJson_ObjectV1Alpha2Props(props),
    };
  }

  /**
   * Defines a "ObjectV1Alpha2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ObjectV1Alpha2Props) {
    super(scope, id, {
      ...ObjectV1Alpha2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ObjectV1Alpha2.GVK,
      ...toJson_ObjectV1Alpha2Props(resolved),
    };
  }
}

/**
 * A Object is an provider Kubernetes API type
 *
 * @schema ObjectV1Alpha2
 */
export interface ObjectV1Alpha2Props {
  /**
   * @schema ObjectV1Alpha2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A ObjectSpec defines the desired state of a Object.
   *
   * @schema ObjectV1Alpha2#spec
   */
  readonly spec: ObjectV1Alpha2Spec;
}

/**
 * Converts an object of type 'ObjectV1Alpha2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectV1Alpha2Props(
  obj: ObjectV1Alpha2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_ObjectV1Alpha2Spec(obj.spec),
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ObjectSpec defines the desired state of a Object.
 *
 * @schema ObjectV1Alpha2Spec
 */
export interface ObjectV1Alpha2Spec {
  /**
   * @schema ObjectV1Alpha2Spec#connectionDetails
   */
  readonly connectionDetails?: ObjectV1Alpha2SpecConnectionDetails[];

  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ObjectV1Alpha2Spec#deletionPolicy
   */
  readonly deletionPolicy?: ObjectV1Alpha2SpecDeletionPolicy;

  /**
   * ObjectParameters are the configurable fields of a Object.
   *
   * @schema ObjectV1Alpha2Spec#forProvider
   */
  readonly forProvider: ObjectV1Alpha2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ObjectV1Alpha2Spec#managementPolicies
   */
  readonly managementPolicies?: ObjectV1Alpha2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ObjectV1Alpha2Spec#providerConfigRef
   */
  readonly providerConfigRef?: ObjectV1Alpha2SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ObjectV1Alpha2Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ObjectV1Alpha2SpecPublishConnectionDetailsTo;

  /**
   * Readiness defines how the object's readiness condition should be computed,
   * if not specified it will be considered ready as soon as the underlying external
   * resource is considered up-to-date.
   *
   * @schema ObjectV1Alpha2Spec#readiness
   */
  readonly readiness?: ObjectV1Alpha2SpecReadiness;

  /**
   * @schema ObjectV1Alpha2Spec#references
   */
  readonly references?: ObjectV1Alpha2SpecReferences[];

  /**
   * Watch enables watching the referenced or managed kubernetes resources.
   *
   *
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
   * unless "watches" feature gate is enabled, and may be changed or removed
   * without notice.
   *
   * @schema ObjectV1Alpha2Spec#watch
   */
  readonly watch?: boolean;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema ObjectV1Alpha2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ObjectV1Alpha2SpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ObjectV1Alpha2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectV1Alpha2Spec(
  obj: ObjectV1Alpha2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    connectionDetails: obj.connectionDetails?.map((y) =>
      toJson_ObjectV1Alpha2SpecConnectionDetails(y),
    ),
    deletionPolicy: obj.deletionPolicy,
    forProvider: toJson_ObjectV1Alpha2SpecForProvider(obj.forProvider),
    managementPolicies: obj.managementPolicies?.map((y) => y),
    providerConfigRef: toJson_ObjectV1Alpha2SpecProviderConfigRef(
      obj.providerConfigRef,
    ),
    publishConnectionDetailsTo:
      toJson_ObjectV1Alpha2SpecPublishConnectionDetailsTo(
        obj.publishConnectionDetailsTo,
      ),
    readiness: toJson_ObjectV1Alpha2SpecReadiness(obj.readiness),
    references: obj.references?.map((y) =>
      toJson_ObjectV1Alpha2SpecReferences(y),
    ),
    watch: obj.watch,
    writeConnectionSecretToRef:
      toJson_ObjectV1Alpha2SpecWriteConnectionSecretToRef(
        obj.writeConnectionSecretToRef,
      ),
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConnectionDetail represents an entry in the connection secret for an Object
 *
 * @schema ObjectV1Alpha2SpecConnectionDetails
 */
export interface ObjectV1Alpha2SpecConnectionDetails {
  /**
   * API version of the referent.
   *
   * @schema ObjectV1Alpha2SpecConnectionDetails#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * If referring to a piece of an object instead of an entire object, this string
   * should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
   * For example, if the object reference is to a container within a pod, this would take on a value like:
   * "spec.containers{name}" (where "name" refers to the name of the container that triggered
   * the event) or if no container name is specified "spec.containers[2]" (container with
   * index 2 in this pod). This syntax is chosen only to have some well-defined way of
   * referencing a part of an object.
   * TODO: this design is not final and this field is subject to change in the future.
   *
   * @schema ObjectV1Alpha2SpecConnectionDetails#fieldPath
   */
  readonly fieldPath?: string;

  /**
   * Kind of the referent.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema ObjectV1Alpha2SpecConnectionDetails#kind
   */
  readonly kind?: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ObjectV1Alpha2SpecConnectionDetails#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ObjectV1Alpha2SpecConnectionDetails#namespace
   */
  readonly namespace?: string;

  /**
   * Specific resourceVersion to which this reference is made, if any.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   *
   * @schema ObjectV1Alpha2SpecConnectionDetails#resourceVersion
   */
  readonly resourceVersion?: string;

  /**
   * @schema ObjectV1Alpha2SpecConnectionDetails#toConnectionSecretKey
   */
  readonly toConnectionSecretKey?: string;

  /**
   * UID of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
   *
   * @schema ObjectV1Alpha2SpecConnectionDetails#uid
   */
  readonly uid?: string;
}

/**
 * Converts an object of type 'ObjectV1Alpha2SpecConnectionDetails' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectV1Alpha2SpecConnectionDetails(
  obj: ObjectV1Alpha2SpecConnectionDetails | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
    kind: obj.kind,
    name: obj.name,
    namespace: obj.namespace,
    resourceVersion: obj.resourceVersion,
    toConnectionSecretKey: obj.toConnectionSecretKey,
    uid: obj.uid,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ObjectV1Alpha2SpecDeletionPolicy
 */
export enum ObjectV1Alpha2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ObjectParameters are the configurable fields of a Object.
 *
 * @schema ObjectV1Alpha2SpecForProvider
 */
export interface ObjectV1Alpha2SpecForProvider {
  /**
   * Raw JSON representation of the kubernetes object to be created.
   *
   * @schema ObjectV1Alpha2SpecForProvider#manifest
   */
  readonly manifest: any;
}

/**
 * Converts an object of type 'ObjectV1Alpha2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectV1Alpha2SpecForProvider(
  obj: ObjectV1Alpha2SpecForProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    manifest: obj.manifest,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ObjectV1Alpha2SpecManagementPolicies
 */
export enum ObjectV1Alpha2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ObjectV1Alpha2SpecProviderConfigRef
 */
export interface ObjectV1Alpha2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectV1Alpha2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectV1Alpha2SpecProviderConfigRef#policy
   */
  readonly policy?: ObjectV1Alpha2SpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ObjectV1Alpha2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectV1Alpha2SpecProviderConfigRef(
  obj: ObjectV1Alpha2SpecProviderConfigRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    policy: toJson_ObjectV1Alpha2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ObjectV1Alpha2SpecPublishConnectionDetailsTo
 */
export interface ObjectV1Alpha2SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema ObjectV1Alpha2SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ObjectV1Alpha2SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ObjectV1Alpha2SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ObjectV1Alpha2SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ObjectV1Alpha2SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectV1Alpha2SpecPublishConnectionDetailsTo(
  obj: ObjectV1Alpha2SpecPublishConnectionDetailsTo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configRef: toJson_ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRef(
      obj.configRef,
    ),
    metadata: toJson_ObjectV1Alpha2SpecPublishConnectionDetailsToMetadata(
      obj.metadata,
    ),
    name: obj.name,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Readiness defines how the object's readiness condition should be computed,
 * if not specified it will be considered ready as soon as the underlying external
 * resource is considered up-to-date.
 *
 * @schema ObjectV1Alpha2SpecReadiness
 */
export interface ObjectV1Alpha2SpecReadiness {
  /**
   * CelQuery defines a cel query to evaluate the readiness. The
   * observed object is passed to the cel query with the word `object`.
   * Cel macros are available to be used, see https://github.com/google/cel-spec/blob/master/doc/langdef.md#macros
   * for more information.
   * Examples:
   * `object.status.isReady == true`: checks for a boolean field called isReady on status.
   * `object.status.conditions.all(x, x.status == "True")` mimics the behavior of the AllTrue readiness policy
   * `object.status.conditions.exists(c, c.type == "condition1" && c.status == "True" )` checks just one condition
   *
   * @schema ObjectV1Alpha2SpecReadiness#celQuery
   */
  readonly celQuery?: string;

  /**
   * Policy defines how the Object's readiness condition should be computed.
   *
   * @schema ObjectV1Alpha2SpecReadiness#policy
   */
  readonly policy?: ObjectV1Alpha2SpecReadinessPolicy;
}

/**
 * Converts an object of type 'ObjectV1Alpha2SpecReadiness' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectV1Alpha2SpecReadiness(
  obj: ObjectV1Alpha2SpecReadiness | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    celQuery: obj.celQuery,
    policy: obj.policy,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference refers to an Object or arbitrary Kubernetes resource and optionally
 * patch values from that resource to the current Object.
 *
 * @schema ObjectV1Alpha2SpecReferences
 */
export interface ObjectV1Alpha2SpecReferences {
  /**
   * DependsOn is used to declare dependency on other Object or arbitrary
   * Kubernetes resource.
   *
   * @schema ObjectV1Alpha2SpecReferences#dependsOn
   */
  readonly dependsOn?: ObjectV1Alpha2SpecReferencesDependsOn;

  /**
   * PatchesFrom is used to declare dependency on other Object or arbitrary
   * Kubernetes resource, and also patch fields from this object.
   *
   * @schema ObjectV1Alpha2SpecReferences#patchesFrom
   */
  readonly patchesFrom?: ObjectV1Alpha2SpecReferencesPatchesFrom;

  /**
   * ToFieldPath is the path of the field on the resource whose value will
   * be changed with the result of transforms. Leave empty if you'd like to
   * propagate to the same path as patchesFrom.fieldPath.
   *
   * @schema ObjectV1Alpha2SpecReferences#toFieldPath
   */
  readonly toFieldPath?: string;
}

/**
 * Converts an object of type 'ObjectV1Alpha2SpecReferences' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectV1Alpha2SpecReferences(
  obj: ObjectV1Alpha2SpecReferences | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    dependsOn: toJson_ObjectV1Alpha2SpecReferencesDependsOn(obj.dependsOn),
    patchesFrom: toJson_ObjectV1Alpha2SpecReferencesPatchesFrom(
      obj.patchesFrom,
    ),
    toFieldPath: obj.toFieldPath,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema ObjectV1Alpha2SpecWriteConnectionSecretToRef
 */
export interface ObjectV1Alpha2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ObjectV1Alpha2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ObjectV1Alpha2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ObjectV1Alpha2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectV1Alpha2SpecWriteConnectionSecretToRef(
  obj: ObjectV1Alpha2SpecWriteConnectionSecretToRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectV1Alpha2SpecProviderConfigRefPolicy
 */
export interface ObjectV1Alpha2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ObjectV1Alpha2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectV1Alpha2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ObjectV1Alpha2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectV1Alpha2SpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ObjectV1Alpha2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectV1Alpha2SpecProviderConfigRefPolicy(
  obj: ObjectV1Alpha2SpecProviderConfigRefPolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resolution: obj.resolution,
    resolve: obj.resolve,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRef
 */
export interface ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRefPolicy;
}

/**
 * Converts an object of type 'ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRef(
  obj: ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    policy: toJson_ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRefPolicy(
      obj.policy,
    ),
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ObjectV1Alpha2SpecPublishConnectionDetailsToMetadata
 */
export interface ObjectV1Alpha2SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectV1Alpha2SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectV1Alpha2SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema ObjectV1Alpha2SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ObjectV1Alpha2SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectV1Alpha2SpecPublishConnectionDetailsToMetadata(
  obj: ObjectV1Alpha2SpecPublishConnectionDetailsToMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : _Object
            .entries(obj.annotations)
            .reduce(
              (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
              {},
            ),
    labels:
      obj.labels === undefined
        ? undefined
        : _Object
            .entries(obj.labels)
            .reduce(
              (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
              {},
            ),
    type: obj.type,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policy defines how the Object's readiness condition should be computed.
 *
 * @schema ObjectV1Alpha2SpecReadinessPolicy
 */
export enum ObjectV1Alpha2SpecReadinessPolicy {
  /** SuccessfulCreate */
  SUCCESSFUL_CREATE = "SuccessfulCreate",
  /** DeriveFromObject */
  DERIVE_FROM_OBJECT = "DeriveFromObject",
  /** AllTrue */
  ALL_TRUE = "AllTrue",
  /** DeriveFromCelQuery */
  DERIVE_FROM_CEL_QUERY = "DeriveFromCelQuery",
}

/**
 * DependsOn is used to declare dependency on other Object or arbitrary
 * Kubernetes resource.
 *
 * @schema ObjectV1Alpha2SpecReferencesDependsOn
 */
export interface ObjectV1Alpha2SpecReferencesDependsOn {
  /**
   * APIVersion of the referenced object.
   *
   * @schema ObjectV1Alpha2SpecReferencesDependsOn#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referenced object.
   *
   * @schema ObjectV1Alpha2SpecReferencesDependsOn#kind
   */
  readonly kind?: string;

  /**
   * Name of the referenced object.
   *
   * @schema ObjectV1Alpha2SpecReferencesDependsOn#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.
   *
   * @schema ObjectV1Alpha2SpecReferencesDependsOn#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ObjectV1Alpha2SpecReferencesDependsOn' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectV1Alpha2SpecReferencesDependsOn(
  obj: ObjectV1Alpha2SpecReferencesDependsOn | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    kind: obj.kind,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PatchesFrom is used to declare dependency on other Object or arbitrary
 * Kubernetes resource, and also patch fields from this object.
 *
 * @schema ObjectV1Alpha2SpecReferencesPatchesFrom
 */
export interface ObjectV1Alpha2SpecReferencesPatchesFrom {
  /**
   * APIVersion of the referenced object.
   *
   * @schema ObjectV1Alpha2SpecReferencesPatchesFrom#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * FieldPath is the path of the field on the resource whose value is to be
   * used as input.
   *
   * @schema ObjectV1Alpha2SpecReferencesPatchesFrom#fieldPath
   */
  readonly fieldPath: string;

  /**
   * Kind of the referenced object.
   *
   * @schema ObjectV1Alpha2SpecReferencesPatchesFrom#kind
   */
  readonly kind?: string;

  /**
   * Name of the referenced object.
   *
   * @schema ObjectV1Alpha2SpecReferencesPatchesFrom#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.
   *
   * @schema ObjectV1Alpha2SpecReferencesPatchesFrom#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ObjectV1Alpha2SpecReferencesPatchesFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectV1Alpha2SpecReferencesPatchesFrom(
  obj: ObjectV1Alpha2SpecReferencesPatchesFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
    kind: obj.kind,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ObjectV1Alpha2SpecProviderConfigRefPolicyResolution
 */
export enum ObjectV1Alpha2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ObjectV1Alpha2SpecProviderConfigRefPolicyResolve
 */
export enum ObjectV1Alpha2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRefPolicy(
  obj: ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRefPolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resolution: obj.resolution,
    resolve: obj.resolve,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ObjectV1Alpha2SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * A ProviderConfig configures a Template provider.
 *
 * @schema ProviderConfig
 */
export class ProviderConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProviderConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "kubernetes.crossplane.io/v1alpha1",
    kind: "ProviderConfig",
  };

  /**
   * Renders a Kubernetes manifest for "ProviderConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProviderConfigProps): any {
    return {
      ...ProviderConfig.GVK,
      ...toJson_ProviderConfigProps(props),
    };
  }

  /**
   * Defines a "ProviderConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProviderConfigProps) {
    super(scope, id, {
      ...ProviderConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProviderConfig.GVK,
      ...toJson_ProviderConfigProps(resolved),
    };
  }
}

/**
 * A ProviderConfig configures a Template provider.
 *
 * @schema ProviderConfig
 */
export interface ProviderConfigProps {
  /**
   * @schema ProviderConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A ProviderConfigSpec defines the desired state of a ProviderConfig.
   *
   * @schema ProviderConfig#spec
   */
  readonly spec: ProviderConfigSpec;
}

/**
 * Converts an object of type 'ProviderConfigProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderConfigProps(
  obj: ProviderConfigProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_ProviderConfigSpec(obj.spec),
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ProviderConfigSpec defines the desired state of a ProviderConfig.
 *
 * @schema ProviderConfigSpec
 */
export interface ProviderConfigSpec {
  /**
   * Credentials used to connect to the Kubernetes API. Typically a
   * kubeconfig file. Use InjectedIdentity for in-cluster config.
   *
   * @schema ProviderConfigSpec#credentials
   */
  readonly credentials: ProviderConfigSpecCredentials;

  /**
   * Identity used to authenticate to the Kubernetes API. The identity
   * credentials can be used to supplement kubeconfig 'credentials', for
   * example by configuring a bearer token source such as OAuth.
   *
   * @schema ProviderConfigSpec#identity
   */
  readonly identity?: ProviderConfigSpecIdentity;
}

/**
 * Converts an object of type 'ProviderConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderConfigSpec(
  obj: ProviderConfigSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentials: toJson_ProviderConfigSpecCredentials(obj.credentials),
    identity: toJson_ProviderConfigSpecIdentity(obj.identity),
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Credentials used to connect to the Kubernetes API. Typically a
 * kubeconfig file. Use InjectedIdentity for in-cluster config.
 *
 * @schema ProviderConfigSpecCredentials
 */
export interface ProviderConfigSpecCredentials {
  /**
   * Env is a reference to an environment variable that contains credentials
   * that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecCredentials#env
   */
  readonly env?: ProviderConfigSpecCredentialsEnv;

  /**
   * Fs is a reference to a filesystem location that contains credentials that
   * must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecCredentials#fs
   */
  readonly fs?: ProviderConfigSpecCredentialsFs;

  /**
   * A SecretRef is a reference to a secret key that contains the credentials
   * that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecCredentials#secretRef
   */
  readonly secretRef?: ProviderConfigSpecCredentialsSecretRef;

  /**
   * Source of the provider credentials.
   *
   * @schema ProviderConfigSpecCredentials#source
   */
  readonly source: ProviderConfigSpecCredentialsSource;
}

/**
 * Converts an object of type 'ProviderConfigSpecCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderConfigSpecCredentials(
  obj: ProviderConfigSpecCredentials | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    env: toJson_ProviderConfigSpecCredentialsEnv(obj.env),
    fs: toJson_ProviderConfigSpecCredentialsFs(obj.fs),
    secretRef: toJson_ProviderConfigSpecCredentialsSecretRef(obj.secretRef),
    source: obj.source,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Identity used to authenticate to the Kubernetes API. The identity
 * credentials can be used to supplement kubeconfig 'credentials', for
 * example by configuring a bearer token source such as OAuth.
 *
 * @schema ProviderConfigSpecIdentity
 */
export interface ProviderConfigSpecIdentity {
  /**
   * Env is a reference to an environment variable that contains credentials
   * that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecIdentity#env
   */
  readonly env?: ProviderConfigSpecIdentityEnv;

  /**
   * Fs is a reference to a filesystem location that contains credentials that
   * must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecIdentity#fs
   */
  readonly fs?: ProviderConfigSpecIdentityFs;

  /**
   * A SecretRef is a reference to a secret key that contains the credentials
   * that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecIdentity#secretRef
   */
  readonly secretRef?: ProviderConfigSpecIdentitySecretRef;

  /**
   * Source of the provider credentials.
   *
   * @schema ProviderConfigSpecIdentity#source
   */
  readonly source: ProviderConfigSpecIdentitySource;

  /**
   * Type of identity.
   *
   * @schema ProviderConfigSpecIdentity#type
   */
  readonly type: ProviderConfigSpecIdentityType;
}

/**
 * Converts an object of type 'ProviderConfigSpecIdentity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderConfigSpecIdentity(
  obj: ProviderConfigSpecIdentity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    env: toJson_ProviderConfigSpecIdentityEnv(obj.env),
    fs: toJson_ProviderConfigSpecIdentityFs(obj.fs),
    secretRef: toJson_ProviderConfigSpecIdentitySecretRef(obj.secretRef),
    source: obj.source,
    type: obj.type,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Env is a reference to an environment variable that contains credentials
 * that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecCredentialsEnv
 */
export interface ProviderConfigSpecCredentialsEnv {
  /**
   * Name is the name of an environment variable.
   *
   * @schema ProviderConfigSpecCredentialsEnv#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ProviderConfigSpecCredentialsEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderConfigSpecCredentialsEnv(
  obj: ProviderConfigSpecCredentialsEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fs is a reference to a filesystem location that contains credentials that
 * must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecCredentialsFs
 */
export interface ProviderConfigSpecCredentialsFs {
  /**
   * Path is a filesystem path.
   *
   * @schema ProviderConfigSpecCredentialsFs#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ProviderConfigSpecCredentialsFs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderConfigSpecCredentialsFs(
  obj: ProviderConfigSpecCredentialsFs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A SecretRef is a reference to a secret key that contains the credentials
 * that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecCredentialsSecretRef
 */
export interface ProviderConfigSpecCredentialsSecretRef {
  /**
   * The key to select.
   *
   * @schema ProviderConfigSpecCredentialsSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ProviderConfigSpecCredentialsSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProviderConfigSpecCredentialsSecretRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ProviderConfigSpecCredentialsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderConfigSpecCredentialsSecretRef(
  obj: ProviderConfigSpecCredentialsSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source of the provider credentials.
 *
 * @schema ProviderConfigSpecCredentialsSource
 */
export enum ProviderConfigSpecCredentialsSource {
  /** None */
  NONE = "None",
  /** Secret */
  SECRET = "Secret",
  /** InjectedIdentity */
  INJECTED_IDENTITY = "InjectedIdentity",
  /** Environment */
  ENVIRONMENT = "Environment",
  /** Filesystem */
  FILESYSTEM = "Filesystem",
}

/**
 * Env is a reference to an environment variable that contains credentials
 * that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecIdentityEnv
 */
export interface ProviderConfigSpecIdentityEnv {
  /**
   * Name is the name of an environment variable.
   *
   * @schema ProviderConfigSpecIdentityEnv#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ProviderConfigSpecIdentityEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderConfigSpecIdentityEnv(
  obj: ProviderConfigSpecIdentityEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fs is a reference to a filesystem location that contains credentials that
 * must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecIdentityFs
 */
export interface ProviderConfigSpecIdentityFs {
  /**
   * Path is a filesystem path.
   *
   * @schema ProviderConfigSpecIdentityFs#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ProviderConfigSpecIdentityFs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderConfigSpecIdentityFs(
  obj: ProviderConfigSpecIdentityFs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A SecretRef is a reference to a secret key that contains the credentials
 * that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecIdentitySecretRef
 */
export interface ProviderConfigSpecIdentitySecretRef {
  /**
   * The key to select.
   *
   * @schema ProviderConfigSpecIdentitySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ProviderConfigSpecIdentitySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProviderConfigSpecIdentitySecretRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ProviderConfigSpecIdentitySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderConfigSpecIdentitySecretRef(
  obj: ProviderConfigSpecIdentitySecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return _Object
    .entries(result)
    .reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source of the provider credentials.
 *
 * @schema ProviderConfigSpecIdentitySource
 */
export enum ProviderConfigSpecIdentitySource {
  /** None */
  NONE = "None",
  /** Secret */
  SECRET = "Secret",
  /** InjectedIdentity */
  INJECTED_IDENTITY = "InjectedIdentity",
  /** Environment */
  ENVIRONMENT = "Environment",
  /** Filesystem */
  FILESYSTEM = "Filesystem",
}

/**
 * Type of identity.
 *
 * @schema ProviderConfigSpecIdentityType
 */
export enum ProviderConfigSpecIdentityType {
  /** GoogleApplicationCredentials */
  GOOGLE_APPLICATION_CREDENTIALS = "GoogleApplicationCredentials",
  /** AzureServicePrincipalCredentials */
  AZURE_SERVICE_PRINCIPAL_CREDENTIALS = "AzureServicePrincipalCredentials",
  /** AzureWorkloadIdentityCredentials */
  AZURE_WORKLOAD_IDENTITY_CREDENTIALS = "AzureWorkloadIdentityCredentials",
  /** UpboundTokens */
  UPBOUND_TOKENS = "UpboundTokens",
}
