// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ServiceAccountIAMMember is the Schema for the ServiceAccountIAMMembers API. <no value>
 *
 * @schema ServiceAccountIAMMember
 */
export class ServiceAccountIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceAccountIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ServiceAccountIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceAccountIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceAccountIamMemberProps): any {
    return {
      ...ServiceAccountIamMember.GVK,
      ...toJson_ServiceAccountIamMemberProps(props),
    };
  }

  /**
   * Defines a "ServiceAccountIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceAccountIamMemberProps) {
    super(scope, id, {
      ...ServiceAccountIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceAccountIamMember.GVK,
      ...toJson_ServiceAccountIamMemberProps(resolved),
    };
  }
}

/**
 * ServiceAccountIAMMember is the Schema for the ServiceAccountIAMMembers API. <no value>
 *
 * @schema ServiceAccountIAMMember
 */
export interface ServiceAccountIamMemberProps {
  /**
   * @schema ServiceAccountIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceAccountIAMMemberSpec defines the desired state of ServiceAccountIAMMember
   *
   * @schema ServiceAccountIAMMember#spec
   */
  readonly spec: ServiceAccountIamMemberSpec;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberProps(obj: ServiceAccountIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceAccountIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceAccountIAMMemberSpec defines the desired state of ServiceAccountIAMMember
 *
 * @schema ServiceAccountIamMemberSpec
 */
export interface ServiceAccountIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceAccountIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceAccountIamMemberSpecDeletionPolicy;

  /**
   * @schema ServiceAccountIamMemberSpec#forProvider
   */
  readonly forProvider: ServiceAccountIamMemberSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ServiceAccountIamMemberSpec#initProvider
   */
  readonly initProvider?: ServiceAccountIamMemberSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServiceAccountIamMemberSpec#managementPolicies
   */
  readonly managementPolicies?: ServiceAccountIamMemberSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ServiceAccountIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceAccountIamMemberSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ServiceAccountIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceAccountIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema ServiceAccountIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceAccountIamMemberSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpec(obj: ServiceAccountIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceAccountIamMemberSpecForProvider(obj.forProvider),
    'initProvider': toJson_ServiceAccountIamMemberSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServiceAccountIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceAccountIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceAccountIamMemberSpecDeletionPolicy
 */
export enum ServiceAccountIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceAccountIamMemberSpecForProvider
 */
export interface ServiceAccountIamMemberSpecForProvider {
  /**
   * @schema ServiceAccountIamMemberSpecForProvider#condition
   */
  readonly condition?: ServiceAccountIamMemberSpecForProviderCondition[];

  /**
   * @schema ServiceAccountIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema ServiceAccountIamMemberSpecForProvider#role
   */
  readonly role?: string;

  /**
   * @schema ServiceAccountIamMemberSpecForProvider#serviceAccountId
   */
  readonly serviceAccountId?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberSpecForProvider#serviceAccountIdRef
   */
  readonly serviceAccountIdRef?: ServiceAccountIamMemberSpecForProviderServiceAccountIdRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberSpecForProvider#serviceAccountIdSelector
   */
  readonly serviceAccountIdSelector?: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecForProvider(obj: ServiceAccountIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_ServiceAccountIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'role': obj.role,
    'serviceAccountId': obj.serviceAccountId,
    'serviceAccountIdRef': toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdRef(obj.serviceAccountIdRef),
    'serviceAccountIdSelector': toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector(obj.serviceAccountIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ServiceAccountIamMemberSpecInitProvider
 */
export interface ServiceAccountIamMemberSpecInitProvider {
  /**
   * @schema ServiceAccountIamMemberSpecInitProvider#condition
   */
  readonly condition?: ServiceAccountIamMemberSpecInitProviderCondition[];

  /**
   * @schema ServiceAccountIamMemberSpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema ServiceAccountIamMemberSpecInitProvider#role
   */
  readonly role?: string;

  /**
   * @schema ServiceAccountIamMemberSpecInitProvider#serviceAccountId
   */
  readonly serviceAccountId?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberSpecInitProvider#serviceAccountIdRef
   */
  readonly serviceAccountIdRef?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberSpecInitProvider#serviceAccountIdSelector
   */
  readonly serviceAccountIdSelector?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecInitProvider(obj: ServiceAccountIamMemberSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_ServiceAccountIamMemberSpecInitProviderCondition(y)),
    'member': obj.member,
    'role': obj.role,
    'serviceAccountId': obj.serviceAccountId,
    'serviceAccountIdRef': toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef(obj.serviceAccountIdRef),
    'serviceAccountIdSelector': toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector(obj.serviceAccountIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ServiceAccountIamMemberSpecManagementPolicies
 */
export enum ServiceAccountIamMemberSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ServiceAccountIamMemberSpecProviderConfigRef
 */
export interface ServiceAccountIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceAccountIamMemberSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecProviderConfigRef(obj: ServiceAccountIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsTo
 */
export interface ServiceAccountIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsTo(obj: ServiceAccountIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema ServiceAccountIamMemberSpecWriteConnectionSecretToRef
 */
export interface ServiceAccountIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceAccountIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceAccountIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecWriteConnectionSecretToRef(obj: ServiceAccountIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ServiceAccountIamMemberSpecForProviderCondition
 */
export interface ServiceAccountIamMemberSpecForProviderCondition {
  /**
   * @schema ServiceAccountIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ServiceAccountIamMemberSpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ServiceAccountIamMemberSpecForProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecForProviderCondition(obj: ServiceAccountIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRef
 */
export interface ServiceAccountIamMemberSpecForProviderServiceAccountIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRef#policy
   */
  readonly policy?: ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProviderServiceAccountIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdRef(obj: ServiceAccountIamMemberSpecForProviderServiceAccountIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector
 */
export interface ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector#policy
   */
  readonly policy?: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector(obj: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ServiceAccountIamMemberSpecInitProviderCondition
 */
export interface ServiceAccountIamMemberSpecInitProviderCondition {
  /**
   * @schema ServiceAccountIamMemberSpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ServiceAccountIamMemberSpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ServiceAccountIamMemberSpecInitProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecInitProviderCondition(obj: ServiceAccountIamMemberSpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef
 */
export interface ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef#policy
   */
  readonly policy?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef(obj: ServiceAccountIamMemberSpecInitProviderServiceAccountIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector
 */
export interface ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector#policy
   */
  readonly policy?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector(obj: ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberSpecProviderConfigRefPolicy
 */
export interface ServiceAccountIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecProviderConfigRefPolicy(obj: ServiceAccountIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef(obj: ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata(obj: ServiceAccountIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy
 */
export interface ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy(obj: ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy
 */
export interface ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy(obj: ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy
 */
export interface ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy(obj: ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy
 */
export interface ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy(obj: ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum ServiceAccountIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum ServiceAccountIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolution
 */
export enum ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolve
 */
export enum ServiceAccountIamMemberSpecForProviderServiceAccountIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolution
 */
export enum ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolve
 */
export enum ServiceAccountIamMemberSpecForProviderServiceAccountIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicyResolution
 */
export enum ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicyResolve
 */
export enum ServiceAccountIamMemberSpecInitProviderServiceAccountIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicyResolution
 */
export enum ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicyResolve
 */
export enum ServiceAccountIamMemberSpecInitProviderServiceAccountIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceAccountIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServiceAccountIAMMember is the Schema for the ServiceAccountIAMMembers API. <no value>
 *
 * @schema ServiceAccountIAMMemberV1Beta2
 */
export class ServiceAccountIamMemberV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceAccountIAMMemberV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta2',
    kind: 'ServiceAccountIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceAccountIAMMemberV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceAccountIamMemberV1Beta2Props): any {
    return {
      ...ServiceAccountIamMemberV1Beta2.GVK,
      ...toJson_ServiceAccountIamMemberV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ServiceAccountIAMMemberV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceAccountIamMemberV1Beta2Props) {
    super(scope, id, {
      ...ServiceAccountIamMemberV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceAccountIamMemberV1Beta2.GVK,
      ...toJson_ServiceAccountIamMemberV1Beta2Props(resolved),
    };
  }
}

/**
 * ServiceAccountIAMMember is the Schema for the ServiceAccountIAMMembers API. <no value>
 *
 * @schema ServiceAccountIAMMemberV1Beta2
 */
export interface ServiceAccountIamMemberV1Beta2Props {
  /**
   * @schema ServiceAccountIAMMemberV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceAccountIAMMemberSpec defines the desired state of ServiceAccountIAMMember
   *
   * @schema ServiceAccountIAMMemberV1Beta2#spec
   */
  readonly spec: ServiceAccountIamMemberV1Beta2Spec;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2Props(obj: ServiceAccountIamMemberV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceAccountIamMemberV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceAccountIAMMemberSpec defines the desired state of ServiceAccountIAMMember
 *
 * @schema ServiceAccountIamMemberV1Beta2Spec
 */
export interface ServiceAccountIamMemberV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceAccountIamMemberV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceAccountIamMemberV1Beta2SpecDeletionPolicy;

  /**
   * @schema ServiceAccountIamMemberV1Beta2Spec#forProvider
   */
  readonly forProvider: ServiceAccountIamMemberV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ServiceAccountIamMemberV1Beta2Spec#initProvider
   */
  readonly initProvider?: ServiceAccountIamMemberV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServiceAccountIamMemberV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: ServiceAccountIamMemberV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ServiceAccountIamMemberV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceAccountIamMemberV1Beta2SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ServiceAccountIamMemberV1Beta2Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema ServiceAccountIamMemberV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2Spec(obj: ServiceAccountIamMemberV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceAccountIamMemberV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_ServiceAccountIamMemberV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServiceAccountIamMemberV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecDeletionPolicy
 */
export enum ServiceAccountIamMemberV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceAccountIamMemberV1Beta2SpecForProvider
 */
export interface ServiceAccountIamMemberV1Beta2SpecForProvider {
  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecForProvider#condition
   */
  readonly condition?: ServiceAccountIamMemberV1Beta2SpecForProviderCondition;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecForProvider#role
   */
  readonly role?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecForProvider#serviceAccountId
   */
  readonly serviceAccountId?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProvider#serviceAccountIdRef
   */
  readonly serviceAccountIdRef?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProvider#serviceAccountIdSelector
   */
  readonly serviceAccountIdSelector?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecForProvider(obj: ServiceAccountIamMemberV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': toJson_ServiceAccountIamMemberV1Beta2SpecForProviderCondition(obj.condition),
    'member': obj.member,
    'role': obj.role,
    'serviceAccountId': obj.serviceAccountId,
    'serviceAccountIdRef': toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef(obj.serviceAccountIdRef),
    'serviceAccountIdSelector': toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector(obj.serviceAccountIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProvider
 */
export interface ServiceAccountIamMemberV1Beta2SpecInitProvider {
  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProvider#condition
   */
  readonly condition?: ServiceAccountIamMemberV1Beta2SpecInitProviderCondition;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProvider#role
   */
  readonly role?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProvider#serviceAccountId
   */
  readonly serviceAccountId?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProvider#serviceAccountIdRef
   */
  readonly serviceAccountIdRef?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProvider#serviceAccountIdSelector
   */
  readonly serviceAccountIdSelector?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecInitProvider(obj: ServiceAccountIamMemberV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderCondition(obj.condition),
    'member': obj.member,
    'role': obj.role,
    'serviceAccountId': obj.serviceAccountId,
    'serviceAccountIdRef': toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef(obj.serviceAccountIdRef),
    'serviceAccountIdSelector': toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector(obj.serviceAccountIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecManagementPolicies
 */
export enum ServiceAccountIamMemberV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRef
 */
export interface ServiceAccountIamMemberV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecProviderConfigRef(obj: ServiceAccountIamMemberV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsTo
 */
export interface ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsTo(obj: ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef
 */
export interface ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef(obj: ServiceAccountIamMemberV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderCondition
 */
export interface ServiceAccountIamMemberV1Beta2SpecForProviderCondition {
  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecForProviderCondition(obj: ServiceAccountIamMemberV1Beta2SpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef
 */
export interface ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef#policy
   */
  readonly policy?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef(obj: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector
 */
export interface ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector#policy
   */
  readonly policy?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector(obj: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderCondition
 */
export interface ServiceAccountIamMemberV1Beta2SpecInitProviderCondition {
  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderCondition(obj: ServiceAccountIamMemberV1Beta2SpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef
 */
export interface ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef#policy
   */
  readonly policy?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef(obj: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccountId.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector
 */
export interface ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector#policy
   */
  readonly policy?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector(obj: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy
 */
export interface ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy(obj: ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef(obj: ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata
 */
export interface ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata(obj: ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy
 */
export interface ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy(obj: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy
 */
export interface ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy(obj: ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy
 */
export interface ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy(obj: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy
 */
export interface ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy(obj: ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum ServiceAccountIamMemberV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicyResolution
 */
export enum ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicyResolve
 */
export enum ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicyResolution
 */
export enum ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicyResolve
 */
export enum ServiceAccountIamMemberV1Beta2SpecForProviderServiceAccountIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicyResolution
 */
export enum ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicyResolve
 */
export enum ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicyResolution
 */
export enum ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicyResolve
 */
export enum ServiceAccountIamMemberV1Beta2SpecInitProviderServiceAccountIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceAccountIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

