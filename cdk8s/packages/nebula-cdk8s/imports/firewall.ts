// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Firewall is the Schema for the Firewalls API. Each network has its own firewall controlling access to and from the instances.
 *
 * @schema Firewall
 */
export class Firewall extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Firewall"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.gcp.upbound.io/v1beta1',
    kind: 'Firewall',
  }

  /**
   * Renders a Kubernetes manifest for "Firewall".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FirewallProps): any {
    return {
      ...Firewall.GVK,
      ...toJson_FirewallProps(props),
    };
  }

  /**
   * Defines a "Firewall" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FirewallProps) {
    super(scope, id, {
      ...Firewall.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Firewall.GVK,
      ...toJson_FirewallProps(resolved),
    };
  }
}

/**
 * Firewall is the Schema for the Firewalls API. Each network has its own firewall controlling access to and from the instances.
 *
 * @schema Firewall
 */
export interface FirewallProps {
  /**
   * @schema Firewall#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FirewallSpec defines the desired state of Firewall
   *
   * @schema Firewall#spec
   */
  readonly spec: FirewallSpec;
}

/**
 * Converts an object of type 'FirewallProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallProps(obj: FirewallProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FirewallSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FirewallSpec defines the desired state of Firewall
 *
 * @schema FirewallSpec
 */
export interface FirewallSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FirewallSpec#deletionPolicy
   */
  readonly deletionPolicy?: FirewallSpecDeletionPolicy;

  /**
   * @schema FirewallSpec#forProvider
   */
  readonly forProvider: FirewallSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema FirewallSpec#initProvider
   */
  readonly initProvider?: FirewallSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FirewallSpec#managementPolicies
   */
  readonly managementPolicies?: FirewallSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema FirewallSpec#providerConfigRef
   */
  readonly providerConfigRef?: FirewallSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema FirewallSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FirewallSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema FirewallSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FirewallSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'FirewallSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpec(obj: FirewallSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FirewallSpecForProvider(obj.forProvider),
    'initProvider': toJson_FirewallSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FirewallSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FirewallSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FirewallSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FirewallSpecDeletionPolicy
 */
export enum FirewallSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FirewallSpecForProvider
 */
export interface FirewallSpecForProvider {
  /**
   * The list of ALLOW rules specified by this firewall. Each rule
   * specifies a protocol and port-range tuple that describes a permitted
   * connection.
   * Structure is documented below.
   *
   * @schema FirewallSpecForProvider#allow
   */
  readonly allow?: FirewallSpecForProviderAllow[];

  /**
   * The list of DENY rules specified by this firewall. Each rule specifies
   * a protocol and port-range tuple that describes a denied connection.
   * Structure is documented below.
   *
   * @schema FirewallSpecForProvider#deny
   */
  readonly deny?: FirewallSpecForProviderDeny[];

  /**
   * An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema FirewallSpecForProvider#description
   */
  readonly description?: string;

  /**
   * If destination ranges are specified, the firewall will apply only to
   * traffic that has destination IP address in these ranges. These ranges
   * must be expressed in CIDR format. IPv4 or IPv6 ranges are supported.
   *
   * @schema FirewallSpecForProvider#destinationRanges
   */
  readonly destinationRanges?: string[];

  /**
   * Direction of traffic to which this firewall applies; default is
   * INGRESS. Note: For INGRESS traffic, one of source_ranges,
   * source_tags or source_service_accounts is required.
   * Possible values are: INGRESS, EGRESS.
   *
   * @schema FirewallSpecForProvider#direction
   */
  readonly direction?: string;

  /**
   * Denotes whether the firewall rule is disabled, i.e not applied to the
   * network it is associated with. When set to true, the firewall rule is
   * not enforced and the network behaves as if it did not exist. If this
   * is unspecified, the firewall rule will be enabled.
   *
   * @schema FirewallSpecForProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * This field denotes whether to enable logging for a particular firewall rule.
   * If logging is enabled, logs will be exported to Stackdriver. Deprecated in favor of log_config
   *
   * @schema FirewallSpecForProvider#enableLogging
   */
  readonly enableLogging?: boolean;

  /**
   * This field denotes the logging options for a particular firewall rule.
   * If defined, logging is enabled, and logs will be exported to Cloud Logging.
   * Structure is documented below.
   *
   * @schema FirewallSpecForProvider#logConfig
   */
  readonly logConfig?: FirewallSpecForProviderLogConfig[];

  /**
   * The name or self_link of the network to attach this firewall to.
   *
   * @schema FirewallSpecForProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema FirewallSpecForProvider#networkRef
   */
  readonly networkRef?: FirewallSpecForProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema FirewallSpecForProvider#networkSelector
   */
  readonly networkSelector?: FirewallSpecForProviderNetworkSelector;

  /**
   * Priority for this rule. This is an integer between 0 and 65535, both
   * inclusive. When not specified, the value assumed is 1000. Relative
   * priorities determine precedence of conflicting rules. Lower value of
   * priority implies higher precedence (eg, a rule with priority 0 has
   * higher precedence than a rule with priority 1). DENY rules take
   * precedence over ALLOW rules having equal priority.
   *
   * @schema FirewallSpecForProvider#priority
   */
  readonly priority?: number;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema FirewallSpecForProvider#project
   */
  readonly project?: string;

  /**
   * If source ranges are specified, the firewall will apply only to
   * traffic that has source IP address in these ranges. These ranges must
   * be expressed in CIDR format. One or both of sourceRanges and
   * sourceTags may be set. If both properties are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP that belongs to a tag listed in the sourceTags property. The
   * connection does not need to match both properties for the firewall to
   * apply. IPv4 or IPv6 ranges are supported. For INGRESS traffic, one of
   * source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallSpecForProvider#sourceRanges
   */
  readonly sourceRanges?: string[];

  /**
   * If source service accounts are specified, the firewall will apply only
   * to traffic originating from an instance with a service account in this
   * list. Source service accounts cannot be used to control traffic to an
   * instance's external IP address because service accounts are associated
   * with an instance, not an IP address. sourceRanges can be set at the
   * same time as sourceServiceAccounts. If both are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP belongs to an instance with service account listed in
   * sourceServiceAccount. The connection does not need to match both
   * properties for the firewall to apply. sourceServiceAccounts cannot be
   * used at the same time as sourceTags or targetTags. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallSpecForProvider#sourceServiceAccounts
   */
  readonly sourceServiceAccounts?: string[];

  /**
   * If source tags are specified, the firewall will apply only to traffic
   * with source IP that belongs to a tag listed in source tags. Source
   * tags cannot be used to control traffic to an instance's external IP
   * address. Because tags are associated with an instance, not an IP
   * address. One or both of sourceRanges and sourceTags may be set. If
   * both properties are set, the firewall will apply to traffic that has
   * source IP address within sourceRanges OR the source IP that belongs to
   * a tag listed in the sourceTags property. The connection does not need
   * to match both properties for the firewall to apply. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallSpecForProvider#sourceTags
   */
  readonly sourceTags?: string[];

  /**
   * A list of service accounts indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * targetServiceAccounts cannot be used at the same time as targetTags or
   * sourceTags. If neither targetServiceAccounts nor targetTags are
   * specified, the firewall rule applies to all instances on the specified
   * network.
   *
   * @schema FirewallSpecForProvider#targetServiceAccounts
   */
  readonly targetServiceAccounts?: string[];

  /**
   * A list of instance tags indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * If no targetTags are specified, the firewall rule applies to all
   * instances on the specified network.
   *
   * @schema FirewallSpecForProvider#targetTags
   */
  readonly targetTags?: string[];
}

/**
 * Converts an object of type 'FirewallSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProvider(obj: FirewallSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allow': obj.allow?.map(y => toJson_FirewallSpecForProviderAllow(y)),
    'deny': obj.deny?.map(y => toJson_FirewallSpecForProviderDeny(y)),
    'description': obj.description,
    'destinationRanges': obj.destinationRanges?.map(y => y),
    'direction': obj.direction,
    'disabled': obj.disabled,
    'enableLogging': obj.enableLogging,
    'logConfig': obj.logConfig?.map(y => toJson_FirewallSpecForProviderLogConfig(y)),
    'network': obj.network,
    'networkRef': toJson_FirewallSpecForProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_FirewallSpecForProviderNetworkSelector(obj.networkSelector),
    'priority': obj.priority,
    'project': obj.project,
    'sourceRanges': obj.sourceRanges?.map(y => y),
    'sourceServiceAccounts': obj.sourceServiceAccounts?.map(y => y),
    'sourceTags': obj.sourceTags?.map(y => y),
    'targetServiceAccounts': obj.targetServiceAccounts?.map(y => y),
    'targetTags': obj.targetTags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema FirewallSpecInitProvider
 */
export interface FirewallSpecInitProvider {
  /**
   * The list of ALLOW rules specified by this firewall. Each rule
   * specifies a protocol and port-range tuple that describes a permitted
   * connection.
   * Structure is documented below.
   *
   * @schema FirewallSpecInitProvider#allow
   */
  readonly allow?: FirewallSpecInitProviderAllow[];

  /**
   * The list of DENY rules specified by this firewall. Each rule specifies
   * a protocol and port-range tuple that describes a denied connection.
   * Structure is documented below.
   *
   * @schema FirewallSpecInitProvider#deny
   */
  readonly deny?: FirewallSpecInitProviderDeny[];

  /**
   * An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema FirewallSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * If destination ranges are specified, the firewall will apply only to
   * traffic that has destination IP address in these ranges. These ranges
   * must be expressed in CIDR format. IPv4 or IPv6 ranges are supported.
   *
   * @schema FirewallSpecInitProvider#destinationRanges
   */
  readonly destinationRanges?: string[];

  /**
   * Direction of traffic to which this firewall applies; default is
   * INGRESS. Note: For INGRESS traffic, one of source_ranges,
   * source_tags or source_service_accounts is required.
   * Possible values are: INGRESS, EGRESS.
   *
   * @schema FirewallSpecInitProvider#direction
   */
  readonly direction?: string;

  /**
   * Denotes whether the firewall rule is disabled, i.e not applied to the
   * network it is associated with. When set to true, the firewall rule is
   * not enforced and the network behaves as if it did not exist. If this
   * is unspecified, the firewall rule will be enabled.
   *
   * @schema FirewallSpecInitProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * This field denotes whether to enable logging for a particular firewall rule.
   * If logging is enabled, logs will be exported to Stackdriver. Deprecated in favor of log_config
   *
   * @schema FirewallSpecInitProvider#enableLogging
   */
  readonly enableLogging?: boolean;

  /**
   * This field denotes the logging options for a particular firewall rule.
   * If defined, logging is enabled, and logs will be exported to Cloud Logging.
   * Structure is documented below.
   *
   * @schema FirewallSpecInitProvider#logConfig
   */
  readonly logConfig?: FirewallSpecInitProviderLogConfig[];

  /**
   * The name or self_link of the network to attach this firewall to.
   *
   * @schema FirewallSpecInitProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema FirewallSpecInitProvider#networkRef
   */
  readonly networkRef?: FirewallSpecInitProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema FirewallSpecInitProvider#networkSelector
   */
  readonly networkSelector?: FirewallSpecInitProviderNetworkSelector;

  /**
   * Priority for this rule. This is an integer between 0 and 65535, both
   * inclusive. When not specified, the value assumed is 1000. Relative
   * priorities determine precedence of conflicting rules. Lower value of
   * priority implies higher precedence (eg, a rule with priority 0 has
   * higher precedence than a rule with priority 1). DENY rules take
   * precedence over ALLOW rules having equal priority.
   *
   * @schema FirewallSpecInitProvider#priority
   */
  readonly priority?: number;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema FirewallSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * If source ranges are specified, the firewall will apply only to
   * traffic that has source IP address in these ranges. These ranges must
   * be expressed in CIDR format. One or both of sourceRanges and
   * sourceTags may be set. If both properties are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP that belongs to a tag listed in the sourceTags property. The
   * connection does not need to match both properties for the firewall to
   * apply. IPv4 or IPv6 ranges are supported. For INGRESS traffic, one of
   * source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallSpecInitProvider#sourceRanges
   */
  readonly sourceRanges?: string[];

  /**
   * If source service accounts are specified, the firewall will apply only
   * to traffic originating from an instance with a service account in this
   * list. Source service accounts cannot be used to control traffic to an
   * instance's external IP address because service accounts are associated
   * with an instance, not an IP address. sourceRanges can be set at the
   * same time as sourceServiceAccounts. If both are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP belongs to an instance with service account listed in
   * sourceServiceAccount. The connection does not need to match both
   * properties for the firewall to apply. sourceServiceAccounts cannot be
   * used at the same time as sourceTags or targetTags. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallSpecInitProvider#sourceServiceAccounts
   */
  readonly sourceServiceAccounts?: string[];

  /**
   * If source tags are specified, the firewall will apply only to traffic
   * with source IP that belongs to a tag listed in source tags. Source
   * tags cannot be used to control traffic to an instance's external IP
   * address. Because tags are associated with an instance, not an IP
   * address. One or both of sourceRanges and sourceTags may be set. If
   * both properties are set, the firewall will apply to traffic that has
   * source IP address within sourceRanges OR the source IP that belongs to
   * a tag listed in the sourceTags property. The connection does not need
   * to match both properties for the firewall to apply. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallSpecInitProvider#sourceTags
   */
  readonly sourceTags?: string[];

  /**
   * A list of service accounts indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * targetServiceAccounts cannot be used at the same time as targetTags or
   * sourceTags. If neither targetServiceAccounts nor targetTags are
   * specified, the firewall rule applies to all instances on the specified
   * network.
   *
   * @schema FirewallSpecInitProvider#targetServiceAccounts
   */
  readonly targetServiceAccounts?: string[];

  /**
   * A list of instance tags indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * If no targetTags are specified, the firewall rule applies to all
   * instances on the specified network.
   *
   * @schema FirewallSpecInitProvider#targetTags
   */
  readonly targetTags?: string[];
}

/**
 * Converts an object of type 'FirewallSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProvider(obj: FirewallSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allow': obj.allow?.map(y => toJson_FirewallSpecInitProviderAllow(y)),
    'deny': obj.deny?.map(y => toJson_FirewallSpecInitProviderDeny(y)),
    'description': obj.description,
    'destinationRanges': obj.destinationRanges?.map(y => y),
    'direction': obj.direction,
    'disabled': obj.disabled,
    'enableLogging': obj.enableLogging,
    'logConfig': obj.logConfig?.map(y => toJson_FirewallSpecInitProviderLogConfig(y)),
    'network': obj.network,
    'networkRef': toJson_FirewallSpecInitProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_FirewallSpecInitProviderNetworkSelector(obj.networkSelector),
    'priority': obj.priority,
    'project': obj.project,
    'sourceRanges': obj.sourceRanges?.map(y => y),
    'sourceServiceAccounts': obj.sourceServiceAccounts?.map(y => y),
    'sourceTags': obj.sourceTags?.map(y => y),
    'targetServiceAccounts': obj.targetServiceAccounts?.map(y => y),
    'targetTags': obj.targetTags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema FirewallSpecManagementPolicies
 */
export enum FirewallSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema FirewallSpecProviderConfigRef
 */
export interface FirewallSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecProviderConfigRef#policy
   */
  readonly policy?: FirewallSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'FirewallSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecProviderConfigRef(obj: FirewallSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema FirewallSpecPublishConnectionDetailsTo
 */
export interface FirewallSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema FirewallSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FirewallSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FirewallSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FirewallSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FirewallSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'FirewallSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecPublishConnectionDetailsTo(obj: FirewallSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FirewallSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FirewallSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema FirewallSpecWriteConnectionSecretToRef
 */
export interface FirewallSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FirewallSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FirewallSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'FirewallSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecWriteConnectionSecretToRef(obj: FirewallSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallSpecForProviderAllow
 */
export interface FirewallSpecForProviderAllow {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: ["22"], ["80","443"], and
   * ["12345-12349"].
   *
   * @schema FirewallSpecForProviderAllow#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallSpecForProviderAllow#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallSpecForProviderAllow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProviderAllow(obj: FirewallSpecForProviderAllow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallSpecForProviderDeny
 */
export interface FirewallSpecForProviderDeny {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: ["22"], ["80","443"], and
   * ["12345-12349"].
   *
   * @schema FirewallSpecForProviderDeny#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallSpecForProviderDeny#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallSpecForProviderDeny' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProviderDeny(obj: FirewallSpecForProviderDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallSpecForProviderLogConfig
 */
export interface FirewallSpecForProviderLogConfig {
  /**
   * This field denotes whether to include or exclude metadata for firewall logs.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA.
   *
   * @schema FirewallSpecForProviderLogConfig#metadata
   */
  readonly metadata?: string;
}

/**
 * Converts an object of type 'FirewallSpecForProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProviderLogConfig(obj: FirewallSpecForProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema FirewallSpecForProviderNetworkRef
 */
export interface FirewallSpecForProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecForProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecForProviderNetworkRef#policy
   */
  readonly policy?: FirewallSpecForProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'FirewallSpecForProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProviderNetworkRef(obj: FirewallSpecForProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecForProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema FirewallSpecForProviderNetworkSelector
 */
export interface FirewallSpecForProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema FirewallSpecForProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallSpecForProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallSpecForProviderNetworkSelector#policy
   */
  readonly policy?: FirewallSpecForProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'FirewallSpecForProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProviderNetworkSelector(obj: FirewallSpecForProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallSpecForProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallSpecInitProviderAllow
 */
export interface FirewallSpecInitProviderAllow {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: ["22"], ["80","443"], and
   * ["12345-12349"].
   *
   * @schema FirewallSpecInitProviderAllow#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallSpecInitProviderAllow#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallSpecInitProviderAllow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProviderAllow(obj: FirewallSpecInitProviderAllow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallSpecInitProviderDeny
 */
export interface FirewallSpecInitProviderDeny {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: ["22"], ["80","443"], and
   * ["12345-12349"].
   *
   * @schema FirewallSpecInitProviderDeny#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallSpecInitProviderDeny#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallSpecInitProviderDeny' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProviderDeny(obj: FirewallSpecInitProviderDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallSpecInitProviderLogConfig
 */
export interface FirewallSpecInitProviderLogConfig {
  /**
   * This field denotes whether to include or exclude metadata for firewall logs.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA.
   *
   * @schema FirewallSpecInitProviderLogConfig#metadata
   */
  readonly metadata?: string;
}

/**
 * Converts an object of type 'FirewallSpecInitProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProviderLogConfig(obj: FirewallSpecInitProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema FirewallSpecInitProviderNetworkRef
 */
export interface FirewallSpecInitProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecInitProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecInitProviderNetworkRef#policy
   */
  readonly policy?: FirewallSpecInitProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'FirewallSpecInitProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProviderNetworkRef(obj: FirewallSpecInitProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecInitProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema FirewallSpecInitProviderNetworkSelector
 */
export interface FirewallSpecInitProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema FirewallSpecInitProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallSpecInitProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallSpecInitProviderNetworkSelector#policy
   */
  readonly policy?: FirewallSpecInitProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'FirewallSpecInitProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProviderNetworkSelector(obj: FirewallSpecInitProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallSpecInitProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecProviderConfigRefPolicy
 */
export interface FirewallSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'FirewallSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecProviderConfigRefPolicy(obj: FirewallSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema FirewallSpecPublishConnectionDetailsToConfigRef
 */
export interface FirewallSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FirewallSpecPublishConnectionDetailsToConfigRefPolicy;
}

/**
 * Converts an object of type 'FirewallSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecPublishConnectionDetailsToConfigRef(obj: FirewallSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FirewallSpecPublishConnectionDetailsToMetadata
 */
export interface FirewallSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema FirewallSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema FirewallSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema FirewallSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'FirewallSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecPublishConnectionDetailsToMetadata(obj: FirewallSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecForProviderNetworkRefPolicy
 */
export interface FirewallSpecForProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallSpecForProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'FirewallSpecForProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProviderNetworkRefPolicy(obj: FirewallSpecForProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallSpecForProviderNetworkSelectorPolicy
 */
export interface FirewallSpecForProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecForProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: FirewallSpecForProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallSpecForProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: FirewallSpecForProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'FirewallSpecForProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecForProviderNetworkSelectorPolicy(obj: FirewallSpecForProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecInitProviderNetworkRefPolicy
 */
export interface FirewallSpecInitProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecInitProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecInitProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallSpecInitProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecInitProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'FirewallSpecInitProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProviderNetworkRefPolicy(obj: FirewallSpecInitProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallSpecInitProviderNetworkSelectorPolicy
 */
export interface FirewallSpecInitProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecInitProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: FirewallSpecInitProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallSpecInitProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: FirewallSpecInitProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'FirewallSpecInitProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecInitProviderNetworkSelectorPolicy(obj: FirewallSpecInitProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecProviderConfigRefPolicyResolution
 */
export enum FirewallSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallSpecProviderConfigRefPolicyResolve
 */
export enum FirewallSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FirewallSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FirewallSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'FirewallSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallSpecPublishConnectionDetailsToConfigRefPolicy(obj: FirewallSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderNetworkRefPolicyResolution
 */
export enum FirewallSpecForProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallSpecForProviderNetworkRefPolicyResolve
 */
export enum FirewallSpecForProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecForProviderNetworkSelectorPolicyResolution
 */
export enum FirewallSpecForProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallSpecForProviderNetworkSelectorPolicyResolve
 */
export enum FirewallSpecForProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecInitProviderNetworkRefPolicyResolution
 */
export enum FirewallSpecInitProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallSpecInitProviderNetworkRefPolicyResolve
 */
export enum FirewallSpecInitProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecInitProviderNetworkSelectorPolicyResolution
 */
export enum FirewallSpecInitProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallSpecInitProviderNetworkSelectorPolicyResolve
 */
export enum FirewallSpecInitProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FirewallSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Firewall is the Schema for the Firewalls API. Each network has its own firewall controlling access to and from the instances.
 *
 * @schema FirewallV1Beta2
 */
export class FirewallV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FirewallV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.gcp.upbound.io/v1beta2',
    kind: 'Firewall',
  }

  /**
   * Renders a Kubernetes manifest for "FirewallV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FirewallV1Beta2Props): any {
    return {
      ...FirewallV1Beta2.GVK,
      ...toJson_FirewallV1Beta2Props(props),
    };
  }

  /**
   * Defines a "FirewallV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FirewallV1Beta2Props) {
    super(scope, id, {
      ...FirewallV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...FirewallV1Beta2.GVK,
      ...toJson_FirewallV1Beta2Props(resolved),
    };
  }
}

/**
 * Firewall is the Schema for the Firewalls API. Each network has its own firewall controlling access to and from the instances.
 *
 * @schema FirewallV1Beta2
 */
export interface FirewallV1Beta2Props {
  /**
   * @schema FirewallV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FirewallSpec defines the desired state of Firewall
   *
   * @schema FirewallV1Beta2#spec
   */
  readonly spec: FirewallV1Beta2Spec;
}

/**
 * Converts an object of type 'FirewallV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2Props(obj: FirewallV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FirewallV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FirewallSpec defines the desired state of Firewall
 *
 * @schema FirewallV1Beta2Spec
 */
export interface FirewallV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FirewallV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: FirewallV1Beta2SpecDeletionPolicy;

  /**
   * @schema FirewallV1Beta2Spec#forProvider
   */
  readonly forProvider: FirewallV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema FirewallV1Beta2Spec#initProvider
   */
  readonly initProvider?: FirewallV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FirewallV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: FirewallV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema FirewallV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: FirewallV1Beta2SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema FirewallV1Beta2Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FirewallV1Beta2SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema FirewallV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FirewallV1Beta2SpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'FirewallV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2Spec(obj: FirewallV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FirewallV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_FirewallV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FirewallV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FirewallV1Beta2SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FirewallV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FirewallV1Beta2SpecDeletionPolicy
 */
export enum FirewallV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FirewallV1Beta2SpecForProvider
 */
export interface FirewallV1Beta2SpecForProvider {
  /**
   * The list of ALLOW rules specified by this firewall. Each rule
   * specifies a protocol and port-range tuple that describes a permitted
   * connection.
   * Structure is documented below.
   *
   * @schema FirewallV1Beta2SpecForProvider#allow
   */
  readonly allow?: FirewallV1Beta2SpecForProviderAllow[];

  /**
   * The list of DENY rules specified by this firewall. Each rule specifies
   * a protocol and port-range tuple that describes a denied connection.
   * Structure is documented below.
   *
   * @schema FirewallV1Beta2SpecForProvider#deny
   */
  readonly deny?: FirewallV1Beta2SpecForProviderDeny[];

  /**
   * An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema FirewallV1Beta2SpecForProvider#description
   */
  readonly description?: string;

  /**
   * If destination ranges are specified, the firewall will apply only to
   * traffic that has destination IP address in these ranges. These ranges
   * must be expressed in CIDR format. IPv4 or IPv6 ranges are supported.
   *
   * @schema FirewallV1Beta2SpecForProvider#destinationRanges
   */
  readonly destinationRanges?: string[];

  /**
   * Direction of traffic to which this firewall applies; default is
   * INGRESS. Note: For INGRESS traffic, one of source_ranges,
   * source_tags or source_service_accounts is required.
   * Possible values are: INGRESS, EGRESS.
   *
   * @schema FirewallV1Beta2SpecForProvider#direction
   */
  readonly direction?: string;

  /**
   * Denotes whether the firewall rule is disabled, i.e not applied to the
   * network it is associated with. When set to true, the firewall rule is
   * not enforced and the network behaves as if it did not exist. If this
   * is unspecified, the firewall rule will be enabled.
   *
   * @schema FirewallV1Beta2SpecForProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * This field denotes whether to enable logging for a particular firewall rule.
   * If logging is enabled, logs will be exported to Stackdriver. Deprecated in favor of log_config
   *
   * @schema FirewallV1Beta2SpecForProvider#enableLogging
   */
  readonly enableLogging?: boolean;

  /**
   * This field denotes the logging options for a particular firewall rule.
   * If defined, logging is enabled, and logs will be exported to Cloud Logging.
   * Structure is documented below.
   *
   * @schema FirewallV1Beta2SpecForProvider#logConfig
   */
  readonly logConfig?: FirewallV1Beta2SpecForProviderLogConfig;

  /**
   * The name or self_link of the network to attach this firewall to.
   *
   * @schema FirewallV1Beta2SpecForProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema FirewallV1Beta2SpecForProvider#networkRef
   */
  readonly networkRef?: FirewallV1Beta2SpecForProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema FirewallV1Beta2SpecForProvider#networkSelector
   */
  readonly networkSelector?: FirewallV1Beta2SpecForProviderNetworkSelector;

  /**
   * Priority for this rule. This is an integer between 0 and 65535, both
   * inclusive. When not specified, the value assumed is 1000. Relative
   * priorities determine precedence of conflicting rules. Lower value of
   * priority implies higher precedence (eg, a rule with priority 0 has
   * higher precedence than a rule with priority 1). DENY rules take
   * precedence over ALLOW rules having equal priority.
   *
   * @schema FirewallV1Beta2SpecForProvider#priority
   */
  readonly priority?: number;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema FirewallV1Beta2SpecForProvider#project
   */
  readonly project?: string;

  /**
   * If source ranges are specified, the firewall will apply only to
   * traffic that has source IP address in these ranges. These ranges must
   * be expressed in CIDR format. One or both of sourceRanges and
   * sourceTags may be set. If both properties are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP that belongs to a tag listed in the sourceTags property. The
   * connection does not need to match both properties for the firewall to
   * apply. IPv4 or IPv6 ranges are supported. For INGRESS traffic, one of
   * source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallV1Beta2SpecForProvider#sourceRanges
   */
  readonly sourceRanges?: string[];

  /**
   * If source service accounts are specified, the firewall will apply only
   * to traffic originating from an instance with a service account in this
   * list. Source service accounts cannot be used to control traffic to an
   * instance's external IP address because service accounts are associated
   * with an instance, not an IP address. sourceRanges can be set at the
   * same time as sourceServiceAccounts. If both are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP belongs to an instance with service account listed in
   * sourceServiceAccount. The connection does not need to match both
   * properties for the firewall to apply. sourceServiceAccounts cannot be
   * used at the same time as sourceTags or targetTags. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallV1Beta2SpecForProvider#sourceServiceAccounts
   */
  readonly sourceServiceAccounts?: string[];

  /**
   * If source tags are specified, the firewall will apply only to traffic
   * with source IP that belongs to a tag listed in source tags. Source
   * tags cannot be used to control traffic to an instance's external IP
   * address. Because tags are associated with an instance, not an IP
   * address. One or both of sourceRanges and sourceTags may be set. If
   * both properties are set, the firewall will apply to traffic that has
   * source IP address within sourceRanges OR the source IP that belongs to
   * a tag listed in the sourceTags property. The connection does not need
   * to match both properties for the firewall to apply. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallV1Beta2SpecForProvider#sourceTags
   */
  readonly sourceTags?: string[];

  /**
   * A list of service accounts indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * targetServiceAccounts cannot be used at the same time as targetTags or
   * sourceTags. If neither targetServiceAccounts nor targetTags are
   * specified, the firewall rule applies to all instances on the specified
   * network.
   *
   * @schema FirewallV1Beta2SpecForProvider#targetServiceAccounts
   */
  readonly targetServiceAccounts?: string[];

  /**
   * A list of instance tags indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * If no targetTags are specified, the firewall rule applies to all
   * instances on the specified network.
   *
   * @schema FirewallV1Beta2SpecForProvider#targetTags
   */
  readonly targetTags?: string[];
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProvider(obj: FirewallV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allow': obj.allow?.map(y => toJson_FirewallV1Beta2SpecForProviderAllow(y)),
    'deny': obj.deny?.map(y => toJson_FirewallV1Beta2SpecForProviderDeny(y)),
    'description': obj.description,
    'destinationRanges': obj.destinationRanges?.map(y => y),
    'direction': obj.direction,
    'disabled': obj.disabled,
    'enableLogging': obj.enableLogging,
    'logConfig': toJson_FirewallV1Beta2SpecForProviderLogConfig(obj.logConfig),
    'network': obj.network,
    'networkRef': toJson_FirewallV1Beta2SpecForProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_FirewallV1Beta2SpecForProviderNetworkSelector(obj.networkSelector),
    'priority': obj.priority,
    'project': obj.project,
    'sourceRanges': obj.sourceRanges?.map(y => y),
    'sourceServiceAccounts': obj.sourceServiceAccounts?.map(y => y),
    'sourceTags': obj.sourceTags?.map(y => y),
    'targetServiceAccounts': obj.targetServiceAccounts?.map(y => y),
    'targetTags': obj.targetTags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema FirewallV1Beta2SpecInitProvider
 */
export interface FirewallV1Beta2SpecInitProvider {
  /**
   * The list of ALLOW rules specified by this firewall. Each rule
   * specifies a protocol and port-range tuple that describes a permitted
   * connection.
   * Structure is documented below.
   *
   * @schema FirewallV1Beta2SpecInitProvider#allow
   */
  readonly allow?: FirewallV1Beta2SpecInitProviderAllow[];

  /**
   * The list of DENY rules specified by this firewall. Each rule specifies
   * a protocol and port-range tuple that describes a denied connection.
   * Structure is documented below.
   *
   * @schema FirewallV1Beta2SpecInitProvider#deny
   */
  readonly deny?: FirewallV1Beta2SpecInitProviderDeny[];

  /**
   * An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema FirewallV1Beta2SpecInitProvider#description
   */
  readonly description?: string;

  /**
   * If destination ranges are specified, the firewall will apply only to
   * traffic that has destination IP address in these ranges. These ranges
   * must be expressed in CIDR format. IPv4 or IPv6 ranges are supported.
   *
   * @schema FirewallV1Beta2SpecInitProvider#destinationRanges
   */
  readonly destinationRanges?: string[];

  /**
   * Direction of traffic to which this firewall applies; default is
   * INGRESS. Note: For INGRESS traffic, one of source_ranges,
   * source_tags or source_service_accounts is required.
   * Possible values are: INGRESS, EGRESS.
   *
   * @schema FirewallV1Beta2SpecInitProvider#direction
   */
  readonly direction?: string;

  /**
   * Denotes whether the firewall rule is disabled, i.e not applied to the
   * network it is associated with. When set to true, the firewall rule is
   * not enforced and the network behaves as if it did not exist. If this
   * is unspecified, the firewall rule will be enabled.
   *
   * @schema FirewallV1Beta2SpecInitProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * This field denotes whether to enable logging for a particular firewall rule.
   * If logging is enabled, logs will be exported to Stackdriver. Deprecated in favor of log_config
   *
   * @schema FirewallV1Beta2SpecInitProvider#enableLogging
   */
  readonly enableLogging?: boolean;

  /**
   * This field denotes the logging options for a particular firewall rule.
   * If defined, logging is enabled, and logs will be exported to Cloud Logging.
   * Structure is documented below.
   *
   * @schema FirewallV1Beta2SpecInitProvider#logConfig
   */
  readonly logConfig?: FirewallV1Beta2SpecInitProviderLogConfig;

  /**
   * The name or self_link of the network to attach this firewall to.
   *
   * @schema FirewallV1Beta2SpecInitProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema FirewallV1Beta2SpecInitProvider#networkRef
   */
  readonly networkRef?: FirewallV1Beta2SpecInitProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema FirewallV1Beta2SpecInitProvider#networkSelector
   */
  readonly networkSelector?: FirewallV1Beta2SpecInitProviderNetworkSelector;

  /**
   * Priority for this rule. This is an integer between 0 and 65535, both
   * inclusive. When not specified, the value assumed is 1000. Relative
   * priorities determine precedence of conflicting rules. Lower value of
   * priority implies higher precedence (eg, a rule with priority 0 has
   * higher precedence than a rule with priority 1). DENY rules take
   * precedence over ALLOW rules having equal priority.
   *
   * @schema FirewallV1Beta2SpecInitProvider#priority
   */
  readonly priority?: number;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema FirewallV1Beta2SpecInitProvider#project
   */
  readonly project?: string;

  /**
   * If source ranges are specified, the firewall will apply only to
   * traffic that has source IP address in these ranges. These ranges must
   * be expressed in CIDR format. One or both of sourceRanges and
   * sourceTags may be set. If both properties are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP that belongs to a tag listed in the sourceTags property. The
   * connection does not need to match both properties for the firewall to
   * apply. IPv4 or IPv6 ranges are supported. For INGRESS traffic, one of
   * source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallV1Beta2SpecInitProvider#sourceRanges
   */
  readonly sourceRanges?: string[];

  /**
   * If source service accounts are specified, the firewall will apply only
   * to traffic originating from an instance with a service account in this
   * list. Source service accounts cannot be used to control traffic to an
   * instance's external IP address because service accounts are associated
   * with an instance, not an IP address. sourceRanges can be set at the
   * same time as sourceServiceAccounts. If both are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP belongs to an instance with service account listed in
   * sourceServiceAccount. The connection does not need to match both
   * properties for the firewall to apply. sourceServiceAccounts cannot be
   * used at the same time as sourceTags or targetTags. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallV1Beta2SpecInitProvider#sourceServiceAccounts
   */
  readonly sourceServiceAccounts?: string[];

  /**
   * If source tags are specified, the firewall will apply only to traffic
   * with source IP that belongs to a tag listed in source tags. Source
   * tags cannot be used to control traffic to an instance's external IP
   * address. Because tags are associated with an instance, not an IP
   * address. One or both of sourceRanges and sourceTags may be set. If
   * both properties are set, the firewall will apply to traffic that has
   * source IP address within sourceRanges OR the source IP that belongs to
   * a tag listed in the sourceTags property. The connection does not need
   * to match both properties for the firewall to apply. For INGRESS traffic,
   * one of source_ranges, source_tags or source_service_accounts is required.
   *
   * @schema FirewallV1Beta2SpecInitProvider#sourceTags
   */
  readonly sourceTags?: string[];

  /**
   * A list of service accounts indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * targetServiceAccounts cannot be used at the same time as targetTags or
   * sourceTags. If neither targetServiceAccounts nor targetTags are
   * specified, the firewall rule applies to all instances on the specified
   * network.
   *
   * @schema FirewallV1Beta2SpecInitProvider#targetServiceAccounts
   */
  readonly targetServiceAccounts?: string[];

  /**
   * A list of instance tags indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * If no targetTags are specified, the firewall rule applies to all
   * instances on the specified network.
   *
   * @schema FirewallV1Beta2SpecInitProvider#targetTags
   */
  readonly targetTags?: string[];
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProvider(obj: FirewallV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allow': obj.allow?.map(y => toJson_FirewallV1Beta2SpecInitProviderAllow(y)),
    'deny': obj.deny?.map(y => toJson_FirewallV1Beta2SpecInitProviderDeny(y)),
    'description': obj.description,
    'destinationRanges': obj.destinationRanges?.map(y => y),
    'direction': obj.direction,
    'disabled': obj.disabled,
    'enableLogging': obj.enableLogging,
    'logConfig': toJson_FirewallV1Beta2SpecInitProviderLogConfig(obj.logConfig),
    'network': obj.network,
    'networkRef': toJson_FirewallV1Beta2SpecInitProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_FirewallV1Beta2SpecInitProviderNetworkSelector(obj.networkSelector),
    'priority': obj.priority,
    'project': obj.project,
    'sourceRanges': obj.sourceRanges?.map(y => y),
    'sourceServiceAccounts': obj.sourceServiceAccounts?.map(y => y),
    'sourceTags': obj.sourceTags?.map(y => y),
    'targetServiceAccounts': obj.targetServiceAccounts?.map(y => y),
    'targetTags': obj.targetTags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema FirewallV1Beta2SpecManagementPolicies
 */
export enum FirewallV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema FirewallV1Beta2SpecProviderConfigRef
 */
export interface FirewallV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: FirewallV1Beta2SpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecProviderConfigRef(obj: FirewallV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema FirewallV1Beta2SpecPublishConnectionDetailsTo
 */
export interface FirewallV1Beta2SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema FirewallV1Beta2SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FirewallV1Beta2SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FirewallV1Beta2SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FirewallV1Beta2SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FirewallV1Beta2SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecPublishConnectionDetailsTo(obj: FirewallV1Beta2SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FirewallV1Beta2SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FirewallV1Beta2SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema FirewallV1Beta2SpecWriteConnectionSecretToRef
 */
export interface FirewallV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FirewallV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FirewallV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecWriteConnectionSecretToRef(obj: FirewallV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallV1Beta2SpecForProviderAllow
 */
export interface FirewallV1Beta2SpecForProviderAllow {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: ["22"], ["80","443"], and
   * ["12345-12349"].
   *
   * @schema FirewallV1Beta2SpecForProviderAllow#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallV1Beta2SpecForProviderAllow#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProviderAllow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProviderAllow(obj: FirewallV1Beta2SpecForProviderAllow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallV1Beta2SpecForProviderDeny
 */
export interface FirewallV1Beta2SpecForProviderDeny {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: ["22"], ["80","443"], and
   * ["12345-12349"].
   *
   * @schema FirewallV1Beta2SpecForProviderDeny#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallV1Beta2SpecForProviderDeny#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProviderDeny' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProviderDeny(obj: FirewallV1Beta2SpecForProviderDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * This field denotes the logging options for a particular firewall rule.
 * If defined, logging is enabled, and logs will be exported to Cloud Logging.
 * Structure is documented below.
 *
 * @schema FirewallV1Beta2SpecForProviderLogConfig
 */
export interface FirewallV1Beta2SpecForProviderLogConfig {
  /**
   * This field denotes whether to include or exclude metadata for firewall logs.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA.
   *
   * @schema FirewallV1Beta2SpecForProviderLogConfig#metadata
   */
  readonly metadata?: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProviderLogConfig(obj: FirewallV1Beta2SpecForProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkRef
 */
export interface FirewallV1Beta2SpecForProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkRef#policy
   */
  readonly policy?: FirewallV1Beta2SpecForProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProviderNetworkRef(obj: FirewallV1Beta2SpecForProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallV1Beta2SpecForProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkSelector
 */
export interface FirewallV1Beta2SpecForProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkSelector#policy
   */
  readonly policy?: FirewallV1Beta2SpecForProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProviderNetworkSelector(obj: FirewallV1Beta2SpecForProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallV1Beta2SpecForProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallV1Beta2SpecInitProviderAllow
 */
export interface FirewallV1Beta2SpecInitProviderAllow {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: ["22"], ["80","443"], and
   * ["12345-12349"].
   *
   * @schema FirewallV1Beta2SpecInitProviderAllow#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallV1Beta2SpecInitProviderAllow#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProviderAllow' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProviderAllow(obj: FirewallV1Beta2SpecInitProviderAllow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema FirewallV1Beta2SpecInitProviderDeny
 */
export interface FirewallV1Beta2SpecInitProviderDeny {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   * Example inputs include: ["22"], ["80","443"], and
   * ["12345-12349"].
   *
   * @schema FirewallV1Beta2SpecInitProviderDeny#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema FirewallV1Beta2SpecInitProviderDeny#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProviderDeny' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProviderDeny(obj: FirewallV1Beta2SpecInitProviderDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * This field denotes the logging options for a particular firewall rule.
 * If defined, logging is enabled, and logs will be exported to Cloud Logging.
 * Structure is documented below.
 *
 * @schema FirewallV1Beta2SpecInitProviderLogConfig
 */
export interface FirewallV1Beta2SpecInitProviderLogConfig {
  /**
   * This field denotes whether to include or exclude metadata for firewall logs.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA.
   *
   * @schema FirewallV1Beta2SpecInitProviderLogConfig#metadata
   */
  readonly metadata?: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProviderLogConfig(obj: FirewallV1Beta2SpecInitProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkRef
 */
export interface FirewallV1Beta2SpecInitProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkRef#policy
   */
  readonly policy?: FirewallV1Beta2SpecInitProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProviderNetworkRef(obj: FirewallV1Beta2SpecInitProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallV1Beta2SpecInitProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkSelector
 */
export interface FirewallV1Beta2SpecInitProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkSelector#policy
   */
  readonly policy?: FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProviderNetworkSelector(obj: FirewallV1Beta2SpecInitProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallV1Beta2SpecProviderConfigRefPolicy
 */
export interface FirewallV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallV1Beta2SpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecProviderConfigRefPolicy(obj: FirewallV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema FirewallV1Beta2SpecPublishConnectionDetailsToConfigRef
 */
export interface FirewallV1Beta2SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallV1Beta2SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallV1Beta2SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FirewallV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecPublishConnectionDetailsToConfigRef(obj: FirewallV1Beta2SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FirewallV1Beta2SpecPublishConnectionDetailsToMetadata
 */
export interface FirewallV1Beta2SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema FirewallV1Beta2SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema FirewallV1Beta2SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema FirewallV1Beta2SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecPublishConnectionDetailsToMetadata(obj: FirewallV1Beta2SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkRefPolicy
 */
export interface FirewallV1Beta2SpecForProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: FirewallV1Beta2SpecForProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: FirewallV1Beta2SpecForProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProviderNetworkRefPolicy(obj: FirewallV1Beta2SpecForProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkSelectorPolicy
 */
export interface FirewallV1Beta2SpecForProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: FirewallV1Beta2SpecForProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallV1Beta2SpecForProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: FirewallV1Beta2SpecForProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecForProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecForProviderNetworkSelectorPolicy(obj: FirewallV1Beta2SpecForProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkRefPolicy
 */
export interface FirewallV1Beta2SpecInitProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: FirewallV1Beta2SpecInitProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: FirewallV1Beta2SpecInitProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProviderNetworkRefPolicy(obj: FirewallV1Beta2SpecInitProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy
 */
export interface FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: FirewallV1Beta2SpecInitProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: FirewallV1Beta2SpecInitProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy(obj: FirewallV1Beta2SpecInitProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum FirewallV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum FirewallV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FirewallV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FirewallV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema FirewallV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema FirewallV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'FirewallV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FirewallV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj: FirewallV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkRefPolicyResolution
 */
export enum FirewallV1Beta2SpecForProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkRefPolicyResolve
 */
export enum FirewallV1Beta2SpecForProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkSelectorPolicyResolution
 */
export enum FirewallV1Beta2SpecForProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallV1Beta2SpecForProviderNetworkSelectorPolicyResolve
 */
export enum FirewallV1Beta2SpecForProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkRefPolicyResolution
 */
export enum FirewallV1Beta2SpecInitProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkRefPolicyResolve
 */
export enum FirewallV1Beta2SpecInitProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkSelectorPolicyResolution
 */
export enum FirewallV1Beta2SpecInitProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallV1Beta2SpecInitProviderNetworkSelectorPolicyResolve
 */
export enum FirewallV1Beta2SpecInitProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema FirewallV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FirewallV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema FirewallV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FirewallV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

