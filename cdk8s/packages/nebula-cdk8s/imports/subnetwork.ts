// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Subnetwork is the Schema for the Subnetworks API. A VPC network is a virtual version of the traditional physical networks that exist within and between physical data centers.
 *
 * @schema Subnetwork
 */
export class Subnetwork extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Subnetwork"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.gcp.upbound.io/v1beta1',
    kind: 'Subnetwork',
  }

  /**
   * Renders a Kubernetes manifest for "Subnetwork".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SubnetworkProps): any {
    return {
      ...Subnetwork.GVK,
      ...toJson_SubnetworkProps(props),
    };
  }

  /**
   * Defines a "Subnetwork" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SubnetworkProps) {
    super(scope, id, {
      ...Subnetwork.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Subnetwork.GVK,
      ...toJson_SubnetworkProps(resolved),
    };
  }
}

/**
 * Subnetwork is the Schema for the Subnetworks API. A VPC network is a virtual version of the traditional physical networks that exist within and between physical data centers.
 *
 * @schema Subnetwork
 */
export interface SubnetworkProps {
  /**
   * @schema Subnetwork#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SubnetworkSpec defines the desired state of Subnetwork
   *
   * @schema Subnetwork#spec
   */
  readonly spec: SubnetworkSpec;
}

/**
 * Converts an object of type 'SubnetworkProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkProps(obj: SubnetworkProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SubnetworkSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SubnetworkSpec defines the desired state of Subnetwork
 *
 * @schema SubnetworkSpec
 */
export interface SubnetworkSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SubnetworkSpec#deletionPolicy
   */
  readonly deletionPolicy?: SubnetworkSpecDeletionPolicy;

  /**
   * @schema SubnetworkSpec#forProvider
   */
  readonly forProvider: SubnetworkSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema SubnetworkSpec#initProvider
   */
  readonly initProvider?: SubnetworkSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SubnetworkSpec#managementPolicies
   */
  readonly managementPolicies?: SubnetworkSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema SubnetworkSpec#providerConfigRef
   */
  readonly providerConfigRef?: SubnetworkSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema SubnetworkSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SubnetworkSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema SubnetworkSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SubnetworkSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'SubnetworkSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpec(obj: SubnetworkSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SubnetworkSpecForProvider(obj.forProvider),
    'initProvider': toJson_SubnetworkSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SubnetworkSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SubnetworkSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SubnetworkSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SubnetworkSpecDeletionPolicy
 */
export enum SubnetworkSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SubnetworkSpecForProvider
 */
export interface SubnetworkSpecForProvider {
  /**
   * An optional description of this resource. Provide this property when
   * you create the resource. This field can be set only at resource
   * creation time.
   *
   * @schema SubnetworkSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The range of external IPv6 addresses that are owned by this subnetwork.
   *
   * @schema SubnetworkSpecForProvider#externalIpv6Prefix
   */
  readonly externalIpv6Prefix?: string;

  /**
   * The range of internal addresses that are owned by this subnetwork.
   * Provide this property when you create the subnetwork. For example,
   * 10.0.0.0/8 or 192.168.0.0/16. Ranges must be unique and
   * non-overlapping within a network. Only IPv4 is supported.
   *
   * @schema SubnetworkSpecForProvider#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation
   * or the first time the subnet is updated into IPV4_IPV6 dual stack. If the ipv6_type is EXTERNAL then this subnet
   * cannot enable direct path.
   * Possible values are: EXTERNAL, INTERNAL.
   *
   * @schema SubnetworkSpecForProvider#ipv6AccessType
   */
  readonly ipv6AccessType?: string;

  /**
   * This field denotes the VPC flow logging options for this subnetwork. If
   * logging is enabled, logs are exported to Cloud Logging. Flow logging
   * isn't supported if the subnet purpose field is set to subnetwork is
   * REGIONAL_MANAGED_PROXY or GLOBAL_MANAGED_PROXY.
   * Structure is documented below.
   *
   * @schema SubnetworkSpecForProvider#logConfig
   */
  readonly logConfig?: SubnetworkSpecForProviderLogConfig[];

  /**
   * The network this subnet belongs to.
   * Only networks that are in the distributed mode can have subnetworks.
   *
   * @schema SubnetworkSpecForProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema SubnetworkSpecForProvider#networkRef
   */
  readonly networkRef?: SubnetworkSpecForProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema SubnetworkSpecForProvider#networkSelector
   */
  readonly networkSelector?: SubnetworkSpecForProviderNetworkSelector;

  /**
   * When enabled, VMs in this subnetwork without external IP addresses can
   * access Google APIs and services by using Private Google Access.
   *
   * @schema SubnetworkSpecForProvider#privateIpGoogleAccess
   */
  readonly privateIpGoogleAccess?: boolean;

  /**
   * The private IPv6 google access type for the VMs in this subnet.
   *
   * @schema SubnetworkSpecForProvider#privateIpv6GoogleAccess
   */
  readonly privateIpv6GoogleAccess?: string;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema SubnetworkSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The purpose of the resource. This field can be either PRIVATE_RFC_1918, REGIONAL_MANAGED_PROXY, GLOBAL_MANAGED_PROXY, PRIVATE_SERVICE_CONNECT or PRIVATE_NAT(Beta).
   * A subnet with purpose set to REGIONAL_MANAGED_PROXY is a user-created subnetwork that is reserved for regional Envoy-based load balancers.
   * A subnetwork in a given region with purpose set to GLOBAL_MANAGED_PROXY is a proxy-only subnet and is shared between all the cross-regional Envoy-based load balancers.
   * A subnetwork with purpose set to PRIVATE_SERVICE_CONNECT reserves the subnet for hosting a Private Service Connect published service.
   * A subnetwork with purpose set to PRIVATE_NAT is used as source range for Private NAT gateways.
   * Note that REGIONAL_MANAGED_PROXY is the preferred setting for all regional Envoy load balancers.
   * If unspecified, the purpose defaults to PRIVATE_RFC_1918.
   *
   * @schema SubnetworkSpecForProvider#purpose
   */
  readonly purpose?: string;

  /**
   * The GCP region for this subnetwork.
   *
   * @schema SubnetworkSpecForProvider#region
   */
  readonly region: string;

  /**
   * The role of subnetwork.
   * Currently, this field is only used when purpose is REGIONAL_MANAGED_PROXY.
   * The value can be set to ACTIVE or BACKUP.
   * An ACTIVE subnetwork is one that is currently being used for Envoy-based load balancers in a region.
   * A BACKUP subnetwork is one that is ready to be promoted to ACTIVE or is currently draining.
   * Possible values are: ACTIVE, BACKUP.
   *
   * @schema SubnetworkSpecForProvider#role
   */
  readonly role?: string;

  /**
   * An array of configurations for secondary IP ranges for VM instances
   * contained in this subnetwork. The primary IP of such VM must belong
   * to the primary ipCidrRange of the subnetwork. The alias IPs may belong
   * to either primary or secondary ranges.
   * Note: This field uses attr-as-block mode to avoid
   * breaking users during the 0.12 upgrade. To explicitly send a list
   * of zero objects you must use the following syntax:
   * example=[]
   * For more details about this behavior, see this section.
   * Structure is documented below.
   *
   * @schema SubnetworkSpecForProvider#secondaryIpRange
   */
  readonly secondaryIpRange?: SubnetworkSpecForProviderSecondaryIpRange[];

  /**
   * Controls the removal behavior of secondary_ip_range.
   * When false, removing secondary_ip_range from config will not produce a diff as
   * the provider will default to the API's value.
   * When true, the provider will treat removing secondary_ip_range as sending an
   * empty list of secondary IP ranges to the API.
   * Defaults to false.
   *
   * @default false.
   * @schema SubnetworkSpecForProvider#sendSecondaryIpRangeIfEmpty
   */
  readonly sendSecondaryIpRangeIfEmpty?: boolean;

  /**
   * The stack type for this subnet to identify whether the IPv6 feature is enabled or not.
   * If not specified IPV4_ONLY will be used.
   * Possible values are: IPV4_ONLY, IPV4_IPV6.
   *
   * @schema SubnetworkSpecForProvider#stackType
   */
  readonly stackType?: string;
}

/**
 * Converts an object of type 'SubnetworkSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecForProvider(obj: SubnetworkSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'externalIpv6Prefix': obj.externalIpv6Prefix,
    'ipCidrRange': obj.ipCidrRange,
    'ipv6AccessType': obj.ipv6AccessType,
    'logConfig': obj.logConfig?.map(y => toJson_SubnetworkSpecForProviderLogConfig(y)),
    'network': obj.network,
    'networkRef': toJson_SubnetworkSpecForProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_SubnetworkSpecForProviderNetworkSelector(obj.networkSelector),
    'privateIpGoogleAccess': obj.privateIpGoogleAccess,
    'privateIpv6GoogleAccess': obj.privateIpv6GoogleAccess,
    'project': obj.project,
    'purpose': obj.purpose,
    'region': obj.region,
    'role': obj.role,
    'secondaryIpRange': obj.secondaryIpRange?.map(y => toJson_SubnetworkSpecForProviderSecondaryIpRange(y)),
    'sendSecondaryIpRangeIfEmpty': obj.sendSecondaryIpRangeIfEmpty,
    'stackType': obj.stackType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema SubnetworkSpecInitProvider
 */
export interface SubnetworkSpecInitProvider {
  /**
   * An optional description of this resource. Provide this property when
   * you create the resource. This field can be set only at resource
   * creation time.
   *
   * @schema SubnetworkSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The range of external IPv6 addresses that are owned by this subnetwork.
   *
   * @schema SubnetworkSpecInitProvider#externalIpv6Prefix
   */
  readonly externalIpv6Prefix?: string;

  /**
   * The range of internal addresses that are owned by this subnetwork.
   * Provide this property when you create the subnetwork. For example,
   * 10.0.0.0/8 or 192.168.0.0/16. Ranges must be unique and
   * non-overlapping within a network. Only IPv4 is supported.
   *
   * @schema SubnetworkSpecInitProvider#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation
   * or the first time the subnet is updated into IPV4_IPV6 dual stack. If the ipv6_type is EXTERNAL then this subnet
   * cannot enable direct path.
   * Possible values are: EXTERNAL, INTERNAL.
   *
   * @schema SubnetworkSpecInitProvider#ipv6AccessType
   */
  readonly ipv6AccessType?: string;

  /**
   * This field denotes the VPC flow logging options for this subnetwork. If
   * logging is enabled, logs are exported to Cloud Logging. Flow logging
   * isn't supported if the subnet purpose field is set to subnetwork is
   * REGIONAL_MANAGED_PROXY or GLOBAL_MANAGED_PROXY.
   * Structure is documented below.
   *
   * @schema SubnetworkSpecInitProvider#logConfig
   */
  readonly logConfig?: SubnetworkSpecInitProviderLogConfig[];

  /**
   * The network this subnet belongs to.
   * Only networks that are in the distributed mode can have subnetworks.
   *
   * @schema SubnetworkSpecInitProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema SubnetworkSpecInitProvider#networkRef
   */
  readonly networkRef?: SubnetworkSpecInitProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema SubnetworkSpecInitProvider#networkSelector
   */
  readonly networkSelector?: SubnetworkSpecInitProviderNetworkSelector;

  /**
   * When enabled, VMs in this subnetwork without external IP addresses can
   * access Google APIs and services by using Private Google Access.
   *
   * @schema SubnetworkSpecInitProvider#privateIpGoogleAccess
   */
  readonly privateIpGoogleAccess?: boolean;

  /**
   * The private IPv6 google access type for the VMs in this subnet.
   *
   * @schema SubnetworkSpecInitProvider#privateIpv6GoogleAccess
   */
  readonly privateIpv6GoogleAccess?: string;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema SubnetworkSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The purpose of the resource. This field can be either PRIVATE_RFC_1918, REGIONAL_MANAGED_PROXY, GLOBAL_MANAGED_PROXY, PRIVATE_SERVICE_CONNECT or PRIVATE_NAT(Beta).
   * A subnet with purpose set to REGIONAL_MANAGED_PROXY is a user-created subnetwork that is reserved for regional Envoy-based load balancers.
   * A subnetwork in a given region with purpose set to GLOBAL_MANAGED_PROXY is a proxy-only subnet and is shared between all the cross-regional Envoy-based load balancers.
   * A subnetwork with purpose set to PRIVATE_SERVICE_CONNECT reserves the subnet for hosting a Private Service Connect published service.
   * A subnetwork with purpose set to PRIVATE_NAT is used as source range for Private NAT gateways.
   * Note that REGIONAL_MANAGED_PROXY is the preferred setting for all regional Envoy load balancers.
   * If unspecified, the purpose defaults to PRIVATE_RFC_1918.
   *
   * @schema SubnetworkSpecInitProvider#purpose
   */
  readonly purpose?: string;

  /**
   * The role of subnetwork.
   * Currently, this field is only used when purpose is REGIONAL_MANAGED_PROXY.
   * The value can be set to ACTIVE or BACKUP.
   * An ACTIVE subnetwork is one that is currently being used for Envoy-based load balancers in a region.
   * A BACKUP subnetwork is one that is ready to be promoted to ACTIVE or is currently draining.
   * Possible values are: ACTIVE, BACKUP.
   *
   * @schema SubnetworkSpecInitProvider#role
   */
  readonly role?: string;

  /**
   * An array of configurations for secondary IP ranges for VM instances
   * contained in this subnetwork. The primary IP of such VM must belong
   * to the primary ipCidrRange of the subnetwork. The alias IPs may belong
   * to either primary or secondary ranges.
   * Note: This field uses attr-as-block mode to avoid
   * breaking users during the 0.12 upgrade. To explicitly send a list
   * of zero objects you must use the following syntax:
   * example=[]
   * For more details about this behavior, see this section.
   * Structure is documented below.
   *
   * @schema SubnetworkSpecInitProvider#secondaryIpRange
   */
  readonly secondaryIpRange?: SubnetworkSpecInitProviderSecondaryIpRange[];

  /**
   * Controls the removal behavior of secondary_ip_range.
   * When false, removing secondary_ip_range from config will not produce a diff as
   * the provider will default to the API's value.
   * When true, the provider will treat removing secondary_ip_range as sending an
   * empty list of secondary IP ranges to the API.
   * Defaults to false.
   *
   * @default false.
   * @schema SubnetworkSpecInitProvider#sendSecondaryIpRangeIfEmpty
   */
  readonly sendSecondaryIpRangeIfEmpty?: boolean;

  /**
   * The stack type for this subnet to identify whether the IPv6 feature is enabled or not.
   * If not specified IPV4_ONLY will be used.
   * Possible values are: IPV4_ONLY, IPV4_IPV6.
   *
   * @schema SubnetworkSpecInitProvider#stackType
   */
  readonly stackType?: string;
}

/**
 * Converts an object of type 'SubnetworkSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecInitProvider(obj: SubnetworkSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'externalIpv6Prefix': obj.externalIpv6Prefix,
    'ipCidrRange': obj.ipCidrRange,
    'ipv6AccessType': obj.ipv6AccessType,
    'logConfig': obj.logConfig?.map(y => toJson_SubnetworkSpecInitProviderLogConfig(y)),
    'network': obj.network,
    'networkRef': toJson_SubnetworkSpecInitProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_SubnetworkSpecInitProviderNetworkSelector(obj.networkSelector),
    'privateIpGoogleAccess': obj.privateIpGoogleAccess,
    'privateIpv6GoogleAccess': obj.privateIpv6GoogleAccess,
    'project': obj.project,
    'purpose': obj.purpose,
    'role': obj.role,
    'secondaryIpRange': obj.secondaryIpRange?.map(y => toJson_SubnetworkSpecInitProviderSecondaryIpRange(y)),
    'sendSecondaryIpRangeIfEmpty': obj.sendSecondaryIpRangeIfEmpty,
    'stackType': obj.stackType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema SubnetworkSpecManagementPolicies
 */
export enum SubnetworkSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema SubnetworkSpecProviderConfigRef
 */
export interface SubnetworkSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetworkSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetworkSpecProviderConfigRef#policy
   */
  readonly policy?: SubnetworkSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'SubnetworkSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecProviderConfigRef(obj: SubnetworkSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetworkSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema SubnetworkSpecPublishConnectionDetailsTo
 */
export interface SubnetworkSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema SubnetworkSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SubnetworkSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SubnetworkSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SubnetworkSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SubnetworkSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'SubnetworkSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecPublishConnectionDetailsTo(obj: SubnetworkSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SubnetworkSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SubnetworkSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema SubnetworkSpecWriteConnectionSecretToRef
 */
export interface SubnetworkSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SubnetworkSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SubnetworkSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'SubnetworkSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecWriteConnectionSecretToRef(obj: SubnetworkSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubnetworkSpecForProviderLogConfig
 */
export interface SubnetworkSpecForProviderLogConfig {
  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Toggles the aggregation interval for collecting flow logs. Increasing the
   * interval time will reduce the amount of generated flow logs for long
   * lasting connections. Default is an interval of 5 seconds per connection.
   * Default value is INTERVAL_5_SEC.
   * Possible values are: INTERVAL_5_SEC, INTERVAL_30_SEC, INTERVAL_1_MIN, INTERVAL_5_MIN, INTERVAL_10_MIN, INTERVAL_15_MIN.
   *
   * @default an interval of 5 seconds per connection.
   * @schema SubnetworkSpecForProviderLogConfig#aggregationInterval
   */
  readonly aggregationInterval?: string;

  /**
   * Export filter used to define which VPC flow logs should be logged, as as CEL expression. See
   * https://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.
   * The default value is 'true', which evaluates to include everything.
   *
   * @schema SubnetworkSpecForProviderLogConfig#filterExpr
   */
  readonly filterExpr?: string;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * The value of the field must be in [0, 1]. Set the sampling rate of VPC
   * flow logs within the subnetwork where 1.0 means all collected logs are
   * reported and 0.0 means no logs are reported. Default is 0.5 which means
   * half of all collected logs are reported.
   *
   * @default 0.5 which means
   * @schema SubnetworkSpecForProviderLogConfig#flowSampling
   */
  readonly flowSampling?: number;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Configures whether metadata fields should be added to the reported VPC
   * flow logs.
   * Default value is INCLUDE_ALL_METADATA.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA, CUSTOM_METADATA.
   *
   * @schema SubnetworkSpecForProviderLogConfig#metadata
   */
  readonly metadata?: string;

  /**
   * List of metadata fields that should be added to reported logs.
   * Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" is set to CUSTOM_METADATA.
   *
   * @schema SubnetworkSpecForProviderLogConfig#metadataFields
   */
  readonly metadataFields?: string[];
}

/**
 * Converts an object of type 'SubnetworkSpecForProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecForProviderLogConfig(obj: SubnetworkSpecForProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationInterval': obj.aggregationInterval,
    'filterExpr': obj.filterExpr,
    'flowSampling': obj.flowSampling,
    'metadata': obj.metadata,
    'metadataFields': obj.metadataFields?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema SubnetworkSpecForProviderNetworkRef
 */
export interface SubnetworkSpecForProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetworkSpecForProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetworkSpecForProviderNetworkRef#policy
   */
  readonly policy?: SubnetworkSpecForProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'SubnetworkSpecForProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecForProviderNetworkRef(obj: SubnetworkSpecForProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetworkSpecForProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema SubnetworkSpecForProviderNetworkSelector
 */
export interface SubnetworkSpecForProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema SubnetworkSpecForProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubnetworkSpecForProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubnetworkSpecForProviderNetworkSelector#policy
   */
  readonly policy?: SubnetworkSpecForProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'SubnetworkSpecForProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecForProviderNetworkSelector(obj: SubnetworkSpecForProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubnetworkSpecForProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubnetworkSpecForProviderSecondaryIpRange
 */
export interface SubnetworkSpecForProviderSecondaryIpRange {
  /**
   * The range of IP addresses belonging to this subnetwork secondary
   * range. Provide this property when you create the subnetwork.
   * Ranges must be unique and non-overlapping with all primary and
   * secondary IP ranges within a network. Only IPv4 is supported.
   *
   * @schema SubnetworkSpecForProviderSecondaryIpRange#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * The name associated with this subnetwork secondary range, used
   * when adding an alias IP range to a VM instance. The name must
   * be 1-63 characters long, and comply with RFC1035. The name
   * must be unique within the subnetwork.
   *
   * @schema SubnetworkSpecForProviderSecondaryIpRange#rangeName
   */
  readonly rangeName?: string;
}

/**
 * Converts an object of type 'SubnetworkSpecForProviderSecondaryIpRange' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecForProviderSecondaryIpRange(obj: SubnetworkSpecForProviderSecondaryIpRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipCidrRange': obj.ipCidrRange,
    'rangeName': obj.rangeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubnetworkSpecInitProviderLogConfig
 */
export interface SubnetworkSpecInitProviderLogConfig {
  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Toggles the aggregation interval for collecting flow logs. Increasing the
   * interval time will reduce the amount of generated flow logs for long
   * lasting connections. Default is an interval of 5 seconds per connection.
   * Default value is INTERVAL_5_SEC.
   * Possible values are: INTERVAL_5_SEC, INTERVAL_30_SEC, INTERVAL_1_MIN, INTERVAL_5_MIN, INTERVAL_10_MIN, INTERVAL_15_MIN.
   *
   * @default an interval of 5 seconds per connection.
   * @schema SubnetworkSpecInitProviderLogConfig#aggregationInterval
   */
  readonly aggregationInterval?: string;

  /**
   * Export filter used to define which VPC flow logs should be logged, as as CEL expression. See
   * https://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.
   * The default value is 'true', which evaluates to include everything.
   *
   * @schema SubnetworkSpecInitProviderLogConfig#filterExpr
   */
  readonly filterExpr?: string;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * The value of the field must be in [0, 1]. Set the sampling rate of VPC
   * flow logs within the subnetwork where 1.0 means all collected logs are
   * reported and 0.0 means no logs are reported. Default is 0.5 which means
   * half of all collected logs are reported.
   *
   * @default 0.5 which means
   * @schema SubnetworkSpecInitProviderLogConfig#flowSampling
   */
  readonly flowSampling?: number;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Configures whether metadata fields should be added to the reported VPC
   * flow logs.
   * Default value is INCLUDE_ALL_METADATA.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA, CUSTOM_METADATA.
   *
   * @schema SubnetworkSpecInitProviderLogConfig#metadata
   */
  readonly metadata?: string;

  /**
   * List of metadata fields that should be added to reported logs.
   * Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" is set to CUSTOM_METADATA.
   *
   * @schema SubnetworkSpecInitProviderLogConfig#metadataFields
   */
  readonly metadataFields?: string[];
}

/**
 * Converts an object of type 'SubnetworkSpecInitProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecInitProviderLogConfig(obj: SubnetworkSpecInitProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationInterval': obj.aggregationInterval,
    'filterExpr': obj.filterExpr,
    'flowSampling': obj.flowSampling,
    'metadata': obj.metadata,
    'metadataFields': obj.metadataFields?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema SubnetworkSpecInitProviderNetworkRef
 */
export interface SubnetworkSpecInitProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetworkSpecInitProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetworkSpecInitProviderNetworkRef#policy
   */
  readonly policy?: SubnetworkSpecInitProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'SubnetworkSpecInitProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecInitProviderNetworkRef(obj: SubnetworkSpecInitProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetworkSpecInitProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema SubnetworkSpecInitProviderNetworkSelector
 */
export interface SubnetworkSpecInitProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema SubnetworkSpecInitProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubnetworkSpecInitProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubnetworkSpecInitProviderNetworkSelector#policy
   */
  readonly policy?: SubnetworkSpecInitProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'SubnetworkSpecInitProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecInitProviderNetworkSelector(obj: SubnetworkSpecInitProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubnetworkSpecInitProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubnetworkSpecInitProviderSecondaryIpRange
 */
export interface SubnetworkSpecInitProviderSecondaryIpRange {
  /**
   * The range of IP addresses belonging to this subnetwork secondary
   * range. Provide this property when you create the subnetwork.
   * Ranges must be unique and non-overlapping with all primary and
   * secondary IP ranges within a network. Only IPv4 is supported.
   *
   * @schema SubnetworkSpecInitProviderSecondaryIpRange#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * The name associated with this subnetwork secondary range, used
   * when adding an alias IP range to a VM instance. The name must
   * be 1-63 characters long, and comply with RFC1035. The name
   * must be unique within the subnetwork.
   *
   * @schema SubnetworkSpecInitProviderSecondaryIpRange#rangeName
   */
  readonly rangeName?: string;
}

/**
 * Converts an object of type 'SubnetworkSpecInitProviderSecondaryIpRange' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecInitProviderSecondaryIpRange(obj: SubnetworkSpecInitProviderSecondaryIpRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipCidrRange': obj.ipCidrRange,
    'rangeName': obj.rangeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetworkSpecProviderConfigRefPolicy
 */
export interface SubnetworkSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetworkSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetworkSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecProviderConfigRefPolicy(obj: SubnetworkSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema SubnetworkSpecPublishConnectionDetailsToConfigRef
 */
export interface SubnetworkSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetworkSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetworkSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SubnetworkSpecPublishConnectionDetailsToConfigRefPolicy;
}

/**
 * Converts an object of type 'SubnetworkSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecPublishConnectionDetailsToConfigRef(obj: SubnetworkSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetworkSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SubnetworkSpecPublishConnectionDetailsToMetadata
 */
export interface SubnetworkSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema SubnetworkSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema SubnetworkSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema SubnetworkSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'SubnetworkSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecPublishConnectionDetailsToMetadata(obj: SubnetworkSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetworkSpecForProviderNetworkRefPolicy
 */
export interface SubnetworkSpecForProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkSpecForProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: SubnetworkSpecForProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkSpecForProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: SubnetworkSpecForProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkSpecForProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecForProviderNetworkRefPolicy(obj: SubnetworkSpecForProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema SubnetworkSpecForProviderNetworkSelectorPolicy
 */
export interface SubnetworkSpecForProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkSpecForProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: SubnetworkSpecForProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkSpecForProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: SubnetworkSpecForProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkSpecForProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecForProviderNetworkSelectorPolicy(obj: SubnetworkSpecForProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetworkSpecInitProviderNetworkRefPolicy
 */
export interface SubnetworkSpecInitProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkSpecInitProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: SubnetworkSpecInitProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkSpecInitProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: SubnetworkSpecInitProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkSpecInitProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecInitProviderNetworkRefPolicy(obj: SubnetworkSpecInitProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema SubnetworkSpecInitProviderNetworkSelectorPolicy
 */
export interface SubnetworkSpecInitProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkSpecInitProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: SubnetworkSpecInitProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkSpecInitProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: SubnetworkSpecInitProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkSpecInitProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecInitProviderNetworkSelectorPolicy(obj: SubnetworkSpecInitProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkSpecProviderConfigRefPolicyResolution
 */
export enum SubnetworkSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkSpecProviderConfigRefPolicyResolve
 */
export enum SubnetworkSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SubnetworkSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SubnetworkSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetworkSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetworkSpecPublishConnectionDetailsToConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkSpecPublishConnectionDetailsToConfigRefPolicy(obj: SubnetworkSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkSpecForProviderNetworkRefPolicyResolution
 */
export enum SubnetworkSpecForProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkSpecForProviderNetworkRefPolicyResolve
 */
export enum SubnetworkSpecForProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkSpecForProviderNetworkSelectorPolicyResolution
 */
export enum SubnetworkSpecForProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkSpecForProviderNetworkSelectorPolicyResolve
 */
export enum SubnetworkSpecForProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkSpecInitProviderNetworkRefPolicyResolution
 */
export enum SubnetworkSpecInitProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkSpecInitProviderNetworkRefPolicyResolve
 */
export enum SubnetworkSpecInitProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkSpecInitProviderNetworkSelectorPolicyResolution
 */
export enum SubnetworkSpecInitProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkSpecInitProviderNetworkSelectorPolicyResolve
 */
export enum SubnetworkSpecInitProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SubnetworkSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SubnetworkSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Subnetwork is the Schema for the Subnetworks API. A VPC network is a virtual version of the traditional physical networks that exist within and between physical data centers.
 *
 * @schema SubnetworkV1Beta2
 */
export class SubnetworkV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SubnetworkV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.gcp.upbound.io/v1beta2',
    kind: 'Subnetwork',
  }

  /**
   * Renders a Kubernetes manifest for "SubnetworkV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SubnetworkV1Beta2Props): any {
    return {
      ...SubnetworkV1Beta2.GVK,
      ...toJson_SubnetworkV1Beta2Props(props),
    };
  }

  /**
   * Defines a "SubnetworkV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SubnetworkV1Beta2Props) {
    super(scope, id, {
      ...SubnetworkV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...SubnetworkV1Beta2.GVK,
      ...toJson_SubnetworkV1Beta2Props(resolved),
    };
  }
}

/**
 * Subnetwork is the Schema for the Subnetworks API. A VPC network is a virtual version of the traditional physical networks that exist within and between physical data centers.
 *
 * @schema SubnetworkV1Beta2
 */
export interface SubnetworkV1Beta2Props {
  /**
   * @schema SubnetworkV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SubnetworkSpec defines the desired state of Subnetwork
   *
   * @schema SubnetworkV1Beta2#spec
   */
  readonly spec: SubnetworkV1Beta2Spec;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2Props(obj: SubnetworkV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SubnetworkV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SubnetworkSpec defines the desired state of Subnetwork
 *
 * @schema SubnetworkV1Beta2Spec
 */
export interface SubnetworkV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SubnetworkV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: SubnetworkV1Beta2SpecDeletionPolicy;

  /**
   * @schema SubnetworkV1Beta2Spec#forProvider
   */
  readonly forProvider: SubnetworkV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema SubnetworkV1Beta2Spec#initProvider
   */
  readonly initProvider?: SubnetworkV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SubnetworkV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: SubnetworkV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema SubnetworkV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: SubnetworkV1Beta2SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema SubnetworkV1Beta2Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SubnetworkV1Beta2SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema SubnetworkV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SubnetworkV1Beta2SpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2Spec(obj: SubnetworkV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SubnetworkV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_SubnetworkV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SubnetworkV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SubnetworkV1Beta2SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SubnetworkV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SubnetworkV1Beta2SpecDeletionPolicy
 */
export enum SubnetworkV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SubnetworkV1Beta2SpecForProvider
 */
export interface SubnetworkV1Beta2SpecForProvider {
  /**
   * An optional description of this resource. Provide this property when
   * you create the resource. This field can be set only at resource
   * creation time.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#description
   */
  readonly description?: string;

  /**
   * The range of external IPv6 addresses that are owned by this subnetwork.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#externalIpv6Prefix
   */
  readonly externalIpv6Prefix?: string;

  /**
   * The range of internal addresses that are owned by this subnetwork.
   * Provide this property when you create the subnetwork. For example,
   * 10.0.0.0/8 or 192.168.0.0/16. Ranges must be unique and
   * non-overlapping within a network. Only IPv4 is supported.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation
   * or the first time the subnet is updated into IPV4_IPV6 dual stack. If the ipv6_type is EXTERNAL then this subnet
   * cannot enable direct path.
   * Possible values are: EXTERNAL, INTERNAL.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#ipv6AccessType
   */
  readonly ipv6AccessType?: string;

  /**
   * This field denotes the VPC flow logging options for this subnetwork. If
   * logging is enabled, logs are exported to Cloud Logging. Flow logging
   * isn't supported if the subnet purpose field is set to subnetwork is
   * REGIONAL_MANAGED_PROXY or GLOBAL_MANAGED_PROXY.
   * Structure is documented below.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#logConfig
   */
  readonly logConfig?: SubnetworkV1Beta2SpecForProviderLogConfig;

  /**
   * The network this subnet belongs to.
   * Only networks that are in the distributed mode can have subnetworks.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#networkRef
   */
  readonly networkRef?: SubnetworkV1Beta2SpecForProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#networkSelector
   */
  readonly networkSelector?: SubnetworkV1Beta2SpecForProviderNetworkSelector;

  /**
   * When enabled, VMs in this subnetwork without external IP addresses can
   * access Google APIs and services by using Private Google Access.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#privateIpGoogleAccess
   */
  readonly privateIpGoogleAccess?: boolean;

  /**
   * The private IPv6 google access type for the VMs in this subnet.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#privateIpv6GoogleAccess
   */
  readonly privateIpv6GoogleAccess?: string;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#project
   */
  readonly project?: string;

  /**
   * The purpose of the resource. This field can be either PRIVATE_RFC_1918, REGIONAL_MANAGED_PROXY, GLOBAL_MANAGED_PROXY, PRIVATE_SERVICE_CONNECT or PRIVATE_NAT(Beta).
   * A subnet with purpose set to REGIONAL_MANAGED_PROXY is a user-created subnetwork that is reserved for regional Envoy-based load balancers.
   * A subnetwork in a given region with purpose set to GLOBAL_MANAGED_PROXY is a proxy-only subnet and is shared between all the cross-regional Envoy-based load balancers.
   * A subnetwork with purpose set to PRIVATE_SERVICE_CONNECT reserves the subnet for hosting a Private Service Connect published service.
   * A subnetwork with purpose set to PRIVATE_NAT is used as source range for Private NAT gateways.
   * Note that REGIONAL_MANAGED_PROXY is the preferred setting for all regional Envoy load balancers.
   * If unspecified, the purpose defaults to PRIVATE_RFC_1918.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#purpose
   */
  readonly purpose?: string;

  /**
   * The GCP region for this subnetwork.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#region
   */
  readonly region: string;

  /**
   * The role of subnetwork.
   * Currently, this field is only used when purpose is REGIONAL_MANAGED_PROXY.
   * The value can be set to ACTIVE or BACKUP.
   * An ACTIVE subnetwork is one that is currently being used for Envoy-based load balancers in a region.
   * A BACKUP subnetwork is one that is ready to be promoted to ACTIVE or is currently draining.
   * Possible values are: ACTIVE, BACKUP.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#role
   */
  readonly role?: string;

  /**
   * An array of configurations for secondary IP ranges for VM instances
   * contained in this subnetwork. The primary IP of such VM must belong
   * to the primary ipCidrRange of the subnetwork. The alias IPs may belong
   * to either primary or secondary ranges.
   * Note: This field uses attr-as-block mode to avoid
   * breaking users during the 0.12 upgrade. To explicitly send a list of zero objects,
   * set send_secondary_ip_range_if_empty = true
   * Structure is documented below.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#secondaryIpRange
   */
  readonly secondaryIpRange?: SubnetworkV1Beta2SpecForProviderSecondaryIpRange[];

  /**
   * Controls the removal behavior of secondary_ip_range.
   * When false, removing secondary_ip_range from config will not produce a diff as
   * the provider will default to the API's value.
   * When true, the provider will treat removing secondary_ip_range as sending an
   * empty list of secondary IP ranges to the API.
   * Defaults to false.
   *
   * @default false.
   * @schema SubnetworkV1Beta2SpecForProvider#sendSecondaryIpRangeIfEmpty
   */
  readonly sendSecondaryIpRangeIfEmpty?: boolean;

  /**
   * The stack type for this subnet to identify whether the IPv6 feature is enabled or not.
   * If not specified IPV4_ONLY will be used.
   * Possible values are: IPV4_ONLY, IPV4_IPV6.
   *
   * @schema SubnetworkV1Beta2SpecForProvider#stackType
   */
  readonly stackType?: string;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecForProvider(obj: SubnetworkV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'externalIpv6Prefix': obj.externalIpv6Prefix,
    'ipCidrRange': obj.ipCidrRange,
    'ipv6AccessType': obj.ipv6AccessType,
    'logConfig': toJson_SubnetworkV1Beta2SpecForProviderLogConfig(obj.logConfig),
    'network': obj.network,
    'networkRef': toJson_SubnetworkV1Beta2SpecForProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_SubnetworkV1Beta2SpecForProviderNetworkSelector(obj.networkSelector),
    'privateIpGoogleAccess': obj.privateIpGoogleAccess,
    'privateIpv6GoogleAccess': obj.privateIpv6GoogleAccess,
    'project': obj.project,
    'purpose': obj.purpose,
    'region': obj.region,
    'role': obj.role,
    'secondaryIpRange': obj.secondaryIpRange?.map(y => toJson_SubnetworkV1Beta2SpecForProviderSecondaryIpRange(y)),
    'sendSecondaryIpRangeIfEmpty': obj.sendSecondaryIpRangeIfEmpty,
    'stackType': obj.stackType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema SubnetworkV1Beta2SpecInitProvider
 */
export interface SubnetworkV1Beta2SpecInitProvider {
  /**
   * An optional description of this resource. Provide this property when
   * you create the resource. This field can be set only at resource
   * creation time.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The range of external IPv6 addresses that are owned by this subnetwork.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#externalIpv6Prefix
   */
  readonly externalIpv6Prefix?: string;

  /**
   * The range of internal addresses that are owned by this subnetwork.
   * Provide this property when you create the subnetwork. For example,
   * 10.0.0.0/8 or 192.168.0.0/16. Ranges must be unique and
   * non-overlapping within a network. Only IPv4 is supported.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation
   * or the first time the subnet is updated into IPV4_IPV6 dual stack. If the ipv6_type is EXTERNAL then this subnet
   * cannot enable direct path.
   * Possible values are: EXTERNAL, INTERNAL.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#ipv6AccessType
   */
  readonly ipv6AccessType?: string;

  /**
   * This field denotes the VPC flow logging options for this subnetwork. If
   * logging is enabled, logs are exported to Cloud Logging. Flow logging
   * isn't supported if the subnet purpose field is set to subnetwork is
   * REGIONAL_MANAGED_PROXY or GLOBAL_MANAGED_PROXY.
   * Structure is documented below.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#logConfig
   */
  readonly logConfig?: SubnetworkV1Beta2SpecInitProviderLogConfig;

  /**
   * The network this subnet belongs to.
   * Only networks that are in the distributed mode can have subnetworks.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Network in compute to populate network.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#networkRef
   */
  readonly networkRef?: SubnetworkV1Beta2SpecInitProviderNetworkRef;

  /**
   * Selector for a Network in compute to populate network.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#networkSelector
   */
  readonly networkSelector?: SubnetworkV1Beta2SpecInitProviderNetworkSelector;

  /**
   * When enabled, VMs in this subnetwork without external IP addresses can
   * access Google APIs and services by using Private Google Access.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#privateIpGoogleAccess
   */
  readonly privateIpGoogleAccess?: boolean;

  /**
   * The private IPv6 google access type for the VMs in this subnet.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#privateIpv6GoogleAccess
   */
  readonly privateIpv6GoogleAccess?: string;

  /**
   * The ID of the project in which the resource belongs.
   * If it is not provided, the provider project is used.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The purpose of the resource. This field can be either PRIVATE_RFC_1918, REGIONAL_MANAGED_PROXY, GLOBAL_MANAGED_PROXY, PRIVATE_SERVICE_CONNECT or PRIVATE_NAT(Beta).
   * A subnet with purpose set to REGIONAL_MANAGED_PROXY is a user-created subnetwork that is reserved for regional Envoy-based load balancers.
   * A subnetwork in a given region with purpose set to GLOBAL_MANAGED_PROXY is a proxy-only subnet and is shared between all the cross-regional Envoy-based load balancers.
   * A subnetwork with purpose set to PRIVATE_SERVICE_CONNECT reserves the subnet for hosting a Private Service Connect published service.
   * A subnetwork with purpose set to PRIVATE_NAT is used as source range for Private NAT gateways.
   * Note that REGIONAL_MANAGED_PROXY is the preferred setting for all regional Envoy load balancers.
   * If unspecified, the purpose defaults to PRIVATE_RFC_1918.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#purpose
   */
  readonly purpose?: string;

  /**
   * The role of subnetwork.
   * Currently, this field is only used when purpose is REGIONAL_MANAGED_PROXY.
   * The value can be set to ACTIVE or BACKUP.
   * An ACTIVE subnetwork is one that is currently being used for Envoy-based load balancers in a region.
   * A BACKUP subnetwork is one that is ready to be promoted to ACTIVE or is currently draining.
   * Possible values are: ACTIVE, BACKUP.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#role
   */
  readonly role?: string;

  /**
   * An array of configurations for secondary IP ranges for VM instances
   * contained in this subnetwork. The primary IP of such VM must belong
   * to the primary ipCidrRange of the subnetwork. The alias IPs may belong
   * to either primary or secondary ranges.
   * Note: This field uses attr-as-block mode to avoid
   * breaking users during the 0.12 upgrade. To explicitly send a list of zero objects,
   * set send_secondary_ip_range_if_empty = true
   * Structure is documented below.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#secondaryIpRange
   */
  readonly secondaryIpRange?: SubnetworkV1Beta2SpecInitProviderSecondaryIpRange[];

  /**
   * Controls the removal behavior of secondary_ip_range.
   * When false, removing secondary_ip_range from config will not produce a diff as
   * the provider will default to the API's value.
   * When true, the provider will treat removing secondary_ip_range as sending an
   * empty list of secondary IP ranges to the API.
   * Defaults to false.
   *
   * @default false.
   * @schema SubnetworkV1Beta2SpecInitProvider#sendSecondaryIpRangeIfEmpty
   */
  readonly sendSecondaryIpRangeIfEmpty?: boolean;

  /**
   * The stack type for this subnet to identify whether the IPv6 feature is enabled or not.
   * If not specified IPV4_ONLY will be used.
   * Possible values are: IPV4_ONLY, IPV4_IPV6.
   *
   * @schema SubnetworkV1Beta2SpecInitProvider#stackType
   */
  readonly stackType?: string;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecInitProvider(obj: SubnetworkV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'externalIpv6Prefix': obj.externalIpv6Prefix,
    'ipCidrRange': obj.ipCidrRange,
    'ipv6AccessType': obj.ipv6AccessType,
    'logConfig': toJson_SubnetworkV1Beta2SpecInitProviderLogConfig(obj.logConfig),
    'network': obj.network,
    'networkRef': toJson_SubnetworkV1Beta2SpecInitProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_SubnetworkV1Beta2SpecInitProviderNetworkSelector(obj.networkSelector),
    'privateIpGoogleAccess': obj.privateIpGoogleAccess,
    'privateIpv6GoogleAccess': obj.privateIpv6GoogleAccess,
    'project': obj.project,
    'purpose': obj.purpose,
    'role': obj.role,
    'secondaryIpRange': obj.secondaryIpRange?.map(y => toJson_SubnetworkV1Beta2SpecInitProviderSecondaryIpRange(y)),
    'sendSecondaryIpRangeIfEmpty': obj.sendSecondaryIpRangeIfEmpty,
    'stackType': obj.stackType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema SubnetworkV1Beta2SpecManagementPolicies
 */
export enum SubnetworkV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema SubnetworkV1Beta2SpecProviderConfigRef
 */
export interface SubnetworkV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetworkV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetworkV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: SubnetworkV1Beta2SpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecProviderConfigRef(obj: SubnetworkV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetworkV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsTo
 */
export interface SubnetworkV1Beta2SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SubnetworkV1Beta2SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecPublishConnectionDetailsTo(obj: SubnetworkV1Beta2SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SubnetworkV1Beta2SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema SubnetworkV1Beta2SpecWriteConnectionSecretToRef
 */
export interface SubnetworkV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SubnetworkV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SubnetworkV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecWriteConnectionSecretToRef(obj: SubnetworkV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * This field denotes the VPC flow logging options for this subnetwork. If
 * logging is enabled, logs are exported to Cloud Logging. Flow logging
 * isn't supported if the subnet purpose field is set to subnetwork is
 * REGIONAL_MANAGED_PROXY or GLOBAL_MANAGED_PROXY.
 * Structure is documented below.
 *
 * @schema SubnetworkV1Beta2SpecForProviderLogConfig
 */
export interface SubnetworkV1Beta2SpecForProviderLogConfig {
  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Toggles the aggregation interval for collecting flow logs. Increasing the
   * interval time will reduce the amount of generated flow logs for long
   * lasting connections. Default is an interval of 5 seconds per connection.
   * Default value is INTERVAL_5_SEC.
   * Possible values are: INTERVAL_5_SEC, INTERVAL_30_SEC, INTERVAL_1_MIN, INTERVAL_5_MIN, INTERVAL_10_MIN, INTERVAL_15_MIN.
   *
   * @default an interval of 5 seconds per connection.
   * @schema SubnetworkV1Beta2SpecForProviderLogConfig#aggregationInterval
   */
  readonly aggregationInterval?: string;

  /**
   * Export filter used to define which VPC flow logs should be logged, as as CEL expression. See
   * https://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.
   * The default value is 'true', which evaluates to include everything.
   *
   * @schema SubnetworkV1Beta2SpecForProviderLogConfig#filterExpr
   */
  readonly filterExpr?: string;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * The value of the field must be in [0, 1]. Set the sampling rate of VPC
   * flow logs within the subnetwork where 1.0 means all collected logs are
   * reported and 0.0 means no logs are reported. Default is 0.5 which means
   * half of all collected logs are reported.
   *
   * @default 0.5 which means
   * @schema SubnetworkV1Beta2SpecForProviderLogConfig#flowSampling
   */
  readonly flowSampling?: number;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Configures whether metadata fields should be added to the reported VPC
   * flow logs.
   * Default value is INCLUDE_ALL_METADATA.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA, CUSTOM_METADATA.
   *
   * @schema SubnetworkV1Beta2SpecForProviderLogConfig#metadata
   */
  readonly metadata?: string;

  /**
   * List of metadata fields that should be added to reported logs.
   * Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" is set to CUSTOM_METADATA.
   *
   * @schema SubnetworkV1Beta2SpecForProviderLogConfig#metadataFields
   */
  readonly metadataFields?: string[];
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecForProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecForProviderLogConfig(obj: SubnetworkV1Beta2SpecForProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationInterval': obj.aggregationInterval,
    'filterExpr': obj.filterExpr,
    'flowSampling': obj.flowSampling,
    'metadata': obj.metadata,
    'metadataFields': obj.metadataFields?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkRef
 */
export interface SubnetworkV1Beta2SpecForProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkRef#policy
   */
  readonly policy?: SubnetworkV1Beta2SpecForProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecForProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecForProviderNetworkRef(obj: SubnetworkV1Beta2SpecForProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetworkV1Beta2SpecForProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkSelector
 */
export interface SubnetworkV1Beta2SpecForProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkSelector#policy
   */
  readonly policy?: SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecForProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecForProviderNetworkSelector(obj: SubnetworkV1Beta2SpecForProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubnetworkV1Beta2SpecForProviderSecondaryIpRange
 */
export interface SubnetworkV1Beta2SpecForProviderSecondaryIpRange {
  /**
   * The range of IP addresses belonging to this subnetwork secondary
   * range. Provide this property when you create the subnetwork.
   * Ranges must be unique and non-overlapping with all primary and
   * secondary IP ranges within a network. Only IPv4 is supported.
   *
   * @schema SubnetworkV1Beta2SpecForProviderSecondaryIpRange#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * The name associated with this subnetwork secondary range, used
   * when adding an alias IP range to a VM instance. The name must
   * be 1-63 characters long, and comply with RFC1035. The name
   * must be unique within the subnetwork.
   *
   * @schema SubnetworkV1Beta2SpecForProviderSecondaryIpRange#rangeName
   */
  readonly rangeName?: string;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecForProviderSecondaryIpRange' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecForProviderSecondaryIpRange(obj: SubnetworkV1Beta2SpecForProviderSecondaryIpRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipCidrRange': obj.ipCidrRange,
    'rangeName': obj.rangeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * This field denotes the VPC flow logging options for this subnetwork. If
 * logging is enabled, logs are exported to Cloud Logging. Flow logging
 * isn't supported if the subnet purpose field is set to subnetwork is
 * REGIONAL_MANAGED_PROXY or GLOBAL_MANAGED_PROXY.
 * Structure is documented below.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderLogConfig
 */
export interface SubnetworkV1Beta2SpecInitProviderLogConfig {
  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Toggles the aggregation interval for collecting flow logs. Increasing the
   * interval time will reduce the amount of generated flow logs for long
   * lasting connections. Default is an interval of 5 seconds per connection.
   * Default value is INTERVAL_5_SEC.
   * Possible values are: INTERVAL_5_SEC, INTERVAL_30_SEC, INTERVAL_1_MIN, INTERVAL_5_MIN, INTERVAL_10_MIN, INTERVAL_15_MIN.
   *
   * @default an interval of 5 seconds per connection.
   * @schema SubnetworkV1Beta2SpecInitProviderLogConfig#aggregationInterval
   */
  readonly aggregationInterval?: string;

  /**
   * Export filter used to define which VPC flow logs should be logged, as as CEL expression. See
   * https://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.
   * The default value is 'true', which evaluates to include everything.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderLogConfig#filterExpr
   */
  readonly filterExpr?: string;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * The value of the field must be in [0, 1]. Set the sampling rate of VPC
   * flow logs within the subnetwork where 1.0 means all collected logs are
   * reported and 0.0 means no logs are reported. Default is 0.5 which means
   * half of all collected logs are reported.
   *
   * @default 0.5 which means
   * @schema SubnetworkV1Beta2SpecInitProviderLogConfig#flowSampling
   */
  readonly flowSampling?: number;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Configures whether metadata fields should be added to the reported VPC
   * flow logs.
   * Default value is INCLUDE_ALL_METADATA.
   * Possible values are: EXCLUDE_ALL_METADATA, INCLUDE_ALL_METADATA, CUSTOM_METADATA.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderLogConfig#metadata
   */
  readonly metadata?: string;

  /**
   * List of metadata fields that should be added to reported logs.
   * Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" is set to CUSTOM_METADATA.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderLogConfig#metadataFields
   */
  readonly metadataFields?: string[];
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecInitProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecInitProviderLogConfig(obj: SubnetworkV1Beta2SpecInitProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationInterval': obj.aggregationInterval,
    'filterExpr': obj.filterExpr,
    'flowSampling': obj.flowSampling,
    'metadata': obj.metadata,
    'metadataFields': obj.metadataFields?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Network in compute to populate network.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkRef
 */
export interface SubnetworkV1Beta2SpecInitProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkRef#policy
   */
  readonly policy?: SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecInitProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecInitProviderNetworkRef(obj: SubnetworkV1Beta2SpecInitProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Network in compute to populate network.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelector
 */
export interface SubnetworkV1Beta2SpecInitProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelector#policy
   */
  readonly policy?: SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecInitProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecInitProviderNetworkSelector(obj: SubnetworkV1Beta2SpecInitProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubnetworkV1Beta2SpecInitProviderSecondaryIpRange
 */
export interface SubnetworkV1Beta2SpecInitProviderSecondaryIpRange {
  /**
   * The range of IP addresses belonging to this subnetwork secondary
   * range. Provide this property when you create the subnetwork.
   * Ranges must be unique and non-overlapping with all primary and
   * secondary IP ranges within a network. Only IPv4 is supported.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderSecondaryIpRange#ipCidrRange
   */
  readonly ipCidrRange?: string;

  /**
   * The name associated with this subnetwork secondary range, used
   * when adding an alias IP range to a VM instance. The name must
   * be 1-63 characters long, and comply with RFC1035. The name
   * must be unique within the subnetwork.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderSecondaryIpRange#rangeName
   */
  readonly rangeName?: string;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecInitProviderSecondaryIpRange' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecInitProviderSecondaryIpRange(obj: SubnetworkV1Beta2SpecInitProviderSecondaryIpRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipCidrRange': obj.ipCidrRange,
    'rangeName': obj.rangeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetworkV1Beta2SpecProviderConfigRefPolicy
 */
export interface SubnetworkV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetworkV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetworkV1Beta2SpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecProviderConfigRefPolicy(obj: SubnetworkV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRef
 */
export interface SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRef(obj: SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsToMetadata
 */
export interface SubnetworkV1Beta2SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecPublishConnectionDetailsToMetadata(obj: SubnetworkV1Beta2SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkRefPolicy
 */
export interface SubnetworkV1Beta2SpecForProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: SubnetworkV1Beta2SpecForProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: SubnetworkV1Beta2SpecForProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecForProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecForProviderNetworkRefPolicy(obj: SubnetworkV1Beta2SpecForProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy
 */
export interface SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy(obj: SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy
 */
export interface SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: SubnetworkV1Beta2SpecInitProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: SubnetworkV1Beta2SpecInitProviderNetworkRefPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy(obj: SubnetworkV1Beta2SpecInitProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy
 */
export interface SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy(obj: SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum SubnetworkV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum SubnetworkV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj: SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkRefPolicyResolution
 */
export enum SubnetworkV1Beta2SpecForProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkRefPolicyResolve
 */
export enum SubnetworkV1Beta2SpecForProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicyResolution
 */
export enum SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicyResolve
 */
export enum SubnetworkV1Beta2SpecForProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkRefPolicyResolution
 */
export enum SubnetworkV1Beta2SpecInitProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkRefPolicyResolve
 */
export enum SubnetworkV1Beta2SpecInitProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicyResolution
 */
export enum SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicyResolve
 */
export enum SubnetworkV1Beta2SpecInitProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SubnetworkV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

