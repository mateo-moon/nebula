// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ProjectIAMMember is the Schema for the ProjectIAMMembers API. <no value>
 *
 * @schema ProjectIAMMember
 */
export class ProjectIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProjectIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ProjectIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "ProjectIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectIamMemberProps): any {
    return {
      ...ProjectIamMember.GVK,
      ...toJson_ProjectIamMemberProps(props),
    };
  }

  /**
   * Defines a "ProjectIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectIamMemberProps) {
    super(scope, id, {
      ...ProjectIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProjectIamMember.GVK,
      ...toJson_ProjectIamMemberProps(resolved),
    };
  }
}

/**
 * ProjectIAMMember is the Schema for the ProjectIAMMembers API. <no value>
 *
 * @schema ProjectIAMMember
 */
export interface ProjectIamMemberProps {
  /**
   * @schema ProjectIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectIAMMemberSpec defines the desired state of ProjectIAMMember
   *
   * @schema ProjectIAMMember#spec
   */
  readonly spec: ProjectIamMemberSpec;
}

/**
 * Converts an object of type 'ProjectIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberProps(obj: ProjectIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProjectIAMMemberSpec defines the desired state of ProjectIAMMember
 *
 * @schema ProjectIamMemberSpec
 */
export interface ProjectIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectIamMemberSpecDeletionPolicy;

  /**
   * @schema ProjectIamMemberSpec#forProvider
   */
  readonly forProvider: ProjectIamMemberSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ProjectIamMemberSpec#initProvider
   */
  readonly initProvider?: ProjectIamMemberSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProjectIamMemberSpec#managementPolicies
   */
  readonly managementPolicies?: ProjectIamMemberSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ProjectIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectIamMemberSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ProjectIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema ProjectIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectIamMemberSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ProjectIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpec(obj: ProjectIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectIamMemberSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProjectIamMemberSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProjectIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProjectIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectIamMemberSpecDeletionPolicy
 */
export enum ProjectIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectIamMemberSpecForProvider
 */
export interface ProjectIamMemberSpecForProvider {
  /**
   * @schema ProjectIamMemberSpecForProvider#condition
   */
  readonly condition?: ProjectIamMemberSpecForProviderCondition[];

  /**
   * @schema ProjectIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema ProjectIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberSpecForProvider#projectRef
   */
  readonly projectRef?: ProjectIamMemberSpecForProviderProjectRef;

  /**
   * Selector for a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberSpecForProvider#projectSelector
   */
  readonly projectSelector?: ProjectIamMemberSpecForProviderProjectSelector;

  /**
   * @schema ProjectIamMemberSpecForProvider#role
   */
  readonly role?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecForProvider(obj: ProjectIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_ProjectIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'projectRef': toJson_ProjectIamMemberSpecForProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ProjectIamMemberSpecForProviderProjectSelector(obj.projectSelector),
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ProjectIamMemberSpecInitProvider
 */
export interface ProjectIamMemberSpecInitProvider {
  /**
   * @schema ProjectIamMemberSpecInitProvider#condition
   */
  readonly condition?: ProjectIamMemberSpecInitProviderCondition[];

  /**
   * @schema ProjectIamMemberSpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema ProjectIamMemberSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberSpecInitProvider#projectRef
   */
  readonly projectRef?: ProjectIamMemberSpecInitProviderProjectRef;

  /**
   * Selector for a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberSpecInitProvider#projectSelector
   */
  readonly projectSelector?: ProjectIamMemberSpecInitProviderProjectSelector;

  /**
   * @schema ProjectIamMemberSpecInitProvider#role
   */
  readonly role?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecInitProvider(obj: ProjectIamMemberSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_ProjectIamMemberSpecInitProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'projectRef': toJson_ProjectIamMemberSpecInitProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ProjectIamMemberSpecInitProviderProjectSelector(obj.projectSelector),
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ProjectIamMemberSpecManagementPolicies
 */
export enum ProjectIamMemberSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ProjectIamMemberSpecProviderConfigRef
 */
export interface ProjectIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectIamMemberSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecProviderConfigRef(obj: ProjectIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ProjectIamMemberSpecPublishConnectionDetailsTo
 */
export interface ProjectIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecPublishConnectionDetailsTo(obj: ProjectIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema ProjectIamMemberSpecWriteConnectionSecretToRef
 */
export interface ProjectIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecWriteConnectionSecretToRef(obj: ProjectIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ProjectIamMemberSpecForProviderCondition
 */
export interface ProjectIamMemberSpecForProviderCondition {
  /**
   * @schema ProjectIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ProjectIamMemberSpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ProjectIamMemberSpecForProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecForProviderCondition(obj: ProjectIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberSpecForProviderProjectRef
 */
export interface ProjectIamMemberSpecForProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberSpecForProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberSpecForProviderProjectRef#policy
   */
  readonly policy?: ProjectIamMemberSpecForProviderProjectRefPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecForProviderProjectRef(obj: ProjectIamMemberSpecForProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberSpecForProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberSpecForProviderProjectSelector
 */
export interface ProjectIamMemberSpecForProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ProjectIamMemberSpecForProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectIamMemberSpecForProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectIamMemberSpecForProviderProjectSelector#policy
   */
  readonly policy?: ProjectIamMemberSpecForProviderProjectSelectorPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecForProviderProjectSelector(obj: ProjectIamMemberSpecForProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectIamMemberSpecForProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ProjectIamMemberSpecInitProviderCondition
 */
export interface ProjectIamMemberSpecInitProviderCondition {
  /**
   * @schema ProjectIamMemberSpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ProjectIamMemberSpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ProjectIamMemberSpecInitProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecInitProviderCondition(obj: ProjectIamMemberSpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectRef
 */
export interface ProjectIamMemberSpecInitProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectRef#policy
   */
  readonly policy?: ProjectIamMemberSpecInitProviderProjectRefPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecInitProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecInitProviderProjectRef(obj: ProjectIamMemberSpecInitProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberSpecInitProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectSelector
 */
export interface ProjectIamMemberSpecInitProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectSelector#policy
   */
  readonly policy?: ProjectIamMemberSpecInitProviderProjectSelectorPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecInitProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecInitProviderProjectSelector(obj: ProjectIamMemberSpecInitProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectIamMemberSpecInitProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberSpecProviderConfigRefPolicy
 */
export interface ProjectIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecProviderConfigRefPolicy(obj: ProjectIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecPublishConnectionDetailsToConfigRef(obj: ProjectIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface ProjectIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecPublishConnectionDetailsToMetadata(obj: ProjectIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberSpecForProviderProjectRefPolicy
 */
export interface ProjectIamMemberSpecForProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberSpecForProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberSpecForProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberSpecForProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberSpecForProviderProjectRefPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecForProviderProjectRefPolicy(obj: ProjectIamMemberSpecForProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectIamMemberSpecForProviderProjectSelectorPolicy
 */
export interface ProjectIamMemberSpecForProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberSpecForProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberSpecForProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberSpecForProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberSpecForProviderProjectSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecForProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecForProviderProjectSelectorPolicy(obj: ProjectIamMemberSpecForProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectRefPolicy
 */
export interface ProjectIamMemberSpecInitProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberSpecInitProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberSpecInitProviderProjectRefPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecInitProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecInitProviderProjectRefPolicy(obj: ProjectIamMemberSpecInitProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectSelectorPolicy
 */
export interface ProjectIamMemberSpecInitProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberSpecInitProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberSpecInitProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberSpecInitProviderProjectSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecInitProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecInitProviderProjectSelectorPolicy(obj: ProjectIamMemberSpecInitProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum ProjectIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum ProjectIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberSpecForProviderProjectRefPolicyResolution
 */
export enum ProjectIamMemberSpecForProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberSpecForProviderProjectRefPolicyResolve
 */
export enum ProjectIamMemberSpecForProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberSpecForProviderProjectSelectorPolicyResolution
 */
export enum ProjectIamMemberSpecForProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberSpecForProviderProjectSelectorPolicyResolve
 */
export enum ProjectIamMemberSpecForProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectRefPolicyResolution
 */
export enum ProjectIamMemberSpecInitProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectRefPolicyResolve
 */
export enum ProjectIamMemberSpecInitProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectSelectorPolicyResolution
 */
export enum ProjectIamMemberSpecInitProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberSpecInitProviderProjectSelectorPolicyResolve
 */
export enum ProjectIamMemberSpecInitProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProjectIAMMember is the Schema for the ProjectIAMMembers API. <no value>
 *
 * @schema ProjectIAMMemberV1Beta2
 */
export class ProjectIamMemberV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProjectIAMMemberV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta2',
    kind: 'ProjectIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "ProjectIAMMemberV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectIamMemberV1Beta2Props): any {
    return {
      ...ProjectIamMemberV1Beta2.GVK,
      ...toJson_ProjectIamMemberV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ProjectIAMMemberV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectIamMemberV1Beta2Props) {
    super(scope, id, {
      ...ProjectIamMemberV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProjectIamMemberV1Beta2.GVK,
      ...toJson_ProjectIamMemberV1Beta2Props(resolved),
    };
  }
}

/**
 * ProjectIAMMember is the Schema for the ProjectIAMMembers API. <no value>
 *
 * @schema ProjectIAMMemberV1Beta2
 */
export interface ProjectIamMemberV1Beta2Props {
  /**
   * @schema ProjectIAMMemberV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectIAMMemberSpec defines the desired state of ProjectIAMMember
   *
   * @schema ProjectIAMMemberV1Beta2#spec
   */
  readonly spec: ProjectIamMemberV1Beta2Spec;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2Props(obj: ProjectIamMemberV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectIamMemberV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProjectIAMMemberSpec defines the desired state of ProjectIAMMember
 *
 * @schema ProjectIamMemberV1Beta2Spec
 */
export interface ProjectIamMemberV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectIamMemberV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectIamMemberV1Beta2SpecDeletionPolicy;

  /**
   * @schema ProjectIamMemberV1Beta2Spec#forProvider
   */
  readonly forProvider: ProjectIamMemberV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ProjectIamMemberV1Beta2Spec#initProvider
   */
  readonly initProvider?: ProjectIamMemberV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProjectIamMemberV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: ProjectIamMemberV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ProjectIamMemberV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectIamMemberV1Beta2SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ProjectIamMemberV1Beta2Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectIamMemberV1Beta2SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema ProjectIamMemberV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2Spec(obj: ProjectIamMemberV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectIamMemberV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_ProjectIamMemberV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProjectIamMemberV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProjectIamMemberV1Beta2SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectIamMemberV1Beta2SpecDeletionPolicy
 */
export enum ProjectIamMemberV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectIamMemberV1Beta2SpecForProvider
 */
export interface ProjectIamMemberV1Beta2SpecForProvider {
  /**
   * @schema ProjectIamMemberV1Beta2SpecForProvider#condition
   */
  readonly condition?: ProjectIamMemberV1Beta2SpecForProviderCondition;

  /**
   * @schema ProjectIamMemberV1Beta2SpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema ProjectIamMemberV1Beta2SpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProvider#projectRef
   */
  readonly projectRef?: ProjectIamMemberV1Beta2SpecForProviderProjectRef;

  /**
   * Selector for a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProvider#projectSelector
   */
  readonly projectSelector?: ProjectIamMemberV1Beta2SpecForProviderProjectSelector;

  /**
   * @schema ProjectIamMemberV1Beta2SpecForProvider#role
   */
  readonly role?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecForProvider(obj: ProjectIamMemberV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': toJson_ProjectIamMemberV1Beta2SpecForProviderCondition(obj.condition),
    'member': obj.member,
    'project': obj.project,
    'projectRef': toJson_ProjectIamMemberV1Beta2SpecForProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ProjectIamMemberV1Beta2SpecForProviderProjectSelector(obj.projectSelector),
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProvider
 */
export interface ProjectIamMemberV1Beta2SpecInitProvider {
  /**
   * @schema ProjectIamMemberV1Beta2SpecInitProvider#condition
   */
  readonly condition?: ProjectIamMemberV1Beta2SpecInitProviderCondition;

  /**
   * @schema ProjectIamMemberV1Beta2SpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema ProjectIamMemberV1Beta2SpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProvider#projectRef
   */
  readonly projectRef?: ProjectIamMemberV1Beta2SpecInitProviderProjectRef;

  /**
   * Selector for a Project in cloudplatform to populate project.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProvider#projectSelector
   */
  readonly projectSelector?: ProjectIamMemberV1Beta2SpecInitProviderProjectSelector;

  /**
   * @schema ProjectIamMemberV1Beta2SpecInitProvider#role
   */
  readonly role?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecInitProvider(obj: ProjectIamMemberV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': toJson_ProjectIamMemberV1Beta2SpecInitProviderCondition(obj.condition),
    'member': obj.member,
    'project': obj.project,
    'projectRef': toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectSelector(obj.projectSelector),
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ProjectIamMemberV1Beta2SpecManagementPolicies
 */
export enum ProjectIamMemberV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ProjectIamMemberV1Beta2SpecProviderConfigRef
 */
export interface ProjectIamMemberV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecProviderConfigRef(obj: ProjectIamMemberV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsTo
 */
export interface ProjectIamMemberV1Beta2SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecPublishConnectionDetailsTo(obj: ProjectIamMemberV1Beta2SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef
 */
export interface ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef(obj: ProjectIamMemberV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ProjectIamMemberV1Beta2SpecForProviderCondition
 */
export interface ProjectIamMemberV1Beta2SpecForProviderCondition {
  /**
   * @schema ProjectIamMemberV1Beta2SpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ProjectIamMemberV1Beta2SpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ProjectIamMemberV1Beta2SpecForProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecForProviderCondition(obj: ProjectIamMemberV1Beta2SpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRef
 */
export interface ProjectIamMemberV1Beta2SpecForProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRef#policy
   */
  readonly policy?: ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecForProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecForProviderProjectRef(obj: ProjectIamMemberV1Beta2SpecForProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelector
 */
export interface ProjectIamMemberV1Beta2SpecForProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelector#policy
   */
  readonly policy?: ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecForProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecForProviderProjectSelector(obj: ProjectIamMemberV1Beta2SpecForProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ProjectIamMemberV1Beta2SpecInitProviderCondition
 */
export interface ProjectIamMemberV1Beta2SpecInitProviderCondition {
  /**
   * @schema ProjectIamMemberV1Beta2SpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ProjectIamMemberV1Beta2SpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema ProjectIamMemberV1Beta2SpecInitProviderCondition#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecInitProviderCondition(obj: ProjectIamMemberV1Beta2SpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRef
 */
export interface ProjectIamMemberV1Beta2SpecInitProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRef#policy
   */
  readonly policy?: ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecInitProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectRef(obj: ProjectIamMemberV1Beta2SpecInitProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector for a Project in cloudplatform to populate project.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelector
 */
export interface ProjectIamMemberV1Beta2SpecInitProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelector#policy
   */
  readonly policy?: ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecInitProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectSelector(obj: ProjectIamMemberV1Beta2SpecInitProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy
 */
export interface ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberV1Beta2SpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy(obj: ProjectIamMemberV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef(obj: ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata
 */
export interface ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata(obj: ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy
 */
export interface ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy(obj: ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy
 */
export interface ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy(obj: ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy
 */
export interface ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy(obj: ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy
 */
export interface ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy(obj: ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum ProjectIamMemberV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum ProjectIamMemberV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicyResolution
 */
export enum ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicyResolve
 */
export enum ProjectIamMemberV1Beta2SpecForProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicyResolution
 */
export enum ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicyResolve
 */
export enum ProjectIamMemberV1Beta2SpecForProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicyResolution
 */
export enum ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicyResolve
 */
export enum ProjectIamMemberV1Beta2SpecInitProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicyResolution
 */
export enum ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicyResolve
 */
export enum ProjectIamMemberV1Beta2SpecInitProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectIamMemberV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

