// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A Composition defines a collection of managed resources or functions that
Crossplane uses to create and manage new composite resources.

Read the Crossplane documentation for
[more information about Compositions](https://docs.crossplane.io/latest/concepts/compositions).
 *
 * @schema Composition
 */
export class Composition extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Composition"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apiextensions.crossplane.io/v1',
    kind: 'Composition',
  }

  /**
   * Renders a Kubernetes manifest for "Composition".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CompositionProps = {}): any {
    return {
      ...Composition.GVK,
      ...toJson_CompositionProps(props),
    };
  }

  /**
   * Defines a "Composition" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CompositionProps = {}) {
    super(scope, id, {
      ...Composition.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Composition.GVK,
      ...toJson_CompositionProps(resolved),
    };
  }
}

/**
 * A Composition defines a collection of managed resources or functions that
 * Crossplane uses to create and manage new composite resources.
 *
 * Read the Crossplane documentation for
 * [more information about Compositions](https://docs.crossplane.io/latest/concepts/compositions).
 *
 * @schema Composition
 */
export interface CompositionProps {
  /**
   * @schema Composition#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CompositionSpec specifies desired state of a composition.
   *
   * @schema Composition#spec
   */
  readonly spec?: CompositionSpec;
}

/**
 * Converts an object of type 'CompositionProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionProps(obj: CompositionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CompositionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CompositionSpec specifies desired state of a composition.
 *
 * @schema CompositionSpec
 */
export interface CompositionSpec {
  /**
   * CompositeTypeRef specifies the type of composite resource that this
   * composition is compatible with.
   *
   * @schema CompositionSpec#compositeTypeRef
   */
  readonly compositeTypeRef: CompositionSpecCompositeTypeRef;

  /**
   * Mode controls what type or "mode" of Composition will be used.
   *
   * "Pipeline" indicates that a Composition specifies a pipeline of
   * Composition Functions, each of which is responsible for producing
   * composed resources that Crossplane should create or update.
   *
   * "Resources" indicates that a Composition uses what is commonly referred
   * to as "Patch & Transform" or P&T composition. This mode of Composition
   * uses an array of resources, each a template for a composed resource.
   *
   * All Compositions should use Pipeline mode. Resources mode is deprecated.
   * Resources mode won't be removed in Crossplane 1.x, and will remain the
   * default to avoid breaking legacy Compositions. However, it's no longer
   * accepting new features, and only accepting security related bug fixes.
   *
   * @schema CompositionSpec#mode
   */
  readonly mode?: CompositionSpecMode;

  /**
   * PatchSets define a named set of patches that may be included by any
   * resource in this Composition. PatchSets cannot themselves refer to other
   * PatchSets.
   *
   * PatchSets are only used by the "Resources" mode of Composition. They
   * are ignored by other modes.
   *
   * Deprecated: Use Composition Functions instead.
   *
   * @schema CompositionSpec#patchSets
   */
  readonly patchSets?: CompositionSpecPatchSets[];

  /**
   * Pipeline is a list of composition function steps that will be used when a
   * composite resource referring to this composition is created. One of
   * resources and pipeline must be specified - you cannot specify both.
   *
   * The Pipeline is only used by the "Pipeline" mode of Composition. It is
   * ignored by other modes.
   *
   * @schema CompositionSpec#pipeline
   */
  readonly pipeline?: CompositionSpecPipeline[];

  /**
   * PublishConnectionDetailsWithStoreConfig specifies the secret store config
   * with which the connection details of composite resources dynamically
   * provisioned using this composition will be published.
   *
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
   * unless the relevant Crossplane feature flag is enabled, and may be
   * changed or removed without notice.
   *
   * @schema CompositionSpec#publishConnectionDetailsWithStoreConfigRef
   */
  readonly publishConnectionDetailsWithStoreConfigRef?: CompositionSpecPublishConnectionDetailsWithStoreConfigRef;

  /**
   * Resources is a list of resource templates that will be used when a
   * composite resource referring to this composition is created.
   *
   * Resources are only used by the "Resources" mode of Composition. They are
   * ignored by other modes.
   *
   * Deprecated: Use Composition Functions instead.
   *
   * @schema CompositionSpec#resources
   */
  readonly resources?: CompositionSpecResources[];

  /**
   * WriteConnectionSecretsToNamespace specifies the namespace in which the
   * connection secrets of composite resource dynamically provisioned using
   * this composition will be created.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsWithStoreConfigRef. Currently, both could be
   * set independently and connection details would be published to both
   * without affecting each other as long as related fields at MR level
   * specified.
   *
   * @schema CompositionSpec#writeConnectionSecretsToNamespace
   */
  readonly writeConnectionSecretsToNamespace?: string;
}

/**
 * Converts an object of type 'CompositionSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpec(obj: CompositionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compositeTypeRef': toJson_CompositionSpecCompositeTypeRef(obj.compositeTypeRef),
    'mode': obj.mode,
    'patchSets': obj.patchSets?.map(y => toJson_CompositionSpecPatchSets(y)),
    'pipeline': obj.pipeline?.map(y => toJson_CompositionSpecPipeline(y)),
    'publishConnectionDetailsWithStoreConfigRef': toJson_CompositionSpecPublishConnectionDetailsWithStoreConfigRef(obj.publishConnectionDetailsWithStoreConfigRef),
    'resources': obj.resources?.map(y => toJson_CompositionSpecResources(y)),
    'writeConnectionSecretsToNamespace': obj.writeConnectionSecretsToNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CompositeTypeRef specifies the type of composite resource that this
 * composition is compatible with.
 *
 * @schema CompositionSpecCompositeTypeRef
 */
export interface CompositionSpecCompositeTypeRef {
  /**
   * APIVersion of the type.
   *
   * @schema CompositionSpecCompositeTypeRef#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind of the type.
   *
   * @schema CompositionSpecCompositeTypeRef#kind
   */
  readonly kind: string;
}

/**
 * Converts an object of type 'CompositionSpecCompositeTypeRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecCompositeTypeRef(obj: CompositionSpecCompositeTypeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Mode controls what type or "mode" of Composition will be used.
 *
 * "Pipeline" indicates that a Composition specifies a pipeline of
 * Composition Functions, each of which is responsible for producing
 * composed resources that Crossplane should create or update.
 *
 * "Resources" indicates that a Composition uses what is commonly referred
 * to as "Patch & Transform" or P&T composition. This mode of Composition
 * uses an array of resources, each a template for a composed resource.
 *
 * All Compositions should use Pipeline mode. Resources mode is deprecated.
 * Resources mode won't be removed in Crossplane 1.x, and will remain the
 * default to avoid breaking legacy Compositions. However, it's no longer
 * accepting new features, and only accepting security related bug fixes.
 *
 * @schema CompositionSpecMode
 */
export enum CompositionSpecMode {
  /** Resources */
  RESOURCES = "Resources",
  /** Pipeline */
  PIPELINE = "Pipeline",
}

/**
 * A PatchSet is a set of patches that can be reused from all resources within
 * a Composition.
 *
 * @schema CompositionSpecPatchSets
 */
export interface CompositionSpecPatchSets {
  /**
   * Name of this PatchSet.
   *
   * @schema CompositionSpecPatchSets#name
   */
  readonly name: string;

  /**
   * Patches will be applied as an overlay to the base resource.
   *
   * @schema CompositionSpecPatchSets#patches
   */
  readonly patches: CompositionSpecPatchSetsPatches[];
}

/**
 * Converts an object of type 'CompositionSpecPatchSets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPatchSets(obj: CompositionSpecPatchSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'patches': obj.patches?.map(y => toJson_CompositionSpecPatchSetsPatches(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A PipelineStep in a Composition Function pipeline.
 *
 * @schema CompositionSpecPipeline
 */
export interface CompositionSpecPipeline {
  /**
   * Credentials are optional credentials that the Composition Function needs.
   *
   * @schema CompositionSpecPipeline#credentials
   */
  readonly credentials?: CompositionSpecPipelineCredentials[];

  /**
   * FunctionRef is a reference to the Composition Function this step should
   * execute.
   *
   * @schema CompositionSpecPipeline#functionRef
   */
  readonly functionRef: CompositionSpecPipelineFunctionRef;

  /**
   * Input is an optional, arbitrary Kubernetes resource (i.e. a resource
   * with an apiVersion and kind) that will be passed to the Composition
   * Function as the 'input' of its RunFunctionRequest.
   *
   * @schema CompositionSpecPipeline#input
   */
  readonly input?: any;

  /**
   * Step name. Must be unique within its Pipeline.
   *
   * @schema CompositionSpecPipeline#step
   */
  readonly step: string;
}

/**
 * Converts an object of type 'CompositionSpecPipeline' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPipeline(obj: CompositionSpecPipeline | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': obj.credentials?.map(y => toJson_CompositionSpecPipelineCredentials(y)),
    'functionRef': toJson_CompositionSpecPipelineFunctionRef(obj.functionRef),
    'input': obj.input,
    'step': obj.step,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PublishConnectionDetailsWithStoreConfig specifies the secret store config
 * with which the connection details of composite resources dynamically
 * provisioned using this composition will be published.
 *
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
 * unless the relevant Crossplane feature flag is enabled, and may be
 * changed or removed without notice.
 *
 * @schema CompositionSpecPublishConnectionDetailsWithStoreConfigRef
 */
export interface CompositionSpecPublishConnectionDetailsWithStoreConfigRef {
  /**
   * Name of the referenced StoreConfig.
   *
   * @schema CompositionSpecPublishConnectionDetailsWithStoreConfigRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'CompositionSpecPublishConnectionDetailsWithStoreConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPublishConnectionDetailsWithStoreConfigRef(obj: CompositionSpecPublishConnectionDetailsWithStoreConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ComposedTemplate is used to provide information about how the composed resource
 * should be processed.
 *
 * @schema CompositionSpecResources
 */
export interface CompositionSpecResources {
  /**
   * Base is the target resource that the patches will be applied on.
   *
   * @schema CompositionSpecResources#base
   */
  readonly base: any;

  /**
   * ConnectionDetails lists the propagation secret keys from this target
   * resource to the composition instance connection secret.
   *
   * @schema CompositionSpecResources#connectionDetails
   */
  readonly connectionDetails?: CompositionSpecResourcesConnectionDetails[];

  /**
   * A Name uniquely identifies this entry within its Composition's resources
   * array. Names are optional but *strongly* recommended. When all entries in
   * the resources array are named entries may added, deleted, and reordered
   * as long as their names do not change. When entries are not named the
   * length and order of the resources array should be treated as immutable.
   * Either all or no entries must be named.
   *
   * @schema CompositionSpecResources#name
   */
  readonly name?: string;

  /**
   * Patches will be applied as overlay to the base resource.
   *
   * @schema CompositionSpecResources#patches
   */
  readonly patches?: CompositionSpecResourcesPatches[];

  /**
   * ReadinessChecks allows users to define custom readiness checks. All checks
   * have to return true in order for resource to be considered ready. The
   * default readiness check is to have the "Ready" condition to be "True".
   *
   * @schema CompositionSpecResources#readinessChecks
   */
  readonly readinessChecks?: CompositionSpecResourcesReadinessChecks[];
}

/**
 * Converts an object of type 'CompositionSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResources(obj: CompositionSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base': obj.base,
    'connectionDetails': obj.connectionDetails?.map(y => toJson_CompositionSpecResourcesConnectionDetails(y)),
    'name': obj.name,
    'patches': obj.patches?.map(y => toJson_CompositionSpecResourcesPatches(y)),
    'readinessChecks': obj.readinessChecks?.map(y => toJson_CompositionSpecResourcesReadinessChecks(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Patch objects are applied between composite and composed resources. Their
 * behaviour depends on the Type selected. The default Type,
 * FromCompositeFieldPath, copies a value from the composite resource to
 * the composed resource, applying any defined transformers.
 *
 * @schema CompositionSpecPatchSetsPatches
 */
export interface CompositionSpecPatchSetsPatches {
  /**
   * Combine is the patch configuration for a CombineFromComposite or
   * CombineToComposite patch.
   *
   * @schema CompositionSpecPatchSetsPatches#combine
   */
  readonly combine?: CompositionSpecPatchSetsPatchesCombine;

  /**
   * FromFieldPath is the path of the field on the resource whose value is
   * to be used as input. Required when type is FromCompositeFieldPath or
   * ToCompositeFieldPath.
   *
   * @schema CompositionSpecPatchSetsPatches#fromFieldPath
   */
  readonly fromFieldPath?: string;

  /**
   * PatchSetName to include patches from. Required when type is PatchSet.
   *
   * @schema CompositionSpecPatchSetsPatches#patchSetName
   */
  readonly patchSetName?: string;

  /**
   * Policy configures the specifics of patching behaviour.
   *
   * @schema CompositionSpecPatchSetsPatches#policy
   */
  readonly policy?: CompositionSpecPatchSetsPatchesPolicy;

  /**
   * ToFieldPath is the path of the field on the resource whose value will
   * be changed with the result of transforms. Leave empty if you'd like to
   * propagate to the same path as fromFieldPath.
   *
   * @schema CompositionSpecPatchSetsPatches#toFieldPath
   */
  readonly toFieldPath?: string;

  /**
   * Transforms are the list of functions that are used as a FIFO pipe for the
   * input to be transformed.
   *
   * @schema CompositionSpecPatchSetsPatches#transforms
   */
  readonly transforms?: CompositionSpecPatchSetsPatchesTransforms[];

  /**
   * Type sets the patching behaviour to be used. Each patch type may require
   * its own fields to be set on the Patch object.
   *
   * @schema CompositionSpecPatchSetsPatches#type
   */
  readonly type?: CompositionSpecPatchSetsPatchesType;
}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatches' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPatchSetsPatches(obj: CompositionSpecPatchSetsPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'combine': toJson_CompositionSpecPatchSetsPatchesCombine(obj.combine),
    'fromFieldPath': obj.fromFieldPath,
    'patchSetName': obj.patchSetName,
    'policy': toJson_CompositionSpecPatchSetsPatchesPolicy(obj.policy),
    'toFieldPath': obj.toFieldPath,
    'transforms': obj.transforms?.map(y => toJson_CompositionSpecPatchSetsPatchesTransforms(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FunctionCredentials are optional credentials that a Composition Function
 * needs to run.
 *
 * @schema CompositionSpecPipelineCredentials
 */
export interface CompositionSpecPipelineCredentials {
  /**
   * Name of this set of credentials.
   *
   * @schema CompositionSpecPipelineCredentials#name
   */
  readonly name: string;

  /**
   * A SecretRef is a reference to a secret containing credentials that should
   * be supplied to the function.
   *
   * @schema CompositionSpecPipelineCredentials#secretRef
   */
  readonly secretRef?: CompositionSpecPipelineCredentialsSecretRef;

  /**
   * Source of the function credentials.
   *
   * @schema CompositionSpecPipelineCredentials#source
   */
  readonly source: CompositionSpecPipelineCredentialsSource;
}

/**
 * Converts an object of type 'CompositionSpecPipelineCredentials' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPipelineCredentials(obj: CompositionSpecPipelineCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'secretRef': toJson_CompositionSpecPipelineCredentialsSecretRef(obj.secretRef),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FunctionRef is a reference to the Composition Function this step should
 * execute.
 *
 * @schema CompositionSpecPipelineFunctionRef
 */
export interface CompositionSpecPipelineFunctionRef {
  /**
   * Name of the referenced Function.
   *
   * @schema CompositionSpecPipelineFunctionRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'CompositionSpecPipelineFunctionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPipelineFunctionRef(obj: CompositionSpecPipelineFunctionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConnectionDetail includes the information about the propagation of the connection
 * information from one secret to another.
 *
 * @schema CompositionSpecResourcesConnectionDetails
 */
export interface CompositionSpecResourcesConnectionDetails {
  /**
   * FromConnectionSecretKey is the key that will be used to fetch the value
   * from the composed resource's connection secret.
   *
   * @schema CompositionSpecResourcesConnectionDetails#fromConnectionSecretKey
   */
  readonly fromConnectionSecretKey?: string;

  /**
   * FromFieldPath is the path of the field on the composed resource whose
   * value to be used as input. Name must be specified if the type is
   * FromFieldPath.
   *
   * @schema CompositionSpecResourcesConnectionDetails#fromFieldPath
   */
  readonly fromFieldPath?: string;

  /**
   * Name of the connection secret key that will be propagated to the
   * connection secret of the composition instance. Leave empty if you'd like
   * to use the same key name.
   *
   * @schema CompositionSpecResourcesConnectionDetails#name
   */
  readonly name?: string;

  /**
   * Type sets the connection detail fetching behaviour to be used. Each
   * connection detail type may require its own fields to be set on the
   * ConnectionDetail object. If the type is omitted Crossplane will attempt
   * to infer it based on which other fields were specified. If multiple
   * fields are specified the order of precedence is:
   * 1. FromValue
   * 2. FromConnectionSecretKey
   * 3. FromFieldPath
   *
   * @schema CompositionSpecResourcesConnectionDetails#type
   */
  readonly type?: CompositionSpecResourcesConnectionDetailsType;

  /**
   * Value that will be propagated to the connection secret of the composite
   * resource. May be set to inject a fixed, non-sensitive connection secret
   * value, for example a well-known port.
   *
   * @schema CompositionSpecResourcesConnectionDetails#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'CompositionSpecResourcesConnectionDetails' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesConnectionDetails(obj: CompositionSpecResourcesConnectionDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromConnectionSecretKey': obj.fromConnectionSecretKey,
    'fromFieldPath': obj.fromFieldPath,
    'name': obj.name,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Patch objects are applied between composite and composed resources. Their
 * behaviour depends on the Type selected. The default Type,
 * FromCompositeFieldPath, copies a value from the composite resource to
 * the composed resource, applying any defined transformers.
 *
 * @schema CompositionSpecResourcesPatches
 */
export interface CompositionSpecResourcesPatches {
  /**
   * Combine is the patch configuration for a CombineFromComposite or
   * CombineToComposite patch.
   *
   * @schema CompositionSpecResourcesPatches#combine
   */
  readonly combine?: CompositionSpecResourcesPatchesCombine;

  /**
   * FromFieldPath is the path of the field on the resource whose value is
   * to be used as input. Required when type is FromCompositeFieldPath or
   * ToCompositeFieldPath.
   *
   * @schema CompositionSpecResourcesPatches#fromFieldPath
   */
  readonly fromFieldPath?: string;

  /**
   * PatchSetName to include patches from. Required when type is PatchSet.
   *
   * @schema CompositionSpecResourcesPatches#patchSetName
   */
  readonly patchSetName?: string;

  /**
   * Policy configures the specifics of patching behaviour.
   *
   * @schema CompositionSpecResourcesPatches#policy
   */
  readonly policy?: CompositionSpecResourcesPatchesPolicy;

  /**
   * ToFieldPath is the path of the field on the resource whose value will
   * be changed with the result of transforms. Leave empty if you'd like to
   * propagate to the same path as fromFieldPath.
   *
   * @schema CompositionSpecResourcesPatches#toFieldPath
   */
  readonly toFieldPath?: string;

  /**
   * Transforms are the list of functions that are used as a FIFO pipe for the
   * input to be transformed.
   *
   * @schema CompositionSpecResourcesPatches#transforms
   */
  readonly transforms?: CompositionSpecResourcesPatchesTransforms[];

  /**
   * Type sets the patching behaviour to be used. Each patch type may require
   * its own fields to be set on the Patch object.
   *
   * @schema CompositionSpecResourcesPatches#type
   */
  readonly type?: CompositionSpecResourcesPatchesType;
}

/**
 * Converts an object of type 'CompositionSpecResourcesPatches' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesPatches(obj: CompositionSpecResourcesPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'combine': toJson_CompositionSpecResourcesPatchesCombine(obj.combine),
    'fromFieldPath': obj.fromFieldPath,
    'patchSetName': obj.patchSetName,
    'policy': toJson_CompositionSpecResourcesPatchesPolicy(obj.policy),
    'toFieldPath': obj.toFieldPath,
    'transforms': obj.transforms?.map(y => toJson_CompositionSpecResourcesPatchesTransforms(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReadinessCheck is used to indicate how to tell whether a resource is ready
 * for consumption.
 *
 * @schema CompositionSpecResourcesReadinessChecks
 */
export interface CompositionSpecResourcesReadinessChecks {
  /**
   * FieldPath shows the path of the field whose value will be used.
   *
   * @schema CompositionSpecResourcesReadinessChecks#fieldPath
   */
  readonly fieldPath?: string;

  /**
   * MatchCondition specifies the condition you'd like to match if you're using "MatchCondition" type.
   *
   * @schema CompositionSpecResourcesReadinessChecks#matchCondition
   */
  readonly matchCondition?: CompositionSpecResourcesReadinessChecksMatchCondition;

  /**
   * MatchInt is the value you'd like to match if you're using "MatchInt" type.
   *
   * @schema CompositionSpecResourcesReadinessChecks#matchInteger
   */
  readonly matchInteger?: number;

  /**
   * MatchString is the value you'd like to match if you're using "MatchString" type.
   *
   * @schema CompositionSpecResourcesReadinessChecks#matchString
   */
  readonly matchString?: string;

  /**
   * Type indicates the type of probe you'd like to use.
   *
   * @schema CompositionSpecResourcesReadinessChecks#type
   */
  readonly type: CompositionSpecResourcesReadinessChecksType;
}

/**
 * Converts an object of type 'CompositionSpecResourcesReadinessChecks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesReadinessChecks(obj: CompositionSpecResourcesReadinessChecks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldPath': obj.fieldPath,
    'matchCondition': toJson_CompositionSpecResourcesReadinessChecksMatchCondition(obj.matchCondition),
    'matchInteger': obj.matchInteger,
    'matchString': obj.matchString,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Combine is the patch configuration for a CombineFromComposite or
 * CombineToComposite patch.
 *
 * @schema CompositionSpecPatchSetsPatchesCombine
 */
export interface CompositionSpecPatchSetsPatchesCombine {
  /**
   * Strategy defines the strategy to use to combine the input variable values.
   * Currently only string is supported.
   *
   * @schema CompositionSpecPatchSetsPatchesCombine#strategy
   */
  readonly strategy: CompositionSpecPatchSetsPatchesCombineStrategy;

  /**
   * String declares that input variables should be combined into a single
   * string, using the relevant settings for formatting purposes.
   *
   * @schema CompositionSpecPatchSetsPatchesCombine#string
   */
  readonly string?: CompositionSpecPatchSetsPatchesCombineString;

  /**
   * Variables are the list of variables whose values will be retrieved and
   * combined.
   *
   * @schema CompositionSpecPatchSetsPatchesCombine#variables
   */
  readonly variables: CompositionSpecPatchSetsPatchesCombineVariables[];
}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesCombine' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPatchSetsPatchesCombine(obj: CompositionSpecPatchSetsPatchesCombine | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'strategy': obj.strategy,
    'string': toJson_CompositionSpecPatchSetsPatchesCombineString(obj.string),
    'variables': obj.variables?.map(y => toJson_CompositionSpecPatchSetsPatchesCombineVariables(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policy configures the specifics of patching behaviour.
 *
 * @schema CompositionSpecPatchSetsPatchesPolicy
 */
export interface CompositionSpecPatchSetsPatchesPolicy {
  /**
   * FromFieldPath specifies how to patch from a field path. The default is
   * 'Optional', which means the patch will be a no-op if the specified
   * fromFieldPath does not exist. Use 'Required' if the patch should fail if
   * the specified path does not exist.
   *
   * @schema CompositionSpecPatchSetsPatchesPolicy#fromFieldPath
   */
  readonly fromFieldPath?: CompositionSpecPatchSetsPatchesPolicyFromFieldPath;

  /**
   * MergeOptions Specifies merge options on a field path.
   *
   * @schema CompositionSpecPatchSetsPatchesPolicy#mergeOptions
   */
  readonly mergeOptions?: CompositionSpecPatchSetsPatchesPolicyMergeOptions;
}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPatchSetsPatchesPolicy(obj: CompositionSpecPatchSetsPatchesPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
    'mergeOptions': toJson_CompositionSpecPatchSetsPatchesPolicyMergeOptions(obj.mergeOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Transform is a unit of process whose input is transformed into an output with
 * the supplied configuration.
 *
 * @schema CompositionSpecPatchSetsPatchesTransforms
 */
export interface CompositionSpecPatchSetsPatchesTransforms {
  /**
   * Convert is used to cast the input into the given output type.
   *
   * @schema CompositionSpecPatchSetsPatchesTransforms#convert
   */
  readonly convert?: CompositionSpecPatchSetsPatchesTransformsConvert;

  /**
   * Map uses the input as a key in the given map and returns the value.
   *
   * @schema CompositionSpecPatchSetsPatchesTransforms#map
   */
  readonly map?: { [key: string]: any };

  /**
   * Match is a more complex version of Map that matches a list of patterns.
   *
   * @schema CompositionSpecPatchSetsPatchesTransforms#match
   */
  readonly match?: CompositionSpecPatchSetsPatchesTransformsMatch;

  /**
   * Math is used to transform the input via mathematical operations such as
   * multiplication.
   *
   * @schema CompositionSpecPatchSetsPatchesTransforms#math
   */
  readonly math?: CompositionSpecPatchSetsPatchesTransformsMath;

  /**
   * String is used to transform the input into a string or a different kind
   * of string. Note that the input does not necessarily need to be a string.
   *
   * @schema CompositionSpecPatchSetsPatchesTransforms#string
   */
  readonly string?: CompositionSpecPatchSetsPatchesTransformsString;

  /**
   * Type of the transform to be run.
   *
   * @schema CompositionSpecPatchSetsPatchesTransforms#type
   */
  readonly type: CompositionSpecPatchSetsPatchesTransformsType;
}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransforms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransforms(obj: CompositionSpecPatchSetsPatchesTransforms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': toJson_CompositionSpecPatchSetsPatchesTransformsConvert(obj.convert),
    'map': ((obj.map) === undefined) ? undefined : (Object.entries(obj.map).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': toJson_CompositionSpecPatchSetsPatchesTransformsMatch(obj.match),
    'math': toJson_CompositionSpecPatchSetsPatchesTransformsMath(obj.math),
    'string': toJson_CompositionSpecPatchSetsPatchesTransformsString(obj.string),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type sets the patching behaviour to be used. Each patch type may require
 * its own fields to be set on the Patch object.
 *
 * @schema CompositionSpecPatchSetsPatchesType
 */
export enum CompositionSpecPatchSetsPatchesType {
  /** FromCompositeFieldPath */
  FROM_COMPOSITE_FIELD_PATH = "FromCompositeFieldPath",
  /** PatchSet */
  PATCH_SET = "PatchSet",
  /** ToCompositeFieldPath */
  TO_COMPOSITE_FIELD_PATH = "ToCompositeFieldPath",
  /** CombineFromComposite */
  COMBINE_FROM_COMPOSITE = "CombineFromComposite",
  /** CombineToComposite */
  COMBINE_TO_COMPOSITE = "CombineToComposite",
}

/**
 * A SecretRef is a reference to a secret containing credentials that should
 * be supplied to the function.
 *
 * @schema CompositionSpecPipelineCredentialsSecretRef
 */
export interface CompositionSpecPipelineCredentialsSecretRef {
  /**
   * Name of the secret.
   *
   * @schema CompositionSpecPipelineCredentialsSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CompositionSpecPipelineCredentialsSecretRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'CompositionSpecPipelineCredentialsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPipelineCredentialsSecretRef(obj: CompositionSpecPipelineCredentialsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source of the function credentials.
 *
 * @schema CompositionSpecPipelineCredentialsSource
 */
export enum CompositionSpecPipelineCredentialsSource {
  /** None */
  NONE = "None",
  /** Secret */
  SECRET = "Secret",
}

/**
 * Type sets the connection detail fetching behaviour to be used. Each
 * connection detail type may require its own fields to be set on the
 * ConnectionDetail object. If the type is omitted Crossplane will attempt
 * to infer it based on which other fields were specified. If multiple
 * fields are specified the order of precedence is:
 * 1. FromValue
 * 2. FromConnectionSecretKey
 * 3. FromFieldPath
 *
 * @schema CompositionSpecResourcesConnectionDetailsType
 */
export enum CompositionSpecResourcesConnectionDetailsType {
  /** FromConnectionSecretKey */
  FROM_CONNECTION_SECRET_KEY = "FromConnectionSecretKey",
  /** FromFieldPath */
  FROM_FIELD_PATH = "FromFieldPath",
  /** FromValue */
  FROM_VALUE = "FromValue",
}

/**
 * Combine is the patch configuration for a CombineFromComposite or
 * CombineToComposite patch.
 *
 * @schema CompositionSpecResourcesPatchesCombine
 */
export interface CompositionSpecResourcesPatchesCombine {
  /**
   * Strategy defines the strategy to use to combine the input variable values.
   * Currently only string is supported.
   *
   * @schema CompositionSpecResourcesPatchesCombine#strategy
   */
  readonly strategy: CompositionSpecResourcesPatchesCombineStrategy;

  /**
   * String declares that input variables should be combined into a single
   * string, using the relevant settings for formatting purposes.
   *
   * @schema CompositionSpecResourcesPatchesCombine#string
   */
  readonly string?: CompositionSpecResourcesPatchesCombineString;

  /**
   * Variables are the list of variables whose values will be retrieved and
   * combined.
   *
   * @schema CompositionSpecResourcesPatchesCombine#variables
   */
  readonly variables: CompositionSpecResourcesPatchesCombineVariables[];
}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesCombine' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesPatchesCombine(obj: CompositionSpecResourcesPatchesCombine | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'strategy': obj.strategy,
    'string': toJson_CompositionSpecResourcesPatchesCombineString(obj.string),
    'variables': obj.variables?.map(y => toJson_CompositionSpecResourcesPatchesCombineVariables(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policy configures the specifics of patching behaviour.
 *
 * @schema CompositionSpecResourcesPatchesPolicy
 */
export interface CompositionSpecResourcesPatchesPolicy {
  /**
   * FromFieldPath specifies how to patch from a field path. The default is
   * 'Optional', which means the patch will be a no-op if the specified
   * fromFieldPath does not exist. Use 'Required' if the patch should fail if
   * the specified path does not exist.
   *
   * @schema CompositionSpecResourcesPatchesPolicy#fromFieldPath
   */
  readonly fromFieldPath?: CompositionSpecResourcesPatchesPolicyFromFieldPath;

  /**
   * MergeOptions Specifies merge options on a field path.
   *
   * @schema CompositionSpecResourcesPatchesPolicy#mergeOptions
   */
  readonly mergeOptions?: CompositionSpecResourcesPatchesPolicyMergeOptions;
}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesPatchesPolicy(obj: CompositionSpecResourcesPatchesPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
    'mergeOptions': toJson_CompositionSpecResourcesPatchesPolicyMergeOptions(obj.mergeOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Transform is a unit of process whose input is transformed into an output with
 * the supplied configuration.
 *
 * @schema CompositionSpecResourcesPatchesTransforms
 */
export interface CompositionSpecResourcesPatchesTransforms {
  /**
   * Convert is used to cast the input into the given output type.
   *
   * @schema CompositionSpecResourcesPatchesTransforms#convert
   */
  readonly convert?: CompositionSpecResourcesPatchesTransformsConvert;

  /**
   * Map uses the input as a key in the given map and returns the value.
   *
   * @schema CompositionSpecResourcesPatchesTransforms#map
   */
  readonly map?: { [key: string]: any };

  /**
   * Match is a more complex version of Map that matches a list of patterns.
   *
   * @schema CompositionSpecResourcesPatchesTransforms#match
   */
  readonly match?: CompositionSpecResourcesPatchesTransformsMatch;

  /**
   * Math is used to transform the input via mathematical operations such as
   * multiplication.
   *
   * @schema CompositionSpecResourcesPatchesTransforms#math
   */
  readonly math?: CompositionSpecResourcesPatchesTransformsMath;

  /**
   * String is used to transform the input into a string or a different kind
   * of string. Note that the input does not necessarily need to be a string.
   *
   * @schema CompositionSpecResourcesPatchesTransforms#string
   */
  readonly string?: CompositionSpecResourcesPatchesTransformsString;

  /**
   * Type of the transform to be run.
   *
   * @schema CompositionSpecResourcesPatchesTransforms#type
   */
  readonly type: CompositionSpecResourcesPatchesTransformsType;
}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransforms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesPatchesTransforms(obj: CompositionSpecResourcesPatchesTransforms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': toJson_CompositionSpecResourcesPatchesTransformsConvert(obj.convert),
    'map': ((obj.map) === undefined) ? undefined : (Object.entries(obj.map).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'match': toJson_CompositionSpecResourcesPatchesTransformsMatch(obj.match),
    'math': toJson_CompositionSpecResourcesPatchesTransformsMath(obj.math),
    'string': toJson_CompositionSpecResourcesPatchesTransformsString(obj.string),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type sets the patching behaviour to be used. Each patch type may require
 * its own fields to be set on the Patch object.
 *
 * @schema CompositionSpecResourcesPatchesType
 */
export enum CompositionSpecResourcesPatchesType {
  /** FromCompositeFieldPath */
  FROM_COMPOSITE_FIELD_PATH = "FromCompositeFieldPath",
  /** PatchSet */
  PATCH_SET = "PatchSet",
  /** ToCompositeFieldPath */
  TO_COMPOSITE_FIELD_PATH = "ToCompositeFieldPath",
  /** CombineFromComposite */
  COMBINE_FROM_COMPOSITE = "CombineFromComposite",
  /** CombineToComposite */
  COMBINE_TO_COMPOSITE = "CombineToComposite",
}

/**
 * MatchCondition specifies the condition you'd like to match if you're using "MatchCondition" type.
 *
 * @schema CompositionSpecResourcesReadinessChecksMatchCondition
 */
export interface CompositionSpecResourcesReadinessChecksMatchCondition {
  /**
   * Status is the status of the condition you'd like to match.
   *
   * @schema CompositionSpecResourcesReadinessChecksMatchCondition#status
   */
  readonly status: string;

  /**
   * Type indicates the type of condition you'd like to use.
   *
   * @schema CompositionSpecResourcesReadinessChecksMatchCondition#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'CompositionSpecResourcesReadinessChecksMatchCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesReadinessChecksMatchCondition(obj: CompositionSpecResourcesReadinessChecksMatchCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type indicates the type of probe you'd like to use.
 *
 * @schema CompositionSpecResourcesReadinessChecksType
 */
export enum CompositionSpecResourcesReadinessChecksType {
  /** MatchString */
  MATCH_STRING = "MatchString",
  /** MatchInteger */
  MATCH_INTEGER = "MatchInteger",
  /** NonEmpty */
  NON_EMPTY = "NonEmpty",
  /** MatchCondition */
  MATCH_CONDITION = "MatchCondition",
  /** MatchTrue */
  MATCH_TRUE = "MatchTrue",
  /** MatchFalse */
  MATCH_FALSE = "MatchFalse",
  /** None */
  NONE = "None",
}

/**
 * Strategy defines the strategy to use to combine the input variable values.
 * Currently only string is supported.
 *
 * @schema CompositionSpecPatchSetsPatchesCombineStrategy
 */
export enum CompositionSpecPatchSetsPatchesCombineStrategy {
  /** string */
  STRING = "string",
}

/**
 * String declares that input variables should be combined into a single
 * string, using the relevant settings for formatting purposes.
 *
 * @schema CompositionSpecPatchSetsPatchesCombineString
 */
export interface CompositionSpecPatchSetsPatchesCombineString {
  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionSpecPatchSetsPatchesCombineString#fmt
   */
  readonly fmt: string;
}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesCombineString' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPatchSetsPatchesCombineString(obj: CompositionSpecPatchSetsPatchesCombineString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fmt': obj.fmt,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A CombineVariable defines the source of a value that is combined with
 * others to form and patch an output value. Currently, this only supports
 * retrieving values from a field path.
 *
 * @schema CompositionSpecPatchSetsPatchesCombineVariables
 */
export interface CompositionSpecPatchSetsPatchesCombineVariables {
  /**
   * FromFieldPath is the path of the field on the source whose value is
   * to be used as input.
   *
   * @schema CompositionSpecPatchSetsPatchesCombineVariables#fromFieldPath
   */
  readonly fromFieldPath: string;
}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesCombineVariables' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPatchSetsPatchesCombineVariables(obj: CompositionSpecPatchSetsPatchesCombineVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FromFieldPath specifies how to patch from a field path. The default is
 * 'Optional', which means the patch will be a no-op if the specified
 * fromFieldPath does not exist. Use 'Required' if the patch should fail if
 * the specified path does not exist.
 *
 * @schema CompositionSpecPatchSetsPatchesPolicyFromFieldPath
 */
export enum CompositionSpecPatchSetsPatchesPolicyFromFieldPath {
  /** Optional */
  OPTIONAL = "Optional",
  /** Required */
  REQUIRED = "Required",
}

/**
 * MergeOptions Specifies merge options on a field path.
 *
 * @schema CompositionSpecPatchSetsPatchesPolicyMergeOptions
 */
export interface CompositionSpecPatchSetsPatchesPolicyMergeOptions {
  /**
   * Specifies that already existing elements in a merged slice should be preserved
   *
   * @schema CompositionSpecPatchSetsPatchesPolicyMergeOptions#appendSlice
   */
  readonly appendSlice?: boolean;

  /**
   * Specifies that already existing values in a merged map should be preserved
   *
   * @schema CompositionSpecPatchSetsPatchesPolicyMergeOptions#keepMapValues
   */
  readonly keepMapValues?: boolean;
}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesPolicyMergeOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPatchSetsPatchesPolicyMergeOptions(obj: CompositionSpecPatchSetsPatchesPolicyMergeOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appendSlice': obj.appendSlice,
    'keepMapValues': obj.keepMapValues,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Convert is used to cast the input into the given output type.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsConvert
 */
export interface CompositionSpecPatchSetsPatchesTransformsConvert {
  /**
   * The expected input format.
   *
   * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
   * Only used during `string -> float64` conversions.
   * * `json` - parses the input as a JSON string.
   * Only used during `string -> object` or `string -> list` conversions.
   *
   * If this property is null, the default conversion is applied.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsConvert#format
   */
  readonly format?: CompositionSpecPatchSetsPatchesTransformsConvertFormat;

  /**
   * ToType is the type of the output of this transform.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsConvert#toType
   */
  readonly toType: CompositionSpecPatchSetsPatchesTransformsConvertToType;
}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransformsConvert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransformsConvert(obj: CompositionSpecPatchSetsPatchesTransformsConvert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format,
    'toType': obj.toType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Match is a more complex version of Map that matches a list of patterns.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsMatch
 */
export interface CompositionSpecPatchSetsPatchesTransformsMatch {
  /**
   * Determines to what value the transform should fallback if no pattern matches.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMatch#fallbackTo
   */
  readonly fallbackTo?: CompositionSpecPatchSetsPatchesTransformsMatchFallbackTo;

  /**
   * The fallback value that should be returned by the transform if now pattern
   * matches.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMatch#fallbackValue
   */
  readonly fallbackValue?: any;

  /**
   * The patterns that should be tested against the input string.
   * Patterns are tested in order. The value of the first match is used as
   * result of this transform.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMatch#patterns
   */
  readonly patterns?: CompositionSpecPatchSetsPatchesTransformsMatchPatterns[];
}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransformsMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransformsMatch(obj: CompositionSpecPatchSetsPatchesTransformsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallbackTo': obj.fallbackTo,
    'fallbackValue': obj.fallbackValue,
    'patterns': obj.patterns?.map(y => toJson_CompositionSpecPatchSetsPatchesTransformsMatchPatterns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Math is used to transform the input via mathematical operations such as
 * multiplication.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsMath
 */
export interface CompositionSpecPatchSetsPatchesTransformsMath {
  /**
   * ClampMax makes sure that the value is not bigger than the given value.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMath#clampMax
   */
  readonly clampMax?: number;

  /**
   * ClampMin makes sure that the value is not smaller than the given value.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMath#clampMin
   */
  readonly clampMin?: number;

  /**
   * Multiply the value.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMath#multiply
   */
  readonly multiply?: number;

  /**
   * Type of the math transform to be run.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMath#type
   */
  readonly type?: CompositionSpecPatchSetsPatchesTransformsMathType;
}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransformsMath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransformsMath(obj: CompositionSpecPatchSetsPatchesTransformsMath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clampMax': obj.clampMax,
    'clampMin': obj.clampMin,
    'multiply': obj.multiply,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * String is used to transform the input into a string or a different kind
 * of string. Note that the input does not necessarily need to be a string.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsString
 */
export interface CompositionSpecPatchSetsPatchesTransformsString {
  /**
   * Optional conversion method to be specified.
   * `ToUpper` and `ToLower` change the letter case of the input string.
   * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
   * `ToJson` converts any input value into its raw JSON representation.
   * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
   * converted to JSON.
   * `ToAdler32` generate a addler32 hash based on the input string.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsString#convert
   */
  readonly convert?: CompositionSpecPatchSetsPatchesTransformsStringConvert;

  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsString#fmt
   */
  readonly fmt?: string;

  /**
   * Join defines parameters to join a slice of values to a string.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsString#join
   */
  readonly join?: CompositionSpecPatchSetsPatchesTransformsStringJoin;

  /**
   * Extract a match from the input using a regular expression.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsString#regexp
   */
  readonly regexp?: CompositionSpecPatchSetsPatchesTransformsStringRegexp;

  /**
   * Trim the prefix or suffix from the input
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsString#trim
   */
  readonly trim?: string;

  /**
   * Type of the string transform to be run.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsString#type
   */
  readonly type?: CompositionSpecPatchSetsPatchesTransformsStringType;
}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransformsString' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransformsString(obj: CompositionSpecPatchSetsPatchesTransformsString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': obj.convert,
    'fmt': obj.fmt,
    'join': toJson_CompositionSpecPatchSetsPatchesTransformsStringJoin(obj.join),
    'regexp': toJson_CompositionSpecPatchSetsPatchesTransformsStringRegexp(obj.regexp),
    'trim': obj.trim,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type of the transform to be run.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsType
 */
export enum CompositionSpecPatchSetsPatchesTransformsType {
  /** map */
  MAP = "map",
  /** match */
  MATCH = "match",
  /** math */
  MATH = "math",
  /** string */
  STRING = "string",
  /** convert */
  CONVERT = "convert",
}

/**
 * Strategy defines the strategy to use to combine the input variable values.
 * Currently only string is supported.
 *
 * @schema CompositionSpecResourcesPatchesCombineStrategy
 */
export enum CompositionSpecResourcesPatchesCombineStrategy {
  /** string */
  STRING = "string",
}

/**
 * String declares that input variables should be combined into a single
 * string, using the relevant settings for formatting purposes.
 *
 * @schema CompositionSpecResourcesPatchesCombineString
 */
export interface CompositionSpecResourcesPatchesCombineString {
  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionSpecResourcesPatchesCombineString#fmt
   */
  readonly fmt: string;
}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesCombineString' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesPatchesCombineString(obj: CompositionSpecResourcesPatchesCombineString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fmt': obj.fmt,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A CombineVariable defines the source of a value that is combined with
 * others to form and patch an output value. Currently, this only supports
 * retrieving values from a field path.
 *
 * @schema CompositionSpecResourcesPatchesCombineVariables
 */
export interface CompositionSpecResourcesPatchesCombineVariables {
  /**
   * FromFieldPath is the path of the field on the source whose value is
   * to be used as input.
   *
   * @schema CompositionSpecResourcesPatchesCombineVariables#fromFieldPath
   */
  readonly fromFieldPath: string;
}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesCombineVariables' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesPatchesCombineVariables(obj: CompositionSpecResourcesPatchesCombineVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromFieldPath': obj.fromFieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FromFieldPath specifies how to patch from a field path. The default is
 * 'Optional', which means the patch will be a no-op if the specified
 * fromFieldPath does not exist. Use 'Required' if the patch should fail if
 * the specified path does not exist.
 *
 * @schema CompositionSpecResourcesPatchesPolicyFromFieldPath
 */
export enum CompositionSpecResourcesPatchesPolicyFromFieldPath {
  /** Optional */
  OPTIONAL = "Optional",
  /** Required */
  REQUIRED = "Required",
}

/**
 * MergeOptions Specifies merge options on a field path.
 *
 * @schema CompositionSpecResourcesPatchesPolicyMergeOptions
 */
export interface CompositionSpecResourcesPatchesPolicyMergeOptions {
  /**
   * Specifies that already existing elements in a merged slice should be preserved
   *
   * @schema CompositionSpecResourcesPatchesPolicyMergeOptions#appendSlice
   */
  readonly appendSlice?: boolean;

  /**
   * Specifies that already existing values in a merged map should be preserved
   *
   * @schema CompositionSpecResourcesPatchesPolicyMergeOptions#keepMapValues
   */
  readonly keepMapValues?: boolean;
}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesPolicyMergeOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesPatchesPolicyMergeOptions(obj: CompositionSpecResourcesPatchesPolicyMergeOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appendSlice': obj.appendSlice,
    'keepMapValues': obj.keepMapValues,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Convert is used to cast the input into the given output type.
 *
 * @schema CompositionSpecResourcesPatchesTransformsConvert
 */
export interface CompositionSpecResourcesPatchesTransformsConvert {
  /**
   * The expected input format.
   *
   * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
   * Only used during `string -> float64` conversions.
   * * `json` - parses the input as a JSON string.
   * Only used during `string -> object` or `string -> list` conversions.
   *
   * If this property is null, the default conversion is applied.
   *
   * @schema CompositionSpecResourcesPatchesTransformsConvert#format
   */
  readonly format?: CompositionSpecResourcesPatchesTransformsConvertFormat;

  /**
   * ToType is the type of the output of this transform.
   *
   * @schema CompositionSpecResourcesPatchesTransformsConvert#toType
   */
  readonly toType: CompositionSpecResourcesPatchesTransformsConvertToType;
}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransformsConvert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesPatchesTransformsConvert(obj: CompositionSpecResourcesPatchesTransformsConvert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': obj.format,
    'toType': obj.toType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Match is a more complex version of Map that matches a list of patterns.
 *
 * @schema CompositionSpecResourcesPatchesTransformsMatch
 */
export interface CompositionSpecResourcesPatchesTransformsMatch {
  /**
   * Determines to what value the transform should fallback if no pattern matches.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMatch#fallbackTo
   */
  readonly fallbackTo?: CompositionSpecResourcesPatchesTransformsMatchFallbackTo;

  /**
   * The fallback value that should be returned by the transform if now pattern
   * matches.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMatch#fallbackValue
   */
  readonly fallbackValue?: any;

  /**
   * The patterns that should be tested against the input string.
   * Patterns are tested in order. The value of the first match is used as
   * result of this transform.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMatch#patterns
   */
  readonly patterns?: CompositionSpecResourcesPatchesTransformsMatchPatterns[];
}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransformsMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesPatchesTransformsMatch(obj: CompositionSpecResourcesPatchesTransformsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallbackTo': obj.fallbackTo,
    'fallbackValue': obj.fallbackValue,
    'patterns': obj.patterns?.map(y => toJson_CompositionSpecResourcesPatchesTransformsMatchPatterns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Math is used to transform the input via mathematical operations such as
 * multiplication.
 *
 * @schema CompositionSpecResourcesPatchesTransformsMath
 */
export interface CompositionSpecResourcesPatchesTransformsMath {
  /**
   * ClampMax makes sure that the value is not bigger than the given value.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMath#clampMax
   */
  readonly clampMax?: number;

  /**
   * ClampMin makes sure that the value is not smaller than the given value.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMath#clampMin
   */
  readonly clampMin?: number;

  /**
   * Multiply the value.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMath#multiply
   */
  readonly multiply?: number;

  /**
   * Type of the math transform to be run.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMath#type
   */
  readonly type?: CompositionSpecResourcesPatchesTransformsMathType;
}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransformsMath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesPatchesTransformsMath(obj: CompositionSpecResourcesPatchesTransformsMath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clampMax': obj.clampMax,
    'clampMin': obj.clampMin,
    'multiply': obj.multiply,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * String is used to transform the input into a string or a different kind
 * of string. Note that the input does not necessarily need to be a string.
 *
 * @schema CompositionSpecResourcesPatchesTransformsString
 */
export interface CompositionSpecResourcesPatchesTransformsString {
  /**
   * Optional conversion method to be specified.
   * `ToUpper` and `ToLower` change the letter case of the input string.
   * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
   * `ToJson` converts any input value into its raw JSON representation.
   * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
   * converted to JSON.
   * `ToAdler32` generate a addler32 hash based on the input string.
   *
   * @schema CompositionSpecResourcesPatchesTransformsString#convert
   */
  readonly convert?: CompositionSpecResourcesPatchesTransformsStringConvert;

  /**
   * Format the input using a Go format string. See
   * https://golang.org/pkg/fmt/ for details.
   *
   * @schema CompositionSpecResourcesPatchesTransformsString#fmt
   */
  readonly fmt?: string;

  /**
   * Join defines parameters to join a slice of values to a string.
   *
   * @schema CompositionSpecResourcesPatchesTransformsString#join
   */
  readonly join?: CompositionSpecResourcesPatchesTransformsStringJoin;

  /**
   * Extract a match from the input using a regular expression.
   *
   * @schema CompositionSpecResourcesPatchesTransformsString#regexp
   */
  readonly regexp?: CompositionSpecResourcesPatchesTransformsStringRegexp;

  /**
   * Trim the prefix or suffix from the input
   *
   * @schema CompositionSpecResourcesPatchesTransformsString#trim
   */
  readonly trim?: string;

  /**
   * Type of the string transform to be run.
   *
   * @schema CompositionSpecResourcesPatchesTransformsString#type
   */
  readonly type?: CompositionSpecResourcesPatchesTransformsStringType;
}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransformsString' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesPatchesTransformsString(obj: CompositionSpecResourcesPatchesTransformsString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'convert': obj.convert,
    'fmt': obj.fmt,
    'join': toJson_CompositionSpecResourcesPatchesTransformsStringJoin(obj.join),
    'regexp': toJson_CompositionSpecResourcesPatchesTransformsStringRegexp(obj.regexp),
    'trim': obj.trim,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type of the transform to be run.
 *
 * @schema CompositionSpecResourcesPatchesTransformsType
 */
export enum CompositionSpecResourcesPatchesTransformsType {
  /** map */
  MAP = "map",
  /** match */
  MATCH = "match",
  /** math */
  MATH = "math",
  /** string */
  STRING = "string",
  /** convert */
  CONVERT = "convert",
}

/**
 * The expected input format.
 *
 * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
 * Only used during `string -> float64` conversions.
 * * `json` - parses the input as a JSON string.
 * Only used during `string -> object` or `string -> list` conversions.
 *
 * If this property is null, the default conversion is applied.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsConvertFormat
 */
export enum CompositionSpecPatchSetsPatchesTransformsConvertFormat {
  /** none */
  NONE = "none",
  /** quantity */
  QUANTITY = "quantity",
  /** json */
  JSON = "json",
}

/**
 * ToType is the type of the output of this transform.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsConvertToType
 */
export enum CompositionSpecPatchSetsPatchesTransformsConvertToType {
  /** string */
  STRING = "string",
  /** int */
  INT = "int",
  /** int64 */
  INT64 = "int64",
  /** bool */
  BOOL = "bool",
  /** float64 */
  FLOAT64 = "float64",
  /** object */
  OBJECT = "object",
  /** array */
  ARRAY = "array",
}

/**
 * Determines to what value the transform should fallback if no pattern matches.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsMatchFallbackTo
 */
export enum CompositionSpecPatchSetsPatchesTransformsMatchFallbackTo {
  /** Value */
  VALUE = "Value",
  /** Input */
  INPUT = "Input",
}

/**
 * MatchTransformPattern is a transform that returns the value that matches a
 * pattern.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsMatchPatterns
 */
export interface CompositionSpecPatchSetsPatchesTransformsMatchPatterns {
  /**
   * Literal exactly matches the input string (case sensitive).
   * Is required if `type` is `literal`.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMatchPatterns#literal
   */
  readonly literal?: string;

  /**
   * Regexp to match against the input string.
   * Is required if `type` is `regexp`.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMatchPatterns#regexp
   */
  readonly regexp?: string;

  /**
   * The value that is used as result of the transform if the pattern matches.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMatchPatterns#result
   */
  readonly result: any;

  /**
   * Type specifies how the pattern matches the input.
   *
   * * `literal` - the pattern value has to exactly match (case sensitive) the
   * input string. This is the default.
   *
   * * `regexp` - the pattern treated as a regular expression against
   * which the input string is tested. Crossplane will throw an error if the
   * key is not a valid regexp.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsMatchPatterns#type
   */
  readonly type: CompositionSpecPatchSetsPatchesTransformsMatchPatternsType;
}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransformsMatchPatterns' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransformsMatchPatterns(obj: CompositionSpecPatchSetsPatchesTransformsMatchPatterns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'literal': obj.literal,
    'regexp': obj.regexp,
    'result': obj.result,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type of the math transform to be run.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsMathType
 */
export enum CompositionSpecPatchSetsPatchesTransformsMathType {
  /** Multiply */
  MULTIPLY = "Multiply",
  /** ClampMin */
  CLAMP_MIN = "ClampMin",
  /** ClampMax */
  CLAMP_MAX = "ClampMax",
}

/**
 * Optional conversion method to be specified.
 * `ToUpper` and `ToLower` change the letter case of the input string.
 * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
 * `ToJson` converts any input value into its raw JSON representation.
 * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
 * converted to JSON.
 * `ToAdler32` generate a addler32 hash based on the input string.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsStringConvert
 */
export enum CompositionSpecPatchSetsPatchesTransformsStringConvert {
  /** ToUpper */
  TO_UPPER = "ToUpper",
  /** ToLower */
  TO_LOWER = "ToLower",
  /** ToBase64 */
  TO_BASE64 = "ToBase64",
  /** FromBase64 */
  FROM_BASE64 = "FromBase64",
  /** ToJson */
  TO_JSON = "ToJson",
  /** ToSha1 */
  TO_SHA1 = "ToSha1",
  /** ToSha256 */
  TO_SHA256 = "ToSha256",
  /** ToSha512 */
  TO_SHA512 = "ToSha512",
  /** ToAdler32 */
  TO_ADLER32 = "ToAdler32",
}

/**
 * Join defines parameters to join a slice of values to a string.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsStringJoin
 */
export interface CompositionSpecPatchSetsPatchesTransformsStringJoin {
  /**
   * Separator defines the character that should separate the values from each
   * other in the joined string.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsStringJoin#separator
   */
  readonly separator: string;
}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransformsStringJoin' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransformsStringJoin(obj: CompositionSpecPatchSetsPatchesTransformsStringJoin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'separator': obj.separator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Extract a match from the input using a regular expression.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsStringRegexp
 */
export interface CompositionSpecPatchSetsPatchesTransformsStringRegexp {
  /**
   * Group number to match. 0 (the default) matches the entire expression.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsStringRegexp#group
   */
  readonly group?: number;

  /**
   * Match string. May optionally include submatches, aka capture groups.
   * See https://pkg.go.dev/regexp/ for details.
   *
   * @schema CompositionSpecPatchSetsPatchesTransformsStringRegexp#match
   */
  readonly match: string;
}

/**
 * Converts an object of type 'CompositionSpecPatchSetsPatchesTransformsStringRegexp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecPatchSetsPatchesTransformsStringRegexp(obj: CompositionSpecPatchSetsPatchesTransformsStringRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'match': obj.match,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type of the string transform to be run.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsStringType
 */
export enum CompositionSpecPatchSetsPatchesTransformsStringType {
  /** Format */
  FORMAT = "Format",
  /** Convert */
  CONVERT = "Convert",
  /** TrimPrefix */
  TRIM_PREFIX = "TrimPrefix",
  /** TrimSuffix */
  TRIM_SUFFIX = "TrimSuffix",
  /** Regexp */
  REGEXP = "Regexp",
  /** Join */
  JOIN = "Join",
}

/**
 * The expected input format.
 *
 * * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
 * Only used during `string -> float64` conversions.
 * * `json` - parses the input as a JSON string.
 * Only used during `string -> object` or `string -> list` conversions.
 *
 * If this property is null, the default conversion is applied.
 *
 * @schema CompositionSpecResourcesPatchesTransformsConvertFormat
 */
export enum CompositionSpecResourcesPatchesTransformsConvertFormat {
  /** none */
  NONE = "none",
  /** quantity */
  QUANTITY = "quantity",
  /** json */
  JSON = "json",
}

/**
 * ToType is the type of the output of this transform.
 *
 * @schema CompositionSpecResourcesPatchesTransformsConvertToType
 */
export enum CompositionSpecResourcesPatchesTransformsConvertToType {
  /** string */
  STRING = "string",
  /** int */
  INT = "int",
  /** int64 */
  INT64 = "int64",
  /** bool */
  BOOL = "bool",
  /** float64 */
  FLOAT64 = "float64",
  /** object */
  OBJECT = "object",
  /** array */
  ARRAY = "array",
}

/**
 * Determines to what value the transform should fallback if no pattern matches.
 *
 * @schema CompositionSpecResourcesPatchesTransformsMatchFallbackTo
 */
export enum CompositionSpecResourcesPatchesTransformsMatchFallbackTo {
  /** Value */
  VALUE = "Value",
  /** Input */
  INPUT = "Input",
}

/**
 * MatchTransformPattern is a transform that returns the value that matches a
 * pattern.
 *
 * @schema CompositionSpecResourcesPatchesTransformsMatchPatterns
 */
export interface CompositionSpecResourcesPatchesTransformsMatchPatterns {
  /**
   * Literal exactly matches the input string (case sensitive).
   * Is required if `type` is `literal`.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMatchPatterns#literal
   */
  readonly literal?: string;

  /**
   * Regexp to match against the input string.
   * Is required if `type` is `regexp`.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMatchPatterns#regexp
   */
  readonly regexp?: string;

  /**
   * The value that is used as result of the transform if the pattern matches.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMatchPatterns#result
   */
  readonly result: any;

  /**
   * Type specifies how the pattern matches the input.
   *
   * * `literal` - the pattern value has to exactly match (case sensitive) the
   * input string. This is the default.
   *
   * * `regexp` - the pattern treated as a regular expression against
   * which the input string is tested. Crossplane will throw an error if the
   * key is not a valid regexp.
   *
   * @schema CompositionSpecResourcesPatchesTransformsMatchPatterns#type
   */
  readonly type: CompositionSpecResourcesPatchesTransformsMatchPatternsType;
}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransformsMatchPatterns' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesPatchesTransformsMatchPatterns(obj: CompositionSpecResourcesPatchesTransformsMatchPatterns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'literal': obj.literal,
    'regexp': obj.regexp,
    'result': obj.result,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type of the math transform to be run.
 *
 * @schema CompositionSpecResourcesPatchesTransformsMathType
 */
export enum CompositionSpecResourcesPatchesTransformsMathType {
  /** Multiply */
  MULTIPLY = "Multiply",
  /** ClampMin */
  CLAMP_MIN = "ClampMin",
  /** ClampMax */
  CLAMP_MAX = "ClampMax",
}

/**
 * Optional conversion method to be specified.
 * `ToUpper` and `ToLower` change the letter case of the input string.
 * `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
 * `ToJson` converts any input value into its raw JSON representation.
 * `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
 * converted to JSON.
 * `ToAdler32` generate a addler32 hash based on the input string.
 *
 * @schema CompositionSpecResourcesPatchesTransformsStringConvert
 */
export enum CompositionSpecResourcesPatchesTransformsStringConvert {
  /** ToUpper */
  TO_UPPER = "ToUpper",
  /** ToLower */
  TO_LOWER = "ToLower",
  /** ToBase64 */
  TO_BASE64 = "ToBase64",
  /** FromBase64 */
  FROM_BASE64 = "FromBase64",
  /** ToJson */
  TO_JSON = "ToJson",
  /** ToSha1 */
  TO_SHA1 = "ToSha1",
  /** ToSha256 */
  TO_SHA256 = "ToSha256",
  /** ToSha512 */
  TO_SHA512 = "ToSha512",
  /** ToAdler32 */
  TO_ADLER32 = "ToAdler32",
}

/**
 * Join defines parameters to join a slice of values to a string.
 *
 * @schema CompositionSpecResourcesPatchesTransformsStringJoin
 */
export interface CompositionSpecResourcesPatchesTransformsStringJoin {
  /**
   * Separator defines the character that should separate the values from each
   * other in the joined string.
   *
   * @schema CompositionSpecResourcesPatchesTransformsStringJoin#separator
   */
  readonly separator: string;
}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransformsStringJoin' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesPatchesTransformsStringJoin(obj: CompositionSpecResourcesPatchesTransformsStringJoin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'separator': obj.separator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Extract a match from the input using a regular expression.
 *
 * @schema CompositionSpecResourcesPatchesTransformsStringRegexp
 */
export interface CompositionSpecResourcesPatchesTransformsStringRegexp {
  /**
   * Group number to match. 0 (the default) matches the entire expression.
   *
   * @schema CompositionSpecResourcesPatchesTransformsStringRegexp#group
   */
  readonly group?: number;

  /**
   * Match string. May optionally include submatches, aka capture groups.
   * See https://pkg.go.dev/regexp/ for details.
   *
   * @schema CompositionSpecResourcesPatchesTransformsStringRegexp#match
   */
  readonly match: string;
}

/**
 * Converts an object of type 'CompositionSpecResourcesPatchesTransformsStringRegexp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CompositionSpecResourcesPatchesTransformsStringRegexp(obj: CompositionSpecResourcesPatchesTransformsStringRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'match': obj.match,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type of the string transform to be run.
 *
 * @schema CompositionSpecResourcesPatchesTransformsStringType
 */
export enum CompositionSpecResourcesPatchesTransformsStringType {
  /** Format */
  FORMAT = "Format",
  /** Convert */
  CONVERT = "Convert",
  /** TrimPrefix */
  TRIM_PREFIX = "TrimPrefix",
  /** TrimSuffix */
  TRIM_SUFFIX = "TrimSuffix",
  /** Regexp */
  REGEXP = "Regexp",
  /** Join */
  JOIN = "Join",
}

/**
 * Type specifies how the pattern matches the input.
 *
 * * `literal` - the pattern value has to exactly match (case sensitive) the
 * input string. This is the default.
 *
 * * `regexp` - the pattern treated as a regular expression against
 * which the input string is tested. Crossplane will throw an error if the
 * key is not a valid regexp.
 *
 * @schema CompositionSpecPatchSetsPatchesTransformsMatchPatternsType
 */
export enum CompositionSpecPatchSetsPatchesTransformsMatchPatternsType {
  /** literal */
  LITERAL = "literal",
  /** regexp */
  REGEXP = "regexp",
}

/**
 * Type specifies how the pattern matches the input.
 *
 * * `literal` - the pattern value has to exactly match (case sensitive) the
 * input string. This is the default.
 *
 * * `regexp` - the pattern treated as a regular expression against
 * which the input string is tested. Crossplane will throw an error if the
 * key is not a valid regexp.
 *
 * @schema CompositionSpecResourcesPatchesTransformsMatchPatternsType
 */
export enum CompositionSpecResourcesPatchesTransformsMatchPatternsType {
  /** literal */
  LITERAL = "literal",
  /** regexp */
  REGEXP = "regexp",
}

