// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ServiceAccount is the Schema for the ServiceAccounts API. Allows management of a Google Cloud Platform service account.
 *
 * @schema ServiceAccount
 */
export class ServiceAccount extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceAccount"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudplatform.gcp.upbound.io/v1beta1',
    kind: 'ServiceAccount',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceAccount".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceAccountProps): any {
    return {
      ...ServiceAccount.GVK,
      ...toJson_ServiceAccountProps(props),
    };
  }

  /**
   * Defines a "ServiceAccount" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceAccountProps) {
    super(scope, id, {
      ...ServiceAccount.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceAccount.GVK,
      ...toJson_ServiceAccountProps(resolved),
    };
  }
}

/**
 * ServiceAccount is the Schema for the ServiceAccounts API. Allows management of a Google Cloud Platform service account.
 *
 * @schema ServiceAccount
 */
export interface ServiceAccountProps {
  /**
   * @schema ServiceAccount#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceAccountSpec defines the desired state of ServiceAccount
   *
   * @schema ServiceAccount#spec
   */
  readonly spec: ServiceAccountSpec;
}

/**
 * Converts an object of type 'ServiceAccountProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountProps(obj: ServiceAccountProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceAccountSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServiceAccountSpec defines the desired state of ServiceAccount
 *
 * @schema ServiceAccountSpec
 */
export interface ServiceAccountSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceAccountSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceAccountSpecDeletionPolicy;

  /**
   * @schema ServiceAccountSpec#forProvider
   */
  readonly forProvider: ServiceAccountSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ServiceAccountSpec#initProvider
   */
  readonly initProvider?: ServiceAccountSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServiceAccountSpec#managementPolicies
   */
  readonly managementPolicies?: ServiceAccountSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ServiceAccountSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceAccountSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ServiceAccountSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceAccountSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema ServiceAccountSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceAccountSpecWriteConnectionSecretToRef;
}

/**
 * Converts an object of type 'ServiceAccountSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpec(obj: ServiceAccountSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceAccountSpecForProvider(obj.forProvider),
    'initProvider': toJson_ServiceAccountSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServiceAccountSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServiceAccountSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceAccountSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceAccountSpecDeletionPolicy
 */
export enum ServiceAccountSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceAccountSpecForProvider
 */
export interface ServiceAccountSpecForProvider {
  /**
   * If set to true, skip service account creation if a service account with the same email already exists.
   *
   * @schema ServiceAccountSpecForProvider#createIgnoreAlreadyExists
   */
  readonly createIgnoreAlreadyExists?: boolean;

  /**
   * A text description of the service account.
   * Must be less than or equal to 256 UTF-8 bytes.
   *
   * @schema ServiceAccountSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether a service account is disabled or not. Defaults to false. This field has no effect during creation.
   * Must be set after creation to disable a service account.
   *
   * @default false. This field has no effect during creation.
   * @schema ServiceAccountSpecForProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * The display name for the service account.
   * Can be updated without creating a new resource.
   *
   * @schema ServiceAccountSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The ID of the project that the service account will be created in.
   * Defaults to the provider project configuration.
   *
   * @default the provider project configuration.
   * @schema ServiceAccountSpecForProvider#project
   */
  readonly project?: string;
}

/**
 * Converts an object of type 'ServiceAccountSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpecForProvider(obj: ServiceAccountSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createIgnoreAlreadyExists': obj.createIgnoreAlreadyExists,
    'description': obj.description,
    'disabled': obj.disabled,
    'displayName': obj.displayName,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ServiceAccountSpecInitProvider
 */
export interface ServiceAccountSpecInitProvider {
  /**
   * If set to true, skip service account creation if a service account with the same email already exists.
   *
   * @schema ServiceAccountSpecInitProvider#createIgnoreAlreadyExists
   */
  readonly createIgnoreAlreadyExists?: boolean;

  /**
   * A text description of the service account.
   * Must be less than or equal to 256 UTF-8 bytes.
   *
   * @schema ServiceAccountSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Whether a service account is disabled or not. Defaults to false. This field has no effect during creation.
   * Must be set after creation to disable a service account.
   *
   * @default false. This field has no effect during creation.
   * @schema ServiceAccountSpecInitProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * The display name for the service account.
   * Can be updated without creating a new resource.
   *
   * @schema ServiceAccountSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The ID of the project that the service account will be created in.
   * Defaults to the provider project configuration.
   *
   * @default the provider project configuration.
   * @schema ServiceAccountSpecInitProvider#project
   */
  readonly project?: string;
}

/**
 * Converts an object of type 'ServiceAccountSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpecInitProvider(obj: ServiceAccountSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createIgnoreAlreadyExists': obj.createIgnoreAlreadyExists,
    'description': obj.description,
    'disabled': obj.disabled,
    'displayName': obj.displayName,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ServiceAccountSpecManagementPolicies
 */
export enum ServiceAccountSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ServiceAccountSpecProviderConfigRef
 */
export interface ServiceAccountSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceAccountSpecProviderConfigRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpecProviderConfigRef(obj: ServiceAccountSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ServiceAccountSpecPublishConnectionDetailsTo
 */
export interface ServiceAccountSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceAccountSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceAccountSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ServiceAccountSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpecPublishConnectionDetailsTo(obj: ServiceAccountSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceAccountSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceAccountSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema ServiceAccountSpecWriteConnectionSecretToRef
 */
export interface ServiceAccountSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceAccountSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceAccountSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'ServiceAccountSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpecWriteConnectionSecretToRef(obj: ServiceAccountSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountSpecProviderConfigRefPolicy
 */
export interface ServiceAccountSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountSpecProviderConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpecProviderConfigRefPolicy(obj: ServiceAccountSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceAccountSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy;
}

/**
 * Converts an object of type 'ServiceAccountSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpecPublishConnectionDetailsToConfigRef(obj: ServiceAccountSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceAccountSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceAccountSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ServiceAccountSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpecPublishConnectionDetailsToMetadata(obj: ServiceAccountSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountSpecProviderConfigRefPolicyResolution
 */
export enum ServiceAccountSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountSpecProviderConfigRefPolicyResolve
 */
export enum ServiceAccountSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicyResolve;
}

/**
 * Converts an object of type 'ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceAccountSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

