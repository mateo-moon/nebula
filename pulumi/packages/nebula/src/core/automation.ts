/**
 * Stack Manager - Pulumi Automation API utilities for stack management.
 * 
 * Handles:
 * - Creating and selecting Pulumi stacks
 * - Generating Pulumi.yaml project files
 * - Generating Pulumi.<stack>.yaml configuration files
 */
import type { Stack, ProjectSettings } from '@pulumi/pulumi/automation';
import { LocalWorkspace } from '@pulumi/pulumi/automation';
import * as path from 'path';
import * as fs from 'fs';

export interface StackManagerConfig {
  projectName: string;
  stackName: string;
  workDir: string;
  program: () => Promise<void>;
  backendUrl?: string;
  secretsProvider?: string;
}

/**
 * Manages Pulumi stack creation and configuration
 */
export class StackManager {
  constructor(private config: StackManagerConfig) {}

  /**
   * Create or select a Pulumi stack with the configured backend and secrets provider.
   */
  async createOrSelectStack(): Promise<Stack> {
    const { projectName, stackName, workDir, program, backendUrl, secretsProvider } = this.config;

    const projectSettings: ProjectSettings = {
      name: projectName,
      runtime: 'nodejs',
      ...(backendUrl ? { backend: { url: backendUrl } } : {}),
    };

    const envVars: Record<string, string> = {
      ...process.env as Record<string, string>,
    };

    const stack = await LocalWorkspace.createOrSelectStack(
      {
        stackName,
        projectName,
        program,
      },
      {
        workDir,
        projectSettings,
        envVars,
        ...(secretsProvider ? { secretsProvider } : {}),
      }
    );

    return stack;
  }

  /**
   * Initialize encryption by setting a temporary secret.
   * This triggers Pulumi to generate the encryptedkey in Pulumi.<stack>.yaml.
   * Must be called AFTER writeStackConfig().
   */
  async initializeEncryption(stack: Stack): Promise<void> {
    const { secretsProvider } = this.config;
    if (!secretsProvider) return;

    await stack.setConfig('nebula:init', { value: 'init', secret: true });
    await stack.removeConfig('nebula:init');
  }

  /**
   * Write Pulumi.yaml project file
   */
  async writePulumiYaml(): Promise<void> {
    const { projectName, workDir, backendUrl } = this.config;
    
    const pulumiYaml = {
      name: projectName,
      runtime: {
        name: 'nodejs',
        options: {
          typescript: false,
          nodeargs: '--import=tsx/esm',
        },
      },
      ...(backendUrl ? { backend: { url: backendUrl } } : {}),
    };

    const yaml = await import('yaml');
    const content = yaml.stringify(pulumiYaml);
    const filePath = path.join(workDir, 'Pulumi.yaml');
    
    fs.writeFileSync(filePath, content, 'utf-8');
  }

  /**
   * Write Pulumi.<stack>.yaml configuration file
   * Preserves encryptedkey if it exists (generated by Pulumi)
   */
  async writeStackConfig(config: Record<string, any>): Promise<void> {
    const { stackName, workDir, secretsProvider } = this.config;
    const filePath = path.join(workDir, `Pulumi.${stackName}.yaml`);
    const yaml = await import('yaml');
    
    // Read existing config to preserve encryptedkey
    let existingConfig: Record<string, any> = {};
    if (fs.existsSync(filePath)) {
      const existingContent = fs.readFileSync(filePath, 'utf-8');
      existingConfig = yaml.parse(existingContent) || {};
    }
    
    // Default config with disabled default providers
    const defaultConfig: Record<string, any> = {
      'pulumi:disable-default-providers': ['kubernetes', 'gcp'],
    };
    
    const stackConfig: Record<string, any> = {
      ...(secretsProvider ? { secretsprovider: secretsProvider } : {}),
      // Preserve encryptedkey from existing config (generated by Pulumi)
      ...(existingConfig.encryptedkey ? { encryptedkey: existingConfig.encryptedkey } : {}),
      config: { ...defaultConfig, ...config },
    };

    const content = yaml.stringify(stackConfig);
    
    fs.writeFileSync(filePath, content, 'utf-8');
  }
}
