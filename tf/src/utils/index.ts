import * as path from 'path';
import * as fs from 'fs';
import { execSync } from 'child_process';
import { Construct } from 'constructs';
import { Annotations, S3BackendConfig, S3Backend } from 'cdktf';
import { ProjectConfig } from '@src/core';
import { S3Client, HeadBucketCommand, CreateBucketCommand, PutBucketVersioningCommand, BucketLocationConstraint } from '@aws-sdk/client-s3';

declare global {
  /** GLOBAL Root of the git repository */
  var projectRoot: string
  /** GLOBAL
   * Config directory path 
   * Place to store aws config file, kube config and similar */
  var projectConfigPath: string;
  var gitOrigin: string;
}

enum backendTypeVariants {
  S3
}

type backendType = keyof typeof backendTypeVariants;
type backendTypeConfig = S3BackendConfig | null;

/** Backend configuration types */
export interface BackendConfig{
  type: backendType;
  config?: backendTypeConfig;
}

export class Utils {

  public static generateAwsConfigFile(projectConfig: ProjectConfig | undefined) {
    //TODO(OP): Add other authentication method
    if (!projectConfig) return;
    if (!projectConfig.aws?.sso_config) return;
    
    const projectId = projectConfig.id;
    const ssoUrl = projectConfig.aws.sso_config.sso_url;
    const ssoRegion = projectConfig.aws.sso_config.sso_region;
    const ssoRoleName = projectConfig.aws.sso_config.sso_role_name;
    const environments = projectConfig.environments || {};

    let configContent = `\
[default]
sso_session = ${projectId}
region = ${ssoRegion}
`
    Object.entries(environments).forEach(([envId, config]) => {
      if (!config.awsConfig) return;
      configContent += `
[profile ${projectId}-${envId}]
sso_session = ${projectId}
sso_account_id = ${config.awsConfig.accountId}
sso_role_name = ${ssoRoleName}
region = ${config.awsConfig.region}
`
    })
    configContent += `
[sso-session ${projectId}]
sso_start_url = ${ssoUrl}
sso_region = ${ssoRegion}
sso_registration_scopes = sso:account:access\
`
    fs.writeFileSync(`${projectConfigPath}/aws_config`, '# Generated by CDKTF\n' + configContent);
  };

  public static generateBackend(component: any) {
    const { type, config } = component.env.config.backend || {};
    const env = component.env;
    const project = component.env.project;
    switch (type) {
      case 'S3': {
        const finalConfig: S3BackendConfig = {...{
          bucket: `${project.node.id}-${env.node.id}-tfstate`,
          key: component.id,
          region: env.config.awsConfig.region,
          profile: env.config.awsConfig.profile,
          sharedConfigFiles: [`${project.config.aws ? projectConfigPath + '/aws_config' : ''}`],
          allowedAccountIds: env.config.awsConfig?.allowedAccountIds,
        } as S3BackendConfig, ...config};
        this.checkCreateS3Bucket(finalConfig);
        new S3Backend(component, finalConfig);
        break
      }
      default:
        break;
    }
  }

  private static async checkCreateS3Bucket(config: S3BackendConfig) {
    process.env.AWS_CONFIG_FILE = config.sharedConfigFiles?.[0] || '';
    const client = new S3Client({
      region: config.region,
      profile: config.profile,
    })

    // TODO(OP): Fix this try catch mess
    try {
      // Check if bucket exists
      try {
        await client.send(new HeadBucketCommand({ Bucket: config.bucket }));
        return;
      } catch (error: any) {
        if (error.message.includes("To refresh this SSO session run 'aws sso login'") ) {
          execSync(`aws sso login`);
          await new Promise(f => setTimeout(f, 1000));
          try {
            await client.send(new HeadBucketCommand({ Bucket: config.bucket }));
          } catch (error: any) {
            console.log(`Failed to check if S3 bucket exists: ${error.message}`);
            return;
          }
        }
        if (error.$metadata?.httpStatusCode !== 404) {
          console.log(`Failed to check if S3 bucket exists: ${error.message}`);
          return;
        }
      }

      // Create bucket
      await client.send(new CreateBucketCommand({
        Bucket: config.bucket,
        CreateBucketConfiguration: {
          LocationConstraint: config.region as BucketLocationConstraint
        }
      }));

      // Enable versioning
      await client.send(new PutBucketVersioningCommand({
        Bucket: config.bucket,
        VersioningConfiguration: {
          Status: 'Enabled'
        }
      }));
    } catch (error: any) {
      console.log(`S3 bucket operation failed: ${error.message}`);
    }
  }

  public static createProjectConfigPath(scope: Construct, path?: string) {
    path = path || projectConfigPath;
    try {
      if (!fs.existsSync(path)) {
        fs.mkdirSync(path, { recursive: true });
      }
    } catch (error: any) {
      Annotations.of(scope).addError(error)
    }
  }

  public static setGlobalVariables() {
    global.projectRoot = execSync('git rev-parse --show-toplevel').toString().trim()
    global.projectConfigPath = path.resolve(projectRoot, '.config');
    global.gitOrigin = execSync('git config --get remote.origin.url').toString().trim();
  }
}

